<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="deftypes" revision="alpha">
  <title>Defining Types, Streamlining Functions</title>

  <para>Topics: Creating new types.  Ways to write clearer
    functions.</para>

  <sect1 id="deftypes.data">
    <title>Defining a new data type</title>
      
    <para id="x_C4">Although lists and tuples are useful, we'll often
      want to construct new data types of our own.  This allows us to
      add structure to the values in our programs.  Instead of using
      an anonymous tuple, we can give a collection of related values a
      name.  Defining our own types also improves the type safety of
      our code: Haskell will not allow us to accidentally mix values
      of two types that are structurally similar but have different
      names.</para>

    <para>We define a new data type using the <code>data</code>
      keyword.</para>

    &BookStore.hs:BookInfo;

    <para id="x_D4">The <type>BookInfo</type> after the
      <code>data</code> keyword is the name of our new type. We call
      <type>BookInfo</type> a <emphasis>type constructor</emphasis>.
      (As we've already mentioned, a type name, and hence a type
      constructor, must start with a capital letter.)  The string
      <code>Book</code> is the name of the <emphasis>value
	constructor</emphasis> we'll apply to create a value of this
      type.  (As with a type constructor, a value constructor's name
      must start with a capital letter.)</para>

    <para>Finally, the <type>Int</type>, <type>String</type>, and
      <type>[String]</type> that follow are the
      <emphasis>components</emphasis> of the type.  A component serves
      the same purpose in Haskell as a field in a structure or class
      would in another language: it's a <quote>slot</quote> where we
      can put a value.  We'll often refer to components as fields.
      Here, the <type>Int</type> represents a book's identifier
      (perhaps in a database), <type>String</type> its name, and
      <type>[String]</type> the names of its authors.</para>

    <para>The <type>BookInfo</type> type has the same components as an
      <type>(Int, String, [String])</type> 3-tuple, but a distinct
      type.  Haskell won't let us accidentally (or deliberately) use
      one in a context where the other is expected.</para>

    <note>
      <title>Deriving what?</title>

      <para id="x_E4">We'll explain the full meaning of <code>deriving
	  (Show)</code> later, in
	<xref linkend="typeclasses.wellknown.show"/>.  For now,
	it's enough to know that we need to tack this onto a type
	declaration so that &ghci; will automatically know how to
	print a value of this type.</para>
    </note>

    <para id="x_F4">We can create a new value of type
      <type>BookStore</type> by treating
      <function>Book</function> as a function, and applying it with
      arguments of types <type>Int</type>,
      <type>String</type>, and <type>[String]</type>.</para>

    &BookStore.hs:bookInfo;

    <para id="x_G4">Once we've defined a type, we can experiment with
      it in &ghci;.  We begin by using the <command>:load</command>
      command to load our source file.</para>

    &bookstore.ghci:load;

    <para id="x_H4">Remember the <code>fpBook</code> variable we
      defined?  Here it is.</para>

    &bookstore.ghci:bookInfo;

    <para id="x_I4">We can construct new values interactively in
      &ghci;, too.</para>

    &bookstore.ghci:newValue;

    <para id="x_AL">The &ghci; command <command>:type</command> lets
      us see what the type of that expression is.</para>

    &bookstore.ghci:valueType;

    <para id="x_J4">To find out more about a type, we can use some of
      &ghci;'s browsing capabilities.  The <command>:info</command>
      command gets &ghci; to tell us everything it knows about a
      type.</para>
    
    &bookstore.ghci:info;

    <para id="x_K4">We can also find out why we use
      <function>Book</function> to construct a new value of type
      <type>BookStore</type>.</para>

    &bookstore.ghci:type;

    <para id="x_L4">We can treat a value constructor as just another
      function, one that happens to create and return a new value of
      the type we desire.</para>

    <sect2>
      <title>Naming types and values</title>

      <para>When we introduced the type <type>BookStore</type>, we
	deliberately chose to give the type constructor
	<type>BookStore</type> a different name from the value
	constructor <code>Book</code>, purely to make it obvious
	which was which.</para>

      <para>However, in Haskell, the names of types and values occupy
	two independent <emphasis>namespaces</emphasis>, so there is
	no ambiguity if we give a type constructor and a value
	constructor the same name.</para>

      &BookStore.hs:BookReview;

      <para>This definition says that the type named
	<type>BookReview</type> has a value constructor that is also
	named <code>BookReview</code>.  Since a type signature
	doesn't contain value names, and a normal expression doesn't
	contain type names, it's always clear from the context in
	which we use a name whether that name refers to a type or a
	value.</para>

      <para>In fact, not only is it <emphasis>legal</emphasis> for a
	value constructor to have the same name as its type
	constructor, it's <emphasis>normal</emphasis>: you'll see this
	all the time in regular Haskell code.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.adt">
    <title>Algebraic data types</title>

    <para id="x_M4">The <type>Bool</type> type that we introduced
      earlier is the simplest example of a category of type called an
      <emphasis>algebraic data type</emphasis>. An algebraic data type
      has several value constructors.</para>

      &Bool.hs:Bool;

    <para id="x_N4">In the case of <type>Bool</type>, the type has two
      value constructors, <code>True</code> and <code>False</code>.
      Each value constructor is separated in the definition by a
      <literal>|</literal> character, which we can read as
      <quote>or</quote>.  The different value constructors are usually
      referred to as <emphasis>alternatives</emphasis> or
      <emphasis>cases</emphasis>.</para>

    <note>
      <title>Why <quote>algebraic</quote>?</title>

      <para id="x_BL">The use of the word <quote>algebraic</quote> for
	describing these data types comes from abstract
	algebra.</para>

      <para>Although the phrase <quote>algebraic data type</quote> is
	long, we're being careful to avoid using the acronym
	<quote>ADT</quote> instead.  That acronym is already widely
	understood to stand for <quote><emphasis>abstract</emphasis>
	data type</quote>, which is quite different.</para>
    </note>

    <para id="x_O4">Each of an algebraic data type's value
      constructors can take zero or more arguments.  As an example,
      here's one way we might represent versions of the Windows
      operating system.</para>

    &OsVersion.hs:WindowsVersion;

    <para id="x_P4">The alternatives that represent older releases
      don't need arguments, but we use an <type>Int</type> to
      represent a service pack level for newer releases.</para>
      
    &osversion.ghci:types;

    <para>When we apply one of the later value constructors, we must
      supply an argument of type <type>Int</type> in order to produce
      a value.</para>

    &osversion.ghci:apply;

    <sect2>
      <title>Tuples, algebraic data types, and when to use
	each</title>

      <para>There is some overlap between tuples and user-defined
	algebraic data types.  If we wanted to, we could represent our
	<type>BookStore</type> type from earlier as an <type>(Int,
	  String)</type> pair.</para>

      &bookstore.ghci:tuple;

      <para>An algebraic data type gives us additional discrimination:
	two tuples with elements of the same type have the same type,
	but two algebraic data types with elements of the same type
	have distinct types.  This lets us bring the type system to
	bear in writing programs with fewer bugs. Consider the
	following representations of a two-dimensional vector.</para>

      &AlgebraicVector.hs:types;

      <para>The Cartesian and polar forms represent equivalent
	information using the same types for their two elements, but
	using different ranges of values with distinct meanings.
	Because <type>Vector2D</type> and <type>Polar2D</type> are
	distinct types, Haskell will not let us accidentally mix up
	these representations.</para>

      &algebraicvector.ghci:typed;

      <para>If we used tuples to represent these values, we could
	quickly land ourselves in hot water by mixing the two
	representations inappropriately.</para>

      &algebraicvector.ghci:tupled;

      <para>The type system can't rescue us here, because as far as
	it's concerned, we're comparing two <type>(Double,
	  Double)</type> pairs, which is a valid thing to do.</para>

      <para>There's no hard and fast rule for deciding when it's
	better to use a tuple or a distinct data type, but here's a
	rule of thumb to follow.</para>

      <para>If you're using many similarly-structured compound values
	that propagate widely throughout your code, adding type safety
	will almost certainly pay off.  For smaller, localised uses,
	such as returning multiple values from a function and
	immediately consuming them, a tuple is fine.</para>

      <para>In general, as the cost of making a mistake, or locating a
	bug, grows, then increasing type safety makes more sense. In
	practice, Haskell's type system often imposes little or no
	cost in either readability or performance.</para>
    </sect2>

    <sect2 id="deftypes.adt.comp">
      <title>Analogues to algebraic data types in other
	languages</title>

      <para id="x_Q4">Algebraic data types provide a uniform way to
	describe data types.  Other languages often need several
	different features to achieve the same degree of
	expressiveness.  Here are some analogues from C and C++, which
	might make it clearer what we can do with algebraic data
	types, and how they relate to concepts that might be more
	familiar.</para>

      <sect3>
	<title>The structure</title>

	<para id="x_R4">With just one constructor, an algebraic data
	  type is similar to a tuple: it groups related values
	  together into a compound value. It corresponds to a
	  <code>struct</code> in C or C++, and its components
	  correspond to the fields of a <code>struct</code>. Here's a
	  C equivalent of the <type>BookStore</type> type that we
	  defined earlier.</para>

	&types.c:book_info;

	<para>The main difference between the two is that the fields
	  in the Haskell type are anonymous and positional.</para>

	&BookStore.hs:BookInfo.noid;

	<para>By <emphasis>positional</emphasis>, we mean that the
	  section number is in the first field of the Haskell type,
	  and the title is in the second.  We refer to them by
	  location, not by name.</para>

	<para>In <xref linkend="deftypes.pattern"/>, we'll see how to access the
	  fields of a <type>BookStore</type> value.  In <xref
	  linkend="deftypes.record"/>, we'll introduce an alternate
	  syntax for defining data types that looks a little more
	  C-like.</para>

      </sect3>

      <sect3>
	<title>The enumeration</title>

	<para id="x_U4">Algebraic data types also serve where we'd use
	  an <code>enum</code> in C or C++, to represent a range of
	  symbolic values. Such algebraic data types are sometimes
	  referred to as enumeration types.  Here's an example from
	  C.</para>

	&types.c:roygbiv;

	<para id="x_EL">And here's a Haskell equivalent.</para>

	&Roygbiv.hs:Roygbiv;

	<tip>
	  <title>Comparing for equality</title>

	  <para>Notice that in the <code>deriving</code> clause for
	    our <type>Roygbiv</type> type, we added another word,
	    <code>Eq</code>.  This tells the Haskell implementation to
	    allow us to compare the values for equality.</para>
	</tip>

	&roygbiv.ghci:using;

	<para>In C, the values of an <code>enum</code> are unsigned
	  integers.  We can use an integer in a context where an
	  <code>enum</code> is expected.  A C compiler will
	  automatically convert values between the two types.  In
	  Haskell, this is not the case: each type is distinct.  We
	  cannot compare <code>Red</code> with <code>True</code>,
	  because they have different types.</para>

	&roygbiv.ghci:types;

	<para>Similarly, the values of <type>Roygbiv</type> aren't
	  numeric, so a compiler will prevent us from accidentally use
	  a number in place of a <type>Roygbiv</type> value.</para>
      </sect3>

      <sect3>
	<title>The discriminated union</title>

	<para id="x_S4">If an algebraic data type has multiple
	  alternatives, we can think of it as similar to a
	  <code>union</code> in C or C++.  A big difference between
	  the two is that a union doesn't tell us which alternative is
	  actually present; we have to explicitly and manually track
	  which alternative we're using, usually in another field of
	  an enclosing struct.  This means that unions can be sources
	  of nasty bugs, where our notion of which alternative we
	  should be using is incorrect.</para>

	&types.c:shape;

	<para>In the example above, the <code>union</code> can contain
	  valid data for a <code>struct circle</code> or a
	  <code>struct poly</code>, but not both at the same time.
	  The <code>enum</code>, which we have to maintain and inspect
	  by hand, indicates which kind of value is currently stored
	  in the <code>union</code>.</para>

	<para>The Haskell version of this code is both dramatically
	  shorter and safer than the C equivalent.</para>

	&ShapeUnion.hs:Shape;

	<para id="x_T4">If we create a <type>Shape</type> value using
	  the <code>Circle</code> constructor, the fact that we
	  created a <code>Circle</code> is stored along with the
	  circle's centre and radius.  When we later use a
	  <code>Circle</code>, we can't accidentally treat it as a
	  <code>Square</code>; we will see why in <xref
	  linkend="deftypes.pattern"/></para>
      </sect3>
    </sect2>

    <sect2 id="deftypes.adt.notes">
      <title>A few notes</title>

      <para id="x_V4">From reading the preceding sections, it should
	now be clear that <emphasis>all</emphasis> of the data types
	that we define with the <code>data</code> keyword are
	algebraic data types. Some may have just one alternative,
	while others have several, but they're all using the same
	machinery.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.pattern">
    <title>Pattern matching</title>

    <para id="x_Z5">Now that we've seen how to construct values with
      algebraic data types, let's discuss how we work with them.  We
      need to be able to distinguish between alternatives, and to
      extract elements from a compound value.  Haskell has a simple
      <emphasis>pattern matching</emphasis> facility that lets us do
      both of these.</para>

    <para id="x_a5">A pattern lets us peer inside a compound value and
      bind variables to the values it contains.  Here's an example of
      pattern matching in action on a list: we're going to add all
      elements of the list together.</para>

    &add.hs:sumList;

    <para id="x_c5">See that <code>(x:xs)</code> on the left of the
      first line? The <code>:</code> means <quote>match the head of a
	list</quote>; that's the familiar list constructor,
      <function>(:)</function>, in action in a new way.  The variables
      <varname>x</varname> and <varname>xs</varname> are given the
      values of (<quote>bound to</quote>) the head and tail of the
      list, respectively.  The whole pattern is wrapped in parentheses
      so Haskell won't parse it as three separate arguments.</para>

    <para id="x_d5">What effect does pattern matching have? Haskell
      will only evaluate the right hand side of an equation if it can
      match all of the patterns on the left hand side.  In the
      definition of <function>sumList</function> above, the right hand
      side of the first equation won't be evaluated if the input list
      is empty. Instead, Haskell will <quote>fall through</quote> to
      the equation on the following line, which
      <emphasis>does</emphasis> have a pattern for the empty list, and
      it will evaluate that.</para>

    <para id="x_e5">It might initially look like we have two functions
      named <function>sumList</function> here, but Haskell lets us
      define a function as a <emphasis>series of equations</emphasis>:
      so in fact these two clauses are defining the behaviour of one
      function, over different input values.  The <code>[]</code> on
      the left of the second equation is the constructor for an empty
      list.</para>

    <note>
      <title>Ordering is important</title>

      <para id="x_m5">When applying a function, a Haskell
	implementation checks patterns for matches in the order in
	which we specify them in our equations. Matching proceeds from
	top to bottom, and stops at the first success.</para>
    </note>

    <para>As a final note, there already exists a standard function,
      <function>sum</function>, that performs this adding-of-a-list
      for us.  Our <function>sumList</function> is purely for
      illustration.</para>

    <sect2>
      <title>Construction and deconstruction</title>

      <para>Let's step back and take a look at the relationship
	between constructing a value and pattern matching on
	it.</para>

      <para>A value constructor builds a value.  The expression
	<code>'a':['b']</code> applies the <function>(:)</function>
	constructor to the values <code>'a'</code> and
	<code>['b']</code> to produce a new compound value, the list
	<code>['a', 'b']</code>.</para>

      <para>When we pattern match against the <function>(:)</function>
	constructor, we <emphasis>reverse</emphasis> the construction
	process.  First of all, we check to see if the value does in
	fact contain that constructor.  If it does, we inspect the
	compound value to get the individual values that we originally
	passed to the constructor when we created the value.</para>

      <para>Let's consider what happens if we match the pattern
	<code>(x:xs)</code> against our example expression <code>'a':
	  ['b']</code>.</para>

      <itemizedlist>
	<listitem>
	  <para>The match will succeed, because the constructor in the
	    value matches the one in our pattern.</para>
	</listitem>
	<listitem>
	  <para>The variable <varname>x</varname> will be bound to
	    <code>'a'</code>.</para>
	</listitem>
	<listitem>
	  <para>The variable <varname>xs</varname> will be bound to
	    <code>['b']</code>.</para>
	</listitem>
      </itemizedlist>
      
      <para>Because pattern matching acts as the inverse of
	construction, it's sometimes referred to as
	<emphasis>de</emphasis>construction.</para>

      <note>
	<title>Deconstruction doesn't destroy anything</title>

	<para>If you're steeped in object oriented programming jargon,
	  don't confuse deconstruction with destruction! Matching a
	  pattern has no effect on the value we're examining: it just
	  lets us <quote>look inside</quote> it.</para>
      </note>
    </sect2>

    <sect2>
      <title>Further adventures</title>

      <para id="x_f5">The syntax for pattern matching on a tuple is
	similar to the syntax for constructing a tuple.  Here's a
	function that returns the last element of a 3-tuple.</para>

      &Tuple.hs:third;

      <para id="x_g5">There's no limit on how <quote>deep</quote>
	within a value a pattern can look.  This definition looks both
	inside a tuple and inside a list within that tuple.</para>

      &Tuple.hs:complicated;

      <para id="x_h5">We can try this out interactively.</para>

      &tuple.ghci:complicated;

      <para id="x_i5">Wherever a literal value is present in a pattern
	(<literal>True</literal> and <literal>5</literal> in the tuple
	pattern above), that value must match exactly for the pattern
	match to succeed.  If every pattern within a series of
	equations fails to match, we get a runtime error.</para>

      &tuple.ghci:nomatch;

      <para>For an explanation of this error message, skip forward a
	little, to <xref
	  linkend="deftypes.patterns.nonexhaustive"/>.</para>

      <para id="x_j5">We can pattern match on an algebraic data type
	using its value constructors.  Remember the
	<type>BookStore</type> type we defined earlier?  Here's how
	we can extract the values from a
	<type>BookStore</type>.</para>

      &BookStore.hs:accessors;

      <para id="x_k5">Let's see it in action.</para>

      &bookstore.ghci:unwrap;

      <para id="x_l5">The compiler can infer the types of the accessor
	functions based on the constructor we're using in our
	pattern.</para>

      &bookstore.ghci:unwrap.types;

      <para id="x_IL">Here are some rules of thumb to help with
	remembering how pattern matching works.  A constructor in a
	pattern checks that the matched value has the right
	<quote>shape</quote>.  A literal value ensures that that
	portion of the value has exactly the matching contents.  A
	variable makes no assertions about either the shape or
	contents of the matched value; it matches anything, and binds
	the variable to that value.</para>

      <para id="x_JL">So the pattern <code>(3:xs)</code> first of all
	is an assertion that a matching value is a non-empty list, by
	matching against the <function>(:)</function> constructor.  It
	also ensures that the head of the list is the literal value
	<literal>3</literal>.  If both of these conditions hold, the
	tail of the list will be bound to the variable
	<varname>xs</varname>.</para>
    </sect2>

    <sect2>
      <title>Variable naming in patterns</title>

      <para>As you read functions that match on lists, you'll
	frequently find that the names of the variables inside a
	pattern resemble <code>(x:xs)</code> or <code>(d:ds)</code>.
	This is a popular naming convention. The idea is that the name
	<varname>xs</varname> is the <quote>plural</quote> of
	<varname>x</varname>, because <varname>xs</varname> contains
	the remainder of the list, and <varname>x</varname> its
	head.</para>
    </sect2>

    <sect2 id="deftypes.dontcare">
      <title>The don't-care, or wild card, pattern</title>

      <para id="x_o5">When we're writing a pattern, we can specify
	that we don't care what value a particular value within a
	structure has, without actually binding that value to a name.
	The notation for this is <code>_</code>, and we call it a
	<emphasis>wild card</emphasis> or a <emphasis>don't
	  care</emphasis>.  We use it as follows.</para>

      <para>This function tells us whether the result of the
	<function>roots</function> function we defined earlier is
	real-valued or not.  We don't care about root-finding per se:
	this is just a well-known function that's a little (but
	<emphasis>only</emphasis> a little) complicated, so it's a
	good vehicle to explore with.</para>

      &Roots.hs:isRealValued;

      <para id="x_p5">Here, we don't care about the value of the
	result, just about which constructor was used to create it. If
	the constructor was <function>Just</function>, the result must
	be a real number, otherwise it's either infinite or complex.
	We can use a wild card for the entire second pattern; there's
	no need to see if the constructor is
	<function>Nothing</function>, because it
	<emphasis>must</emphasis> be; <type>Maybe</type> only has two
	constructors.</para>

      <para id="x_KL">In a pattern, a wild card acts similarly to a
	variable, only it doesn't bind the value to a name. While we
	can't put the same variable name multiple times in a single
	pattern, we can use a wild card as many times as we need
	to.</para>

      <para id="x_LL">Another advantage of wild cards is that a
	Haskell compiler can warn us if we introduce a variable name
	in a pattern, but don't use it in a function's body; defining
	something but forgetting to use it can often indicate a bug.
	Using a wild card instead of an unused variable makes it
	explicit that we really don't care what value is present, and
	will prevent such a warning.</para>

      <para id="x_ML">Wild cards also help readability, as they make
	it easier to tell which values we're really using.</para>

      &BookStore.hs:niceAccessors;

    </sect2>

    <sect2 id="deftypes.patterns.nonexhaustive">
      <title>Non-exhaustive patterns</title>

      <para>When writing a series of patterns, it's important to cover
	all of a type's constructors.  For example, if we're
	inspecting a list, we should have one equation that matches
	the non-empty constructor <function>(:)</function>, and one
	that matches the empty-list constructor
	<function>[]</function>.</para>

      <para>Let's see what happens if we fail to cover all the cases.
	Here, we're deliberately omitting a match against the
	<function>[]</function> constructor.</para>

      &BadPattern.hs:badExample;

      <para>If we call this with a value that it can't match, we'll
	get an error at runtime: our software has a bug!</para>

      &badpattern.ghci:error;

      <para>In this example, the initial application of
	<function>badExample</function> succeeds, because
	<code>[1]</code> is a more compact way of printing <code>1 :
	  []</code>.  The recursive application of <code>badExample
	  xs</code> is the source of the error, because then the value
	that's being matched against is simply <code>[]</code>.</para>

      <para>&GHC; provides a helpful compilation option,
	<option>-fwarn-incomplete-patterns</option>, that will cause
	it to print a warning during compilation if a sequence of
	patterns don't match all of a type's constructors.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.record">
    <title>Record syntax</title>

    <para>Writing accessor functions for each of a data type's
      components can be tedious.</para>

    &BookStore.hs:niceAccessors.noid;

    <para>Fortunately, Haskell provides a way of defining a data type,
      and accessors for each of its components, simultaneously.</para>

    &BookStore.hs:Customer;

    <para>This is almost exactly identical in meaning to the
      following, more familiar form.</para>

    &AltCustomer.hs:Customer;
    
    <para>When we use record syntax and give a name to each field in a
      data type, Haskell creates an accessor function with the name
      that we supply.</para>

    <para>We can still use the usual function call syntax to create a
      value of this type.</para>

    &BookStore.hs:customer1;

    <para>When we use record syntax to define a type, we can
      optionally use a more verbose form to create a value.</para>

    &BookStore.hs:customer2;

    <para>When we define a type using record syntax, it changes the
      printed representation of the type's values.</para>

    &bookstore.ghci:customer1;

    <para>For comparison, let's take another look at a value of the
      <type>BookInfo</type> type, which we defined without record
      syntax.</para>

    &bookstore.ghci:bookInfo.noid;

    <para>The accessor functions that we get <quote>for free</quote>
      when we use record syntax are normal Haskell functions.</para>

    &bookstore.ghci:accessor;
  </sect1>

  <sect1 id="deftypes.paramtypes">
    <title>Parameterised types</title>

    <para id="x_Z4">We've repeatedly mentioned that the list type is
      polymorphic: the elements of a list can be of any type.  We can
      also add polymorphism to our own types. To do this, we introduce
      type variables into a type declaration.  Let's define a
      <type>Nullable</type> type: we can use this to represent a
      missing value, e.g. an empty field in a database row.</para>

    &Nullable.hs:Nullable;

    <para id="x_a4">Here, the variable <varname
	role="type">a</varname> is not a regular variable: it's a type
      variable.  It indicates that our <type>Nullable</type> type
      takes another type as its parameter.  This lets us use
      <type>Nullable</type> on values of any type.</para>

    &Nullable.hs:wrappedTypes;

    <para id="x_b4">As usual, we can load our source file into &ghci;
      and experiment with it.</para>

    &nullable.ghci:experiment;

    <para id="x_c4"><type>Nullable</type> is a polymorphic, or
      generic, type.  When we create a type by giving the
      <type>Nullable</type> type constructor a parameter, we can see
      what the new type looks like by substituting that type for the
      type variable <varname role="type">a</varname> everywhere in the
      definition of <type>Nullable</type>.  The type <type>Nullable
	String</type> has a value constructor, also named
      <code>Nullable</code>, that takes a parameter of type
      <type>String</type>.  As we might expect, the type
      <type>Nullable Int</type> is distinct from <type>Nullable
	Bool</type>, and so on.</para>

    <para id="x_e4">We can nest uses of parameterised types inside
      each other, but when we do, we may need to use parentheses to
      tell the Haskell compiler how to parse our expression.</para>

    &Nullable.hs:parens;

    <para>If we omitted the parentheses, this would be parsed as
      <code>(Really Really) Int</code>, which isn't valid.</para>

    <para id="x_d4">To once again extend an analogy to more familiar
      languages, parameterised types give us a facility that bears
      some resemblance to templates in C++, and to generics in Java.
      Just be aware that this is a shallow analogy.  Templates and
      generics were added to their respective languages long after the
      languages were initially defined, and have an awkward feel.
      Haskell's parameterised types are simpler and easier to use, as
      the language was designed with them  from the beginning.</para>
  </sect1>

  <sect1 id="deftypes.recursive">
    <title>Recursive types</title>

    <para>The familiar list type is <emphasis>recursive</emphasis>:
      it's defined in terms of itself.  To understand what this means,
      let's create our own list-like type.  We'll use
      <code>Cons</code> in place of the <function>(:)</function>
      constructor, and <code>Nil</code> in place of
      <code>[]</code>.</para>

    &ListADT.hs:List;

    <para>We can visually identify this type as defined in terms of
      itself because <type>List a</type> appears on both the left and
      the right of the <code>=</code> sign.  What this means in
      practice is that if we want to use the <code>Cons</code>
      constructor to create a new value, we must supply a value of
      type <varname role="type">a</varname>, and another value of type
      <varname role="type">List a</varname>.</para>

    <para>The smallest value of type <type>List a</type> that we can
      create is <code>Nil</code>.</para>

    &listadt.ghci:empty;

    <para>We can use <code>Nil</code>, which has the type <type>List
	a</type>, as a parameter to <code>Cons</code>.</para>

    &listadt.ghci:tiny;

    <para>We can also use a value constructed using <code>Cons</code>
      as a parameter to <code>Cons</code>.</para>

    &listadt.ghci:two;

    <para>We could obviously continue in this fashion indefinitely,
      creating ever longer <code>Cons</code> chains, each  with a
      single <code>Nil</code> at the end.  This gives us another way
      to look at <type>List</type> as recursive.</para>
    
    <para>To prove to ourselves that our <type>List a</type> type is
      the same shape as <type>[a]</type>, we can write a function that
      reproduces any value of type <type>[a]</type> in the form of a
      value of type <type>List a</type>.</para>

    &ListADT.hs:fromList;

    <para>By inspection, this clearly substitutes a <code>Cons</code>
      for every <function>(:)</function>, and a <code>Nil</code> for
      each <code>[]</code>.  The two types are
      <emphasis>isomorphic</emphasis>.</para>

    &listadt.ghci:fromList;

    <para id="x_K5">For a third perspective on what a recursive type
      is, here's a definition of a binary tree type.</para>

    &Tree.hs:Tree;

    <para>This time, let's search for insight by looking at a more
      familiar language.  Here's a comparable class definition in
      Java.</para>

    &Tree.java:Tree;

    <para>The one significant difference is that Java lets us use the
      special value <code>null</code> anywhere to indicate
      <quote>nothing</quote>, so we can use <code>null</code> to
      indicate that a node doesn't have a left or right child.  Here's
      a small function that constructs a tree with two leaves (a leaf,
      by convention, has no children).</para>

    &Tree.java:Example;

    <para>In Haskell, we don't have an equivalent of
      <code>null</code>. We could use the <type>Maybe</type> type to
      provide a similar effect, but that bloats the pattern matching
      (try it yourself).  Instead, we've decided to use a no-argument
      <code>Empty</code> constructor.  Where the Java example provides
      <code>null</code> to the <type>Tree</type> constructor, we
      supply <code>Empty</code> in Haskell.</para>

    &Tree.hs:simpleTree;

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Write the converse of <function>fromList</function>:
	      a function that takes a <type>List a</type> and
	      generates a <type>[a]</type>.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="deftypes.error">
    <title>Reporting errors</title>

    <para id="x_w3">Haskell provides a standard function,
      <function>error :: Char -&gt; a</function>, that we can call
      when something has gone terribly wrong in our code.  We give it
      a string parameter, which is the error message to display. Its
      type signature looks peculiar: how can it produce a value of any
      type <varname role="type">a</varname> given just a string? The
      answer is that it doesn't, because <function>error</function> is
      special.</para>

    <para id="x_x3">It has a result type of <varname
	role="type">a</varname> so that we can call it anywhere and it
      will always have the right type.   However, instead of returning
      a value like a normal function, it <emphasis>immediately aborts
	evaluation</emphasis>, and prints the error message we give
      it.</para>

    <para>Here's an example.  The <function>mySecond</function>
      function returns the second element of its input list, but fails
      if its input list isn't long enough.</para>

    &MySecond.hs:mySecond;

    <para id="x_y3">As usual, we can see how this works in practice in
      &ghci;.</para>

    &error.ghci:mySecond;

    <para id="x_z3">Notice that in the third case above, where we're
      trying to use the result of the call to
      <function>mySecond</function> as the argument to another
      function, evaluation still terminates and drops us back to the
      &ghci; prompt.  This is the major weakness of using
      <function>error</function>: it doesn't let our caller
      distinguish between a recoverable error and a problem so severe
      that it really should terminate our program.</para>

    <sect2>
      <title>A more controlled approach</title>

      <para>Haskell defines a standard type, <type>Maybe</type>, that
	we can use to represent the possibility of an error.  It has
	the same structure as the <type>Nullable</type> type that we
	defined earlier.</para>

      &Maybe.hs:Maybe;

      <para>If we want to represent <quote>fail</quote>, we use the
	<function>Nothing</function> constructor.  Otherwise, we wrap
	our value with the <function>Just</function>
	constructor.</para>

      <para>Let's see what our <function>mySecond</function> function
	looks like if we return a <type>Maybe</type> value instead of
	calling <function>error</function>.</para>

      &MySecond.hs:safeSecond;

      <para>If the list we're passed isn't long enough, instead of
	crashing the program, we return <code>Nothing</code> to our
	caller.  This lets them decide what to do if the list isn't
	long enough, where a call to <function>error</function> would
	force a crash.</para>

      <para>To return to an earlier topic, we can use pattern matching
	to clarify this function.</para>

      &MySecond.hs:tidySecond;

      <para>The first pattern only matches if the list is at least two
	elements long (it contains two list constructors), and it
	binds the variable <varname>x</varname> to the list's second
	element. The second pattern is matched if the first
	fails.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.locals">
    <title>Introducing local variables</title>

    <para id="x_f4">Within the body of a function, we can introduce
      new local variables whenever we need them, using a
      &let; expression.  As an example, let's write a
      function that calculates the real-valued roots of the quadratic
      equation <literal>a * (x ** 2) + b * x + c ==
	0</literal>.</para>

    <para>To represent the result, we'll use the <type>Maybe</type>
      type.  The roots could potentially be infinite (if we divide by
      zero) or complex numbers (if the square root term is negative),
      in which cases we'll return <code>Nothing</code>.</para>

    &realRoots.ghci:maybe;

    <para>We'll use <function>Just</function> to contain the roots
      when they're defined, and <function>Nothing</function> to
      indicate that the result is undefined for the given
      inputs.</para>

    &Roots.hs:realRoots;

    <para id="x_g4">The keywords to look out for here are
      &let;, which starts a block of variable declarations,
      and <code>in</code>, which ends it.  Each line introduces a new
      variable.  The name is on the left of the <literal>=</literal>,
      and the expression it's bound to is on the right.</para>

    <note>
      <title>Special notes</title>

      <para>Let us re-emphasise our wording: a name in a &let; block
	is bound to an <emphasis>expression</emphasis>, not to a
	<emphasis>value</emphasis>.  Because Haskell is a lazy
	language, the expression associated with a name won't actually
	be evaluated until it's needed.</para>

      <para>When we define a variable in a &let; block, we refer to it
	as a <emphasis>&let;-bound</emphasis> variable.  This simply
	means what it says: we bound the variable in a &let;
	block.</para>

      <para>Also, our use of white space here is important.  We'll
	talk about the layout rules in <xref
	linkend="deftypes.offside"/>.</para>
    </note>

    <para>We can use the names of a variable in a &let; block both
      within the block itself and in the expression that follows the
      <code>in</code> keyword.</para>

    <para>In general, we'll refer to the places within our code where
      we can use a name as the name's <emphasis>scope</emphasis>.  If
      we can use a name, it's <emphasis>in scope</emphasis>, otherwise
      it's <emphasis>out of scope</emphasis>.  If a name is visible
      throughout a source file, we say it's at the <emphasis>top
	level</emphasis>.</para>

    <sect2>
      <title>Local variables and lazy evaluation</title>

      <para>In our definition of <function>realRoots</function>, we're
	making use of laziness.  Here's how to follow what's going
	on.</para>

      <itemizedlist>
	<listitem>
	  <para>To begin with, recall that the expressions in the
	    &let; block aren't evaluated, they're just bound.</para>
	</listitem>
	<listitem>
	  <para>The first value that is actually inspected is the &if;
	    expression's predicate, <code>a /= 0 &amp;&amp; n &gt;=
	      0</code>.</para>
	</listitem>
	<listitem>
	  <para>If the value of <varname>a</varname> is zero, then the
	    left branch of the <function>(&amp;&amp;)</function>
	    expression is <code>False</code>, and so the whole
	    predicate is <code>False</code>.  No further computation
	    is needed; we immediately return
	    <code>Nothing</code>.</para>
	</listitem>
	<listitem>
	  <para>To compare <varname>n</varname> with zero, we must
	    evaluate it.  If the <function>(&gt;=)</function>
	    comparison fails, we again do no further work, and return
	    <code>Nothing</code>.</para>
	</listitem>
	<listitem>
	  <para>Even when the predicate succeeds and we return the
	    <function>Just</function> branch, we're returning an
	    <emphasis>expression</emphasis>, not a value.  We still
	    won't compute <code>sqrt n</code> until our caller
	    actually needs one or other of the roots.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Shadowing</title>

      <para id="x_i4">We can <quote>nest</quote> multiple
	&let; blocks inside each other in an
	expression.</para>

      &NestedLets.hs:foo;

      <para>It's perfectly legal, but not exactly wise, to repeat a
	variable name in a nested &let; expression.</para>

      &NestedLets.hs:bar;

      <para>Here, the inner <varname>x</varname> is hiding, or
	<emphasis>shadowing</emphasis>, the outer
	<varname>x</varname>.</para>

      &nestedlets.ghci:bar;

      <para>We can also shadow a function's parameters, leading to
	even stranger results.  What is the type of this
	function?</para>

      &NestedLets.hs:quux;

      <para>Because the argument <varname>a</varname> is never used in
	the body of the function, due to being shadowed by the
	&let;-bound <varname>a</varname>, the argument can have any
	type at all.</para>

      &nestedlets.ghci:quux;

      <para>Shadowing can obviously lead to nasty bugs, so &GHC; has a
	helpful <option>-fwarn-name-shadowing</option> option that
	will print a warning message if we accidentally shadow a
	name.</para>
    </sect2>

    <sect2>
      <title>The where clause</title>

      <para>There's another mechanism we can use to introduce local
	variables, called a &where; clause. The definitions
	in a &where; clause apply to the code that
	<emphasis>precedes</emphasis> it.  Let's illustrate what we
	mean with another example.</para>

      <para>For variety, we'll introduce complex numbers to represent
	the complex roots, and an abstract data type for the result.
	The <function>(:+)</function> operator below constructs a
	complex number from its real and imaginary parts.</para>

      &Roots.hs:roots;

      <para id="x_j4">Our <function>roots</function> function returns
	the real-valued roots when they're defined, the complex roots
	otherwise, and <code>Undefined</code> if the roots are
	infinite due to <varname>a</varname> being zero.</para>

      <para>A &where; clause can initially seem very weird to
	non-Haskell programmers.  It's a great way to put your
	reader's focus on the important details of an expression, with
	the supportings definitions following afterwards.  After a
	while, you'll find yourself missing &where; clauses
	in languages that lack them!</para>

      <para id="x_l4">As with &let; expressions, names are bound to
	expressions in &where; clauses, and white space is
	significant.  We'll be talking more about the layout rules
	shortly, in <xref linkend="deftypes.offside"/>.</para>
    </sect2>

    <sect2 id="deftypes.locals.functions">
      <title>Local functions, global variables</title>

      <para id="x_FL">You'll have noticed that Haskell's syntax for
	defining a variable looks very similar to its syntax for
	defining a function.  This symmetry is preserved in
	&let; and &where; blocks: we can define
	local <emphasis>functions</emphasis> just as easily as local
	<emphasis>variables</emphasis>.  All of the same syntax
	applies as at the top level: we can use multiple equations,
	patterns, and guards.</para>

      &LocalFunction.hs:pluralise;

      <para id="x_GL">In this example, we define and use a local
	function <function>plural</function> using several equations.
	Local functions can freely use variables from the scopes that
	enclose them; here, we use <varname>word</varname> from the
	definition of the outer function
	<function>pluralise</function>.  In the definition of
	<function>pluralise</function>, the <function>map</function>
	function (which we'll be revisiting in the next chapter)
	applies the local function <function>plural</function> to
	every element of the <varname>counts</varname> list.</para>

      <para>We can also define variables, as well as functions, at the
	top level of a source file.</para>

      &GlobalVariable.hs:itemName;

      <para>Global variables are frowned upon in imperative languages,
	because they introduce coupling between distant pieces of
	code.  Change a global variable in one function, and it
	affects the behaviour of another, possibly unexpectedly.
	Since values are immutable in Haskell, top level variables are
	risk-free.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.offside">
    <title>The offside rule and white space in an expression</title>

    <para id="x_u4">In our definition of <function>realRoots</function>, the
      left margin of our text wandered around quite a bit.  This was
      not an accident: in Haskell, white space has meaning.</para>

    <para id="x_v4">Haskell uses indentation as a cue to parse sections of code.
      This use of layout to convey structure is sometimes called the
      offside rule. At the top level, the first declaration or
      definition can start in any column, and the Haskell compiler or
      interpreter remembers that indentation level.  Every subsequent
      top-level declaration must have the same indentation.</para>

    <para id="x_w4">Here's an illustration of the top-level indentation rule.
      Our first file, <filename>GoodIndent.hs</filename>, is well
      behaved.</para>

    &GoodIndent.hs:good;

    <para id="x_x4">Our second, <filename>BadIndent.hs</filename>, doesn't play
      by the rules.</para>

    &BadIndent.hs:bad;

    <para id="x_y4">Here's what happens when we try to load the two files into
      &ghci;.</para>

    &indent.ghci:load;

    <para id="x_z4">An empty line is treated as a continuation of the current
      item, as is a line indented to the right of the current current
      item.</para>

    <para id="x_A5">The rules for &let; expressions and
      &where; clauses are similar.  After a
      &let; or &where; keyword, the Haskell
      compiler or interpreter remembers the indentation of the next
      token it sees. If the next line is empty, or its indentation is
      further to the right than the previous line, this counts as
      continuing the previous line. On the other hand, if the
      indentation is the same as the previous line, this is treated as
      beginning a new item in the same block.</para>

    <para id="x_B5">Here are nested uses of &let; and
      &where;.</para>

    &letwhere.hs:let;

    <para id="x_C5">The name <varname>a</varname> is only visible
      within the inner &let; expression.  It's not visible
      in the outer &let;.  If we try to use the name
      <varname>a</varname> there, we'll get a compilation
      error.</para>

    &letwhere.hs:where;

    <para id="x_D5">Similarly, the scope of the first &where; clause
      is the definition of <varname>foo</varname>, but the scope of
      the second is just the first &where; clause.</para>

    <para id="x_E5">The indentation we use for the &let; and
      &where; clauses makes our intentions easy to figure
      out.</para>

    <sect2 id="deftypes.tabs">
      <title>A note about tabs versus spaces</title>

      <para id="x_F5">If you are using a Haskell-aware text editor (e.g. Emacs),
	it is probably already configured to use space characters for
	all white space within a line.  If your editor is
	<emphasis>not</emphasis> Haskell-aware, you should configure
	it to only use space characters.</para>

      <para id="x_G5">The reason for this is portability.  In an editor
	that uses a fixed-width font, tab stops are by default placed
	at different intervals on Unix-like systems (every eight
	characters) than on Windows  (every four characters). This
	means that no matter what your personal beliefs are about
	where tabs belong, you can't rely on someone else's editor
	honouring your preferences.  Any indentation that uses tabs is
	going to look broken under <emphasis>someone's</emphasis>
	configuration.  In fact, this could lead to compilation
	problems, as the Haskell language standard requires
	implementations to use the Unix tab width convention.
	Using space characters avoids these problem
	entirely.</para>
    </sect2>

    <sect2 id="deftypes.block">
      <title>The offside rule is not mandatory</title>

      <para id="x_H5">We can use explicit structuring instead of layout to
	indicate what we mean.  To do so, we start a block of
	equations with an opening curly brace; separate each item with
	a semicolon; and finish the block with a closing curly brace.
	The following two uses of &let; have the same
	meanings.</para>

      &Braces.hs:braces;

      <para id="x_I5">When we use explicit structuring, the normal layout rules
	don't apply, which is why we can get away with unusual
	indentation in the second &let; expression.</para>

      <para id="x_J5">We can use explicit structuring anywhere that we'd
	normally use layout.  It's valid for &where;
	clauses, and even top-level declarations.  Just remember that
	although the facility exists, explicit structuring is hardly
	ever actually <emphasis>used</emphasis> in Haskell
	programs.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.case">
    <title>The case expression</title>

    <para id="x_q5">We're not limited to using patterns in function
      definitions.  The <code>case</code> expression lets us match
      patterns at any time.  Here's what it looks like.</para>

      &Roots.hs:hasRealRoots;

    <para id="x_r5">The <code>case</code> keyword is followed by an
      arbitrary expression: this is the expression that we're
      checking0. The <code>of</code> keyword signifies the end of the
      expression and the beginning of the block of patterns and
      expressions.</para>

    <para id="x_s5">Each item in the block consists of a pattern,
      followed by an arrow <code>-&gt;</code>, followed by an
      expression to evaluate if that pattern matches.  These
      expressions must all have the same type.  The result of the
      <code>case</code> expression is the result of the expression
      associated with the first pattern to match.  Matches are
      attempted from top to bottom.</para>

    <para id="x_t5">To express <quote>here's the expression to
	evaluate if none of the other patterns match</quote>, we just
      use the wild card pattern <code>_</code> as the last in our list
      of patterns.</para>
  </sect1>
  
  <sect1 id="deftypes.pattern.limits">
    <title>Common beginner mistakes with patterns</title>

    <para id="x_NL">There are a few ways in which new Haskell
      programmers can misunderstand or misuse patterns.  Here are a
      few potential missteps that you can easily avoid.</para>

    <para id="x_OL">Here are some attempts at pattern matching gone
      awry.  Depending on what you expect one of these examples to do,
      it might contain a surprise..</para>

    <sect2>
      <title>Matching against a variable</title>

      &BogusPattern.hs:whichFruit;

      <para id="x_w5">A naive glance suggests that this code is trying
	to check the value <function>f</function> to see whether it
	matches the value <varname>apple</varname> or
	<varname>orange</varname>.</para>

      <para id="x_x5">The first appearance of <varname>apple</varname>
	in the <code>case</code> expression is a pattern,
	<emphasis>not</emphasis> a use of the top level
	<function>apple</function> variable. Because this pattern
	doesn't mention a type constructor or a literal value (the two
	things that might cause a pattern matching attempt to fail),
	this branch of the <code>case</code> will
	<emphasis>always</emphasis> match, no matter what the value of
	<varname>f</varname> is.</para>

      <note>
	<title>Irrefutable patterns</title>

	<para id="x_y5">We refer to a pattern that consists only of a
	  variable name, and thus cannot fail to match, as
	  <emphasis>irrefutable</emphasis>. The wild card pattern
	  <code>_</code> is also irrefutable.</para>
      </note>

      <para>Here's a corrected version of this function.</para>

      &BogusPattern.hs:betterFruit;

      <para>Our bugfix involved making this function match against the
	literal values <code>"apple"</code> and
	<code>"orange"</code>.</para>
    </sect2>

    <sect2>
      <title>Comparing values for equality</title>

      <para>What if we want to compare the values stored in two nodes
	of type <type>Tree</type>, and return one of them if they're
	equal?  Here's a naive attempt.</para>

      &BadTree.hs:nodesAreSame;
    
      <para id="x_A6">A variable can only appear once in a function's
	bindings. We can't place a variable in multiple positions to
	express the notion <quote>this value and that should be
	  identical</quote>.  Instead, we'll solve this problem using
	<emphasis>guards</emphasis>, another invaluable language
	feature.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.guard">
    <title>Conditional evaluation with guards</title>

    <para id="x_C6">Pattern matching only lets us make fixed tests of
      a value's shape.  Although this is useful, we often need to
      perform a more expressive check before evaluating a function's
      body.  Haskell provides a feature, <emphasis>guards</emphasis>,
      that give us this ability.  We'll introduce the idea with an
      example.</para>

    &Roots.hs:guardedRoots;

    <para>A pattern can have zero or more guards, each an expression
      of type <type>Bool</type>.  A guard is introduced by a
      <code>|</code> symbol, followed by the guard expression, then an
      <code>=</code> symbol (or <code>-&gt;</code> if we're in a
      &case; expression), then the body to use if the guard succeeds.
      If the pattern matches, each guard is evaluated in turn.  If a
      guard succeeds, its associated body is used as the result of the
      function.  If no guard succeeds, pattern matching moves on to
      the next pattern.</para>

    <para>A guard expression can use any variables mentioned in the
      pattern that it's associated with.  The special-looking guard
      expression <varname>otherwise</varname> is simply a variable
      bound to the value <code>True</code>.</para>

    <para>Here's another example of guards in action, where we've
      rewritten our <function>nodesAreSame</function> example to be
      correct and concise.</para>

    &GoodTree.hs:nodesAreSame;

    <para id="x_F6">We can use guards anywhere that we can use
      patterns.  The advantage of writing a function as a series of
      equations using pattern matching and guards is that it often
      makes code much clearer.  Remember the
      <function>myDrop</function> function we defined in <xref
	linkend="funcstypes.if"/>?</para>

    &myDrop.hs:myDrop.noid;

    <para id="x_H6">Here's a reformulation that uses patterns and
      guards.</para>

    &myDrop.hs:niceDrop;

    <para>This change in style lets us enumerate <emphasis>up
	front</emphasis> the cases in which we expect a function to
      behave differently. If we bury the decisions inside a function
      as &if; expressions, the code becomes harder to read.</para>
  </sect1>

  <sect1 id="deftypes.end">
    <title>Conclusion</title>

    <para>In this chapter, we've seen how to define our own
      algebraic data types.  We've read about Haskell's offside rule
      for laying out functions, and how we can avoid it if we need to.
      We've seen pattern matching and guards.  We've discussed error
      handling.</para>

    <para>At this point, our basic toolbox is complete.  In
      <xref linkend="fp"/>, we'll use this knowledge to develop our
      functional programming and thinking skills.</para>

  </sect1>
</chapter>
<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
