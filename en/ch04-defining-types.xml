<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.deftypes" revision="alpha">
  <title>Defining Types, Streamlining Functions</title>

  <para>Topics: Creating new types.  Ways to write clearer
    functions.</para>

  <sect1 id="hs.deftypes.data">
    <title>Defining a new data type</title>
      
    <para id="x_C4">Although lists and tuples are useful, we'll still often want
      to construct new data types of our own.  We define a new data
      type using the <code>data</code> keyword.</para>

    &BookSection.hs:BookSection;

    <para id="x_D4">The <type>BookSection</type> after the
      <code>data</code> keyword is the name of our new type. We call
      <type>BookSection</type> a <emphasis>type
	constructor</emphasis>.  (As we've already mentioned, a type
      name, and hence a type constructor, must start with a capital
      letter.)  The string <code>Section</code> is the name of the
      <emphasis>value constructor</emphasis> we'll apply to create a
      value of this type.  (As with a type constructor, a value
      constructor's name must start with a capital letter.)</para>

    <para>Finally, the <type>Int</type> and <type>String</type> that
      follow are the <emphasis>components</emphasis> of the type.  A
      component serves the same purpose in Haskell as a field in a
      structure or class would in another language: it's a
      <quote>slot</quote> where we can put a value.  We'll often refer
      to components as fields.</para>

    <note>
      <title>Deriving what?</title>

      <para id="x_E4">We'll explain the full meaning of <code>deriving
	  (Show)</code> later, in
	<xref linkend="hs.typeclasses.wellknown.show"/>.  For now,
	it's enough to know that we need to tack this onto a type
	declaration so that &ghci; will automatically know how to
	print a value of this type.</para>
    </note>

    <para id="x_F4">We can create a new value of type
      <type>BookSection</type> by treating
      <function>Section</function> as a function, and applying it with
      arguments of types <type>Int</type> and
      <type>String</type>.</para>

    &BookSection.hs:fp;

    <para id="x_G4">Once we've defined a type, we can experiment with it in
      &ghci;.  We begin by using the <command>:load</command> command
      to load our source file.</para>

    &booksection.ghci:load;

    <para id="x_H4">Remember the <code>fpSection</code> variable we
      defined?  Here it is.</para>

    &booksection.ghci:fp;

    <para id="x_I4">We can construct new values interactively in &ghci;,
      too.</para>

    &booksection.ghci:newValue;

    <para id="x_AL">The &ghci; command <command>:type</command> lets us see what
      the type of that expression is.</para>

    &booksection.ghci:valueType;

    <para id="x_J4">To find out more about a type, we can use some of &ghci;'s
      browsing capabilities.  The <command>:info</command> command
      gets &ghci; to tell us everything it knows about a
      type.</para>
    
    &booksection.ghci:info;

    <para id="x_K4">We can also find out why we use
      <function>Section</function> to construct a new value of
      type <type>BookSection</type>.</para>

    &booksection.ghci:type;

    <para id="x_L4">We can treat a value constructor as just another
      function, one that happens to create and return a new value of
      the type we desire.</para>

    <sect2>
      <title>Naming types and values</title>

      <para>When we introduced the type <type>BookSection</type>, we
	deliberately chose to give the type constructor
	<type>BookSection</type> a different name from the value
	constructor <code>Section</code>, purely to make it obvious
	which was which.</para>

      <para>However, in Haskell, the names of types and values occupy
	two independent <emphasis>namespaces</emphasis>, so there is
	no ambiguity if we give a type constructor and a value
	constructor the same name.</para>

      &BookSection.hs:BookChapter;

      <para>This definition says that the type named
	<type>BookChapter</type> has a value constructor that is also
	named <code>BookChapter</code>.  Since a type signature
	doesn't contain value names, and a normal expression doesn't
	contain type names, it's always clear from the context in
	which we use a name whether that name refers to a type or a
	value.</para>

      <para>In fact, not only is it <emphasis>legal</emphasis> for a
	value constructor to have the same name as its type
	constructor, it's <emphasis>normal</emphasis>: you'll see this
	all the time in regular Haskell code.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.deftypes.adt">
    <title>Algebraic data types</title>

    <para id="x_M4">The <type>Bool</type> type that we introduced
      earlier is the simplest example of a category of type called an
      <emphasis>algebraic data type</emphasis>. An algebraic data type
      has several value constructors.</para>

      &Bool.hs:Bool;

    <para id="x_N4">In the case of <type>Bool</type>, the type has two
      value constructors, <code>True</code> and <code>False</code>.
      Each value constructor is separated in the definition by a
      <literal>|</literal> character, which we can read as
      <quote>or</quote>.  The different value constructors are usually
      referred to as <emphasis>alternatives</emphasis> or
      <emphasis>cases</emphasis>.</para>

    <note>
      <title>Why <quote>algebraic</quote>?</title>

      <para id="x_BL">The use of the word <quote>algebraic</quote> for
	describing these data types comes from abstract
	algebra.</para>

      <para>Although the phrase <quote>algebraic data type</quote> is
	long, we're being careful to avoid using the acronym
	<quote>ADT</quote> instead.  That acronym is already widely
	understood to stand for <quote><emphasis>abstract</emphasis>
	data type</quote>, which is quite different.</para>
    </note>

    <para id="x_O4">Each of an algebraic data type's value
      constructors can take zero or more arguments.  As an example,
      here's one way we might represent versions of the Windows
      operating system.</para>

    &OsVersion.hs:WindowsVersion;

    <para id="x_P4">The alternatives that represent older releases
      don't need arguments, but we use an <type>Int</type> to
      represent a service pack level for newer releases.</para>
      
    &osversion.ghci:types;

    <para>When we apply one of the later value constructors, we must
      supply an argument of type <type>Int</type> in order to produce
      a value.</para>

    &osversion.ghci:apply;

    <sect2>
      <title>Tuples, algebraic data types, and when to use
	each</title>

      <para>There is some overlap between tuples and user-defined
	algebraic data types.  If we wanted to, we could represent our
	<type>BookSection</type> type from earlier as an <type>(Int,
	  String)</type> pair.</para>

      &booksection.ghci:tuple;

      <para>An algebraic data type gives us additional discrimination:
	two tuples with elements of the same type have the same type,
	but two algebraic data types with elements of the same type
	have distinct types.  This lets us bring the type system to
	bear in writing programs with fewer bugs. Consider the
	following representations of a two-dimensional vector.</para>

      &AlgebraicVector.hs:types;

      <para>The Cartesian and polar forms represent equivalent
	information using the same types for their two elements, but
	using different ranges of values with distinct meanings.
	Because <type>Vector2D</type> and <type>Polar2D</type> are
	distinct types, Haskell will not let us accidentally mix up
	these representations.</para>

      &algebraicvector.ghci:typed;

      <para>If we used tuples to represent these values, we could
	quickly land ourselves in hot water by mixing the two
	representations inappropriately.</para>

      &algebraicvector.ghci:tupled;

      <para>The type system can't rescue us here, because as far as
	it's concerned, we're comparing two <type>(Double,
	  Double)</type> pairs, which is a valid thing to do.</para>

      <para>There's no hard and fast rule for deciding when it's
	better to use a tuple or a distinct data type, but here's a
	rule of thumb to follow.</para>

      <para>If you're using many similarly-structured compound values
	that propagate widely throughout your code, adding type safety
	will almost certainly pay off.  For smaller, localised uses,
	such as returning multiple values from a function and
	immediately consuming them, a tuple is fine.</para>

      <para>In general, as the cost of making a mistake, or locating a
	bug, grows, then increasing type safety makes more sense. In
	practice, Haskell's type system often imposes little or no
	cost in either readability or performance.</para>
    </sect2>

    <sect2 id="hs.deftypes.adt.comp">
      <title>Analogues to algebraic data types in other
	languages</title>

      <para id="x_Q4">Algebraic data types provide a uniform way to
	describe data types.  Other languages often need several
	different features to achieve the same degree of
	expressiveness.  Here are some analogues from C and C++, which
	might make it clearer what we can do with algebraic data
	types, and how they relate to concepts that might be more
	familiar.</para>

      <sect3>
	<title>The structure</title>

	<para id="x_R4">With just one constructor, an algebraic data
	  type is similar to a tuple: it groups related values
	  together into a compound value. It corresponds to a
	  <code>struct</code> in C or C++, and its components
	  correspond to the fields of a <code>struct</code>. Here's a
	  C equivalent of the <type>BookSection</type> type that we
	  defined earlier.</para>

	&types.c:book_section;

	<para>The main difference between the two is that the fields
	  in the Haskell type are anonymous and positional.</para>

	&BookSection.hs:BookSection.noid;

	<para>By <emphasis>positional</emphasis>, we mean that the
	  section number is in the first field of the Haskell type,
	  and the title is in the second.  We refer to them by
	  location, not by name.  In <xref
	linkend="hs.deftypes.pattern"/>, we'll see how to access the
	  fields of a <type>BookSection</type> value.</para>

      </sect3>

      <sect3>
	<title>The enumeration</title>

	<para id="x_U4">Algebraic data types also serve where we'd use
	  an <code>enum</code> in C or C++, to represent a range of
	  symbolic values. Such algebraic data types are sometimes
	  referred to as enumeration types.  Here's an example from
	  C.</para>

	&types.c:roygbiv;

	<para id="x_EL">And here's a Haskell equivalent.</para>

	&Roygbiv.hs:Roygbiv;

	<tip>
	  <title>Comparing for equality</title>

	  <para>Notice that in the <code>deriving</code> clause for
	    our <type>Roygbiv</type> type, we added another word,
	    <code>Eq</code>.  This tells the Haskell implementation to
	    allow us to compare the values for equality.</para>
	</tip>

	&roygbiv.ghci:using;

	<para>In C, the values of an <code>enum</code> are unsigned
	  integers.  We can use an integer in a context where an
	  <code>enum</code> is expected.  A C compiler will
	  automatically convert values between the two types.  In
	  Haskell, this is not the case: each type is distinct.  We
	  cannot compare <code>Red</code> with <code>True</code>,
	  because they have different types.</para>

	&roygbiv.ghci:types;

	<para>Similarly, the values of <type>Roygbiv</type> aren't
	  numeric, so a compiler will prevent us from accidentally use
	  a number in place of a <type>Roygbiv</type> value.</para>
      </sect3>

      <sect3>
	<title>The discriminated union</title>

	<para id="x_S4">If an algebraic data type has multiple
	  alternatives, we can think of it as similar to a
	  <code>union</code> in C or C++.  A big difference between
	  the two is that a union doesn't tell us which alternative is
	  actually present; we have to explicitly and manually track
	  which alternative we're using, usually in another field of
	  an enclosing struct.  This means that unions can be sources
	  of nasty bugs, where our notion of which alternative we
	  should be using is incorrect.</para>

	&types.c:shape;

	<para>In the example above, the <code>union</code> can contain
	  valid data for a <code>struct circle</code> or a
	  <code>struct poly</code>, but not both at the same time.
	  The <code>enum</code>, which we have to maintain and inspect
	  by hand, indicates which kind of value is currently stored
	  in the <code>union</code>.</para>

	<para>The Haskell version of this code is both dramatically
	  shorter and safer than the C equivalent.</para>

	&ShapeUnion.hs:Shape;

	<para id="x_T4">If we create a <type>Shape</type> value using
	  the <code>Circle</code> constructor, the fact that we
	  created a <code>Circle</code> is stored along with the
	  circle's centre and radius.  When we later use a
	  <code>Circle</code>, we can't accidentally treat it as a
	  <code>Square</code>; we will see why in <xref
	  linkend="hs.deftypes.pattern"/></para>
      </sect3>
    </sect2>

    <sect2 id="hs.deftypes.adt.notes">
      <title>A few notes</title>

      <para id="x_V4">From reading the preceding sections, it should
	now be clear that <emphasis>all</emphasis> of the data types
	that we define with the <code>data</code> keyword are
	algebraic data types. Some may have just one alternative,
	while others have several, but they're all using the same
	machinery.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.deftypes.pattern">
    <title>Pattern matching</title>

    <para id="x_Z5">Now that we've seen how to construct values with
      algebraic data types, let's discuss how we work with them.  We
      need to be able to distinguish between alternatives, and to
      extract elements from a compound value.  Haskell has a simple
      <emphasis>pattern matching</emphasis> facility that lets us do
      both of these.</para>

    <para id="x_a5">A pattern lets us peer inside a compound value and
      bind variables to the values it contains.  Here's an example of
      pattern matching in action on a list: we're going to add all
      elements of the list together.</para>

    &add.hs:sumList;

    <para id="x_c5">See that <code>(x:xs)</code> on the left of the first line?
      The <code>:</code> means <quote>match the head of a
	list</quote>; that's the familiar list constructor,
      <function>(:)</function>, in action in a new way.  The variables
      <varname>x</varname> and <varname>xs</varname> are given the
      values of (<quote>bound to</quote>) the head and tail of the
      list, respectively.  The whole pattern is wrapped in parentheses
      so Haskell won't parse it as three separate arguments.</para>

    <para id="x_d5">What effect does pattern matching have? Haskell will only
      evaluate the right hand side of an equation if it can match all
      of the patterns on the left hand side.  In the definition of
      <function>sumList</function> above, the right hand side of the
      first equation won't be evaluated if the input list is empty.
      Instead, Haskell will <quote>fall through</quote> to the
      equation on the following line, which <emphasis>does</emphasis>
      have a pattern for the empty list, and it will evaluate
      that.</para>

    <para id="x_e5">It might initially look like we have two functions
      named <function>sumList</function> here, but Haskell lets us
      define a function as a <emphasis>series of equations</emphasis>:
      so in fact these two clauses are defining the behaviour of one
      function, over different input values.  The <code>[]</code> on
      the left of the second equation is the constructor for an empty
      list.</para>

      <note>
	<title>Ordering is important</title>

	<para id="x_m5">When applying a function, a Haskell
	implementation checks patterns for matches in the order in
	which we specify them in our equations. Matching proceeds from
	top to bottom, and stops at the first success.</para>
      </note>

      <para>As a final note, there already exists a standard function,
      <function>sum</function>, that performs this adding-of-a-list
      for us.  Our <function>sumList</function> is purely for
      illustration.</para>

    <sect2>
      <title>Construction and deconstruction</title>

      <para>Let's step back and take a look at the relationship
	between constructing a value and pattern matching on
	it.</para>

      <para>A value constructor builds a value.  The expression
	<code>'a':['b']</code> applies the <function>(:)</function>
	constructor to the values <code>'a'</code> and
	<code>['b']</code> to produce a new compound value, the list
	<code>['a', 'b']</code>.</para>

      <para>When we pattern match against the <function>(:)</function>
	constructor, we <emphasis>reverse</emphasis> the construction
	process.  First of all, we check to see if the value does in
	fact contain that constructor.  If it does, we inspect the
	compound value to get the individual values that we originally
	passed to the constructor when we created the value.</para>

      <para>Let's consider what happens if we
	match the pattern <code>(x:xs)</code> against our example
	expression <code>'a': ['b']</code>.</para>

      <itemizedlist>
	<listitem>
	  <para>The match will succeed, because the constructor in the
	    value matches the one in our pattern.</para>
	</listitem>
	<listitem>
	  <para>The variable <varname>x</varname> will be bound to
	    <code>'a'</code>.</para>
	</listitem>
	<listitem>
	  <para>The variable <varname>xs</varname> will be bound to
	    <code>['b']</code>.</para>
	</listitem>
      </itemizedlist>
      
      <para>Because pattern matching acts as the inverse of
	construction, it's sometimes referred to as
	<emphasis>de</emphasis>construction.</para>

      <note>
	<title>Deconstruction doesn't destroy anything</title>

	<para>If you're steeped in object oriented programming jargon,
	  don't confuse deconstruction with destruction! Matching a
	  pattern has no effect on the value we're examining: it just
	  lets us <quote>look inside</quote> it.</para>
      </note>
    </sect2>

    <sect2>
      <title>Further adventures</title>

      <para id="x_f5">The syntax for pattern matching on a tuple is
	similar to the syntax for constructing a tuple.  Here's a
	function that returns the last element of a 3-tuple.</para>

      &Tuple.hs:third;

      <para id="x_g5">There's no limit on how <quote>deep</quote>
	within a value a pattern can look.  This definition looks both
	inside a tuple and inside a list within that tuple.</para>

      &Tuple.hs:complicated;

      <para id="x_h5">We can try this out interactively.</para>

      &tuple.ghci:complicated;

      <para id="x_i5">Wherever a literal value is present in a pattern
	(<literal>True</literal> and <literal>5</literal> in the tuple
	pattern above), that value must match exactly for the pattern
	match to succeed.  If every pattern within a series of
	equations fails to match, we get a runtime error.</para>

      &tuple.ghci:nomatch;

      <para>For an explanation of this error message, skip forward a
	little, to <xref
	  linkend="hs.deftypes.patterns.nonexhaustive"/>.</para>

      <para id="x_j5">We can pattern match on an algebraic data type
	using its value constructors.  Remember the
	<type>BookSection</type> type we defined earlier?  Here's how
	we can extract the values from a
	<type>BookSection</type>.</para>

      &BookSection.hs:accessors;

      <para id="x_k5">Let's see it in action.</para>

      &booksection.ghci:unwrap;

      <para id="x_l5">The compiler can infer the types of the accessor
	functions based on the constructor we're using in our
	pattern.</para>

      &booksection.ghci:unwrap.types;

      <para id="x_IL">Here are some rules of thumb to help with
	remembering how pattern matching works.  A constructor in a
	pattern checks that the matched value has the right
	<quote>shape</quote>.  A literal value ensures that that
	portion of the value has exactly the matching contents.  A
	variable makes no assertions about either the shape or
	contents of the matched value; it matches anything, and binds
	the variable to that value.</para>

      <para id="x_JL">So the pattern <code>(3:xs)</code> first of all
	is an assertion that a matching value is a non-empty list, by
	matching against the <function>(:)</function> constructor.  It
	also ensures that the head of the list is the literal value
	<literal>3</literal>.  If both of these conditions hold, the
	tail of the list will be bound to the variable
	<varname>xs</varname>.</para>
    </sect2>

    <sect2>
      <title>Variable naming in patterns</title>

      <para>As you read functions that match on lists, you'll
	frequently find that the names of the variables inside a
	pattern resemble <code>(x:xs)</code> or <code>(d:ds)</code>.
	This is a popular naming convention. The idea is that the name
	<varname>xs</varname> is the <quote>plural</quote> of
	<varname>x</varname>, because <varname>xs</varname> contains
	the remainder of the list, and <varname>x</varname> its
	head.</para>
    </sect2>

    <sect2 id="hs.deftypes.dontcare">
      <title>The don't-care, or wild card, pattern</title>

      <para id="x_o5">When we're writing a pattern, we can specify
	that we don't care what value a particular value within a
	structure has, without actually binding that value to a name.
	The notation for this is <code>_</code>, and we call it a
	<emphasis>wild card</emphasis> or a <emphasis>don't
	  care</emphasis>.  We use it as follows.  This function tells
	us whether the result of the <function>roots</function>
	function we defined earlier is real-valued or not.</para>

      &Roots.hs:isRealValued;

      <para id="x_p5">Here, we don't care about the value of the result, just
	about which constructor was used to create it.  If it was
	<function>Left</function>, the result must be a complex
	number, otherwise it must be real.  We can use a wild card for
	the entire second pattern; there's no need to see if the
	constructor is <function>Right</function>, because it
	<emphasis>must</emphasis> be; <type>Either</type> only has two
	constructors.</para>

      <para id="x_KL">In a pattern, a wild card acts similarly
	to a variable, only it doesn't bind the value to a name.
	While we can't put the same variable name multiple times in a
	single pattern, we can use a wild card as many times as we
	need to.</para>

      <para id="x_LL">Another advantage of wild cards is that a Haskell compiler
	can warn us if we introduce a variable name in a pattern, but
	don't use it in a function's body; defining something but
	forgetting to use it can often indicate a bug.  Using a wild
	card instead of an unused variable makes it explicit that we
	really don't care what value is present, and will prevent such
	a warning.</para>

      <para id="x_ML">Wild cards also help readability, as they make it easier
	to tell which values we're really using.</para>

      &BookSection.hs:niceAccessors;

    </sect2>

    <sect2 id="hs.deftypes.patterns.nonexhaustive">
      <title>Non-exhaustive patterns</title>

      <para>When writing a series of patterns, it's important to cover
	all of a type's constructors.  For example, if we're
	inspecting a list, we should have one equation that matches
	the non-empty constructor <function>(:)</function>, and one
	that matches the empty-list constructor
	<function>[]</function>.</para>

      <para>Let's see what happens if we fail to cover all the cases.
	Here, we're deliberately omitting a match against the
	<function>[]</function> constructor.</para>

      &BadPattern.hs:badExample;

      <para>If we call this with a value that it can't match, we'll
	get an error at runtime: our software has a bug!</para>

      &badpattern.ghci:error;

      <para>In this example, the initial application of
	<function>badExample</function> succeeds, because
	<code>[1]</code> is a more compact way of printing <code>1 :
	  []</code>.  The recursive application of <code>badExample
	  xs</code> is the source of the error, because then the value
	that's being matched against is simply <code>[]</code>.</para>

      <para>&GHC; provides a helpful compilation option,
	<option>-fwarn-incomplete-patterns</option>, that will cause
	it to print a warning at compile time if a sequence of
	patterns don't match all of a type's constructors.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.deftypes.paramtypes">
    <title>Parameterised types</title>

    <para id="x_Z4">We've repeatedly mentioned that the list type is
      polymorphic: the elements of a list can be of any type.  We can
      also add polymorphism to our own types. To do this, we introduce
      type variables into a type declaration.  Let's define a
      <type>Nullable</type> type: we can use this to represent a
      missing value, e.g. an empty field in a database row.</para>

    &Nullable.hs:Nullable;

    <para id="x_a4">Here, the variable <varname
	role="type">a</varname> is not a regular variable: it's a type
      variable.  It indicates that our <type>Nullable</type> type
      takes another type as its parameter.  This lets us use
      <type>Nullable</type> on values of any type.</para>

    &Nullable.hs:wrappedTypes;

    <para id="x_b4">As usual, we can load our source file into &ghci;
      and experiment with it.</para>

    &nullable.ghci:experiment;

    <para id="x_c4"><type>Nullable</type> is a polymorphic, or
      generic, type.  When we create a type by giving the
      <type>Nullable</type> type constructor a parameter, we can see
      what the new type looks like by substituting that type for the
      type variable <varname role="type">a</varname> everywhere in the
      definition of <type>Nullable</type>.  The type <type>Nullable
	String</type> has a value constructor, also named
      <code>Nullable</code>, that takes a parameter of type
      <type>String</type>.  As we might expect, the type
      <type>Nullable Int</type> is distinct from <type>Nullable
	Bool</type>, and so on.</para>

    <para id="x_e4">We can nest uses of parameterised types inside
      each other, but when we do, we may need to use parentheses to
      tell the Haskell compiler how to parse our expression.</para>

    &Nullable.hs:parens;

    <para>If we omitted the parentheses, this would be parsed as
      <code>(Really Really) Int</code>, which isn't valid.</para>

    <para id="x_d4">To once again extend an analogy to more familiar
      languages, parameterised types give us a facility that bears
      some resemblance to templates in C++, and to generics in Java.
      Just be aware that this is a shallow analogy.  Templates and
      generics were added to their respective languages long after the
      languages were initially defined, and have an awkward feel.
      Haskell's parameterised types are simpler and easier to use, as
      the language was designed with them  from the beginning.</para>
  </sect1>

  <sect1 id="hs.deftypes.recursive">
    <title>Recursive types</title>

    <para id="x_K5">Here's a definition of a binary tree type.</para>

      &Tree.hs:Tree;

    <para id="x_L5">We call this a <emphasis>recursive</emphasis> type because
      <type>Tree</type>, the type we're defining, appears both on the
      left hand side and the right hand side of the definition: we
      define the type in terms of itself.</para>
  </sect1>

  <sect1 id="hs.deftypes.listadt">
    <title>A little more about lists</title>

    <para id="x_M5">Now that we're getting familiar with some of the jargon
      around types, we can revisit lists.  Haskell's list type is a
      parameterised type, because we can make lists of any other type.
      It is also an algebraic data type, with two constructors.  One
      is the empty list, written <code>[]</code> (sometimes pronounced
      <quote>nil</quote>, which is borrowed from Lisp).</para>

    &list.ghci:empty;

    <para id="x_N5">The other is the <function>(:)</function> operator, often
      pronounced <quote>cons</quote> (this is short for
      <quote>construct</quote>, and also borrowed from Lisp).  The
      <function>(:)</function> operator takes an element and a list,
      and constructs a new list.</para>

    &list.ghci:cons;

    <para id="x_O5">We can use <function>(:)</function> repeatedly to add new
      elements to the front of a list.</para>

    &list.ghci:cons2;

    <para id="x_P5">The right hand side of <function>(:)</function> must be a
      list, and of the correct type.  If it's not, we'll get an
      error.</para>

    &list.ghci:cons.bad;

    <para id="x_Q5">Because <function>(:)</function> constructs a list from
      another list, the list type is recursive.  So here we have a
      built-in type that's parameterised, recursive, and
      algebraic.</para>

    <para id="x_R5">One consequence of lists being generic is that lists of
      lists, for example, aren't special in any way.</para>

    &list.ghci:listlist;

    <para id="x_S5">This has type <type>[[String]]</type>, a list of lists of
      strings.  But since <type>String</type> is just a synonym for
      <type>[Char]</type>, it's <emphasis>really</emphasis> a list of
      lists of lists of <type>Char</type>.  Whew!</para>

    <para id="x_T5">We're not limited to building up lists one element at a
      time.  Haskell defines an inline function,
      <function>(++)</function>, that we can use to append one list
      onto the end of another.</para>

    &list.ghci:append;

    <para id="x_U5">The <function>concat</function> function takes a list of
      lists, and concatenates the whole lot into a single list.</para>

    &list.ghci:concat;

  </sect1>

  <sect1 id="hs.deftypes.error">
    <title>Reporting errors</title>

    <para id="x_w3">Haskell provides a standard function,
      <function>error :: Char -&gt; a</function>, that we can call
      when something has gone terribly wrong in our code.  We give it
      a string parameter, which is the error message to display. Its
      type signature looks peculiar: how can it produce a value of any
      type <varname role="type">a</varname> given just a string? The
      answer is that it doesn't, because <function>error</function> is
      special.</para>

    <para id="x_x3">It has a result type of <varname
	role="type">a</varname> so that we can call it anywhere and it
      will always have the right type.   However, instead of returning
      a value like a normal function, it <emphasis>immediately aborts
	evaluation</emphasis>, and prints the error message we give
      it.</para>

    <para>Here's an example.  The <function>mySecond</function>
      function returns the second element of its input list, but fails
      if its input list isn't long enough.</para>

    &MySecond.hs:mySecond;

    <para id="x_y3">As usual, we can see how this works in practice in
      &ghci;.</para>

    &error.ghci:mySecond;

    <para id="x_z3">Notice that in the third case above, where we're
      trying to use the result of the call to
      <function>mySecond</function> as the argument to another
      function, evaluation still terminates and drops us back to the
      &ghci; prompt.  This is the major weakness of using
      <function>error</function>: it doesn't let our caller
      distinguish between a recoverable error and a problem so severe
      that it really should terminate our program.</para>

    <sect2>
      <title>A more controlled approach</title>

      <para>Haskell defines a standard type, <type>Maybe</type>, that
	we can use to represent the possibility of an error.  It has
	the same structure as the <type>Nullable</type> type that we
	defined earlier.</para>

      &Maybe.hs:Maybe;

      <para>If we want to represent <quote>fail</quote>, we use the
	<function>Nothing</function> constructor.  Otherwise, we wrap
	our value with the <function>Just</function>
	constructor.</para>

      <para>Let's see what our <function>mySecond</function> function
	looks like if we return a <type>Maybe</type> value instead of
	calling <function>error</function>.</para>

      &MySecond.hs:safeSecond;

      <para>If the list we're passed isn't long enough, instead of
	crashing the program, we return <code>Nothing</code> to our
	caller.  This lets them decide what to do if the list isn't
	long enough, where a call to <function>error</function> would
	force a crash.</para>

      <para>To return to an earlier topic, we can use pattern matching
	to clarify this function.</para>

      &MySecond.hs:tidySecond;

      <para>The first pattern only matches if the list is at least two
	elements long (it contains two list constructors), and it
	binds the variable <varname>x</varname> to the list's second
	element. The second pattern is matched if the first
	fails.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.deftypes.locals">
    <title>Introducing local variables</title>

    <para id="x_f4">Within the body of a function, we can introduce
      new local variables whenever we need them, using a
      <code>let</code> expression.  As an example, let's write a
      function that calculates the real-valued roots of the quadratic
      equation <literal>a * (x ** 2) + b * x + c ==
	0</literal>.</para>

    <para>To represent the result, we'll use the <type>Maybe</type>
      type.  The roots could potentially be infinite (if we divide by
      zero) or complex numbers (if the square root term is negative),
      in which cases we'll return <code>Nothing</code>.</para>

    &realRoots.ghci:maybe;

    <para>We'll use <function>Just</function> to contain the roots
      when they're defined, and <function>Nothing</function> to
      indicate that the result is undefined for the given
      inputs.</para>

    &Roots.hs:realRoots;

    <para id="x_g4">The keywords to look out for here are
      <code>let</code>, which starts a block of variable declarations,
      and <code>in</code>, which ends it.  Each line introduces a new
      variable.  The name is on the left of the <literal>=</literal>,
      and the expression it's bound to is on the right.</para>

    <note>
      <title>Special notes</title>

      <para>Let us re-emphasise our wording: a name in a &let; block
	is bound to an <emphasis>expression</emphasis>, not to a
	<emphasis>value</emphasis>.  Because Haskell is a lazy
	language, the expression associated with a name won't actually
	be evaluated until it's needed.</para>

      <para>When we define a variable in a &let; block, we refer to it
	as a <emphasis>&let;-bound</emphasis> variable.  This simply
	means what it says: we bound the variable in a &let;
	block.</para>

      <para>Also, our use of white space here is important.  We'll
	talk about the layout rules in <xref
	linkend="hs.deftypes.offside"/>.</para>
    </note>

    <para>We can use the names of a variable in a &let; block both
      within the block itself and in the expression that follows the
      <code>in</code> keyword.</para>

    <para>In general, we'll refer to the places within our code where
      we can use a name as the name's <emphasis>scope</emphasis>.  If
      we can use a name, it's <emphasis>in scope</emphasis>, otherwise
      it's <emphasis>out of scope</emphasis>.</para>

    <sect2>
      <title>Local variables and lazy evaluation</title>

      <para>In our definition of <function>realRoots</function>, we're
	making use of laziness.  Here's how to follow what's going
	on.</para>

      <itemizedlist>
	<listitem>
	  <para>To begin with, recall that the expressions in the
	    &let; block aren't evaluated, they're just bound.</para>
	</listitem>
	<listitem>
	  <para>The first value that is actually inspected is the &if;
	    expression's predicate, <code>a /= 0 &amp;&amp; n &gt;=
	      0</code>.</para>
	</listitem>
	<listitem>
	  <para>If the value of <varname>a</varname> is zero, then the
	    left branch of the <function>(&amp;&amp;)</function>
	    expression is <code>False</code>, and so the whole
	    predicate is <code>False</code>.  No further computation
	    is needed; we immediately return
	    <code>Nothing</code>.</para>
	</listitem>
	<listitem>
	  <para>To compare <varname>n</varname> with zero, we must
	    evaluate it.  If the <function>(&gt;=)</function>
	    comparison fails, we again do no further work, and return
	    <code>Nothing</code>.</para>
	</listitem>
	<listitem>
	  <para>Even when the predicate succeeds and we return the
	    <function>Just</function> branch, we're returning an
	    <emphasis>expression</emphasis>, not a value.  We still
	    won't compute <code>sqrt n</code> until our caller
	    actually needs one or other of the roots.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Shadowing</title>

      <para id="x_i4">We can <quote>nest</quote> multiple
	<code>let</code> blocks inside each other in an
	expression.</para>

      &NestedLets.hs:foo;

      <para>It's perfectly legal, but not exactly wise, to repeat a
	variable name in a nested &let; expression.</para>

      &NestedLets.hs:bar;

      <para>Here, the inner <varname>x</varname> is hiding, or
	<emphasis>shadowing</emphasis>, the outer
	<varname>x</varname>.</para>

      &nestedlets.ghci:bar;

      <para>We can also shadow a function's parameters, leading to
	even stranger results.  What is the type of this
	function?</para>

      &NestedLets.hs:quux;

      <para>Because the argument <varname>a</varname> is never used in
	the body of the function, due to being shadowed by the
	&let;-bound <varname>a</varname>, the argument can have any
	type at all.</para>

      &nestedlets.ghci:quux;

      <para>Shadowing can obviously lead to nasty bugs, so &GHC; has a
	helpful <option>-fwarn-name-shadowing</option> option that
	will print a warning message if we accidentally shadow a
	name.</para>
    </sect2>

    <sect2>
      <title>The where clause</title>

      <para>There's another mechanism we can use to introduce local
	variables, called a <code>where</code> clause. The definitions
	in a <code>where</code> clause apply to the code that
	<emphasis>precedes</emphasis> it.  Let's illustrate what we
	mean with another example.</para>

      <para>For variety, we'll introduce complex numbers to represent
	the complex roots, and an abstract data type for the result.
	The <function>(:+)</function> operator below constructs a
	complex number from its real and imaginary parts.</para>

      &Roots.hs:roots;

      <para id="x_j4">Our <function>roots</function> function returns
	the real-valued roots when they're defined, the complex roots
	otherwise, and <code>Undefined</code> if the roots are
	infinite due to <varname>a</varname> being zero.</para>

      <para>A &where; clause can initially seem very weird to
	non-Haskell programmers.  It's a great way to put your
	reader's focus on the important details of an expression, with
	the supportings definitions following afterwards.  After a
	while, you'll find yourself missing <code>where</code> clauses
	in languages that lack them!</para>

      <para id="x_l4">As with &let; expressions, names are bound to
	expressions in &where; clauses, and white space is
	significant.  We'll be talking more about the layout rules
	shortly, in <xref linkend="hs.deftypes.offside"/>.</para>
    </sect2>

    <sect2 id="hs.deftypes.locals.functions">
      <title>Local functions</title>

      <para id="x_FL">You'll have noticed that Haskell's syntax for
	defining a variable looks very similar to its syntax for
	defining a function.  This symmetry is preserved in
	<code>let</code> and <code>where</code> blocks; we can define
	local <emphasis>functions</emphasis> just as easily as local
	<emphasis>variables</emphasis>.  All of the same syntax
	applies as at the top level: we can use multiple equations,
	patterns, and guards.</para>

      &LocalFunction.hs:pluralise;

      <para id="x_GL">In this example, we define and use a local
	function <function>plural</function> using several equations.
	Local functions can freely use variables from the scopes that
	enclose them; here, we use <varname>word</varname> from the
	definition of the outer function
	<function>pluralise</function>.  In the definition of
	<function>pluralise</function>, the <function>map</function>
	function (which we'll be revisiting in the next chapter)
	applies the local function <function>plural</function> to
	every element of the <varname>counts</varname> list.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.deftypes.case">
    <title>The case expression</title>

    <para id="x_q5">We're not limited to using patterns in function
      definitions.  The <code>case</code> expression lets us match
      patterns at any time.  Here's what it looks like.</para>

      &Roots.hs:hasRealRoots;

    <para id="x_r5">The <code>case</code> keyword is followed by an
      arbitrary expression; the result of this expression is what
      we're pattern matching on.  The <code>of</code> keyword
      signifies the end of the expression and the beginning of the
      block of patterns and expressions.</para>

    <para id="x_s5">Each item in the block consists of a pattern,
      followed by an arrow <code>-&gt;</code>, followed by an
      expression to evaluate if that pattern matches.  The result of
      the <code>case</code> expression is the result of the expression
      associated with the first pattern to match, taken from top to
      bottom.</para>

    <para id="x_t5">To express <quote>here's the expression to
	evaluate if none of the other patterns match</quote>, we would
      just use the wild card pattern <code>_</code> as the last in our
      list of patterns.</para>

    <sect2 id="hs.deftypes.where">
      <title>A flying visit back to the where clause</title>

      <para id="x_u5">Now that we've seen that we can define a
	function as a series of equations, the usefulness of the
	<code>where</code> clause should be a bit more clear.
	Variables that we define inside a <code>where</code> clause
	are visible across all of the equations that precede it in a
	single block.</para>
    </sect2>
  </sect1>
  
  <sect1 id="hs.deftypes.pattern.limits">
    <title>Common beginner mistakes with patterns</title>

    <para id="x_NL">There are a few ways in which new Haskell
      programmers can misunderstand or misuse patterns.  Here are a
      few potential missteps that you can easily avoid.</para>

    <para id="x_v5">There's no way to write a pattern that compares a
      value with a variable.  Matching a pattern only lets us perform
      exact comparisons against combinations of constructors and
      simple values.</para>

    <para id="x_OL">Here's a well-intentioned example of pattern
      matching gone awry.  This code compiles cleanly, but depending
      on what you expect it to do, it might surprise you.</para>

    &BogusPattern.hs:isHead;

    <para id="x_w5">A naive glance suggests that this code is trying
      to check the value of <function>f</function> to see if it's
      actually the standard function <function>head</function>, but
      here's what it is <emphasis>really</emphasis> doing.</para>

    <para id="x_x5">Because the first pattern in the <code>case</code>
      expression is a variable, this branch of the <code>case</code>
      will <emphasis>always</emphasis> match, no matter what the value
      of <varname>f</varname> is.  The name <varname>head</varname>
      thus acts as a local variable whose value is the value of
      <varname>f</varname>, which hides the global definition of the
      well-known <function>head</function> function.  </para>

    <note>
      <title>Irrefutable patterns</title>

      <para id="x_y5">A pattern that consists only of a variable will
	always match, because it's not being compared against any
	value that could cause the match to fail.  We refer to
	patterns that always match as
	<quote>irrefutable</quote>.</para>
    </note>

    <para id="x_z5">The first pattern always matches, because it's
      irrefutable.  But the second pattern <emphasis>also</emphasis>
      always matches, because it uses a wild card.  However, because
      Haskell attempts to match patterns in the order in which we
      write them, the first pattern will always succeed, and the
      second pattern will never actually be reached. Because the two
      patterns will match the same values, they are said to
      <emphasis>overlap</emphasis>.  If &GHC; ever complains to you
      about overlapping patterns, it's telling you that one of your
      patterns is the same as another, and so it will never actually
      be matched.</para>

    <para id="x_A6">Another thing to be aware of is that a variable
      can only appear once in a pattern.  For example, we can't put a
      variable in multiple places within a pattern to express the
      notion <quote>this value and that should be
	identical</quote>.</para>

    <para id="x_B6">The way around these restrictions of Haskell's
      patterns is to use patterns in combination with a language
      facility called <emphasis>guards</emphasis>, which we'll talk
      about next.</para>
  </sect1>

  <sect1 id="hs.deftypes.guard">
    <title>Conditional evaluation with guards</title>

    <para id="x_C6">We can further extend our expressive arsenal using
      <emphasis>guards</emphasis>.  A guard is an expression of type
      <type>Bool</type>; if it evaluates to <function>True</function>,
      the equation that follows it is evaluated.  Otherwise, the next
      guard in the series is evaluated, and so on.  A series of guards
      is only checked if the patterns that they're associated with
      match.  Here's an example of guards in action.</para>

    &Roots.hs:guardedRoots;

    <para id="x_D6">Each guard is introduced by a <code>|</code> symbol,
      followed by the guard expression, then an <code>=</code> symbol
      (or <code>-&gt;</code> if within a <code>case</code>
      expression), then the expression to evaluate if the guard
      succeeds.  A guard expression can use any variables matched in
      the pattern that precedes it.</para>

    <para id="x_E6">The <varname>otherwise</varname> used in the second guard
      has an obvious meaning: it's the expression to evaluate if
      previous guards all evaluate to <function>False</function>. It's
      not a special piece of syntax, though; it's just a predefined variable
      whose value is <function>True</function>.</para>

    <para id="x_F6">We can use guards anywhere that we can use
      patterns.  The advantage of writing a function as a series of
      equations using pattern matching and guards is that it often
      makes code much clearer.  Remember the
      <function>myDrop</function> function we defined in <xref
	linkend="hs.funcstypes.if"/>?</para>

    &myDrop.hs:myDrop.noid;

    <para id="x_H6">Here's a reformulation of that function using
      patterns and guards.  Instead of reasoning about what an
      <code>if</code> expression is doing and which branch will be
      evaluated, the code uses a series of equations with simple
      patterns and guards. Hoisting the control decisions to the
      <quote>outside</quote> of the code, instead of burying it inside
      with <code>if</code> expressions, lets us enumerate up front
      the cases in which we expect the behaviour of the function to
      differ.</para>

    &myDrop.hs:niceDrop;

    <para id="x_I6">Let's return to one of the limitations of patterns that we
      mentioned in the previous section: the fact that we can't 
      check two variables within a pattern for equality.
      We can express this quite easily by following the pattern with a
      guard.</para>

    &Guard.hs:secondEqualsThird;

    <para id="x_J6">Here, for good measure, we've illustrated guard
      syntax in a <code>case</code> expression.  This guard expression
      compares the variables matched in the pattern for equality.</para>
  </sect1>

  <sect1 id="hs.deftypes.infix">
    <title>Infix functions</title>

    <para id="x_K6">Usually, when we define or call a function in Haskell, we
      write the name of the function, followed by its arguments; this
      is called prefix notation, because the name of the function
      comes before its arguments.  For a function that takes two
      arguments, we have the option of using it in
      <emphasis>infix</emphasis> form, between its first and second
      arguments.  This allows us to write expressions using functions
      as if they were infix operators.</para>

    <para id="x_L6">The syntax for defining or calling a function in infix form
      is to enclose the name of the function in backtick characters
      (sometimes known as backquotes).  Here's a simple infix
      definition.</para>

    &Plus.hs:plus;

    <para id="x_M6">Defining a function in infix form doesn't change anything
      about the behaviour of the function.  We can call the function
      using infix or prefix notation, as we prefer.</para>

    &infix.ghci:plus;

    <para id="x_N6">Infix notation is useful for more than just our own
      functions.  For example, Haskell's standard
      <code>Data.List</code> module defines a function,
      <function>isPrefixOf</function>, that indicates whether all
      elements of its first argument are equal to the first elements
      of its second argument.</para>

    &infix.ghci:type;

    <para id="x_O6">Let's define a few variables in &ghci;.</para>

    &infix.ghci:vars;

    <para id="x_P6">If we call <function>isPrefixOf</function> using prefix
      notation, we can have a hard time remembering which argument
      we're checking for as a prefix of the other.</para>

    &infix.ghci:prefix;

    <para id="x_Q6">But if we use infix notation, the code <quote>reads</quote>
      more naturally; it's now obvious that we're checking the
      variable on the left to see if it's a prefix of the variable on
      the right.</para>

    &infix.ghci:infix;

    <para id="x_R6">There's no hard-and-fast rule that dictates when you ought
      to use infix versus prefix notation, although prefix notation is
      far more common.  It's best to choose whichever makes your code
      more readable in a specific situation.</para>

    <note>
      <para id="x_S6">The backtick notation is not a general mechanism: it's a
	piece of special syntax that applies only to names.  For
	example, we can't put backticks around an expression that
	returns a function, and then treat that as an infix
	function.</para>
    </note>
  </sect1>

  <sect1 id="hs.deftypes.offside">
    <title>The offside rule, and white space in a function
      body</title>

    <para id="x_u4">In our definition of <function>realRoots</function>, the
      left margin of our text wandered around quite a bit.  This was
      not an accident: in Haskell, white space has meaning.</para>

    <para id="x_v4">Haskell uses indentation as a cue to parse sections of code.
      This use of layout to convey structure is sometimes called the
      offside rule. At the top level, the first declaration or
      definition can start in any column, and the Haskell compiler or
      interpreter remembers that indentation level.  Every subsequent
      top-level declaration must have the same indentation.</para>

    <para id="x_w4">Here's an illustration of the top-level indentation rule.
      Our first file, <filename>GoodIndent.hs</filename>, is well
      behaved.</para>

    &GoodIndent.hs:good;

    <para id="x_x4">Our second, <filename>BadIndent.hs</filename>, doesn't play
      by the rules.</para>

    &BadIndent.hs:bad;

    <para id="x_y4">Here's what happens when we try to load the two files into
      &ghci;.</para>

    &indent.ghci:load;

    <para id="x_z4">An empty line is treated as a continuation of the current
      item, as is a line indented to the right of the current current
      item.</para>

    <para id="x_A5">The rules for <code>let</code> expressions and
      <code>where</code> clauses are similar.  After a
      <code>let</code> or <code>where</code> keyword, the Haskell
      compiler or interpreter remembers the indentation of the next
      token it sees. If the next line is empty, or its indentation is
      further to the right than the previous line, this counts as
      continuing the previous line. On the other hand, if the
      indentation is the same as the previous line, this is treated as
      beginning a new item in the same block.</para>

    <para id="x_B5">Here are nested uses of <code>let</code> and
      <code>where</code>.</para>

    &letwhere.hs:let;

    <para id="x_C5">In the body of <varname>bar</varname>, the variable
      <varname>a</varname> is only visible within the <code>let</code>
      expression that defines it.  It's not visible to the
      <code>let</code> expression that defines <varname>b</varname>;
      only the <emphasis>result</emphasis> of the inner
      <code>let</code> expression is visible.</para>

    &letwhere.hs:where;

    <para id="x_D5">Similarly, the scope of the first <code>where</code> clause
      is the definition of <varname>foo</varname>, but the scope of
      the second is just the first <code>where</code> clause.</para>

    <para id="x_E5">The indentation we use for the <code>let</code> and
      <code>where</code> clauses makes our intentions easy to figure
      out.</para>

    <sect2 id="hs.deftypes.tabs">
      <title>A note about tabs versus spaces</title>

      <para id="x_F5">If you are using a Haskell-aware text editor (e.g. Emacs),
	it is probably already configured to use space characters for
	all white space within a line.  If your editor is
	<emphasis>not</emphasis> Haskell-aware, you should configure
	it to only use space characters.</para>

      <para id="x_G5">The reason for this is simple portability.  In an editor
	that uses a fixed-width font, tab stops are by default placed
	at different intervals on Unix-like systems (every eight
	characters) than on Windows  (every four characters). This
	means that no matter what your personal beliefs are about
	where tabs belong, you can't rely on someone else's editor
	honouring your preferences.  Any indentation that uses tabs is
	going to look broken under <emphasis>someone's</emphasis>
	configuration.  In fact, this could lead to compilation
	problems, as the Haskell language standard requires
	implementations to use the Unix tab width convention.
	Using space characters avoids these problem
	entirely.</para>
    </sect2>

    <sect2 id="hs.deftypes.block">
      <title>The offside rule is not mandatory</title>

      <para id="x_H5">We can use explicit structuring instead of layout to
	indicate what we mean.  To do so, we start a block of
	equations with an opening curly brace; separate each item with
	a semicolon; and finish the block with a closing curly brace.
	The following two uses of <code>let</code> have the same
	meanings.</para>

      &Braces.hs:braces;

      <para id="x_I5">When we use explicit structuring, the normal layout rules
	don't apply, which is why we can get away with unusual
	indentation in the second <code>let</code> expression.</para>

      <para id="x_J5">We can use explicit structuring anywhere that we'd
	normally use layout.  It's valid for <code>where</code>
	clauses, and even top-level declarations.  Just remember that
	although the facility exists, explicit structuring is hardly
	ever actually <emphasis>used</emphasis> in Haskell
	programs.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.deftypes.end">
    <title>Conclusion</title>

    <para>In this chapter, we've seen how to define our own
      algebraic data types.  We've read about Haskell's offside rule
      for laying out functions, and how we can avoid it if we need to.
      We've seen pattern matching and guards.  We've discussed error
      handling.</para>

    <para>At this point, our basic toolbox is complete.  In
      <xref linkend="hs.fp"/>, we'll use this knowledge to develop our
      functional programming and thinking skills.</para>

  </sect1>
</chapter>
<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
