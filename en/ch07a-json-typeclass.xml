<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="jsonclass" revision="alpha;beta">
  <title>A typeclass approach to JSON</title>

  <sect1>
    <title></title>
    <para>The <type>JValue</type> type that we introduced in <xref
      linkend="library.jvalue"/> is not especially easy to work with.
      Here is a truncated and tidied snippet of some real JSON data,
      produced by a well known search engine.</para>

    &result.js:result;

    <para>And here's a further slimmed down fragment of that data,
      represented in Haskell.</para>

    &SimpleResult.hs:result;

    <para>Because Haskell doesn't natively support lists that contain
      types of different value, we can't directly represent a JSON
      object that contains values of different types. Instead, we must
      wrap each value with a <type>JValue</type> constructor.  This
      limits our flexibility: if we want to change the number
      <code>3920</code> to a string <code>"3,920"</code>, we must
      change the constructor that we use to wrap it from
      <code>JNumber</code> to <code>JString</code>.</para>

    <para>Haskell's typeclasses offer a tempting solution to this
      problem.</para>

    &JSONClass.hs:class;

    <para>Now, instead of applying a constructor like
      <code>JNumber</code> to a value to wrap it, we apply the
      <function>toJValue</function> function.  If we change a value's
      type, the compiler will choose a suitable implementation of
      <type>toJValue</type> to use with it.</para>

    <para>We also provide a <function>fromJValue</function> function,
      which attempts to convert a <type>JValue</type> into a value of
      our desired type.</para>

    <sect2>
      <title>More helpful errors</title>

      <para>The return type of our <function>fromJValue</function>
	function uses the predefined <type>Either</type> type.  Like
	<type>Maybe</type>, this type is predefined for us, and we'll
	often use it to represent a computation that could
	fail.</para>

      <para>While <type>Maybe</type> is useful for this purpose, it
	gives us no information if a failure occurs: we literally have
	<code>Nothing</code>.  The <type>Either</type> type has a
	similar structure, but instead of <code>Nothing</code>, the
	<quote>something bad happened</quote> constructor is named
	<code>Left</code>, and it takes a parameter.</para>

      &DataEither.hs:Either;

      <para>Quite often, the type we use for the <varname
	  role="type">a</varname> parameter value is
	<type>String</type>, which lets us return an error message if
	something goes wrong.  To see how we use the
	<type>Either</type> type in practice, let's look at a simple
	instance of our typeclass.</para>

      &JSONClass.hs:Bool;

    </sect2>

    <sect2>
      <title>Making an instance with a type synonym</title>
      
      <para>The Haskell 98 standard does not allow us to write an
	instance of the following form, even though it seems perfectly
	reasonable.</para>

      &JSONClass.hs:String;

      <para>Recall that <type>String</type> is a synonym for
	<type>[Char]</type>, which in turn is the type
	<type>[a]</type> where <type>Char</type> is substituted for
	the type parameter <varname role="type">a</varname>. According
	to Haskell 98's rules, we are not allowed to supply a type in
	place of a type parameter when we write an instance.  In other
	words, it would be legal for us to write an instance for
	<type>[a]</type>, but not for <type>[Char]</type>.</para>

      <para>While &GHC; follows the Haskell 98 standard by default, we
	can relax this particular restriction by placing a specially
	formatted comment at the top of our source file.</para>

      &JSONClass.hs:LANGUAGE;

      <para>This comment is a directive to the compiler, called a
	<emphasis>pragma</emphasis>, which tells it to enable a
	language extension.  The <code>TypeSynonymInstances</code>
	language extension makes the above code legal.  We'll
	encounter a few other language extensions in this chapter, and
	a handful more later in this book.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Living in an open world</title>

    <para>Haskell's typeclasses are intentionally designed to let us
      create new instances of a typeclass whenever we like.</para>

    &JSONClass.hs:doubleToJValue;

    <para>We can add new instances anywhere; they are not confined to
      the module where we define a typeclass.  This feature of the
      typeclass system is referred to as its <emphasis>open world
	assumption</emphasis>.  If we could say <quote>the following
	are the only instances of this typeclass that can
	exist</quote>, we could have a <emphasis>closed</emphasis>
      world.</para>

    <para>One useful instance we'd like to be able to write is to turn
      a list into what JSON calls an array.  We won't worry about
      implementation details just yet, so let's use
      <code>undefined</code> as the bodies of the instance's
      methods.</para>

    &BrokenClass.hs:array;

    <para>It would also be convenient if we could turn a list of
      name/value pairs into a JSON object.</para>

    &BrokenClass.hs:object;

    <sect2>
      <title>When do overlapping instances cause problems?</title>
      
      <para>If we put these definitions into a source file and load
	them into &ghci;, everything initially seems fine.</para>

      &brokenClass.ghci:load;

      <para>However, once we try to <emphasis>use</emphasis> the
	list-of-pairs instance, we run into trouble.</para>

      &brokenClass.ghci:use;

      <para>This problem of <emphasis>overlapping instances</emphasis>
	is a consequence of Haskell's open world assumption.  Here's a
	simpler example that makes it clearer what's going on.</para>

      &Overlap.hs:Borked;

      <para>We have two instances of the typeclass <type>Borked</type>
	for pairs: one for a pair of <type>Int</type>s and another for
	a pair of anything else that's <type>Borked</type>.</para>

      <para>Suppose that we want to <function>bork</function> a pair
	of <type>Int</type> values.  To do so, the compiler must
	choose an instance to use.  Because these instances are right
	next to each other, it may seem that it could simply choose
	the more specific instance.</para>

      <para>However, &GHC; is conservative by default, and insists
	that there must be only one possible instance that it could
	use.  It will thus report an error if we try to use
	<code>bork</code>.</para>

      <note>
	<para>As we mentioned earlier, we can scatter instances of a
	  typeclass across several modules.  &GHC; does not complain
	  about the mere existence of overlapping instances.  Instead,
	  it only complains when we try to use a method of the
	  affected typeclass, when it is forced to make a decision
	  about which instance to use.</para>
      </note>
    </sect2>

    <sect2>
      <title>Relaxing the rules for overlapping instances</title>

      <para>&GHC; supports a useful language extension,
	<code>OverlappingInstances</code>: when there are multiple
	overlapping instances to choose from, this extension causes
	the compiler to pick the most specific one.</para>

      <para>We frequently use this extension together with
	<code>TypeSynonymInstances</code>, so that we can provide an
	instance for <type>String</type> and an instance for other
	types of list.  Here's an example.</para>

      &SimpleClass.hs:Foo;
    
      <para>With the <code>OverlappingInstances</code> extension
	enabled, &GHC; will still reject code if it finds more than
	one most specific instance.</para>

      <note>
	<title>When to use the OverlappingInstances extension</title>

	<para>Here's an important point: &GHC; treats
	  <code>OverlappingInstances</code> as affecting the
	  declaration of an instance, <emphasis>not</emphasis> a
	  location where we use the instance.  In other words, when we
	  define an instance that we wish to allow to overlap with
	  another instance, we must enable the extension for the
	  module that contains the definition.  When it compiles the
	  module, &GHC; will mark that instance as <quote>can be
	    overlapped with other instances</quote>.</para>

	<para>Once we import this module and use the instance, we
	  <emphasis>won't</emphasis> need to enable
	  <code>OverlappingInstances</code> in the importing module:
	  &GHC; will already know that the instance was marked as
	  <quote>okay to overlap</quote> when it was defined.</para>

	<para>This behaviour is useful when we are writing a library:
	  it lets us choose to create overlappable instances, without
	  forcing clients of our library to enable language extensions
	  in order to use it.</para>
      </note>
    </sect2>

    <sect2>
      <title>How does show work for strings?</title>

      <para>The <code>OverlappingInstances</code> and
	<code>TypeSynonymInstances</code> language extensions are
	specific to &GHC;, and by definition were not present in
	Haskell 98.  However, the familiar <type>Show</type> typeclass
	from Haskell 98 somehow renders a list of <type>Char</type>
	differently from a list of <type>Int</type>.  It achieves this
	via a clever, but simple, trick.</para>

      <para>The <type>Show</type> class defines both a
	<function>show</function> method and a
	<function>showList</function> method.  The default
	implementation of <function>showList</function> renders
	elements using square brackets and commas.  The instance of
	<type>Show</type> for <type>[a]</type> uses
	<function>showList</function>.  The instance of
	<type>Show</type> for <type>Char</type> simply provides a
	special implementation of <function>showList</function> that
	uses double quotes and escapes non-ASCII-printable
	characters.</para>

      <para>At least sometimes, then, we can avoid the need for the
	<code>OverlappingInstances</code> extension with a little bit
	of lateral thinking.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>How to give a type a secret identity</title>

    <para>In addition to the familiar &data; keyword, Haskell provides
      us with another way to create a new type, via &newtype;.</para>

    &Newtype.hs:newtype;

    <para>The purpose of a &newtype; declaration is to rename an
      existing type, giving it a distinct identity.  As we can see, it
      is similar in appearance to a type declaration using the &data;
      keyword.</para>

    <para>When we declare a &newtype;, we can choose to make any of
      the underlying type's typeclass instances available. Here, we've
      elected to make <type>NewtypeInt</type> provide
      <type>Int</type>'s instances for <type>Eq</type>,
      <type>Ord</type> and <type>Show</type>.  As a result, we can
      compare and print values of type <type>NewtypeInt</type>.</para>

    &newtype.ghci:compare;

    <para>However, since we are <emphasis>not</emphasis> exposing
      <type>Int</type>'s <type>Num</type> or <type>Integral</type>
      instances, values of type <type>NewtypeInt</type> are not
      numbers.  For instance, we can't add them.</para>

    &newtype.ghci:num;

    <para>As with the &data; keyword, we can use a &newtype;'s value
      constructor to create a new value, or to pattern match on an
      existing value.</para>

    <sect2>
      <title>Differences between data and newtype declarations</title>

      <para>The &newtype; keyword exists to give an existing type a
	new identity, and it is more restricted in how we can use it
	than the &data; keyword.  Specifically, a &newtype; can only
	have one value constructor, and that constructor must have
	exactly one field.</para>

      &NewtypeDiff.hs:newtype;

      <para>Beyond this, there's another important difference between
	&data; and &newtype;.   A type created with the &data; keyword
	has some runtime book-keeping overhead, to record which
	constructor a value was created with.  A &newtype; value, on
	the other hand, can only have one constructor, and so does not
	need this overhead.  This makes it more space- and
	time-efficient at runtime.</para>

      <para>Because a &newtype;'s constructor is used only at compile
	time and doesn't have a runtime representation, pattern
	matching on &undefined; behaves differently.</para>

      <para>To understand the difference, let's first review what we
	might expect with a normal datatype.  We are already familiar
	with the idea that if &undefined; is evaluated at runtime, it
	causes a crash.</para>
      
      &newtype.ghci:undefined;

      <para>Here is a pattern match where we construct a
	<type>DataInt</type> using the <code>D</code> constructor, and
	put &undefined; inside.</para>

      &newtype.ghci:D;

      <para>Since our pattern matches against the constructor but
	doesn't inspect the payload, the &undefined; remains
	unevaluated and does not cause a crash.</para>

      <para>In this example, we're not using the <code>D</code>
	constructor, so the unprotected &undefined; gets evaluated
	when the pattern match occurs, and we crash.</para>

      &newtype.ghci:data;

      <para>When we use the <code>N</code> constructor, we get the
	same behaviour as we did with the <code>D</code> constructor:
	no crash.</para>

      &newtype.ghci:N;

      <para>The crucial difference arises when we get rid of the
	<code>N</code> constructor from the expression, and match
	against an unprotected &undefined;.</para>

      &newtype.ghci:newtype;

      <para>We don't crash!  Because there's no constructor present at
	runtime, matching against <code>N _</code> is actually
	equivalent to matching against the plain wild card
	<code>_</code>: since this always matches, the expression
	doesn't need to be evaluated.</para>

      <tip>
	<title>Another perspective on newtype constructors</title>

	<para>Even though we use a <code>newtype</code> type's
	  constructor in the same way as a <code>data</code> type's
	  constructor, it really exists just to coerce a value between
	  the two types.</para>

	<para>In other words, when we apply the <code>N</code>
	  constructor in an expression, we coerce an expression from type
	  <type>Int</type> to type <type>NewtypeInt</type> as far as
	  we and the compiler are concerned, but absolutely nothing
	  happens at runtime.</para>

	<para>Similarly, when we match on the <code>N</code>
	  constructor in a pattern, we coerce an expression from type
	  <type>NewtypeInt</type> to <type>Int</type>, but again
	  there's no overhead involved at runtime.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Summary: the three ways of naming types</title>

      <para>Here's a brief recap of Haskell's three ways to introduce
	new names for types.</para>

      <itemizedlist>
	<listitem>
	  <para>The <code>data</code> keyword introduces a truly new
	    albegraic data type.</para>
	</listitem>
	<listitem>
	  <para>The <code>type</code> keyword gives us a synonym to
	    use for an existing type.  We can use the type and its
	    synonym interchangeably.</para>
	</listitem>
	<listitem>
	  <para>The <code>newtype</code> keyword gives an existing
	    type a distinct identity.  The original type and the new
	    type are <emphasis>not</emphasis> interchangeable.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="jsonclass.instances">
    <title>JSON typeclasses without overlapping instances</title>

    <para>Enabling &GHC;'s support for overlapping instances might be
      a tempting and quick way to make our JSON code happy, but it
      won't teach us how to work with &newtype;.  In any case, we will
      on occasion be faced with several equally good instances, in
      which case overlapping instances will not save us.</para>

    <para>Our first task, then, is to wrap up the list type so that
      the compiler will not see it as a list.</para>

    &JSONClass.hs:JAry;

    <para>When we export this type from our module, we'll export the
      complete details of the type.  Our module header will look like
      this:</para>

    &JSONClassExport.hs:module;

    <para>The <quote><code>(..)</code></quote> following the
      <type>JAry</type> name means <quote>export all details of this
	type</quote>.</para>

    <para>Usually, when we export a &newtype;, we do
      <emphasis>not</emphasis> export the data constructor. Instead,
      we define a function that applies the constructor for us.</para>

    &JSONClass.hs:jary;

    <para>We then export the type constructor, the deconstructor
      function, and the construction function, but
      <emphasis>not</emphasis> the data constructor.</para>

    &JSONClassExport.hs:abstract;

    <para>However, the usual reason to avoid exporting the data
      constructor is to <quote>hide the plumbing</quote>, keeping our
      type abstract.  When we don't export a type's data constructor,
      clients of our library can only use the functions we provide to
      construct and deconstruct values of that type.  That gives us,
      the library authors, the liberty to change our internal
      representation if we need to.  If we export the data
      constructor, and decide to change the details of our type, we'll
      run the risk of breaking any existing code that uses the
      constructor.</para>

    <para>In this case, we really won't gain anything by making the
      array wrapper abstract, so it makes more sense if we simply
      export the entire definition.</para>

    <para>We provide another wrapper type that hides our
      representation of a JSON object.</para>

    &JSONClass.hs:JObj;

    <para>With these types defined, we make small changes to the
      definition of our <code>JValue</code> type.</para>

    &JSONClass.hs:JValue;

    <para>This change doesn't affect the instances of the
      <type>JSON</type> typeclass that we've already written, but we'd
      like to write instances for our new <type>JAry</type> and
      <type>JObj</type> types.</para>

    &JSONClass.hs:instance.JAry;

    <para>Let's take a slow walk through the individual steps of
      converting a <type>JAry a</type> to a <type>JValue</type>. Given
      a list where we know that everything inside is a
      <type>JSON</type> instance, converting it to a list of
      <type>JValue</type>s is easy.</para>

    &JSONClass.hs:listToJValues;

    <para>Taking this and wrapping it to become a <type>JAry
	JValue</type> is just a matter of applying the &newtype;'s
      type constructor.</para>
    
    &JSONClass.hs:jvaluesToJAry;

    <para>(Remember, this has no performance cost.  We're just telling
      the compiler to hide the fact that we're using a list.)  To turn
      this into a <type>JValue</type>, we apply another type
      constructor.</para>

    &JSONClass.hs:jaryOfJValuesToJValue;

    <para>Assemble these pieces using function composition, and we get
      a concise one-liner for converting to a
      <type>JValue</type>.</para>

    &JSONClass.hs:jaryToJValue;

    <para>We have more work to do to convert <emphasis>from</emphasis>
      a <type>JValue</type> to a <type>JAry a</type>, but we'll break
      it into reusable parts.  The basic function is
      straightforward.</para>

    &JSONClass.hs:jaryFromJValue;

    <para>The <function>whenRight</function> function inspects its
      argument: calls a function on it if it was created with the
      <code>Right</code> constructor, and leaves a <code>Left</code>
      value untouched.</para>

    &JSONClass.hs:whenRight;

    <para>More complicated is <function>mapEithers</function>.  It
      acts like the regular <function>map</function> function, but if
      it ever encounters a <code>Left</code> value, it returns that
      immediately, instead of continuing to accumulate a list of
      <code>Right</code> values.</para>

    &JSONClass.hs:mapEithers;

    <para>Because the elements of the list hidden in the
      <type>JObj</type> type have a little more structure, the code to
      convert to and from a <type>JValue</type> is a bit more complex.
      Fortunately, we can reuse the functions that we just
      defined.</para>

    &JSONClass.hs:instance.JObj;

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Load the <code>Control.Arrow</code> module into
	      &ghci;, and find out what the
	      <function>second</function> function does.</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para>What is the type of <function>(,)</function>?  When
	      you use it in &ghci;, what does it do?  What about
	      <function>(,,)</function>?</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
