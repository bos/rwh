<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="jsonclass" revision="alpha;beta">
  <title>More work with typeclasses</title>

  <sect1>
    <title></title>
    <para id="x_jz">The <type>JValue</type> type that we introduced in <xref
      linkend="library.jvalue"/> is not especially easy to work with.
      Here is a truncated and tidied snippet of some real JSON data,
      produced by a well known search engine.</para>

    &result.js:result;

    <para id="x_kz">And here's a further slimmed down fragment of that data,
      represented in Haskell.</para>

    &SimpleResult.hs:result;

    <para id="x_lz">Because Haskell doesn't natively support lists that contain
      types of different value, we can't directly represent a JSON
      object that contains values of different types. Instead, we must
      wrap each value with a <type>JValue</type> constructor.  This
      limits our flexibility: if we want to change the number
      <code>3920</code> to a string <code>"3,920"</code>, we must
      change the constructor that we use to wrap it from
      <code>JNumber</code> to <code>JString</code>.</para>

    <para id="x_mz">Haskell's typeclasses offer a tempting solution to this
      problem.</para>

    &JSONClass.hs:class;

    <para id="x_nz">Now, instead of applying a constructor like
      <code>JNumber</code> to a value to wrap it, we apply the
      <function>toJValue</function> function.  If we change a value's
      type, the compiler will choose a suitable implementation of
      <type>toJValue</type> to use with it.</para>

    <para id="x_oz">We also provide a <function>fromJValue</function> function,
      which attempts to convert a <type>JValue</type> into a value of
      our desired type.</para>

    <sect2>
      <title>More helpful errors</title>

      <para id="x_pz">The return type of our <function>fromJValue</function>
	function uses the predefined <type>Either</type> type.  Like
	<type>Maybe</type>, this type is predefined for us, and we'll
	often use it to represent a computation that could
	fail.</para>

      <para id="x_qz">While <type>Maybe</type> is useful for this purpose, it
	gives us no information if a failure occurs: we literally have
	<code>Nothing</code>.  The <type>Either</type> type has a
	similar structure, but instead of <code>Nothing</code>, the
	<quote>something bad happened</quote> constructor is named
	<code>Left</code>, and it takes a parameter.</para>

      &DataEither.hs:Either;

      <para id="x_rz">Quite often, the type we use for the <varname
	  role="type">a</varname> parameter value is
	<type>String</type>, which lets us return an error message if
	something goes wrong.  To see how we use the
	<type>Either</type> type in practice, let's look at a simple
	instance of our typeclass.</para>

      &JSONClass.hs:Bool;

    </sect2>

    <sect2>
      <title>Making an instance with a type synonym</title>
      
      <para id="x_sz">The Haskell 98 standard does not allow us to write an
	instance of the following form, even though it seems perfectly
	reasonable.</para>

      &JSONClass.hs:String;

      <para id="x_tz">Recall that <type>String</type> is a synonym for
	<type>[Char]</type>, which in turn is the type
	<type>[a]</type> where <type>Char</type> is substituted for
	the type parameter <varname role="type">a</varname>. According
	to Haskell 98's rules, we are not allowed to supply a type in
	place of a type parameter when we write an instance.  In other
	words, it would be legal for us to write an instance for
	<type>[a]</type>, but not for <type>[Char]</type>.</para>

      <para id="x_uz">While &GHC; follows the Haskell 98 standard by default, we
	can relax this particular restriction by placing a specially
	formatted comment at the top of our source file.</para>

      &JSONClass.hs:LANGUAGE;

      <para id="x_vz">This comment is a directive to the compiler, called a
	<emphasis>pragma</emphasis>, which tells it to enable a
	language extension.  The <code>TypeSynonymInstances</code>
	language extension makes the above code legal.  We'll
	encounter a few other language extensions in this chapter, and
	a handful more later in this book.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Living in an open world</title>

    <para id="x_wz">Haskell's typeclasses are intentionally designed to let us
      create new instances of a typeclass whenever we like.</para>

    &JSONClass.hs:doubleToJValue;

    <para id="x_xz">We can add new instances anywhere; they are not confined to
      the module where we define a typeclass.  This feature of the
      typeclass system is referred to as its <emphasis>open world
	assumption</emphasis>.  If we could say <quote>the following
	are the only instances of this typeclass that can
	exist</quote>, we could have a <emphasis>closed</emphasis>
      world.</para>

    <para id="x_yz">One useful instance we'd like to be able to write is to turn
      a list into what JSON calls an array.  We won't worry about
      implementation details just yet, so let's use
      <code>undefined</code> as the bodies of the instance's
      methods.</para>

    &BrokenClass.hs:array;

    <para id="x_zz">It would also be convenient if we could turn a list of
      name/value pairs into a JSON object.</para>

    &BrokenClass.hs:object;

    <sect2>
      <title>When do overlapping instances cause problems?</title>
      
      <para id="x_A01">If we put these definitions into a source file and load
	them into &ghci;, everything initially seems fine.</para>

      &brokenClass.ghci:load;

      <para id="x_B01">However, once we try to <emphasis>use</emphasis> the
	list-of-pairs instance, we run into trouble.</para>

      &brokenClass.ghci:use;

      <para id="x_C01">This problem of <emphasis>overlapping instances</emphasis>
	is a consequence of Haskell's open world assumption.  Here's a
	simpler example that makes it clearer what's going on.</para>

      &Overlap.hs:Borked;

      <para id="x_D01">We have two instances of the typeclass <type>Borked</type>
	for pairs: one for a pair of <type>Int</type>s and another for
	a pair of anything else that's <type>Borked</type>.</para>

      <para id="x_E01">Suppose that we want to <function>bork</function> a pair
	of <type>Int</type> values.  To do so, the compiler must
	choose an instance to use.  Because these instances are right
	next to each other, it may seem that it could simply choose
	the more specific instance.</para>

      <para id="x_F01">However, &GHC; is conservative by default, and insists
	that there must be only one possible instance that it could
	use.  It will thus report an error if we try to use
	<code>bork</code>.</para>

      <note>
	<para id="x_G01">As we mentioned earlier, we can scatter instances of a
	  typeclass across several modules.  &GHC; does not complain
	  about the mere existence of overlapping instances.  Instead,
	  it only complains when we try to use a method of the
	  affected typeclass, when it is forced to make a decision
	  about which instance to use.</para>
      </note>
    </sect2>

    <sect2>
      <title>Relaxing the rules for overlapping instances</title>

      <para id="x_H01">&GHC; supports a useful language extension,
	<code>OverlappingInstances</code>: when there are multiple
	overlapping instances to choose from, this extension causes
	the compiler to pick the most specific one.</para>

      <para id="x_I01">We frequently use this extension together with
	<code>TypeSynonymInstances</code>, so that we can provide an
	instance for <type>String</type> and an instance for other
	types of list.  Here's an example.</para>

      &SimpleClass.hs:Foo;
    
      <para id="x_J01">With the <code>OverlappingInstances</code> extension
	enabled, &GHC; will still reject code if it finds more than
	one most specific instance.</para>

      <note>
	<title>When to use the OverlappingInstances extension</title>

	<para id="x_K01">Here's an important point: &GHC; treats
	  <code>OverlappingInstances</code> as affecting the
	  declaration of an instance, <emphasis>not</emphasis> a
	  location where we use the instance.  In other words, when we
	  define an instance that we wish to allow to overlap with
	  another instance, we must enable the extension for the
	  module that contains the definition.  When it compiles the
	  module, &GHC; will mark that instance as <quote>can be
	    overlapped with other instances</quote>.</para>

	<para id="x_L01">Once we import this module and use the instance, we
	  <emphasis>won't</emphasis> need to enable
	  <code>OverlappingInstances</code> in the importing module:
	  &GHC; will already know that the instance was marked as
	  <quote>okay to overlap</quote> when it was defined.</para>

	<para id="x_M01">This behaviour is useful when we are writing a library:
	  it lets us choose to create overlappable instances, without
	  forcing clients of our library to enable language extensions
	  in order to use it.</para>
      </note>
    </sect2>

    <sect2>
      <title>How does show work for strings?</title>

      <para id="x_N01">The <code>OverlappingInstances</code> and
	<code>TypeSynonymInstances</code> language extensions are
	specific to &GHC;, and by definition were not present in
	Haskell 98.  However, the familiar <type>Show</type> typeclass
	from Haskell 98 somehow renders a list of <type>Char</type>
	differently from a list of <type>Int</type>.  It achieves this
	via a clever, but simple, trick.</para>

      <para id="x_O01">The <type>Show</type> class defines both a
	<function>show</function> method and a
	<function>showList</function> method.  The default
	implementation of <function>showList</function> renders
	elements using square brackets and commas.  The instance of
	<type>Show</type> for <type>[a]</type> uses
	<function>showList</function>.  The instance of
	<type>Show</type> for <type>Char</type> simply provides a
	special implementation of <function>showList</function> that
	uses double quotes and escapes non-ASCII-printable
	characters.</para>

      <para id="x_P01">At least sometimes, then, we can avoid the need for the
	<code>OverlappingInstances</code> extension with a little bit
	of lateral thinking.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>How to give a type a secret identity</title>

    <para id="x_Q01">In addition to the familiar &data; keyword, Haskell provides
      us with another way to create a new type, via &newtype;.</para>

    &Newtype.hs:newtype;

    <para id="x_R01">The purpose of a &newtype; declaration is to rename an
      existing type, giving it a distinct identity.  As we can see, it
      is similar in appearance to a type declaration using the &data;
      keyword.</para>

    <para id="x_S01">When we declare a &newtype;, we can choose to make any of
      the underlying type's typeclass instances available. Here, we've
      elected to make <type>NewtypeInt</type> provide
      <type>Int</type>'s instances for <type>Eq</type>,
      <type>Ord</type> and <type>Show</type>.  As a result, we can
      compare and print values of type <type>NewtypeInt</type>.</para>

    &newtype.ghci:compare;

    <para id="x_T01">However, since we are <emphasis>not</emphasis> exposing
      <type>Int</type>'s <type>Num</type> or <type>Integral</type>
      instances, values of type <type>NewtypeInt</type> are not
      numbers.  For instance, we can't add them.</para>

    &newtype.ghci:num;

    <para id="x_U01">As with the &data; keyword, we can use a &newtype;'s value
      constructor to create a new value, or to pattern match on an
      existing value.</para>

    <sect2>
      <title>Differences between data and newtype declarations</title>

      <para id="x_V01">The &newtype; keyword exists to give an existing type a
	new identity, and it is more restricted in how we can use it
	than the &data; keyword.  Specifically, a &newtype; can only
	have one value constructor, and that constructor must have
	exactly one field.</para>

      &NewtypeDiff.hs:newtype;

      <para id="x_W01">Beyond this, there's another important difference between
	&data; and &newtype;.   A type created with the &data; keyword
	has some runtime book-keeping overhead, to record which
	constructor a value was created with.  A &newtype; value, on
	the other hand, can only have one constructor, and so does not
	need this overhead.  This makes it more space- and
	time-efficient at runtime.</para>

      <para id="x_X01">Because a &newtype;'s constructor is used only at compile
	time and doesn't have a runtime representation, pattern
	matching on &undefined; behaves differently.</para>

      <para id="x_Y01">To understand the difference, let's first review what we
	might expect with a normal datatype.  We are already familiar
	with the idea that if &undefined; is evaluated at runtime, it
	causes a crash.</para>
      
      &newtype.ghci:undefined;

      <para id="x_Z01">Here is a pattern match where we construct a
	<type>DataInt</type> using the <code>D</code> constructor, and
	put &undefined; inside.</para>

      &newtype.ghci:D;

      <para id="x_a01">Since our pattern matches against the constructor but
	doesn't inspect the payload, the &undefined; remains
	unevaluated and does not cause a crash.</para>

      <para id="x_b01">In this example, we're not using the <code>D</code>
	constructor, so the unprotected &undefined; gets evaluated
	when the pattern match occurs, and we crash.</para>

      &newtype.ghci:data;

      <para id="x_c01">When we use the <code>N</code> constructor, we get the
	same behaviour as we did with the <code>D</code> constructor:
	no crash.</para>

      &newtype.ghci:N;

      <para id="x_d01">The crucial difference arises when we get rid of the
	<code>N</code> constructor from the expression, and match
	against an unprotected &undefined;.</para>

      &newtype.ghci:newtype;

      <para id="x_e01">We don't crash!  Because there's no constructor present at
	runtime, matching against <code>N _</code> is actually
	equivalent to matching against the plain wild card
	<code>_</code>: since this always matches, the expression
	doesn't need to be evaluated.</para>

      <tip>
	<title>Another perspective on newtype constructors</title>

	<para id="x_f01">Even though we use a <code>newtype</code> type's
	  constructor in the same way as a <code>data</code> type's
	  constructor, it really exists just to coerce a value between
	  the two types.</para>

	<para id="x_g01">In other words, when we apply the <code>N</code>
	  constructor in an expression, we coerce an expression from type
	  <type>Int</type> to type <type>NewtypeInt</type> as far as
	  we and the compiler are concerned, but absolutely nothing
	  happens at runtime.</para>

	<para id="x_h01">Similarly, when we match on the <code>N</code>
	  constructor in a pattern, we coerce an expression from type
	  <type>NewtypeInt</type> to <type>Int</type>, but again
	  there's no overhead involved at runtime.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Summary: the three ways of naming types</title>

      <para id="x_i01">Here's a brief recap of Haskell's three ways to introduce
	new names for types.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_j01">The <code>data</code> keyword introduces a truly new
	    albegraic data type.</para>
	</listitem>
	<listitem>
	  <para id="x_k01">The <code>type</code> keyword gives us a synonym to
	    use for an existing type.  We can use the type and its
	    synonym interchangeably.</para>
	</listitem>
	<listitem>
	  <para id="x_l01">The <code>newtype</code> keyword gives an existing
	    type a distinct identity.  The original type and the new
	    type are <emphasis>not</emphasis> interchangeable.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="jsonclass.instances">
    <title>JSON typeclasses without overlapping instances</title>

    <para id="x_m01">Enabling &GHC;'s support for overlapping instances might be
      a tempting and quick way to make our JSON code happy, but it
      won't teach us how to work with &newtype;.  In any case, we will
      on occasion be faced with several equally good instances, in
      which case overlapping instances will not save us.</para>

    <para id="x_n01">Our first task, then, is to wrap up the list type so that
      the compiler will not see it as a list.</para>

    &JSONClass.hs:JAry;

    <para id="x_o01">When we export this type from our module, we'll export the
      complete details of the type.  Our module header will look like
      this:</para>

    &JSONClassExport.hs:module;

    <para id="x_p01">The <quote><code>(..)</code></quote> following the
      <type>JAry</type> name means <quote>export all details of this
	type</quote>.</para>

    <para id="x_q01">Usually, when we export a &newtype;, we do
      <emphasis>not</emphasis> export the data constructor. Instead,
      we define a function that applies the constructor for us.</para>

    &JSONClass.hs:jary;

    <para id="x_r01">We then export the type constructor, the deconstructor
      function, and the construction function, but
      <emphasis>not</emphasis> the data constructor.</para>

    &JSONClassExport.hs:abstract;

    <para id="x_s01">However, the usual reason to avoid exporting the data
      constructor is to <quote>hide the plumbing</quote>, keeping our
      type abstract.  When we don't export a type's data constructor,
      clients of our library can only use the functions we provide to
      construct and deconstruct values of that type.  That gives us,
      the library authors, the liberty to change our internal
      representation if we need to.  If we export the data
      constructor, and decide to change the details of our type, we'll
      run the risk of breaking any existing code that uses the
      constructor.</para>

    <para id="x_t01">In this case, we really won't gain anything by making the
      array wrapper abstract, so it makes more sense if we simply
      export the entire definition.</para>

    <para id="x_u01">We provide another wrapper type that hides our
      representation of a JSON object.</para>

    &JSONClass.hs:JObj;

    <para id="x_v01">With these types defined, we make small changes to the
      definition of our <code>JValue</code> type.</para>

    &JSONClass.hs:JValue;

    <para id="x_w01">This change doesn't affect the instances of the
      <type>JSON</type> typeclass that we've already written, but we'd
      like to write instances for our new <type>JAry</type> and
      <type>JObj</type> types.</para>

    &JSONClass.hs:instance.JAry;

    <para id="x_x01">Let's take a slow walk through the individual steps of
      converting a <type>JAry a</type> to a <type>JValue</type>. Given
      a list where we know that everything inside is a
      <type>JSON</type> instance, converting it to a list of
      <type>JValue</type>s is easy.</para>

    &JSONClass.hs:listToJValues;

    <para id="x_y01">Taking this and wrapping it to become a <type>JAry
	JValue</type> is just a matter of applying the &newtype;'s
      type constructor.</para>
    
    &JSONClass.hs:jvaluesToJAry;

    <para id="x_z01">(Remember, this has no performance cost.  We're just telling
      the compiler to hide the fact that we're using a list.)  To turn
      this into a <type>JValue</type>, we apply another type
      constructor.</para>

    &JSONClass.hs:jaryOfJValuesToJValue;

    <para id="x_A11">Assemble these pieces using function composition, and we get
      a concise one-liner for converting to a
      <type>JValue</type>.</para>

    &JSONClass.hs:jaryToJValue;

    <para id="x_B11">We have more work to do to convert <emphasis>from</emphasis>
      a <type>JValue</type> to a <type>JAry a</type>, but we'll break
      it into reusable parts.  The basic function is
      straightforward.</para>

    &JSONClass.hs:jaryFromJValue;

    <para id="x_C11">The <function>whenRight</function> function inspects its
      argument: calls a function on it if it was created with the
      <code>Right</code> constructor, and leaves a <code>Left</code>
      value untouched.</para>

    &JSONClass.hs:whenRight;

    <para id="x_D11">More complicated is <function>mapEithers</function>.  It
      acts like the regular <function>map</function> function, but if
      it ever encounters a <code>Left</code> value, it returns that
      immediately, instead of continuing to accumulate a list of
      <code>Right</code> values.</para>

    &JSONClass.hs:mapEithers;

    <para id="x_E11">Because the elements of the list hidden in the
      <type>JObj</type> type have a little more structure, the code to
      convert to and from a <type>JValue</type> is a bit more complex.
      Fortunately, we can reuse the functions that we just
      defined.</para>

    &JSONClass.hs:instance.JObj;

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para id="x_F11">Load the <code>Control.Arrow</code> module into
	      &ghci;, and find out what the
	      <function>second</function> function does.</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para id="x_G11">What is the type of <function>(,)</function>?  When
	      you use it in &ghci;, what does it do?  What about
	      <function>(,,)</function>?</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>The dreaded monomorphism restriction</title>

    <para id="x_H11">The Haskell 98 standard has a subtle feature that can
      sometimes bite us in unexpected circumstances. Here's a simple
      function definition that illustrates the issue.</para>

    &Monomorphism.hs:myShow;

    <para id="x_I11">If we try to load this definition into &ghci;, it issues a
      peculiar complaint.</para>

    &monomorphism.ghci:load;

    <para id="x_J11">The <quote>monomorphism restriction</quote> to which the
      error message refers is a part of the Haskell 98 standard.
      <emphasis>Monomorphism</emphasis> is simply the opposite of
      polymorphism: it indicates that an expression has exactly one
      type.  The <emphasis>restriction</emphasis> lies in the fact
      that Haskell sometimes forces a declaration to be less
      polymorphic than we would expect.</para>

    <para id="x_K11">We mention the monomorphism restriction here because
      although it isn't specifically related to typeclasses, they
      usually provide the circumstances in which it crops up.</para>

    <tip>
      <para id="x_L11">It's possible that you will not run into the monomorphism
	restriction in real code for a long time.  We don't think you
	need to try to remember the details of this section.  It
	should suffice to make a mental note of its existence, until
	eventually &GHC; complains at you with something like the
	above error message. If that occurs, simply remember that you
	read about the error here, and come back for guidance.</para>
    </tip>

    <para id="x_M11">We won't attempt to explain the monomorphism
      restriction<footnote>
	<para id="x_N11">If you simply <emphasis>must</emphasis> read the gory
	  details, see <ulink
	    url="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">section 
	    4.5.5</ulink> of the Haskell 98 Report.</para>
      </footnote>.  The consensus within the Haskell community is that
      it doesn't arise often; it is tricky to explain; it provides
      almost no practical benefit; and so it mostly serves to trip
      people up.  For an example of its trickiness, while the
      definition above falls afoul of it, the following two compile
      without problems.</para>

    &Monomorphism.hs:myShow2;

    <para id="x_O11">As these alternative definitions suggest, if &GHC; complains
      about the monomorphism restriction, we have three easy ways to
      address the error.</para>

    <itemizedlist>
      <listitem>
	<para id="x_P11">Make the function's arguments explicit, instead of
	  leaving them implicit.</para>
      </listitem>
      <listitem>
	<para id="x_Q11">Give the definition an explicit type signature, instead
	  of making the compiler infer its type.</para>
      </listitem>
      <listitem>
	<para id="x_R11">Leave the code untouched, and compile the module with
	  the <code>NoMonomorphismRestriction</code> language
	  extension enabled.  This disables the monomorphism
	  restriction.</para>
      </listitem>
    </itemizedlist>

    <para id="x_S11">Because the monomorphism restriction is unwanted and
      unloved, it will almost certainly be dropped from the next
      revision of the Haskell standard.  This does not quite mean that
      compiling with <code>NoMonomorphismRestriction</code> is always
      the right thing to do: some Haskell compilers (including older
      versions of &GHC;) do not understand this extension, but they'll
      accept either of the other approaches to making the error
      disappear.  If this degree of portability isn't a concern to
      you, then by all means enable the language extension.</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
