<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="jsonclass" revision="alpha;beta">
  <title>A typeclass approach to JSON</title>

  <sect1>
    <title></title>
    <para>The <type>JValue</type> type that we introduced in <xref
      linkend="library.jvalue"/> is not especially easy to work with.
      Here is a truncated and tidied snippet of some real JSON data,
      produced by a well known search engine.</para>

    &result.js:result;

    <para>And here's a further slimmed down fragment of that data,
      represented in Haskell.</para>

    &SimpleResult.hs:result;

    <para>Because Haskell doesn't natively support lists that contain
      types of different value, we can't directly represent a JSON
      object that contains values of different types. Instead, we must
      wrap each value with a <type>JValue</type> constructor.  This
      limits our flexibility: if we want to change the number
      <code>3920</code> to a string <code>"3,920"</code>, we must
      change the constructor that we use to wrap it from
      <code>JNumber</code> to <code>JString</code>.</para>

    <para>Haskell's typeclasses offer a tempting solution to this
      problem.</para>

    &JSONClass.hs:class;

    <para>Now, instead of applying a constructor like
      <code>JNumber</code> to a value to wrap it, we apply the
      <function>toJValue</function> function.  If we change a value's
      type, the compiler will choose a suitable implementation of
      <type>toJValue</type> to use with it.</para>

    <para>We also provide a <function>fromJValue</function> function,
      which attempts to convert a <type>JValue</type> into a value of
      our desired type.</para>

    <sect2>
      <title>More helpful errors</title>

      <para>The return type of our <function>fromJValue</function>
	function uses the predefined <type>Either</type> type.  Like
	<type>Maybe</type>, this type is predefined for us, and we'll
	often use it to represent a computation that could
	fail.</para>

      <para>While <type>Maybe</type> is useful for this purpose, it
	gives us no information if a failure occurs: we literally have
	<code>Nothing</code>.  The <type>Either</type> type has a
	similar structure, but instead of <code>Nothing</code>, the
	<quote>something bad happened</quote> constructor is named
	<code>Left</code>, and it takes a parameter.</para>

      &DataEither.hs:Either;

      <para>Quite often, the type we use for the <varname
	  role="type">a</varname> parameter value is
	<type>String</type>, which lets us return an error message if
	something goes wrong.  To see how we use the
	<type>Either</type> type in practice, let's look at a simple
	instance of our typeclass.</para>

      &JSONClass.hs:Bool;

    </sect2>

    <sect2>
      <title>Making an instance with a type synonym</title>
      
      <para>The Haskell 98 standard does not allow us to write an
	instance of the following form, even though it seems perfectly
	reasonable.</para>

      &JSONClass.hs:String;

      <para>Recall that <type>String</type> is a synonym for
	<type>[Char]</type>, which in turn is the type
	<type>[a]</type> where <type>Char</type> is substituted for
	the type parameter <varname role="type">a</varname>. According
	to Haskell 98's rules, we are not allowed to supply a type in
	place of a type parameter when we write an instance.  In other
	words, it would be legal for us to write an instance for
	<type>[a]</type>, but not for <type>[Char]</type>.</para>

      <para>While &GHC; follows the Haskell 98 standard by default, we
	can relax this particular restriction by placing a specially
	formatted comment at the top of our source file.</para>

      &JSONClass.hs:LANGUAGE;

      <para>This comment is a directive to the compiler, called a
	<emphasis>pragma</emphasis>, which tells it to enable a
	language extension.  The <code>TypeSynonymInstances</code>
	language extension makes the above code legal.  We'll
	encounter a few other language extensions in this chapter, and
	a handful more later in this book.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Living in an open world</title>

    <para>Haskell's typeclasses are intentionally designed to let us
      create new instances of a typeclass whenever we like.</para>

      &JSONClass.hs:doubleToJValue;

    <para>We can add new instances anywhere; they are not confined to
      the module where we define a typeclass.  This feature of the
      typeclass system is referred to as its <emphasis>open world
	assumption</emphasis>.  If we could say <quote>the following
	are the only instances of this typeclass that can
	exist</quote>, we could have a <emphasis>closed</emphasis>
      world.</para>

    <para>One useful instance we'd like to be able to write is to turn
      a list into a JSON array.  We won't worry about implementation
      details just yet, so let's use <code>undefined</code> as the
      bodies of the instance's methods.</para>

      &BrokenClass.hs:array;

    <para>It would also be convenient if we could turn a list of
      name/value pairs into a JSON object.</para>

      &BrokenClass.hs:object;

    <para>If we put these definitions into a source file and load them
      into &ghci;, everything initially seems fine.</para>

      &brokenClass.ghci:load;

    <para>However, once we try to <emphasis>use</emphasis> the
      list-of-pairs instance, we run into trouble.</para>

      &brokenClass.ghci:use;

    <para>This problem of <emphasis>overlapping instances</emphasis>
      is a consequence of Haskell's open world assumption.  Here's a
      simpler example that makes it clearer what's going on.</para>

      &Overlap.hs:Borked;

    <para>We have two instances of the typeclass <type>Borked</type>
      for pairs: one for a pair of <type>Int</type>s and another for a
      pair of anything else that's <type>Borked</type>.</para>

    <para>Suppose that we want to <function>bork</function> a pair of
      <type>Int</type> values.  To do so, the compiler must choose an
      instance to use.  Because these instances are right next to each
      other, it may seem that it could simply choose the more specific
      instance.</para>

    <para>However, &GHC; is conservative by default, and insists that
      there must be only one possible instance that it could use.  It
      will thus report an error if we try to use
      <code>bork</code>.</para>

    <note>
      <title>When do overlapping instances cause an error?</title>

      <para>As we mentioned earlier, we can scatter instances of a
	typeclass across several modules.  &GHC; does not complain
	about the mere existence of overlapping instances.  Instead,
	it only complains when we try to use a method of the affected
	typeclass, when it is forced to make a decision about which
	instance to use.</para>
    </note>

    <sect2>
      <title>Relaxing the rules for overlapping instances</title>

      <para>&GHC; supports a useful language extension,
	<code>OverlappingInstances</code>: when there are multiple
	overlapping instances to choose from, this extension causes
	the compiler to pick the most specific one.</para>

      <para>We frequently use this extension together with
	<code>TypeSynonymInstances</code>, so that we can provide an
	instance for <type>String</type> and an instance for other
	types of list.  Here's an example.</para>

      &SimpleClass.hs:Foo;
    
      <para>With the <code>OverlappingInstances</code> extension
	enabled, &GHC; will still reject code if it finds more than
	one most specific instance.</para>

      <note>
	<title>When to use the OverlappingInstances extension</title>

	<para>Here's an important point: &GHC; treats
	  <code>OverlappingInstances</code> as affecting the
	  declaration of an instance, <emphasis>not</emphasis> a
	  location where we use the instance.  In other words, when we
	  define an instance that we wish to allow to overlap with
	  another instance, we must enable the extension for the
	  module that contains the definition.  When it compiles the
	  module, &GHC; will mark that instance as <quote>can be
	    overlapped with other instances</quote>.</para>

	<para>Once we import this module and use the instance, we
	  <emphasis>won't</emphasis> need to enable
	  <code>OverlappingInstances</code> in the importing module:
	  &GHC; will already know that the instance was marked as
	  <quote>okay to overlap</quote> when it was defined.</para>

	<para>This behaviour is useful when we are writing a library:
	  it lets us choose to create overlappable instances, without
	  forcing clients of our library to enable language extensions
	  in order to use it.</para>
      </note>
    </sect2>

    <sect2>

      <title>How does show work for strings?</title>

      <para>Since the <code>OverlappingInstances</code> and
	<code>TypeSynonymInstances</code> language extensions are
	specific to &GHC;, how does the machinery around the familiar
	<type>Show</type> typeclass render <type>[Char]</type>
	differently from <type>[Int]</type>? Via a clever
	trick.</para>

      <para>The <type>Show</type> class defines both a
	<function>show</function> method and a
	<function>showList</function> method.  The default
	implementation of <function>showList</function> renders using
	square brackets and commas.  The instance of <type>Show</type>
	for <type>Char</type> provides a special implementation of
	<function>showList</function> that uses double quotes and
	escapes non-ASCII-printable characters.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>How to give a type a secret identity</title>

    <para>In addition to the familiar &data; keyword, Haskell provides
      us with another way to create a new type, via &newtype;.</para>

    &Newtype.hs:newtype;

    <para>The purpose of a &newtype; declaration is to rename an
      existing type, giving it a distinct identity.  As we can see, it
      is similar in appearance to a type declaration using the &data;
      keyword.</para>

    <para>When we declare a &newtype;, we can choose to make any of
      the underlying type's typeclass instances available. Here, we've
      elected to make <type>NewtypeInt</type> provide
      <type>Int</type>'s instances for <type>Eq</type>,
      <type>Ord</type> and <type>Show</type>.  As a result, we can
      compare and print values of type <type>NewtypeInt</type>.</para>

    &newtype.ghci:compare;

    <para>However, since we are <emphasis>not</emphasis> exposing
      <type>Int</type>'s <type>Num</type> or <type>Integral</type>
      instances, values of type <type>NewtypeInt</type> are not
      numbers.  For instance, we can't add them.</para>

    &newtype.ghci:num;

    <para>As with the &data; keyword, we can use a &newtype;'s value
      constructor to create a new value, or to pattern match on an
      existing value.</para>

    <sect2>
      <title>Differences between data and newtype declarations</title>

      <para>The &newtype; keyword exists to give an existing type a
	new identity, and it is more restricted in how we can use it
	than the &data; keyword.  Specifically, a &newtype; can only
	have one value constructor, and that constructor must have
	exactly one field.</para>

      &NewtypeDiff.hs:newtype;

      <para>Beyond this, there's another important difference between
	&data; and &newtype;.   A type created with the &data; keyword
	has some runtime book-keeping overhead, to record which
	constructor a value was created with.  A &newtype; value, on
	the other hand, can only have one constructor, and so does not
	need this overhead.  This makes it more space- and
	time-efficient at runtime.</para>

      <para>Because a &newtype;'s constructor is used only at compile
	time and doesn't have a runtime representation, pattern
	matching on &undefined; behaves differently.</para>

      <para>To understand the difference, let's first review what we
	might expect with a normal datatype.  We are already familiar
	with the idea that if &undefined; is evaluated at runtime, it
	causes a crash.</para>
      
      &newtype.ghci:undefined;

      <para>Here is a pattern match where we construct a
	<type>DataInt</type> using the <code>D</code> constructor, and
	put &undefined; inside.</para>

      &newtype.ghci:D;

      <para>Since our pattern matches against the constructor but
	doesn't inspect the payload, the &undefined; remains
	unevaluated and does not cause a crash.</para>

      <para>In this example, we're not using the <code>D</code>
	constructor, so the unprotected &undefined; gets evaluated
	when the pattern match occurs, and we crash.</para>

      &newtype.ghci:data;

      <para>When we use the <code>N</code> constructor, we get the
	same behaviour as we did with the <code>D</code> constructor:
	no crash.</para>

      &newtype.ghci:N;

      <para>The crucial difference arises when we get rid of the
	<code>N</code> constructor, and match against an unprotected
	&undefined;.</para>

      &newtype.ghci:newtype;

      <para>We didn't crash!  Because there's no constructor present
	at runtime, matching against <code>N _</code> is actually
	equivalent to matching against the plain wild card
	<code>_</code>: since this always matches, the expression
	doesn't need to be evaluated.</para>
    </sect2>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
