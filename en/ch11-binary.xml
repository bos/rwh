<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="binary" revision="alpha;beta">
  <title>Code case study: parsing a binary data format</title>

  <para id="x_sQ">In this chapter, we'll discuss a common task:
    parsing a binary file.  We will use this task for two purposes.
    Our first is indeed to talk a little about parsing, but our main
    goal is to talk about program organisation, refactoring, and
    <quote>boilerplate removal</quote>.  We will demonstrate how you
    can tidy up repetitious code, and set the stage for our discussion
    of monads in <xref linkend="monads"/>.</para>

  <para id="x_tQ">The file formats that we will work with come from
    the netpbm suite, an ancient and venerable collection of programs
    and file formats for working with bitmap images.  These file
    formats have the dual advantages of wide use and being fairly
    easy, though not completely trivial, to parse.  Most importantly
    for our convenience, netpbm files are not compressed.</para>

  <sect1>
    <title>Greyscale files</title>

    <para id="x_uQ">The name of netpbm's greyscale file format is PGM
      (<quote>portable grey map</quote>).  It is actually not one
      format, but two; the <quote>plain</quote> (or <quote>P2</quote>)
      format is encoded as ASCII, while the more common
      <quote>raw</quote> (<quote>P5</quote>) format is mostly
      binary.</para>

    <para id="x_vQ">A file of either format starts with a header, which in turn
      begins with a <quote>magic</quote> string describing the format.
      For a plain file, the string is <literal>P2</literal>, and for
      raw, it's <literal>P5</literal>. The magic string is followed by
      white space, then by three numbers: the width, height, and
      maximum grey value of the image. These numbers are represented
      as ASCII decimal numbers, separated by white space.</para>

    <para id="x_wQ">After the maximum grey value comes the image data.  In a raw
      file, this is a string of binary values.  In a plain file, the
      values are represented as ASCII decimal numbers separated by
      single space characters.</para>

    <para id="x_xQ">A raw file can contain a sequence of images, one after the
      other, each with its own header.  A plain file contains only one
      image.</para>

  </sect1>

  <sect1>
    <title>Parsing a raw PGM file</title>

    <para id="x_yQ">For our first try at a parsing function, we'll only worry
      about raw PGM files. We'll write our PGM parser as a
      <emphasis>pure</emphasis> function. It's not responsible for
      obtaining the data to parse, just for the actual parsing.  This
      is a common approach in Haskell programs. By separating the
      reading of the data from what we subsequently do with it, we
      gain flexibility in where we take the data from.</para>

    <para id="x_zQ">We'll use the <type>ByteString</type> type to
      store our greymap data, because it's compact.  Since the header
      of a PGM file is ASCII text, but its body is binary, we import
      both the text- and binary-oriented <type>ByteString</type>
      modules.</para>

    &PNM.hs:imports;

    <para id="x_AR">For our purposes, it doesn't matter whether we use a lazy or
      strict <type>ByteString</type>, so we've somewhat arbitrarily
      chosen the lazy kind.</para>

    <para id="x_CR">We'll use a straightforward data type to represent PGM
      images.</para>

    &PNM.hs:Greymap;

    <para id="x_DR">Normally, a Haskell <type>Show</type> instance should
      produce a string representation that we can read back by calling
      <function>read</function>.  However, for a bitmap graphics file,
      this would potentially produce huge text strings, for example if
      we were to <function>show</function> a photo.  For this reason,
      we're not going to let the compiler automatically derive a
      <type>Show</type> instance for us: we'll write our own,
      and intentionally simplify it.</para>

    &PNM.hs:Show;

    <para id="x_ER">Because our <type>Show</type> instance intentionally avoids
      printing the bitmap data, there's no point in writing a
      <type>Read</type> instance, as we can't reconstruct a valid
      <type>Greymap</type> from the result of
      <function>show</function>.</para>

    <para id="x_FR">Here's an obvious type for our parsing function.</para>

    &PNM.hs:parseP5.type;

    <para id="x_GR">This will take a <type>ByteString</type>, and if the parse
      succeeds, it will return a single parsed <type>Greymap</type>, along
      with the string that remains after parsing.  That residual
      string will</para>

    <para id="x_HR">Our parsing function has to consume a little bit
      of its input at a time.  First, we need to assure ourselves that
      we're really looking at a raw PGM file; then we need to parse
      the numbers from the remainder of the header; then we consume
      the bitmap data.  Here's an obvious way to express this, which
      we will use as a base for later improvements.</para>

    &PNM.hs:parseP5;

    <para id="x_IR">This is a very literal piece of code, performing
      all of the parsing in one long staircase of &case; expressions.
      Each function returns the residual <type>ByteString</type> left
      over after it has consumed all it needs from its input string.
      We pass each residual string along to the next step.  We
      deconstruct each result in turn, either returning
      <code>Nothing</code> if the parsing step failed, or building up
      a piece of the final result as we proceed. Here are the bodies
      of the functions that we apply during parsing.  Their types are
      commented out because we already presented them above.</para>

    &PNM.hs:parseP5.functions;

  </sect1>

  <sect1>
    <title>Getting rid of boilerplate code</title>

    <para id="x_JR">While our <function>parseP5</function> function
      works, the style in which we wrote it is somehow not pleasing.
      Our code marches steadily to the right of the screen, and it's
      clear that a slightly more complicated function would soon run
      out of visual real estate.  We repeat a pattern of
      constructing and then deconstructing <type>Maybe</type> values,
      only continuing if a particular value matches
      <function>Just</function>.  All of the similar &case;
      expressions act as <quote>boilerplate code</quote>, busywork
      that obscures what we're really trying to do.  In short, this
      function is begging for some abstraction and refactoring.</para>

    <para id="x_KR">If we step back a little, we can see two patterns.  First is
      that many of the functions that we apply have similar types.  Each
      takes a <type>ByteString</type> as its last argument, and
      returns <type>Maybe</type> something else.  Secondly, every step
      in the <quote>ladder</quote> of our <function>parseP5</function>
      function deconstructs a <type>Maybe</type> value, and either
      fails or passes the unwrapped result to a function.</para>

    <para id="x_LR">We can quite easily write a function that captures this
      second pattern.</para>

    &PNM.hs:bind;

    <para id="x_MR">The <function>(&gt;&gt;?)</function> function acts
	very simply: it takes a value as its left argument, and a
	function as its right. If the value is not
	<literal>Nothing</literal>, it applies the function to
	whatever is wrapped in the <code>Just</code> constructor.  We
	have defined our function as an operator so that we can use it
	to chain functions together.  Finally, we haven't provided a
	fixity declaration for <function>(>>?)</function>, so it
	defaults to <code>infixl 9</code> (left associative, strongest
	operator precedence).  In other words, <code>a &gt;&gt;? b
	  &gt;&gt;? c</code> will be evaluated from left to right, as
	<code>(a &gt;&gt;? b) &gt;&gt;? c)</code>.</para>

    <para id="x_NR">With this chaining function in hand, we can take a second
      try at our parsing function.</para>

    &PNM.hs:parseP5_take2;

    <para id="x_OR">The key to understanding this function is to think about the
      chaining.  On the left hand side of each
      <function>(&gt;&gt;?)</function> is a <type>Maybe</type> value;
      on the right is a function that returns a <type>Maybe</type>
      value.  Each left-and-right-sides expression is thus of type
      <type>Maybe</type>, suitable for passing to the following
      <function>(&gt;&gt;?)</function> expression.</para>

    <para id="x_PR">The other change that we've made to improve readability is
      add a <function>skipSpace</function> function.  With these
      changes, we've halved the number of lines of code compared to
      our original parsing function.  By removing the boilerplate
      &case; expressions, we've made the code easier to follow.</para>

    <para id="x_QR">While we warned against overuse of anonymous functions in
      <xref linkend="fp.anonymous"/>, we use several in our chain
      of functions here.  Because these functions are so small, we
      wouldn't improve readability by giving them names.</para>
  </sect1>

  <sect1 id="binary.implicit">
    <title>Implicit state</title>

    <para id="x_RR">We're not yet out of the woods.  Our code
      explicitly passes pairs around, using one element for an
      intermediate part of the parsed result and the other for the
      current residual <type>ByteString</type>.  If we want to extend
      the code, for example to track the number of bytes we've
      consumed so that we can report the location of a parse failure,
      we already have eight different spots that we will need to
      modify, just to pass a three-tuple around.</para>

    <para>This approach makes even a small body of code difficult to
      change.  The problem lies with our use of pattern matching to
      pull values out of each pair: we have embedded the knowledge
      that we are always working with pairs straight into our code.
      As pleasant and helpful as pattern matching is, it can lead us
      in some undesirable directions if we do not use it
      carefully.</para>

    <para id="x_TR">Let's do something to address the inflexibility of
      our new code.  First, we will change the type of state that our
      parser uses.</para>

    &Parse.hs:ParseState;

    <para id="x_UR">In our switch to an algebraic data type, we added
      the ability to track both the current residual string and the
      offset into the original string since we started parsing.  The
      more important change was our use of record syntax: we can now
      <emphasis>avoid</emphasis> pattern matching on the pieces of
      state that we pass around, and use the accessor functions
      <function>string</function> and <function>offset</function>
      instead.</para>

    <para>We have given our parsing state a name.  When we name
      something, it can become easier to reason about.  For example,
      we can now look at parsing as a kind of function: it consumes a
      parsing state, and produces both a new parsing state and some
      other piece of information.  We can directly represent this as a
      Haskell type.</para>

    &Parse.hs:simpleParse;

    <para>To provide more help to our users, we would like to
      report an error message if parsing fails.  This only requires a
      minor tweak to the type of our parser.</para>

    &Parse.hs:betterParse;

    <para>In order to future-proof our code, it is best if we do not
      expose the implementation of our parser to our users.  When we
      explicitly used pairs for state earlier, we found ourselves in
      trouble almost immediately, once we considered extending the
      capabilities of our parser.  To stave off a repeat of that
      difficulty, we will hide the details of our parser type using a
      &newtype; declaration.</para>

    &Parse.hs:Parse;

    <para>Remember that the &newtype; definition is just a
      compile-time wrapper around a function, so it has no run-time
      overhead.  When we want to use the function, we will apply the
      <function>runParser</function> accessor.</para>

    <para id="x_VR">If we do not export the <code>Parse</code> value
      constructor from our module, we can ensure that nobody else will
      be able to accidentally create a parser, nor will they be able
      to inspect its internals via pattern matching.</para>

    <sect2>
      <title>The identity parser</title>

      <para id="x_XR">Let's try to define a simple parser, the
	<emphasis>identity</emphasis> parser.  All it does is turn
	whatever it is passed into the result of the parse.  In this
	way, it somewhat resembles the <function>id</function>
	function.</para>

      &Parse.hs:identity;

      <para id="x_YR">This function leaves the parse state untouched,
	and uses its argument as the result of the parse.  We wrap the
	body of the function in our <type>Parse</type> type to satisfy
	the type checker.  How can we use this wrapped function to
	parse something?</para>

      <para id="x_ZR">The first thing we must do is peel off the
	<function>Parse</function> wrapper so that we can get at the
	function inside.  We do so using the
	<function>runParse</function> function. We also need to
	construct a <type>ParseState</type>, then run our parsing
	function on that parse state.  Finally, we'd like to separate
	the result of the parse from the final
	<type>ParseState</type>.</para>

      &Parse.hs:parse;

      <para id="x_aR">Because neither the
	<function>identity</function> parser nor the
	<function>parse</function> function examines the parse state,
	we don't even need to create an input string in order to try
	our code.</para>

      &parse.ghci:parse;

      <para id="x_bR">A parser that doesn't even inspect its input
	might not seem interesting, but we will shortly see that in
	fact it is useful.   Meanwhile, we have gained confidence that
	our types are correct and that we understand the basic
	workings of our code.</para>
    </sect2>

    <sect2>
      <title>Record syntax, updates, and pattern matching</title>

      <para>Record syntax is useful for more than just accessor
	functions: we can use it to copy and partly change an existing
	value.  In use, the notation looks like this.</para>

      &Parse.hs:modifyOffset;

      <para>This creates a new <type>ParseState</type> value identical
	to <varname>initState</varname>, but with its
	<code>offset</code> field set to whatever value we specify for
	<code>newOffset</code>.</para>

      &parse.ghci:modifyOffset;

      <para>We can set as many fields as we want inside the curly
	braces, separating them using commas.</para>
    </sect2>

    <sect2>
      <title>A more interesting parser</title>

      <para>Let's focus now on writing a parser that does something
	meaningful.  We're not going to get too ambitious yet: all we
	want to do is parse a single byte.</para>

      &Parse.hs:parseByte;

      <para id="x_cR">There are a number of new functions in our
	definition.</para>

      <para>The <function>L8.uncons</function> function takes the
	first element from a <type>ByteString</type>.</para>

      &parse.ghci:uncons;

      <para>Our <function>getState</function> function retrieves the
	current parsing state, while <function>putState</function>
	replaces it.  The <function>bail</function> function
	terminates parsing and reports an error.  The
	<function>(==&gt;)</function> function chains parsers
	together.  We will cover each of these functions
	shortly.</para>

      <tip>
	<title>Hanging lambdas</title>

	<para id="x_qS">The definition of
	  <function>parseByte</function> has a visual style that we
	  haven't discussed before. It contains anonymous functions in
	  which the parameters and <code>&rarrow;</code> sit at the
	  end of a line, with the function's body following on the
	  next line.</para>

	<para id="x_rS">This style of laying out an anonymous function
	  doesn't have an official name, so let's call it a
	  <quote>hanging lambda</quote>.  Its main use is to make room
	  for more text in the body of the function.  It also makes it
	  more visually clear that there's a relationship between one
	  function and the one that follows.  Often, for instance, the
	  result of the first function is being passed as a parameter
	  to the second.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Obtaining and modifying the parse state</title>

      <para id="x_fR">Our <function>parseByte</function> function
	doesn't take the parse state as an argument.  Instead, it has
	to call <function>getState</function> to get a copy of the
	state, and <function>putState</function> to replace the
	current state with a new one.</para>

      &Parse.hs:getPut;

      <para id="x_gR">When reading these functions, recall that the
	left element of the tuple is the result of a
	<type>Parse</type>, while the right is the current
	<type>ParseState</type>.  This makes it easier to follow what
	these functions are doing.</para>
    
      <para id="x_hR">The <function>getState</function> function
	extracts the current parsing state, so that the caller can
	access the string. The <function>putState</function> function
	replaces the current parsing state with a new one.  This
	becomes the state that will be seen by the next function in
	the <function>(==&gt;)</function> chain.</para>

      <para id="x_iR">These functions let us move explicit state
	handling into the bodies of only those functions that need it.
	Many functions don't need to know what the current state is,
	and so they'll never call <function>getState</function> or
	<function>putState</function>.  This lets us write more
	compact code than our earlier parser, which had to pass tuples
	around by hand.  We will see the effect in some of the code
	that follows.</para>

      <para id="x_jR">We've packaged up the details of the parsing
	state into the <type>ParseState</type> type, and we work with
	it using accessors instead of pattern matching.  Now that the
	parsing state is passed around implicitly, we gain a further
	benefit.  If we want to add more information to the parsing
	state, all we need to do is modify the definition of
	<type>ParseState</type>, and the bodies of whatever functions
	need the new information.  Compared to our earlier parsing
	code, where all of our state was exposed through pattern
	matching, this is much more modular: the only code we affect
	is code that needs the new information.</para>

    </sect2>

    <sect2>
      <title>Reporting parse errors</title>

      <para id="x_kR">We carefully defined our <type>Parse</type> type to
	accommodate the possibility of failure.  The
	<function>(==&gt;)</function> combinator checks for a parse
	failure and stops parsing if it runs into a failure.  But we
	haven't yet introduced the <function>bail</function> function,
	which we use to report a parse error.</para>

      &Parse.hs:bail;

      <para id="x_lR">After we call <function>bail</function>,
	<function>(==&gt;)</function> will successfully pattern match
	on the <code>Left</code> constructor that it wraps the error
	message with, and it will not invoke the next parser in the
	chain.  This will cause the error message to percolate back
	through the chain of prior callers.</para>
    </sect2>

    <sect2>
      <title>Chaining parsers together</title>

      <para>The <function>(==&gt;)</function> function serves a
	similar purpose to our earlier
	<function>(&gt;&gt;?)</function> function: it is
	<quote>glue</quote> that lets us chain functions
	together.</para>

      &Parse.hs:bind;

      <para id="x_dR">The body of <function>(==&gt;)</function> is
	interesting, and ever so slightly tricky.  Recall that the
	<type>Parse</type> type represents really a function inside a
	wrapper.  Since <function>(==&gt;)</function> lets us chain
	two <type>Parse</type> values to produce a third, it must
	return a function, in a wrapper.</para>

      <para>The function doesn't really <quote>do</quote> much: it
	just creates a <emphasis>closure</emphasis> to remember the
	values of <varname>firstParser</varname> and
	<varname>secondParser</varname>.  This closure won't be
	unwrapped and applied until we apply
	<function>parse</function>.  At that point, it will be applied
	with a <type>ParseState</type>.  It will apply
	<varname>firstParser</varname> and inspect its result.  If
	that parse fails, the closure will fail too.  Otherwise, it
	will pass the result of the parse and the new
	<type>ParseState</type> to
	<varname>secondParser</varname>.</para>

      <para id="x_eR">This is really quite fancy and subtle stuff:
	we're effectively passing the <type>ParseState</type> down the
	chain of <type>Parse</type> values in a hidden argument.
	(We'll be revisiting this kind of code in a few chapters, so
	don't fret if that description seemed dense.)</para>

    </sect2>
  </sect1>

  <sect1 id="binary.functor">
    <title>Introducing functors</title>

    <para id="x_mR">We're by now thoroughly familiar with the
      <function>map</function> function, which applies a function to
      every element of a list, returning a list of possibly a
      different type.</para>

    &functor.ghci:map;

    <para id="x_nR">This <function>map</function>-like activity can be useful in
      other instances.  For example, consider a binary tree.</para>

    &TreeMap.hs:Tree;

    <para id="x_oR">If we want to take a tree of strings and turn it into a tree
      containing the lengths of those strings, we could write a
      function to do this.</para>

    &TreeMap.hs:treeLengths;

    <para id="x_pR">Now that our eyes are attuned to looking for patterns that
      we can turn into generally useful functions, we can see a
      possible case of this here.</para>

    &TreeMap.hs:treeMap;

    <para id="x_qR">As we might hope, <function>treeLengths</function> and
      <function>treeMap length</function> give the same
      results.</para>

    &functor.ghci:treeLengths;

    <para id="x_rR">Haskell provides a well-known typeclass to further
      generalise <function>treeMap</function>.  This typeclass is
      named <type>Functor</type>, and it defines one function,
      <function>fmap</function>.</para>

    &TreeMap.hs:Functor;

    <para id="x_sR">We can think of <function>fmap</function> as a kind of
      <emphasis>lifting</emphasis> function, as we introduced in <xref
      linkend="find.predicate.lift"/>.  It takes a function over
      ordinary values <type>a -&gt; b</type> and lifts it to become a
      function over containers <type>f a -&gt; f b</type>, where
      <varname>f</varname> is the container type.</para>

    <para id="x_tR">If we substitute <type>Tree</type> for the type variable
      <varname>f</varname>, for example, the type of
      <function>fmap</function> is identical to the type of
      <function>treeMap</function>, and in fact we can use
      <function>treeMap</function> as the implementation of
      <function>fmap</function> over <type>Tree</type>s.</para>

    &TreeMap.hs:Functor.Tree;

    <para id="x_uR">We can also use <function>map</function> as the
      implementation of <function>fmap</function> for lists.</para>

    &TreeMap.hs:Functor.List;

    <para id="x_vR">We can now use <function>fmap</function> over different
      container types.</para>

    &functor.ghci:fmap;

    <para id="x_wR">The Prelude defines instances of
      <type>Functor</type> for several common types, notably lists and
      <type>Maybe</type>.</para>

    &TreeMap.hs:Functor.Maybe;

    <para id="x_xR">The instance for <type>Maybe</type> makes it particularly
      clear what an <function>fmap</function> implementation needs to
      do.  The implementation must have a sensible behaviour for each
      of a type's constructors.  If a value is wrapped in
      <code>Just</code>, for example, the <function>fmap</function>
      implementation calls the function on the unwrapped value, then
      rewraps it in <code>Just</code>.</para>

    <para id="x_yR">The definition of <type>Functor</type> imposes a few obvious
      restrictions on what we can do with <function>fmap</function>.
      For example, we can only make instances of
      <function>Functor</function> from types that have exactly one
      type parameter.</para>

    <para id="x_AS">We can't write an <function>fmap</function> implementation
      for <type>Either a b</type> or <type>(a, b)</type>, for example,
      because these have two type parameters. We also can't write
      one for <type>Bool</type> or <type>Int</type>, as they have no
      type parameters.</para>

    <para id="x_BS">In addition, we can't place any constraints on our type
      definition.  What does this mean?  To illustrate, let's first
      look at a normal &data; definition and its <code>Functor</code>
      instance.</para>

    &ValidFunctor.hs:Foo;

    <para id="x_CS">When we define a new type, we can add a type
      constraint just after the &data; keyword as follows.</para>

    &ValidFunctor.hs:Bar;

    <para id="x_DS">This says that we can only put a type <varname
	role="type">a</varname> into a <type>Foo</type> if <varname
	role="type">a</varname> is a member of the <code>Eq</code>
      typeclass.  However, the constraint renders it impossible to
      write a <code>Functor</code> instance for
      <type>Bar</type>.</para>

    &functor.ghci:invalid;

    <sect2>
      <title>Constraints on type definitions are bad</title>

      <para id="x_ES">Adding a constraint to a type definition is
	essentially never a good idea.  It has the effect of forcing
	you to add type constraints to <emphasis>every</emphasis>
	function that will operate on values of that type.  Let's say
	that we need a stack data structure that we want to be able to
	query to see whether its elements obey some ordering.  Here's
	a naive definition of the data type.</para>

      &TypeConstraint.hs:OrdStack;

      <para id="x_FS">If we want to write a function that checks the
	stack to see whether it is increasing (i.e. every element is
	bigger than the element below it), we'll obviously need an
	<code>Ord</code> constraint to perform the pairwise
	comparisons.</para>

      &TypeConstraint.hs:isIncreasing;

      <para id="x_GS">However, because we wrote the type constraint on the type
	definition, that constraint ends up infecting places where it
	isn't needed: we need to add the <code>Ord</code>
	constraint to <function>push</function>, which does not care
	about the ordering of elements on the stack.</para>

      &TypeConstraint.hs:push;

      <para id="x_HS">Try removing that <code>Ord</code> constraint above, and
	the definition of <function>push</function> will fail to
	typecheck.</para>

      <para id="x_IS">This is why our attempt to write a <code>Functor</code>
	instance for <type>Bar</type> failed earlier: it would have
	required an <code>Eq</code> constraint to somehow get
	retroactively added to the signature of
	<function>fmap</function>.</para>

      <para id="x_JS">Now that we've tentatively established that putting a type
	constraint on a type definition is a misfeature of Haskell,
	what's a more sensible alternative?  The answer is simply to
	omit type constraints from type definitions, and instead place
	them on the functions that need them.</para>

      <para id="x_KS">In this example, we can drop the <code>Ord</code>
	constraints from <code>OrdStack</code> and
	<function>push</function>.  It needs to stay on
	<function>isIncreasing</function>, which otherwise couldn't
	call <function>(&lt;)</function>.  We now have the
	constraints where they actually matter.  This has the further
	benefit of making the type signatures better document the true
	requirements of each function.</para>

      <para id="x_LS">Most Haskell container types follow this
	pattern.  The <type>Map</type> type in the
	<code>Data.Map</code> module requires that its keys be
	ordered, but the type itself does not have such a constraint.
	The constraint is expressed on functions like
	<function>insert</function>, where it's actually needed, and
	not on <function>size</function>, where ordering isn't
	used.</para>
    </sect2>

    <sect2 id="binary.fmap">
      <title>Infix use of fmap</title>

      <para id="x_MS">Quite often, you'll see <function>fmap</function> called
	as an operator.</para>

      &functor.ghci:operator;

      <para id="x_NS">Perhaps strangely, plain old <function>map</function> is
	almost never used in this way.</para>

      <para id="x_OS">One possible reason for the stickiness of the
	<function>fmap</function>-as-operator meme is that this use
	lets us omit parentheses from its second argument.  Fewer
	parentheses leads to reduced mental juggling while reading a
	function.</para>

      &functor.ghci:prefix;

      <para id="x_PS">If you really want to use
	<function>fmap</function> as an operator, the
	<code>Control.Applicative</code> module contains an operator
	<function>(&lt;$&gt;)</function> that is an alias for
	<function>fmap</function>.  The <code>$</code> in its name
	appeals to the similarity between applying a function to its
	arguments (using the <function>($)</function> operator) and
	lifting a function into a functor.  We will see that this
	works well for parsing when we return to the code that we have
	been writing.</para>
    </sect2>

    <sect2>
      <title>Flexible instances</title>

      <para id="x_QS">You might hope that we could write a <type>Functor</type>
	instance for the type <type>Either Int b</type>, which has one
	type parameter.</para>

      &EitherInt.hs:Functor;

      <para id="x_RS">However, the type system of Haskell 98 cannot guarantee
	that checking the constraints on such an instance will
	terminate.  A non-terminating constraint check may send a
	compiler into an infinite loop, so instances of this form are
	forbidden.</para>

      &functor.ghci:EitherInt;

      <para id="x_SS">&GHC; has a more powerful type system than the base
	Haskell 98 standard.  It operates in Haskell 98 compatibility
	mode by default, for maximal portability.  We can instruct it
	to allow more flexible instances using a special compiler
	directive.</para>

      &EitherIntFlexible.hs:Functor;

      <para id="x_TS">The directive is embedded in the specially formatted
	<code>LANGUAGE</code> pragma.</para>

      <para id="x_VS">With our <type>Functor</type> instance in hand, let's try
	out <function>fmap</function> on <type>Either
	  Int</type>.</para>

      &functor.ghci:EitherIntFlexible;

    </sect2>

    <sect2 id="binary.functor.laws">
      <title>Thinking more about functors</title>

      <para id="x_WS">We've made a few implicit assumptions about how functors
	ought to work.  It's helpful to make these explicit and to
	think of them as rules to follow, because this lets us treat
	functors as uniform, well-behaved objects.  We have only two
	rules to remember, and they're simple.</para>

      <para id="x_XS">Our first rule is that a functor must preserve
	<emphasis>identity</emphasis>.  That is, applying <code>fmap
	  id</code> to a value should give us back an identical
	value.</para>

      &functor.ghci:id;

      <para id="x_YS">Our second rule is that functors must be
	<emphasis>composable</emphasis>. That is, composing two uses
	of <function>fmap</function> should give the same result as
	one <function>fmap</function> with the same functions
	composed.</para>

      &functor.ghci:composition;

      <para id="x_ZS">Another way of looking at these two rules is that a
	functor must preserve <emphasis>shape</emphasis>.  The
	structure of a collection should not be affected by a functor;
	only the values that it contains should change.</para>

      &functor.ghci:shape;

      <para id="x_aS">If you're writing a <type>Functor</type> instance, it's
	useful to keep these rules in mind, and indeed to test them,
	because the compiler can't check the rules we've listed above.
	On the other hand, if you're simply <emphasis>using</emphasis>
	functors, the rules are <quote>natural</quote> enough that
	there's no need to memorise them.  They just formalize a few
	intuitive notions of <quote>do what I mean</quote>.  Here is a
	pseudocode representation of the expected behavior.</para>

      &FunctorLaws.hs:fmap;
    </sect2>
  </sect1>

  <sect1>
    <title>Writing a functor instance for Parse</title>

    <para id="x_bS">For the types we have surveyed so far, the behaviour we
      ought to expect of <function>fmap</function> has been obvious.
      This is a little less clear for <type>Parse</type>, due to its
      complexity.  A reasonable guess is that the function we're
      <function>fmap</function>ping should be applied to the current
      result of a parse, and leave the parse state untouched.</para>

    &Parse.hs:Functor;

    <para id="x_cS">This definition is easy to read, so let's
      perform a few quick experiments to see if we're following our
      rules for functors.</para>

    <para id="x_dS">First, we'll check that identity is preserved.  Let's try
      this first on a parse that ought to fail: parsing a byte
      from an empty string (remember that
      <function>(&lt;$&gt;)</function> is <function>fmap</function>).</para>

    &parse.ghci:id.fail;

    <para id="x_eS">Good.  Now for a parse that should succeed.</para>

      &parse.ghci:id.success;

    <para id="x_fS">By inspecting the results above, we can also see that our
      functor instance is obeying our second rule, that of preserving
      shape.  Failure is preserved as failure, and success as
      success.</para>
      
    <para id="x_gS">Finally, we'll ensure that composability is
      preserved.</para>

      &parse.ghci:compose;

    <para id="x_hS">On the basis of this brief inspection, our
      <type>Functor</type> instance appears to be well behaved.</para>
  </sect1>

  <sect1>
    <title>Using functors for parsing</title>

    <para id="x_iS">All this talk of functors had a purpose: they often
      let us write tidy, expressive code.  Recall the
      <function>parseByte</function> function that we introduced
      earlier.  In recasting our PGM parser to use our new parser
      infrastructure, we'll often want to work with ASCII characters
      instead of <type>Word8</type> values.</para>

    <para id="x_jS">While we could write a <function>parseChar</function>
      function that has a similar structure to
      <function>parseByte</function>, we can now avoid this code
      duplication by taking advantage of the functor nature of
      <type>Parse</type>.  Our functor takes the result of a parse and
      applies a function to it, so what we need is a function that
      turns a <type>Word8</type> into a <type>Char</type>.</para>
      
    &Parse.hs:parseChar;

    <para id="x_kS">We can also use functors to write a compact
      <quote>peek</quote> function.  This returns <code>Nothing</code>
      if we're at the end of the input string.  Otherwise, it returns
      the next character without consuming it (i.e. it inspects, but
      doesn't disturb, the current parsing state).</para>

    &Parse.hs:peekByte;

    <para id="x_lS">The same lifting trick that let us define
      <function>parseChar</function> lets us write a compact
      definition for <function>peekChar</function>.</para>

    &Parse.hs:peekChar;

    <para id="x_mS">Notice that <function>peekByte</function> and
      <function>peekChar</function> each make two calls to
      <function>fmap</function>, one of which is disguised as
      <function>(&lt;$&gt;)</function>. This is necessary because the
      type <type>Parse (Maybe a)</type> is a functor within a functor.
      We thus have to lift a function twice to <quote>get it
	into</quote> the inner functor.</para>

    <para id="x_nS">Finally, we'll write another generic combinator, which is
      the <type>Parse</type> analogue of the familiar
      <function>takeWhile</function>: it consumes its input while its
      predicate returns <function>True</function>.</para>

    &Parse.hs:parseWhile;

    <para id="x_oS">Once again, we're using functors in several places (doubled
      up, when necessary) to reduce the verbosity of our code.  Here's
      a rewrite of the same function in a more direct style that does
      not use functors.</para>

    &Parse.hs:parseWhileVerbose;

    <para id="x_pS">The more verbose definition is likely easier to read when
      you are less familiar with functors.  However, use of functors
      is sufficiently common in Haskell code that the more compact
      representation should become second nature (both to read and to
      write) fairly quickly.</para>
  </sect1>

  <sect1>
    <title>Rewriting our PGM parser</title>

    <para id="x_sS">With our new parsing code, what does the raw PGM parsing
      function look like now?</para>

    &Parse.hs:parseRawPGM;

    <para id="x_tS">This definition makes use of a few more helper functions
      that we present here, following a pattern that should by now be
      familiar.</para>

    &Parse.hs:helpers;

    <para id="x_uS">The <function>(==&gt;&amp;)</function> combinator chains
      parsers like <function>(==&gt;)</function>, but the right hand
      side ignores the result from the left.  The
      <function>assert</function> function lets us check a property,
      and abort parsing with a useful error message if the property is
      <code>False</code>.</para>

    <para id="x_vS">Notice how few of the functions that we have written make
      any reference to the current parsing state.  Most notably, where
      our old <function>parseP5</function> function explicitly passed
      two-tuples down the chain of dataflow, all of the state
      management in <function>parseRawPGM</function> is hidden from
      us.</para>

    <para id="x_wS">Of course, we can't completely avoid inspecting and
      modifying the parsing state.  Here's a case in point, the last
      of the helper functions needed by
      <function>parseRawPGM</function>.</para>

    &Parse.hs:parseBytes;

  </sect1>

  <sect1>
    <title>Future directions</title>

    <para id="x_yS">Our main theme in this chapter has been
      abstraction.  We found passing explicit state down a chain of
      functions to be unsatisfactory, so we abstracted this detail
      away.  We noticed some recurring needs as we worked out our
      parsing code, and abstracted those into common functions.  Along
      the way, we introduced the notion of a functor, which offers a
      generalised way to map over a parameterised type.</para>

    <para id="x_zS">We will revisit parsing in <xref
	linkend="parsec"/>, to discuss Parsec, a widely used and
      flexible parsing library.  And in <xref linkend="monads"/>, we
      will return to our theme of
      abstraction, where we will find that much of the code that we
      have developed in this chapter can be further simplified by the
      use of monads.</para>

    <para>For efficiently parsing binary data represented as a
      <type>ByteString</type>, a number of packages are available via
      the Hackage package database.  At the time of writing, the most
      popular is named <code>binary</code>, which is easy to use and
      offers high performance.</para>
  </sect1>

  <sect1>
    <title>Exercises</title>

    <qandaset defaultlabel="number">
      <qandaentry>
	<question>
	  <para id="x_AT">Write a parser for <quote>plain</quote> PGM
	    files.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_BT">In our description of <quote>raw</quote> PGM files, we
	    omitted a small detail.  If the <quote>maximum
	      grey</quote> value in the header is less than 256, each
	    pixel is represented by a single byte.  However, it can
	    range up to 65535, in which case each pixel will be
	    represented by two bytes, in big endian order (most
	    significant byte first).</para>

	  <para id="x_CT">Rewrite the raw PGM parser to accommodate both the
	    single- and double-byte pixel formats.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_DT">Extend your parser so that it can identify a raw or
	    plain PGM file, and parse the appropriate file
	    type.</para>
	</question>
      </qandaentry>
    </qandaset>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
