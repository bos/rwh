<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="binary" revision="alpha;beta">
  <title>Code case study: parsing a binary data format</title>

  <para id="x_sQ">In this chapter, we'll discuss a common task: parsing a binary
    file.  We're going to use this for two purposes.  Our first is to
    talk a little about parsing, but our main goal is to talk about
    program organisation and <quote>boilerplate
      removal</quote>.</para>

  <para id="x_tQ">As our task, we'll choose parsing a few different netpbm file
    types.  The netpbm suite is an ancient and venerable collection of
    programs and file formats for working with bitmap images.  These
    file formats have the dual advantages of wide use and being fairly
    easy, but not completely trivial, to parse.  Most importantly for
    our convenience, netpbm files are not compressed.</para>

  <sect1>
    <title>Greyscale files</title>

    <para id="x_uQ">The name of netpbm's greyscale file format is PGM
      (<quote>portable grey map</quote>).  It is actually not one
      format, but two; the <quote>plain</quote> (or <quote>P2</quote>)
      format is encoded as ASCII, while the more common
      <quote>raw</quote> (<quote>P5</quote>) format is mostly
      binary.</para>

    <para id="x_vQ">A file of either format starts with a header, which in turn
      begins with a <quote>magic</quote> string describing the format.
      For a plain file, the string is <literal>P5</literal>, and for
      raw, it's <literal>P2</literal>. The magic string is followed by
      white space, then by three numbers: the width, height, and
      maximum grey value of the image. These numbers are represented
      as ASCII decimal numbers, separated by white space.</para>

    <para id="x_wQ">After the maximum grey value comes the image data.  In a raw
      file, this is a string of binary values.  In a plain file, the
      values are represented as ASCII decimal numbers separated by
      white space.</para>

    <para id="x_xQ">A raw file can contain a sequence of images, one after the
      other, each with its own header.  A plain file contains only one
      image.</para>

  </sect1>

  <sect1>
    <title>Parsing a raw PGM file</title>

    <para id="x_yQ">For our first try at a parsing function, we'll only worry
      about raw PGM files. We'll write our PGM parser as a
      <emphasis>pure</emphasis> function. It's not responsible for
      obtaining the data to parse, just for the actual parsing.  This
      is a common approach in Haskell programs. By separating the
      reading of the data from what we subsequently do with it, we
      gain flexibility in where we take the data from.</para>

    <para id="x_zQ">We'll use the <type>ByteString</type> type to store our
      greymap data, because it's compact.</para>

    &PNM.hs:imports;

    <para id="x_AR">For our purposes, it doesn't matter whether we use a lazy or
      strict <type>ByteString</type>, so we've somewhat arbitrarily
      chosen the lazy kind.</para>

    <para id="x_BR">The <type>ByteString</type> module contains many definitions
      that have the same names as existing Prelude definitions that
      are automatically imported for us.  Because of this, if we try
      to use a name that is present in both the
      <type>ByteString</type> module and the Prelude, the compiler
      will complain about ambiguity.  We avoid this problem by
      importing the module under an alias, <code>L</code>: every time
      you see a name prefixed with <code>L.</code>, we're using the
      name from <type>ByteString</type>.</para>

    <para id="x_CR">We'll use a straightforward data type to represent PGM
      files.</para>

    &PNM.hs:Greymap;

    <para id="x_DR">Normally, a Haskell <type>Show</type> instance should
      produce a string representation that we can read back by calling
      <function>read</function>.  However, for a bitmap graphics file,
      this would potentially produce huge text strings, for example if
      we were to <function>show</function> a photo.  For this reason,
      we're not going to let the compiler automatically derive a
      <type>Show</type> instance for us: we'll write our own,
      intentionally less capable, implementation.</para>

    &PNM.hs:Show;

    <para id="x_ER">Because our <type>Show</type> instance intentionally avoids
      printing the bitmap data, there's no point in writing a
      <type>Read</type> instance, as we can't reconstruct a valid
      <type>Greymap</type> from the result of
      <function>show</function>.</para>

    <para id="x_FR">Here's an obvious type for our parsing function.</para>

    &PNM.hs:parseP5.type;

    <para id="x_GR">This will take a <type>ByteString</type>, and if the parse
      succeeds, it will return the parsed <type>Greymap</type>, along
      with the string that remains after parsing.</para>

    <para id="x_HR">Our parsing function has to consume a little bit of its
      input at a time.  First, we need to assure ourselves that we're
      really looking at a raw PGM file; then we need to parse the
      numbers from the remainder of the header; then we consume the
      bitmap data.  Here's an obvious, brutish way to express
      this.</para>

    &PNM.hs:parseP5;

    <para id="x_IR">Stylistically, this is a very <quote>direct</quote> piece of
      code, doing all of the parsing in one long staircase of &case;
      expressions.  Each function that it calls returns the residual
      <type>ByteString</type> left over after it has consumed all it
      needs from its input string.  This residual string can then be
      passed along to the next step.  It deconstructs each result in
      turn, either failing if the function failed, or building up a
      piece of the result as it continues. The bodies of the functions
      that it calls aren't especially interesting, but we'll include
      them for completeness.</para>

    &PNM.hs:parseP5.functions;

  </sect1>

  <sect1>
    <title>Getting rid of boilerplate code</title>

    <para id="x_JR">Our <function>parseP5</function>  function is somehow
      unsatisfying.  It marches steadily to the right of the screen,
      so it's clear that a slightly more complicated function would
      soon run out of visual real estate.  And it repeats a pattern of
      constructing and then deconstructing <type>Maybe</type> values,
      only continuing if a particular value matches
      <function>Just</function>.  All of the similar &case;
      expressions act as <quote>boilerplate code</quote>, busywork
      that obscures what we're really trying to do.  In short, this
      function is begging for some abstraction and refactoring.</para>

    <para id="x_KR">If we step back a little, we can see two patterns.  First is
      that the functions that we're calling have similar types.  Each
      takes a <type>ByteString</type> as its last argument, and
      returns <type>Maybe</type> something else.  Secondly, every step
      in the <quote>ladder</quote> of our <function>parseP5</function>
      function deconstructs a <type>Maybe</type> value, and either
      fails or passes the unwrapped result to a function.</para>

    <para id="x_LR">We can quite easily write a function that captures this
      second pattern.</para>

    &PNM.hs:bind;

    <para id="x_MR">The <function>(&gt;&gt;?)</function> function acts very
      simply: it takes a value as its left argument, and a function as
      its right. If the value is not <literal>Nothing</literal>, it
      calls the function.  We have written this function as an
      operator so that we can use it to chain functions
      together.</para>

    <para id="x_NR">With this chaining function in hand, we can take a second
      try at our parsing function.</para>

    &PNM.hs:parseP5_take2;

    <para id="x_OR">The key to understanding this function is to think about the
      chaining.  On the left hand side of each
      <function>(&gt;&gt;?)</function> is a <type>Maybe</type> value;
      on the right is a function that returns a <type>Maybe</type>
      value.  Each left-and-right-sides expression is thus of type
      <type>Maybe</type>, suitable for passing to the following
      <function>(&gt;&gt;?)</function> expression.</para>

    <para id="x_PR">The other change that we've made to improve readability is
      add a <function>skipSpace</function> function.  With these
      changes, we've halved the number of lines of code compared to
      our original parsing function.  By removing the boilerplate
      &case; expressions, we've made the code easier to follow.</para>

    <para id="x_QR">While we warned against overuse of anonymous functions in
      <xref linkend="fp.anonymous"/>, we use several in our chain
      of functions here.  Because these functions are so small, we
      wouldn't improve readability by giving them names.</para>

    <para id="x_RR">However, we're not yet out of the woods.  This code
      explicitly passes two-tuples around, using one element for an
      intermediate part of the parsed result and the other for the
      current residual <type>ByteString</type>.  If we want to extend
      the code, for example to track the number of bytes we've
      consumed so that we can report the location of a parse failure,
      we need to modify eight different locations so that we can pass
      a three-tuple around.</para>
  </sect1>

  <sect1 id="binary.implicit">
    <title>Implicit state</title>

    <para id="x_SR">While we've gotten rid of some boilerplate code, the
      two-tuple that we use to pass around our partial result and
      residual string is a serious problem: it makes our code
      difficult to change.</para>

    <para id="x_TR">We can do something about this, though.  First, let's
      augment the state that our parser uses.</para>

    &Parse.hs:ParseState;

    <para id="x_UR">We can now track both the current residual string and the
      offset into the original string since we started parsing.  This
      lets us think of parsing as a function from one
      <type>ParseState</type> to another, also returning the result of
      the parse.</para>

    &Parse.hs:Parse;

    <para id="x_VR">The &newtype; declaration for the <type>Parse</type> type
      just acts as a safety wrapper around this function type.  It
      allows us to ensure that we can't accidentally run a
      parser.</para>

    <para id="x_WR">The <type>Parse</type> type is encoding two concepts in one.
      The first is the possibility of failure, reported via an error
      message.  This we achieve using <type>Either</type> to represent
      two possible results of a parse.  The second is the update of
      the parser state and presentation of an intermediate result,
      represented by the type of <function>runParse</function>.  In
      other words, if a parse succeeds, it will generate both a result
      and a new parse state.</para>

    <para id="x_XR">Let's try to define a minimal parser.</para>

    &Parse.hs:identity;

    <para id="x_YR">All this function has to do is take a parse state, leave it
      untouched, and use the function's argument as the result of the
      parse.  We wrap this function in our <type>Parse</type> type,
      but how can we actually use this wrapped function to parse
      something?</para>

    <para id="x_ZR">The first thing we must do is peel off the
      <function>Parse</function> wrapper so that we can get at the
      function inside.  We do this by calling
      <function>runParse</function>.  We also need to construct a
      <type>ParseState</type>, then run our parsing function on that
      parse state.  Finally, we'd like to extract the result of the
      parse from the final <type>ParseState</type>.</para>

    &Parse.hs:parse;

    <para id="x_aR">Because neither the <function>identity</function> parser nor
      the <function>parse</function> function examine the parse state
      at all, we don't even need to bother creating an input string in
      order to try this out.</para>

    &parse.ghci:parse;

    <para id="x_bR">A parser that doesn't even inspect its input isn't very
      interesting, but at least we have confidence that our types are
      correct.  Let's focus now on writing a parser that does
      something meaningful.  We're not going to get very ambitious
      yet, though: all we want to do is parse a single byte.</para>

    &Parse.hs:parseByte;

    <para id="x_cR">There's some unfamiliar code in use here, so let's take a
      deeper look.  The <function>(==&gt;)</function> function serves
      a similar purpose to our earlier
      <function>(&gt;&gt;?)</function> function, acting as
      <quote>glue</quote> to let us chain functions together.</para>

    &Parse.hs:bind;

    <para id="x_dR">Indeed, the types of the two functions are very similar. The
      body of <function>(==&gt;)</function> is interesting, and ever
      so slightly tricky.  Remember that <type>Parse</type> is really
      a function type with a wrapper.  Therefore,
      <function>(==&gt;)</function> must return a function, in a
      wrapper.  It doesn't really <quote>do</quote> much: it just
      creates a <emphasis>closure</emphasis> to remember the values of
      <varname>x</varname> and <varname>f</varname>.  This closure
      won't be unwrapped and called until we call
      <function>parse</function>.  At that point, it will be called
      with a <type>ParseState</type>.  It will call the
      <type>Parse</type> that is its left argument and inspect its
      result.  If that parse failed, the closure fails too. Otherwise,
      it passes the result of the parse and the new
      <type>ParseState</type> to <varname>f</varname>.</para>

    <para id="x_eR">This is really quite fancy and subtle stuff: we're
      effectively passing the <type>ParseState</type> down the chain
      of <type>Parse</type> values in a hidden argument.  (We'll be
      revisiting this kind of code in a few chapters, so don't fret if
      that description seemed dense.)</para>

    <sect2>
      <title>Obtaining and modifying the parse state</title>

    <para id="x_fR">Our <function>parseByte</function> function doesn't take the
      parse state as an argument.  Instead, it has to call
      <function>getState</function> to get a copy of the state, and
      <function>putState</function> to replace the current state with
      a new one.</para>

    &Parse.hs:getPut;

    <para id="x_gR">When reading these functions, recall that the left element
      of the tuple is the result of a <type>Parse</type>, while the
      right is the current <type>ParseState</type>.  This makes it
      easier to follow what these functions are doing.</para>
    
    <para id="x_hR">The <function>getState</function> function extracts the
      current parsing state, so that the caller can access the string.
      The <function>putState</function> function replaces the current
      parsing state with a new one.  This becomes the state that will
      be seen by the next function in the
      <function>(==&gt;)</function> chain.</para>

    <para id="x_iR">these functions let us move explicit state handling into the
      bodies of only those functions that need it.  Many functions
      don't need to know what the current state is, and so they'll
      never call <function>getState</function> or
      <function>putState</function>.  This lets us write more compact
      code than our earlier parser, which had to pass tuples around by
      hand.</para>

    <para id="x_jR">Even better, because we've packaged up the details of the
      parsing state into the <type>ParseState</type> type, if we want
      to add more information to the parsing state, all we need to do
      is modify the definition of <type>ParseState</type>, and the
      bodies of whatever functions need the new information.  Compare
      this to our earlier parsing code, where we'd have had to turn
      every use of a two-tuple into a three-tuple, and the advantage
      should be clear.</para>

    </sect2>

    <sect2>
      <title>Reporting parse errors</title>

      <para id="x_kR">We carefully defined our <type>Parse</type> type to
	accommodate the possibility of failure.  The
	<function>(==&gt;)</function> combinator checks for a parse
	failure and stops parsing if it runs into a failure.  But we
	haven't yet introduced the <function>bail</function> function,
	which we use to report a parse error.</para>

      &Parse.hs:bail;

      <para id="x_lR">After we call <function>bail</function>,
	<function>(==&gt;)</function> will successfully pattern match
	on the <code>Left</code> constructor that it wraps the error
	message with, and it will not invoke the next parser in the
	chain.  This will cause the error message to percolate back
	through the chain of prior callers.</para>
    </sect2>
  </sect1>

  <sect1 id="binary.functor">
    <title>Introducing functors</title>

    <para id="x_mR">We're by now thoroughly familiar with the
      <function>map</function> function, which applies a function to
      every element of a list, returning a list of possibly a
      different type.</para>

    &functor.ghci:map;

    <para id="x_nR">This <function>map</function>-like activity can be useful in
      other instances.  For example, consider a binary tree.</para>

    &TreeMap.hs:Tree;

    <para id="x_oR">If we want to take a tree of strings and turn it into a tree
      containing the lengths of those strings, we could write a
      function to do this.</para>

    &TreeMap.hs:treeLengths;

    <para id="x_pR">Now that our eyes are attuned to looking for patterns that
      we can turn into generally useful functions, we can see a
      possible case of this here.</para>

    &TreeMap.hs:treeMap;

    <para id="x_qR">As we might hope, <function>treeLengths</function> and
      <function>treeMap length</function> give the same
      results.</para>

    &functor.ghci:treeLengths;

    <para id="x_rR">Haskell provides a well-known typeclass to further
      generalise <function>treeMap</function>.  This typeclass is
      named <type>Functor</type>, and it defines one function,
      <function>fmap</function>.</para>

    &TreeMap.hs:Functor;

    <para id="x_sR">We can think of <function>fmap</function> as a kind of
      <emphasis>lifting</emphasis> function, as we introduced in <xref
      linkend="find.predicate.lift"/>.  It takes a function over
      ordinary values <type>a -&gt; b</type> and lifts it to become a
      function over containers <type>f a -&gt; f b</type>, where
      <varname>f</varname> is the container type.</para>

    <para id="x_tR">If we substitute <type>Tree</type> for the type variable
      <varname>f</varname>, for example, the type of
      <function>fmap</function> is identical to the type of
      <function>treeMap</function>, and in fact we can use
      <function>treeMap</function> as the implementation of
      <function>fmap</function> over <type>Tree</type>s.</para>

    &TreeMap.hs:Functor.Tree;

    <para id="x_uR">We can also use <function>map</function> as the
      implementation of <function>fmap</function> for lists.</para>

    &TreeMap.hs:Functor.List;

    <para id="x_vR">We can now use <function>fmap</function> over different
      container types.</para>

    &functor.ghci:fmap;

    <para id="x_wR">The Prelude defines instances of <type>Functor</type> for
      several common types.  The instance for lists is provided in the
      Prelude, as is the instance for <type>Maybe</type>.</para>

    &TreeMap.hs:Functor.Maybe;

    <para id="x_xR">The instance for <type>Maybe</type> makes it particularly
      clear what an <function>fmap</function> implementation needs to
      do.  The implementation must have a sensible behaviour for each
      of a type's constructors.  If a value is wrapped in
      <code>Just</code>, for example, the <function>fmap</function>
      implementation calls the function on the unwrapped value, then
      rewraps it in <code>Just</code>.</para>

    <para id="x_yR">The definition of <type>Functor</type> imposes a few obvious
      restrictions on what we can do with <function>fmap</function>.
      For example, we can only make instances of
      <function>Functor</function> from types that have exactly one
      free type variable.</para>

    <note>
      <title>What's a free type variable?</title>

      <para id="x_zR">A free type variable is a lower-case type variable, such
	as <varname>a</varname>, that hasn't been bound to a
	particular type.  For example, the type <type>Maybe a</type>
	has one free type variable, but <type>Maybe Int</type> has
	none.  We say that the type variable <varname>a</varname> is
	<emphasis>bound to</emphasis> the type
	<type>Int</type>.</para>
    </note>

    <para id="x_AS">We can't write an <function>fmap</function> implementation
      for <type>Either a b</type> or <type>(a, b)</type>, for example,
      because these have two free type variables. We also can't write
      work with <type>Bool</type> or <type>Int</type>, as they have no
      free type variables.</para>

    <para id="x_BS">In addition, we can't place any constraints on our type
      definition.  What does this mean?  To illustrate, let's first
      look at a normal &data; definition and its <code>Functor</code>
      instance.</para>

    &ValidFunctor.hs:Foo;

    <para id="x_CS">When we define a new type, we can add a type constraint just
      after the &data; keyword as follows.</para>

    &ValidFunctor.hs:Bar;

    <para id="x_DS">This says that we can only put a type <varname
	role="type">a</varname> into a n<type>Foo</type> if <varname
	role="type">a</varname> is a member of the <code>Eq</code>
      typeclass.  However, the constraint renders it impossible to
      write a <code>Functor</code> instance for
      <type>Bar</type>.</para>

    &functor.ghci:invalid;

    <sect2>
      <title>Constraints on type definitions are bad</title>

      <para id="x_ES">Adding a  constraint to a type definition is never a good
	idea.  It has the effect of forcing you to add type
	constraints to <emphasis>every</emphasis> function that will
	operate on values of that type.  Let's say that we need a
	stack data structure that we want to be able to query to see
	whether its elements obey some ordering.  Here's a naive
	definition of the data type.</para>

      &TypeConstraint.hs:OrdStack;

      <para id="x_FS">If we want to write a function that checks the stack to
	see whether it is monotonic (i.e. either every element is
	bigger than the element below it, or every element is
	smaller), we'll obviously need an <code>Ord</code> constraint
	to perform the pairwise comparisons.</para>

      &TypeConstraint.hs:isMonotonic;

      <para id="x_GS">However, because we wrote the type constraint on the type
	definition, that constraint ends up infecting places where it
	isn't needed at all: we need to add the <code>Ord</code>
	constraint to <function>push</function>, which does not care
	at all about the ordering of elements on the stack.</para>

      &TypeConstraint.hs:push;

      <para id="x_HS">Try removing that <code>Ord</code> constraint above, and
	the definition of <function>push</function> will fail to
	typecheck.</para>

      <para id="x_IS">This is why our attempt to write a <code>Functor</code>
	instance for <type>Bar</type> failed earlier: it would have
	required an <code>Eq</code> constraint to somehow get
	retroactively added to the signature of
	<function>fmap</function>.</para>

      <para id="x_JS">Now that we've tentatively established that putting a type
	constraint on a type definition is a misfeature of Haskell,
	what's a more sensible alternative?  The answer is simply to
	omit type constraints from type definitions, and instead place
	them on the functions that need them.</para>

      <para id="x_KS">In this example, we can drop the <code>Ord</code>
	constraints from <code>OrdStack</code> and
	<function>push</function>.  It needs to stay on
	<function>isMonotonic</function>, which otherwise couldn't
	call <function>compare</function>.  We now have the
	constraints where they actually matter.  This has the further
	benefit of making the type signatures better document the real
	requirements of each function.</para>

      <para id="x_LS">Most Haskell container types follow this pattern.  The
	<type>Map</type> type in the <code>Data.Map</code> module
	requires that its keys be ordered, but this constraint is
	expressed on functions like <function>insert</function>, where
	it's actually needed, and not on <function>size</function>,
	where ordering isn't used.</para>
    </sect2>

    <sect2 id="binary.fmap">
      <title>Functors as operators</title>

      <para id="x_MS">Quite often, you'll see <function>fmap</function> called
	as an operator.</para>

      &functor.ghci:operator;

      <para id="x_NS">Perhaps strangely, plain old <function>map</function> is
	almost never used in this way.</para>

      <para id="x_OS">One possible reason for the stickiness of the
	<function>fmap</function>-as-operator meme is that this use
	lets us omit parentheses from its second argument.  Fewer
	parentheses leads to reduced mental juggling while reading a
	function.</para>

      &functor.ghci:prefix;

      <para id="x_PS">If you really want to use <function>fmap</function> as an
	operator, the <code>Control.Applicative</code> module contains
	an operator <function>(&lt;$&gt;)</function> that is an alias
	for <function>fmap</function>.  The <code>$</code> in its name
	appeals to the similarity between applying a function to its
	arguments (using the <function>($)</function> operator) and
	lifting a function into a functor.</para>
    </sect2>

    <sect2>
      <title>Flexible instances</title>

      <para id="x_QS">You might hope that we could write a <type>Functor</type>
	instance for the type <type>Either Int b</type>, which has one
	free type variable.</para>

      &EitherInt.hs:Functor;

      <para id="x_RS">However, the type system of Haskell 98 cannot guarantee
	that checking the constraints on such an instance will
	terminate.  A non-terminating constraint check will send a
	compiler into an infinite loop, so instances of this form are
	forbidden.</para>

      &functor.ghci:EitherInt;

      <para id="x_SS">&GHC; has a more powerful type system than the base
	Haskell 98 standard.  It operates in Haskell 98 compatibility
	mode by default, for maximal portability.  We can instruct it
	to allow more flexible instances using a special compiler
	directive.</para>

      &EitherIntFlexible.hs:Functor;

      <para id="x_TS">The directive is embedded in the specially formatted
	<code>LANGUAGE</code> comment.  These directives are usually
	referred to as <quote>pragmas</quote>.  Pragmas are always
	enclosed in the special comment sequences <code>{-#</code>, to
	begin, and <code>#-}</code>, to end.</para>

      <para id="x_US">&GHC; supports many kinds of pragma.  Most pragmas only
	have meaning at specific locations in a source file.  Language
	pragmas, for example, are only obeyed if they are present at
	the beginning of a source file.</para>

      <para id="x_VS">With our <type>Functor</type> instance in hand, let's try
	out <function>fmap</function> on <type>Either
	  Int</type>.</para>

      &functor.ghci:EitherIntFlexible;

    </sect2>

    <sect2 id="binary.functor.laws">
      <title>Thinking more about functors</title>

      <para id="x_WS">We've made a few implicit assumptions about how functors
	ought to work.  It's helpful to make these explicit and to
	think of them as rules to follow, because this lets us treat
	functors as uniform, well-behaved objects.  We have only two
	rules to remember, and they're simple.</para>

      <para id="x_XS">Our first rule is that a functor must preserve
	<emphasis>identity</emphasis>.  That is, applying <code>fmap
	  id</code> to a value should give us back an identical
	value.</para>

      &functor.ghci:id;

      <para id="x_YS">Our second rule is that functors must be
	<emphasis>composable</emphasis>. That is, composing two uses
	of <function>fmap</function> should give the same result as
	one <function>fmap</function> with the same functions
	composed.</para>

      &functor.ghci:composition;

      <para id="x_ZS">Another way of looking at these two rules is that a
	functor must preserve <emphasis>shape</emphasis>.  The
	structure of a collection should not be affected by a functor;
	only the values that it contains should change.</para>

      &functor.ghci:shape;

      <para id="x_aS">If you're writing a <type>Functor</type> instance, it's
	useful to keep these rules in mind, and indeed to test them,
	because the compiler can't check the rules we've listed above.
	On the other hand, if you're simply <emphasis>using</emphasis>
	functors, the rules are <quote>natural</quote> enough that
	there's no need to memorise them.  They just formalise a few
	intuitive notions of <quote>do what I mean</quote>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Writing a functor instance for Parse</title>

    <para id="x_bS">For the types we have surveyed so far, the behaviour we
      ought to expect of <function>fmap</function> has been obvious.
      This is a little less clear for <type>Parse</type>, due to its
      complexity.  A reasonable guess is that the function we're
      <function>fmap</function>ping should be applied to the current
      result of a parse, and leave the parse state untouched.</para>

      &Parse.hs:Functor;

    <para id="x_cS">Since this definition isn't especially easy to read, let's
      perform a few quick experiments to see if we're following our
      rules for functors.</para>

    <para id="x_dS">First, we'll check that identity is preserved.  Let's try
      this first on a parse that should fail: trying to parse a byte
      from an empty string.</para>

      &parse.ghci:id.fail;

    <para id="x_eS">Good.  Now for a parse that should succeed.</para>

      &parse.ghci:id.success;

    <para id="x_fS">By inspecting the results above, we can also see that our
      functor instance is obeying our second rule, that of preserving
      shape.  Failure is preserved as failure, and success as
      success.</para>
      
    <para id="x_gS">Finally, we'll ensure that composability is
      preserved.</para>

      &parse.ghci:compose;

    <para id="x_hS">On the basis of this brief inspection, our
      <type>Functor</type> instance appears to be well behaved.</para>
  </sect1>

  <sect1>
    <title>Using functors for parsing</title>

    <para id="x_iS">All of this talk about functors had a purpose: they often
      let us write tidy, expressive code.  Recall the
      <function>parseByte</function> function that we introduced
      earlier.  In recasting our PGM parser to use our new parser
      infrastructure, we'll often want to work with ASCII characters
      instead of <type>Word8</type> values.</para>

    <para id="x_jS">While we could write a <function>parseChar</function>
      function that has a similar structure to
      <function>parseByte</function>, we can now avoid this code
      duplication by taking advantage of the functor nature of
      <type>Parse</type>.  Our functor takes the result of a parse and
      applies a function to it, so what we need is a function that
      turns a <type>Word8</type> into a <type>Char</type>.</para>
      
    &Parse.hs:parseChar;

    <para id="x_kS">We can also use functors to write a compact
      <quote>peek</quote> function.  This returns <code>Nothing</code>
      if we're at the end of the input string.  Otherwise, it returns
      the next character without consuming it (i.e. it inspects, but
      doesn't disturb, the current parsing state).</para>

    &Parse.hs:peekByte;

    <para id="x_lS">The same lifting trick that let us define
      <function>parseChar</function> lets us write a compact
      definition for <function>peekChar</function>.</para>

    &Parse.hs:peekChar;

    <para id="x_mS">Notice that <function>peekByte</function> and
      <function>peekChar</function> each make two calls to
      <function>fmap</function>, one of which is disguised as
      <function>(&lt;$&gt;)</function>. This is necessary because the
      type <type>Parse (Maybe a)</type> is a functor within a functor.
      We thus have to lift a function twice to <quote>get it
	into</quote> the inner function.</para>

    <para id="x_nS">Finally, we'll write another generic combinator, which is
      the <type>Parse</type> analogue of the familiar
      <function>takeWhile</function>: it consumes its input while its
      predicate returns <function>True</function>.</para>

    &Parse.hs:parseWhile;

    <para id="x_oS">Once again, we're using functors in several places (doubled
      up, when necessary) to reduce the verbosity of our code.  Here's
      a rewrite of the same function in a more direct style that does
      not use functors.</para>

    &Parse.hs:parseWhileVerbose;

    <para id="x_pS">The more verbose definition is likely easier to read when
      you are less familiar with functors.  However, use of functors
      is sufficiently common in Haskell code that the more compact
      representation should become second nature (both to read and to
      write) fairly quickly.</para>

    <tip>
      <title>Hanging lambdas</title>

      <para id="x_qS">The definitions of both parsing functions above have a
	visual style to them that we haven't discussed before.  Each
	contains anonymous functions in which the parameters and
	<code>&rarrow;</code> sit at the end of a line, with the
	function's body following on the next line.</para>

      <para id="x_rS">This style of laying out an anonymous function doesn't
	have an official name, so let's call it a <quote>hanging
	  lambda</quote>.  Its main use is to make room for more text
	in the body of the function.  It also makes it a little
	visually clearer that there's a relationship between one
	function and the one that follows.  Most often, either the
	first function is taking the second function as a parameter,
	or its result is being passed as a parameter to the
	second.</para>
    </tip>
  </sect1>

  <sect1>
    <title>Rewriting our PGM parser</title>

    <para id="x_sS">With our new parsing code, what does the raw PGM parsing
      function look like now?</para>

    &Parse.hs:parseRawPGM;

    <para id="x_tS">This definition makes use of a few more helper functions
      that we present here, following a pattern that should by now be
      familiar.</para>

    &Parse.hs:helpers;

    <para id="x_uS">The <function>(==&gt;&amp;)</function> combinator chains
      parsers like <function>(==&gt;)</function>, but the right hand
      side ignores the result from the left.  The
      <function>assert</function> function lets us check a property,
      and abort parsing with a useful error message if the property is
      <code>False</code>.</para>

    <para id="x_vS">Notice how few of the functions that we have written make
      any reference to the current parsing state.  Most notably, where
      our old <function>parseP5</function> function explicitly passed
      two-tuples down the chain of dataflow, all of the state
      management in <function>parseRawPGM</function> is hidden from
      us.</para>

    <para id="x_wS">Of course, we can't completely avoid inspecting and
      modifying the parsing state.  Here's a case in point, the last
      of the helper functions needed by
      <function>parseRawPGM</function>.</para>

    &Parse.hs:parseBytes;

  </sect1>

  <sect1>
    <title>Conclusions</title>

    <para id="x_xS">In this chapter, we started with a naive file parser, and
      successively refined it into code that is at once less brittle
      and more general.  Although our initial task was parsing
      graphics files, the combinator-based library that we developed
      along the way is not tied to graphics.</para>

    <para id="x_yS">Our main theme in this chapter has been abstraction.  We
      found passing explicit state down a chain of functions to be
      unsatisfactory, so we abstracted this detail away.  We noticed
      some recurring needs as we worked out our parsing code, and
      abstracted those into common functions.  Along the way, we
      introduced the notion of a functor as offering a generalised way
      to map over a container type.</para>

    <para id="x_zS">We will revisit parsing in <xref linkend="parsec"/>, to
      discuss Parsec, a widely used and flexible parsing library.  And
      in <xref linkend="monads"/>, we will return to our theme of
      abstraction.</para>
  </sect1>

  <sect1>
    <title>Exercises</title>

    <qandaset defaultlabel="number">
      <qandaentry>
	<question>
	  <para id="x_AT">Write a parser for <quote>plain</quote> PGM
	    files.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_BT">In our description of <quote>raw</quote> PGM files, we
	    omitted a small detail.  If the <quote>maximum
	      grey</quote> value in the header is less than 256, each
	    pixel is represented by a single byte.  However, it can
	    range up to 65535, in which case each pixel will be
	    represented by two bytes, in big endian order (most
	    significant byte first).</para>

	  <para id="x_CT">Rewrite the raw PGM parser to accommodate both the
	    single- and double-byte pixel formats.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_DT">Extend your parser so that it can identify a raw or
	    plain PGM file, and parse the appropriate file
	    type.</para>
	</question>
      </qandaentry>
    </qandaset>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
