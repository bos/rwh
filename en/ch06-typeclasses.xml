<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.typeclasses" revision="alpha">
  <title>Using Typeclasses</title>

  <para id="x_iA">
    Typeclasses are one of the most powerful features in Haskell.  They
    are also at the heart of some basic language features such as equality
    testing and numeric operators.  Before we talk about what exactly
    typeclasses are, though, we'd like to first explain the need for them.
  </para>

  <sect1 id="hs.typeclasses.need">
    <title>The need for typeclasses</title>
    <para id="x_jA">
      Let's imaging that for some unfathomable reason, the designers of the
      Haskell language neglected to implement the equality test
      <function>==</function>.  Once you got over your shock at hearing this, 
      you resolved to implement your own equality tests.  Your application
      consisted of a simple <type>Color</type> type, and so your first
      equality test is for this type.  Your first attempt might look like
      this:
    </para>
    <example id="hs.typeclasses.ex.naiveeq">
      <title>Naive Equality -- Colors (naiveeq.hs)</title>
      &naiveeq.hs:color;
    </example>
    <para id="x_kA">
      You can test this with &ghci; or
      <application>hugs</application>:
    </para>
    <screen>
*Main&gt; <userinput>colorEq Red Red</userinput>
True
*Main&gt; <userinput>colorEq Red Blue</userinput>
False
</screen>
    <para id="x_lA">
      Now, let's say that you want to add an equality test for
      &String;s.
      Since a Haskell &String; is a list of characters, we can
      write a simple function to perform that test.
        For simplicity, we
      cheat a bit and use the <function>==</function> operator a couple
      of times.
    </para>
    &naiveeq.hs:string;
    <para id="x_mA">
      You should now be able to see a problem: we have to define a new
      function for every different type that we want to be able to compare.
      That's inefficient and annoying.  It's much more convenient to be able
      to just use <function>==</function> to compare anything.  As it turns
      out, this is exactly what Haskell's typeclasses are for.  
    </para>
  </sect1>
  <sect1 id="hs.typeclasses.whatarethey">
    <title>What are typeclasses?</title>
    <para id="x_nA">
      Typeclasses define a set of functions that can operate on more than one
      type of data.  A typeclass defines an interface, and perhaps even
      default implementations of functions.  You then create an instance for
      each type that should conform to the typeclass.  Once that is done, a
      function that's part of the typeclass definition can be called with any
      type that's an instance of the typeclass as a parameter.
    </para>
    <para id="x_oA">
      Those familiar with object-oriented programming can think of
      typeclasses as objects in reverse.  In OOP, when you define an object,
      you define what its parent classes are at that time.  You must also
      define how it implements the methods in the parent class, if you need a
      custom implementation.
    </para>
    <para id="x_pA">
      With typeclasses, you have greater freedom.  Let's say that you have a
      type from a third party.  Perhaps that third party didn't make it part
      of a typeclass that you'd like it to be part of.  No problem; you can
      define an instance yourself.  With OOP, the best you can do is subclass
      an object and use multiple inheritance (or, in Java, interfaces) to
      make the child object behave as you like.  But you're still stuck if
      you have a parent object from somewhere.
    </para>
    <para id="x_qA">
      In case that wasn't all clear, let's consider an example.  Imagine you have a
      basket of fruit.  There are things that you might want to do 
      with just about all
      fruit: eat it, peel it, or maybe remove the seeds.  If you were to
      model these actions in a Haskell library, you'd set up a <literal>Fruit</literal>
      typeclass.  You might define functions such as <literal>eat</literal>,
      <literal>peel</literal>, and <literal>removeSeeds</literal> in that
      typeclass.
    </para>
    <para id="x_rA">
      Now, your <literal>Apple</literal> type could be an instance of
      <literal>Fruit</literal>, implementing the three functions.  It could
      describe removing the core of the apple to get rid of the seeds.  You
      might also define a <literal>Peach</literal> instance that describes
      removing the one big seed at the center.  Now, you can release Fruit
      v1.0.  Yum!
    </para>
    <para id="x_sA">
      Now, some of your friends download your library.  They think that
      apples and peaches are fine, but maybe they'd also like to be able to
      eat oranges.  No problem; they define an <literal>Orange</literal> type
      and make it an instance of <literal>Fruit</literal>.  It's not
      necessary to modify your code to do this; anything that can operate on
      a <literal>Fruit</literal> can now automatically operate an an
      <literal>Orange</literal> as well.  Thanks to typeclasses, you'll have
      the best fruit salad out there.
    </para>
  </sect1>


  <sect1 id="hs.typeclasses.defining">
    <title>Defining new typeclasses</title>
    <para id="x_tA">
      Let's use typeclasses to solve our equality dilemma from earlier in the
      chapter.  The first thing that we need to do is define the typeclass
      itself.  What we want is a function that takes two parameters, both the
      same type, and returns a <type>Bool</type> indicating whether or not
      they are equal.  Here's our first definition of a typeclass:
    </para>
    &eqclasses.hs:basiceq;
    <para id="x_uA">
      This says that we are declaring a typeclass named
      <varname>BasicEq</varname>, and we'll refer to instance types with the
      letter <parameter id="x_vA">a</parameter>.  This typeclass defines one function.
      That function takes two parameters&emdash;both corresponding to instance
      types&emdash;and returns a <type>Bool</type>.
    </para>
    <para id="x_wA">
      On the first line, the name of the parameter <parameter id="x_xA">a</parameter>
      was chosen arbitrarily.  We could have used any name.  The key is that,
      when you list the types of your functions, you must use that name to
      refer to instance types.
    </para>
    <para id="x_yA">
      Let's look at this in &ghci;.  <remark>FIXME:
        insert reference to where this is defined</remark>
      Recall that you
      can type <command>:t</command> in &ghci; to 
      have it show you the type of something.  Let's see what it says about
      <function>isEqual</function>:
    </para>
    <screen>
*Main&gt; <userinput>:t isEqual</userinput>
isEqual :: (BasicEq a) => a -> a -> Bool
    </screen>
    <para id="x_zA">
      You can read that this way: "For all types of <type>a</type>, so
      long as <type>a</type> is an instance of
      <varname>BasicEq</varname>, <function>isEqual</function> takes two
      parameters of type <type>a</type> and returns a <type>Bool</type>".
    </para>
    <para id="x_AB">
      Now that we've seen a very simple typeclass, let's expand it a bit.  
      A not-equal-to function might be useful.
      Here's what we might say to define a typeclass with two functions:
    </para>
    &eqclasses.hs:basiceq2;
    <para id="x_BB">
      Someone providing an instance of <varname>BasicEq2</varname> will
      be required to define two functions: <function>isEqual2</function> and
      <function>isNotEqual2</function>.
    </para>
    <para id="x_CB">
      While our definition of <varname>BasicEq2</varname> is fine, it seems
      that we're making extra work for ourselves.  Logically speaking, if we
      know what <function>isEqual</function> or
      <function>isNotEqual</function> would return, we know how to figure out
      what the other function would return, for all types.  Rather than
      making users of the typeclass define both functions for all types, we
      can provide default implementations for them.  Then, users will only
      have to implement one function.
      <footnote>
        <para id="x_DB">
          We provided a default implementation of both functions, which gives
          implementers of instances choice: they can pick which one they
          implement.  We could have provided a default for only one function,
          which would have forced users to implement the other every time.
        </para>
      </footnote>
      Here's an example that shows how to do
      this.
    </para>
    &eqclasses.hs:basiceq3;
    <para id="x_EB">
      People implementing this class must provide an implementation of at
      least one function.  They can implement both if they wish, but they
      will not be required to.
    </para>
    <para id="x_FB">
      With <varname>BasicEq3</varname>, we have provided a class that does
      very much the same thing as Haskell's built-in <function>==</function>
      and <function>/=</function> operators.  In fact, these operators are
      defined by a typeclass that looks almost identical to
      <varname>BasicEq3</varname>.  The Haskell 98 Report <remark>FIXME: add
        reference? --jg</remark> defines a typeclass that implements equality
      comparison.  See the below example for the built-in
        <varname>Eq</varname> typeclass, and note how similar it is to our
        <varname>BasicEq3</varname> typeclass.
    </para>
    <remark>FIXME: How to cite sources on this? -- jg</remark>
    <example id="hs.typeclasses.ex.eq">
      <title>Haskell Standard Eq Typeclass</title>
      <programlisting>
class  Eq a  where
    (==), (/=) :: a -> a -> Bool

       &emdash;Minimal complete definition:
       &emdash;     (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)
     </programlisting>

  </sect1>

  <sect1 id="hs.typeclasses.instances">
    <title>Declaring typeclass instances</title>
    <para id="x_GB">
      Now that you know how to define typeclasses, it's time to learn how to
      define instances of typeclasses.  An instance is just a type.  Making
      it an instance of a particular typeclass means implementing the
      functions necessary for that typeclass.
    </para>
    <para id="x_HB">
      Recall our attempt to create a test for equality over a
      <literal>Color</literal> type back in <xref
      linkend="hs.typeclasses.ex.naiveeq"/>.
      Now let's see how we could make that same <literal>Color</literal>
      type a member of the <literal>BasicEq3</literal> class.
    </para>
    &eqclasses.hs:basiceq3inst;
    <para id="x_IB">
      Notice that we provide essentially the same function as we used
      back in <xref linkend="hs.typeclasses.ex.naiveeq"/>.  In fact, the
      implementation is identical.  However, in this case, we can use
      <literal>isEqual3</literal> on <emphasis>any</emphasis> type that
      we declare is an instance of <literal>BasicEq3</literal>, not just
      this one color type.  We could define equality tests for any anything
      from numbers to graphics using the same basic pattern.  In fact, as you
      will see in <xref linkend="hs.typeclasses.wellknown.equality"/>, this
      works the same as making Haskell's <literal>==</literal> operator
      work for your own custom types.
    </para>
    <para id="x_JB">
      Note also that the <literal>BasicEq3</literal> class defined both
      <literal>isEqual3</literal> and <literal>isNotEqual3</literal>, but we
      defined only one of them.  That's because of the default implementation
      contained in <literal>BasicEq3</literal>.  Since we didn't explicitly
      define <literal>isNotEqual3</literal>, the compiler automatically uses
      the default implementation given in the <literal>BasicEq3</literal>
      declaration.
    </para>

  </sect1>

  <sect1 id="hs.typeclasses.wellknown">
    <title>Well-known typeclasses</title>

    <para id="x_KB">
      Now that you're familiar with defining your own typeclasses and making
      your types instances of typeclasses, it's time to introduce you to
      typeclasses that are a standard part of Haskell.  As we mentioned at
      the beginning of this chapter, typeclasses are at the core of some
      important aspects of the language.  We'll cover the most common ones
      here.
    </para>

    <sect2 id="hs.typeclasses.wellknown.show">
      <title>Show</title>
      <para id="x_LB">
        The <literal>Show</literal> typeclass is used to convert types to
        &String;s.  It is perhaps most commonly used to
        convert numbers to &String;s, but it is defined for
        so many types that it can be used to convert quite a bit more.  You
        can also, of course, define instances for your own types as well.
      </para>
      <para id="x_MB">
        The most important function of <literal>Show</literal> is
        <literal>show</literal>.  It takes one argument: the type to convert.
        It returns a &String; representing that type.
        &ghci; reports that this way:
      </para>

      &show.ghci:showtype;

      <para id="x_NB">
        Let's look at some examples of converting numbers to strings:
      </para>
      &show.ghci:showex;
      <para id="x_OB">
        Remember that &ghci; displays results as they would
        be entered into Haskell.  So the expression <literal>show 1</literal>
        returns a single-character string containing the digit
        <literal>1</literal>.  That is, the quotes are not part of the string
        itself.  We can make that clear by using
        <literal>printStrLn</literal>:
      </para>
      &show.ghci:printshowex;
      <para id="x_PB">
        You can also use <literal>show</literal> on
        &String;s:
      </para>
      &show.ghci:showstr;
      <para id="x_QB">
        Running <literal>show</literal> on &String;s can be
        confusing.  Since <literal>show</literal> generates a result that
        is suitable for a Haskell literal, <literal>show</literal> adds
        quotes and escaping suitable for inclusion in a Haskell program.
        &ghci; also uses <literal>show</literal> to
        display results, so quotes and escaping get added twice.  Using
        <literal>putStrLn</literal> can help make this difference clear.
      </para>

      <para id="x_RB">
        You can define a <literal>Show</literal> instance for your own types
        easily.  Here's an example:
      </para>

      &eqclasses.hs:show;

      <para id="x_SB">
        This example defines an instance of <literal>Show</literal> for our
        type 
        <literal>Color</literal> (see <xref
          linkend="hs.typeclasses.ex.naiveeq"/>).  The implementation is
        simple: we define a function <literal>show</literal> and that's all
        that's needed.
      </para>

    </sect2>

    <sect2 id="hs.typeclasses.wellknown.read">
      <title>Read</title>
      <para id="x_TB">
        The &Read; typeclass is essentially the opposite of &Show;: it will
        take a &String;, parse it, and return data in a native Haskell type.
        The most useful function in &Read; is &read;.
        You can ask &ghci; for its type like this:
      </para>

      &read.ghci:readtype;

      <para id="x_UB">
        Here's an example illustrating the use of &read; and &show;:
      </para>

      &read.hs:read;

      <remark>FIXME: have we already explained main?</remark>

      <para id="x_VB">
        This is a simple example of &read; and &show; together.  Notice that
        we gave an explicit typecast to &Integer; when processing the &read;.
        That's because &read; returns a value of type
        <literal>Read a => a</literal> and &show; expects a value of type
        <literal>Show a => a</literal>.  There are many, many types that are
        defined for both &Read; and &Show;.  Without knowing a specific type,
        the compiler can't possibly guess from these many types which one is
        needed&emdash;at least not in this case.  Therefore, we give an explicit
        cast.
      </para>
      <para id="x_WB">
        You can see the same effect at work if you try to use &read; on the
        &ghci; command line.  &ghci; internally uses &show; to display
        results, meaning that you can hit this ambiguous typing problem there
        as well.  You'll need to explicitly cast your &read; results in
        &ghci; as shown here:
      </para>
      &read.ghci:readerrors;
      <para id="x_XB">
        Recall the type of &read;:
        <literal>(Read a) => String -&gt; a</literal>.  The
        <literal>a</literal> here is the type of each instance of &Read;.
        Which particular parsing function is called depends upon the type
        that is expected from the return value of &read;.  Let's see how that
        works:
      </para>
      &read.ghci:readtypes;
      <para id="x_YB">
        Notice the error when trying to parse <literal>5.0</literal> as an
        Integer.  The interpreter selected a different parser there because the
        return value of &read; was expected to be of a different type.
      </para>
      <para id="x_ZB">
        The &Read; class provides for some fairly complicated parsers.  Most
        people, however, choose to use Parsec for complicated parsers these
        days.  <remark>FIXME: insert xref to parsec</remark>  You can 
        define a simple parser by providing an implementation for the
        <literal>readsPrec</literal> function.  Your implementation can
        return a list containing exactly one tuple on a successful parse, or
        an empty list on an unsuccessful parse.  Here's an example
        implementation:
      </para>
      &eqclasses.hs:read;
      <para id="x_aB">
        This example handles the known cases for the three colors.  It
        returns an empty list (resulting in a "no parse" message) for others.
        The function is supposed to return the part of the input that was not
        parsed, so that the system can integrate the parsing of different
        types together.  Here's an example of using this new instance of
        &Read;:
      </para>
      &read.ghci:readcolor;
      <para id="x_bB">
        Notice the error on the final attempt.  That's because our parser is
        not smart enough to handle leading spaces yet.  If we modified it to
        accept leading spaces, that attempt would work.
      </para>
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.serialization">
      <title>Serialization with Read and Show</title>
      <para id="x_cB">
        Often times, you may have a data structure in memory that you need to
        store on disk for later retrieval or send across the network.  The
        process of converting data in memory to a flat series of bits for
        storage is called <emphasis>serialization</emphasis>.
      </para>
      <para id="x_dB">
        It turns out that &read; and &show; make excellent tools for
        serialization.  &show; produces output that is both human-readable and
        machine-readable.  It also mostly matches Haskell syntax.
      </para>
      <para id="x_eB">
        Let's try it out in &ghci;:
      </para>
      &serialization.ghci:ex1;
      <para id="x_fB">
        First, we assign <literal>d1</literal> to be a list.  Next, we print
        out the result of <literal>show d1</literal> so we can see what it
        generates.  Then, we write the result of <literal>show d1</literal>
        to a file named <literal>/tmp/test</literal>.
      </para>
      <para id="x_gB">
        Let's try reading it back.
      </para>
      &serialization.ghci:ex2;
      <para id="x_hB">
        First, we ask Haskell to read the file back.<footnote><para id="x_iB">As you will see
          in <remark>FIXME: insert ref</remark>, Haskell doesn't actually
          read the entire file at this point.  But for the purposes of this
          example, we can ignore that distinction.</para></footnote>  Then,
        we try to assign the result of <literal>read input</literal> to
        <literal>d2</literal>.  That generates an error.  The reason is that
        the interpreter doesn't know what type <literal>d2</literal> is meant
        to be, so it doesn't know how to parse the input.  If we give it an
        explicit type, it works, and we can verify that the two sets of data
        are equal.
      </para>
      <para id="x_jB">
        Since so many different types are instances of &Read; and &Show; by
        default (and others can be made instances easily; see <xref
          linkend="hs.typeclasses.auto.derivation"/>), you can use it for
        some really complex data structures.  Here are a few examples of
        slightly more complex data structures:
      </para>
      &serialization.ghci:ex3;
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.numeric">
      <title>Numeric Types</title>
      <remark>FIXME: some of these tables don't render well under sgml2x.
      Will need to verify that they look good under the O'Reilly
      renderer.</remark>
      <para id="x_kB">
        Haskell has a powerful set of numeric types.  You can using everything
        from fast 32-bit or 64-bit integers to arbitrary-precision rational
        numbers.  Yet you probably know that operators such as
        <literal>+</literal> can work with just about all of these.  This
        feature is implemented using typeclasses.  As a side benefit, it
        allows you to define your own numeric types and make them first-class
        citizens in Haskell.
      </para>
      <para id="x_lB">
        Let's begin our discussion of the typeclasses surrounding numeric
        types with an examination of the types themselves.  <xref
          linkend="hs.numerictypes.summary"/> describes the most
        commonly-used numeric types in Haskell.  Note that there are also
        many more numeric types available for specific purposes such as
        interfacing to C.
      </para>
      <table id="hs.numerictypes.summary" tocentry="1">
        <title>Selected Numeric Types</title>
        <tgroup cols='2' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;</entry>
              <entry>Double-precision floating point</entry>
            </row>
            <row>
              <entry>&Float;</entry>
              <entry>Single-precision floating point</entry>
            </row>
            <row>
              <entry>&Int;</entry>
              <entry>Fixed-precision signed integer; minimum range [-2^29..2^29-1]</entry>
            </row>
            <row>
              <entry>&Int16;</entry>
              <entry>16-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int32;</entry>
              <entry>32-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int64;</entry>
              <entry>64-bit signed integer</entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry>Arbitrary-precision signed integer; range limited only by
                machine resources</entry>
            </row>
            <row>
              <entry>&Rational;</entry>
              <entry>Arbitrary-precision rational numbers.  Stored as a
                ratio of two &Integer;s.</entry>
            </row>
            <row>
              <entry>&Word;</entry>
              <entry>Fixed-precision unsigned integer; storage size same as
                &Int;</entry>
            </row>
            <row>
              <entry>&Word16;</entry>
              <entry>16-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word32;</entry>
              <entry>32-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word64;</entry>
              <entry>64-bit unsigned integer</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="x_mB">
        These are quite a few different numeric types.  There are some
        operations, such as addition, that ought to work with all of them.
        There are others, such as <literal>asin</literal>, that only apply to
        floating-point types.  <xref linkend="hs.numerictypes.funcs"/>
        summarizes the different functions that operate on numeric types,
        and
        <xref linkend="hs.numerictypes.typeclasses"/> matches the types with
        their respective typeclasses.  As you read that table, keep in mind
        that Haskell operators are just functions: you can say either
        <literal>(+) 2 3</literal> or <literal>2 + 3</literal> with the same
        result.  By convention, when referring to an operator as a function,
        it is written in parenthesis as seen in this table.
      </para>

      <remark>FIXME: how to sort the operators?</remark>

      <table id="hs.numerictypes.funcs" tocentry="1">
        <title>Selected Numeric Functions and Constants</title>
        <tgroup cols='3' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <colspec colname='c3'/>
          <thead>
            <row>
              <entry>Item</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>(+)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry>Addition</entry>
            </row>
            <row>
              <entry><literal>(-)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry>Subtraction</entry>
            </row>
            <row>
              <entry><literal>(*)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry>Multiplication</entry>
            </row>
            <row>
              <entry><literal>(/)</literal></entry>
              <entry><literal>Fractional a => a -> a -> a</literal></entry>
              <entry>Fractional division</entry>
            </row>
            <row>
              <entry><literal>(**)</literal></entry>
              <entry><literal>Floating a => a -> a -> a</literal></entry>
              <entry>Raise to the power of</entry>
            </row>
            <row>
              <entry><literal>(%)</literal></entry>
              <entry><literal>Integral a => a -> a -> Ratio a</literal></entry>
              <entry>Ratio composition</entry>
            </row>

            <row>
              <entry><literal>(.&amp;.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry>Bitwise and</entry>
            </row>
            <row>
              <entry><literal>(.|.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry>Bitwise or</entry>
            </row>
            <row>
              <entry><literal>abs</literal></entry>
              <entry><literal>Num a => a -> a</literal></entry>
              <entry>Absolute value</entry>
            </row>
            <row>
              <entry><literal>approxRational</literal></entry>
              <entry><literal>RealFrac a => a -> a ->
                  Rational</literal></entry>
              <entry>Approximate rational composition based on fractional numerators and
                denominators</entry>
            </row>

            <row>
              <entry><literal>cos</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry>Cosine.  Also provided are <literal>acos</literal>,
                <literal>cosh</literal>, and <literal>acosh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>div</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry>Integer division always truncated down; see also
                <literal>quot</literal></entry>
            </row>
            <row>
              <entry><literal>fromInteger</literal></entry>
              <entry><literal>Num a => Integer -> a</literal></entry>
              <entry>Conversion from an &Integer; to any numeric type</entry>
            </row>
            <row>
              <entry><literal>fromRational</literal></entry>
              <entry><literal>Fractional a => Rational -> a</literal></entry>
              <entry>Conversion from a &Rational;.  May be lossy.</entry>
            </row>
            <row>
              <entry><literal>log</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry>Natural logarithm</entry>
            </row>
            <row>
              <entry><literal>logBase</literal></entry>
              <entry><literal>Floating a => a -> a -> a</literal></entry>
              <entry>Log with explicit base</entry>
            </row>
            <row>
              <entry><literal>maxBound</literal></entry>
              <entry><literal>Bounded a => a</literal></entry>
              <entry>The maximum value of a bounded
                  type</entry>
            </row>
            <row>
              <entry><literal>minBound</literal></entry>
              <entry><literal>Bounded a => a</literal></entry>
              <entry>The minimum value of a bounded
                  type</entry>
            </row>
            <row>
              <entry><literal>mod</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry>Integer modulus</entry>
            </row>
            <row>
              <entry><literal>pi</literal></entry>
              <entry><literal>Floating a => a</literal></entry>
              <entry>Mathematical constant pi</entry>
            </row>
            <row>
              <entry><literal>quot</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry>Integer division; fractional part of quotient
                  truncated towards zero</entry>
            </row>
            <row>
              <entry><literal>recip</literal></entry>
              <entry><literal>Fractional a => a -> a</literal></entry>
              <entry>Reciprocal</entry>
            </row>
            <row>
              <entry><literal>rem</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry>Remainder of integer division</entry>
            </row>
            <row>
              <entry><literal>round</literal></entry>
              <entry><literal>(RealFrac a, Integral b) => a -> b</literal></entry>
              <entry>Rounds to nearest integer</entry>
            </row>
            <row>
              <entry><literal>shift</literal></entry>
              <entry><literal>Bits a => a -> Int -> a</literal></entry>
              <entry>Shift left by the specified number of bits,
                  which may be negative for a right shift.</entry>
            </row>
            <row>
              <entry><literal>sin</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry>Sine.  Also provided are <literal>asin</literal>,
                <literal>sinh</literal>, and <literal>asinh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>sqrt</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry>Square root</entry>
            </row>

            <row>
              <entry><literal>tan</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry>Tangent.  Also provided are <literal>atan</literal>,
                <literal>tanh</literal>, and <literal>atanh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>toInteger</literal></entry>
              <entry><literal>Integral a => a -> Integer</literal></entry>
              <entry>Convert any &Integral; to an &Integer;</entry>
            </row>
            <row>
              <entry><literal>toRational</literal></entry>
              <entry><literal>Real a => a -> Rational</literal></entry>
              <entry>Convert losslessly to &Rational;</entry>
            </row>
            <row>
              <entry><literal>truncate</literal></entry>
              <entry><literal>(RealFrac a, Integral b) => a -> b</literal></entry>
              <entry>Truncates number towards zero</entry>
            </row>
            <row>
              <entry><literal>xor</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry>Bitwise exclusive or</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table id="hs.numerictypes.typeclasses" tocentry="1" pgwide="1">
        <title>Typeclass Instances for Numeric Types</title>
        <tgroup cols='9' align='left'>
          <colspec colname='ctype'/>
          <colspec colname='cbits'/>
          <colspec colname='cbounded'/>
          <colspec colname='cfloating'/>
          <colspec colname='cfractional'/>
          <colspec colname='cintegral'/>
          <colspec colname='cnum'/>
          <colspec colname='creal'/>
          <colspec colname='crealfrac'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry><literal>Bits</literal></entry>
              <entry><literal>Bounded</literal></entry>
              <entry><literal>Floating</literal></entry>
              <entry><literal>Fractional</literal></entry>
              <entry><literal>Integral</literal></entry>
              <entry><literal>Num</literal></entry>
              <entry><literal>Real</literal></entry>
              <entry><literal>RealFrac</literal></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;</entry>
              <entry colname="cfloating">X</entry>
              <entry colname="cfractional">X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Float;</entry>
              <entry colname="cfloating">X</entry>
              <entry colname="cfractional">X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Int;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int16;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int32;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int64;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry colname='cbits'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Rational; or any &Ratio;</entry>
              <entry colname='cfractional'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Word;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word16;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word32;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word64;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para id="x_nB">
        One other question regarding Haskell's numeric types is conversion
        between them.  <xref linkend="hs.numerictypes.funcs"/> listed many
        functions that can be used for conversion.  However, it is not always
        obvious how to apply them to convert between two arbitrary types.  To
        help you out, <xref linkend="hs.numerictypes.conversion"/> provides
        information on converting between different types.
      </para>
      <table id='hs.numerictypes.conversion' tocentry='1'>
        <title>Conversion Between Numeric Types</title>
        <tgroup cols='5'>
          <colspec colname='source'/>
          <colspec colname='float'/>
          <colspec colname='int'/>
          <colspec colname='integer'/>
          <colspec colname='rational'/>

          <thead>
            <row>
              <entry morerows='1'>Source Type</entry>
              <entry align='center' namest='float' nameend='rational'>Destination
                Type</entry>
            </row>
            <row>
              <entry colname='float'>&Double;, &Float;</entry>
              <entry colname='int'>&Int;s, &Word;s</entry>
              <entry colname="integer">&Integer;</entry>
              <entry colname="rational">&Rational;</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;, &Float;</entry>
              <entry colname='float'><literal>fromRational . toRational</literal></entry>
              <entry colname='int'><literal>truncate</literal></entry>
              <entry colname='integer'><literal>truncate</literal></entry>
              <entry colname='rational'><literal>toRational</literal></entry>
            </row>
            <row>
              <entry>&Int;s, &Word;s</entry>
              <entry colname='float'><literal>fromIntegral</literal></entry>
              <entry colname='int'><literal>fromIntegral</literal></entry>
              <entry colname='integer'><literal>fromIntegral</literal> or
                <literal>toInteger</literal></entry>
              <entry colname='rational'><literal>fromIntegral</literal></entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry colname='float'><literal>fromIntegral</literal></entry>
              <entry colname='int'><literal>fromIntegral</literal></entry>
              <entry colname='integer'>N/A</entry>
              <entry colname='rational'><literal>fromIntegral</literal></entry>
            </row>
            <row>
              <entry>&Rational;</entry>
              <entry colname='float'><literal>fromRational</literal></entry>
              <entry colname='int'><literal>truncate</literal></entry>
              <entry colname='integer'><literal>truncate</literal></entry>
              <entry colname='rational'>N/A</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
        For an extended example demonstrating the use of these numeric
        typeclasses, see <xref linkend="hs.data.num"/>.
      </para>


    </sect2>

    <sect2 id="hs.typeclasses.wellknown.equality">
      <title>Equality, Ordering, and Comparisons</title>
      <para id="x_oB">
        We've already talked about the arithmetic operators such as
        <literal>+</literal> that can be used for all sorts of different
        numbers.  But there are some even more widely-applied operators in
        Haskell.  The most obvious, of course, are the equality tests:
        <literal>==</literal> and <literal>/=</literal>.  Any type that can
        be evaluated for equality is a member of &Eq;, which defines those
        operators.
      </para>
      <para id="x_pB">
        There are also comparison operators such as <literal>>=</literal> and
        <literal>&lt;=</literal>.  These are defined by the &Ord; typeclass.
        These are in a separate typeclass because there are some types, such
        as &Handle;, where an equality test makes sense, but there is no way
        to express a particular ordering.  Anything that is an instance of
        &Ord; can be sorted by <literal>Data.List.sort</literal>.
      </para>
      <para id="x_qB">
        Virtually all Haskell types are instances of &Eq;, and almost as many
        are instances of &Ord;.
      </para>

    </sect2>
  </sect1>

  <sect1 id="hs.typeclasses.auto.derivation">
    <title>Automatic Derivation</title>
    <para id="x_rB">
      For many simple data types, the Haskell compiler can automatically
      derive instances of &Read;, &Show;, &Bounded;, &Eq;, and &Ord; for you.
      This saves you the effort of having to manually write parsers and
      display code for each type.  Here's an example:
    </para>
    &colorderived.hs:all;
    <para id="x_sB">
      Let's take a look at how these derived instances work for us:
    </para>
    &derived.ghci:all;
    <para id="x_tB">
      Notice that the derived instance of &Read; actually works better than
      our hand-written version did: it successfully parsed a list with
      embedded white space.
    </para>
    <para id="x_uB">
      Automatic derivation is not always possible.  For instance, if you
      defined a type <literal>Data MyType = MyType (Int -> Bool)</literal>,
      the compiler will not be able to derive an instance of &Show; because
      it doesn't know how to render a function.  You will get a compilation
      error in such a situation.
    </para>
  </sect1>

  <!-- FIXME: cover these? 
  <sect1 id="hs.typeclasses.overlapping">
    <title>Overlapping Instances</title>
    <para id="x_vB">
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.undecidable">
    <title>Undecidable Instances</title>
    <para id="x_wB">
      FIXME
    </para>
  </sect1>
  -->

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
