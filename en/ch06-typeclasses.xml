<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="typeclasses">
  <title>Using Typeclasses</title>

  <para id="x_iA">
    Typeclasses are among the most powerful features in Haskell.
    They allow you to define generic interfaces that provide a common
    feature set over a wide variety of types.  Typeclasses 
    are at the heart of some basic language features such as equality
    testing and numeric operators.  Before we talk about what exactly
    typeclasses are, though, we'd like to explain the need for them.
  </para>

  <sect1 id="typeclasses.need">
    <title>The need for typeclasses</title>
    <para id="x_jA">
      Let's imagine that for some unfathomable reason, the designers of the
      Haskell language neglected to implement the equality test
      <literal>==</literal>.  Once you got over your shock at hearing this, 
      you resolved to implement your own equality tests.  Your application
      consisted of a simple <literal>Color</literal> type, and so your first
      equality test is for this type.  Your first attempt might look like
      this:
    </para>
    &naiveeq.hs:color;
    <para id="x_kA">
      You can test this with &ghci;:
    </para>
    &naiveeq.ghci:all;
    <para id="x_lA">
      Now, let's say that you want to add an equality test for
      &String;s.
      Since a Haskell &String; is a list of characters, we can
      write a simple function to perform that test.
        For simplicity, we
      cheat a bit and use the <literal>==</literal> operator here to
      illustrate.
    </para>
    &naiveeq.hs:string;
    <para id="x_mA">
      You should now be able to see a problem: we have to use a function
      with a different name for every different type that we want to be able to compare.
      That's inefficient and annoying.  It's much more convenient to be able
      to just use <literal>==</literal> to compare anything.  It may also
      be useful to write generic functions such as <literal>/=</literal>
      that could be implemented in terms of <literal>==</literal>, and
      valid for almost anything.  By having a generic function that
      can compare anything, we can also make our code generic: if a
      piece of code only needs to compare things, then it ought to be
      able to accept any data type that the compiler knows how to
      compare.  And, what's more, if new data types are added later,
      the existing code shouldn't have to be modified.
    </para>
    <para id="x_jp">
      Haskell's typeclasses are designed to address all of these things.
    </para>
  </sect1>
  <sect1 id="typeclasses.whatarethey">
    <title>What are typeclasses?</title>
    <para id="x_nA">
      Typeclasses define a set of functions that can have different
      implementations depending on the type of data they are given.
      Typeclasses may look like the objects of object-oriented
      programming, but they are truly quite different.
    </para>

    <para id="x_tA">
      Let's use typeclasses to solve our equality dilemma from earlier in the
      chapter.  To begin with, we must define the typeclass
      itself.  We want a function that takes two parameters, both the
      same type, and returns a <literal>Bool</literal> indicating whether or not
      they are equal.  We don't care what that type is, but we just want two
      items of that type.  Here's our first definition of a typeclass:
    </para>
    &eqclasses.hs:basiceq;
    <para id="x_uA">
      This says that we are declaring a typeclass named
      <literal>BasicEq</literal>, and we'll refer to instance types with the
      letter <literal>a</literal>.  An instance type of this typeclass
      is any type that implements the functions defined in the typeclass.
      This typeclass defines one function.
      That function takes two parameters&emdash;both corresponding to instance
      types&emdash;and returns a <literal>Bool</literal>.
    </para>
    <note>
      <para id="x_vD1">
        The keywoard to define a typeclass in Haskell is
        <literal>class</literal>.  Unfortunately, this may be
        confusing for those of you coming from an object-oriented
        background, as we are not really defining the same thing.
      </para>
    </note>
    <para id="x_wA">
      On the first line, the name of the parameter <literal>a</literal>
      was chosen arbitrarily.  We could have used any name.  The key is that,
      when you list the types of your functions, you must use that name to
      refer to instance types.
    </para>
    <para id="x_yA">
      Let's look at this in &ghci;.
      Recall that you
      can type <command>:type</command> in &ghci; to 
      have it show you the type of something.  Let's see what it says about
      <literal>isEqual</literal>:
    </para>
    <screen>
*Main&gt; <userinput>:type isEqual</userinput>
isEqual :: (BasicEq a) => a -> a -> Bool
    </screen>
    <para id="x_zA">
      You can read that this way: "For all types <literal>a</literal>, so
      long as <literal>a</literal> is an instance of
      <literal>BasicEq</literal>, <literal>isEqual</literal> takes two
      parameters of type <literal>a</literal> and returns a
      <literal>Bool</literal>".  Let's take a quick look at defining
      <literal>isEqual</literal> for a particular type.
    </para>
    &eqclasses.hs:basicinstance;
    <para id="x_EN">
      You can also use &ghci; to verify that we can now use
      <literal>isEqual</literal> on &Bool;s, but not on any other type:
    </para>
    &eqclasses.ghci:all;
    <para id="x_FN">
      Notice that when we tried to compare two strings, &ghci; noticed that
      we hadn't provided an instance of <literal>BasicEq</literal> for
      &String;.  It therefore didn't know how to compare a &String;, and
      suggested that we could fix the problem by defining an instance of
      <literal>BasicEq</literal> for <literal>[Char]</literal>, which is the
      same as &String;.
    </para>
    <para id="x_GN">
      We'll go into more detail on defining instances in <xref
        linkend="typeclasses.instances"/>.  First, though, let's continue
      to look at ways to define typeclasses.  In this example, a
      not-equal-to function might be useful.
      Here's what we might say to define a typeclass with two functions:
    </para>
    &eqclasses.hs:basiceq2;
    <para id="x_BB">
      Someone providing an instance of <literal>BasicEq2</literal> will
      be required to define two functions: <literal>isEqual2</literal> and
      <literal>isNotEqual2</literal>.
    </para>
    <para id="x_CB">
      While our definition of <literal>BasicEq2</literal> is fine, it seems
      that we're making extra work for ourselves.  
      Logically speaking, if we
      know what <literal>isEqual</literal> or
      <literal>isNotEqual</literal> would return, we know how to figure out
      what the other function would return, for all types.  Rather than
      making users of the typeclass define both functions for all types, we
      can provide default implementations for them.  Then, users will only
      have to implement one function.
      <footnote>
        <para id="x_DB">
          We provided a default implementation of both functions, which gives
          implementers of instances choice: they can pick which one they
          implement.  We could have provided a default for only one function,
          which would have forced users to implement the other every time.
          As it is, users can implement one or both, as they see fit.
        </para>
      </footnote>
      Here's an example that shows how to do
      this.
    </para>
    &eqclasses.hs:basiceq3;
    <para id="x_EB">
      People implementing this class must provide an implementation of
      at least one function.  They can implement both if they wish,
      but they will not be required to.  While we did provide defaults
      for both functions, each function depends on the presence of the
      other to calculate an answer.  If we don't specify at least one,
      the resulting code would be an endless loop.  Therefore, at
      least one function must always be implemented.
    </para>
    <para id="x_FB">
      With <literal>BasicEq3</literal>, we have provided a class that does
      very much the same thing as Haskell's built-in <literal>==</literal>
      and <literal>/=</literal> operators.  In fact, these operators are
      defined by a typeclass that looks almost identical to
      <literal>BasicEq3</literal>.  The Haskell 98 Report
      defines a typeclass that implements equality
      comparison.  Here is the code for the built-in
      <literal>Eq</literal> typeclass.
      Note how similar it is to our
        <literal>BasicEq3</literal> typeclass.
    </para>
    <programlisting>
class  Eq a  where
    (==), (/=) :: a -> a -> Bool

       -- Minimal complete definition:
       --     (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)
   </programlisting>

  </sect1>

  <sect1 id="typeclasses.instances">
    <title>Declaring typeclass instances</title>
    <para id="x_GB">
      Now that you know how to define typeclasses, it's time to learn how to
      define instances of typeclasses.  Recall that types are made
      instances of a particular typeclass by implementing the
      functions necessary for that typeclass.
    </para>
    <para id="x_HB">
      <remark>FIXME: rearrange? see comments</remark>
      Recall our attempt to create a test for equality over a
      <literal>Color</literal> type back in <xref
      linkend="typeclasses.need"/>.
      Now let's see how we could make that same <literal>Color</literal>
      type a member of the <literal>BasicEq3</literal> class.
    </para>
    &eqclasses.hs:basiceq3inst;
    <para id="x_IB">
      Notice that we provide essentially the same function as we used
      back in <xref linkend="typeclasses.need"/>.  In fact, the
      implementation is identical.  However, in this case, we can use
      <literal>isEqual3</literal> on <emphasis>any</emphasis> type that
      we declare is an instance of <literal>BasicEq3</literal>, not just
      this one color type.  We could define equality tests for anything
      from numbers to graphics using the same basic pattern.  In fact, as you
      will see in <xref linkend="typeclasses.wellknown.equality"/>, this
      is exactly how you can make Haskell's <literal>==</literal> operator
      work for your own custom types.
    </para>
    <para id="x_JB">
      Note also that the <literal>BasicEq3</literal> class defined both
      <literal>isEqual3</literal> and <literal>isNotEqual3</literal>, but we
      implemented only one of them in the <literal>Color</literal> instance.  
      That's because of the default implementation
      contained in <literal>BasicEq3</literal>.  Since we didn't explicitly
      define <literal>isNotEqual3</literal>, the compiler automatically uses
      the default implementation given in the <literal>BasicEq3</literal>
      declaration.
    </para>

  </sect1>

  <sect1 id="typeclasses.wellknown">
    <title>Important Built-In Typeclasses</title>

    <para id="x_KB">
      Now that we've discussed defining your own typeclasses and making
      your types instances of typeclasses, it's time to introduce you to
      typeclasses that are a standard part of the Haskell Prelude.  As we mentioned at
      the beginning of this chapter, typeclasses are at the core of some
      important aspects of the language.  We'll cover the most common ones
      here.  For more details, the Haskell library reference is a good
      resource.  It will give you a description of the typeclasses, and
      usually also will tell you which functions you must implement to have a
      complete definition.  
    </para>

    <sect2 id="typeclasses.wellknown.show">
      <title>Show</title>
      <para id="x_LB">
        The <literal>Show</literal> typeclass is used to convert values to
        &String;s.  It is perhaps most commonly used to
        convert numbers to &String;s, but it is defined for
        so many types that it can be used to convert quite a bit more.  
        If you have defined your own types, making them instances of
        <literal>Show</literal> will make it easy to display them in &ghci;
        or print them out in programs.
      </para>
      <para id="x_MB">
        The most important function of <literal>Show</literal> is
        <literal>show</literal>.  It takes one argument: the data to convert.
        It returns a &String; representing that data.
        &ghci; reports the type of <literal>show</literal> like this:
      </para>

      &show.ghci:showtype;

      <para id="x_NB">
        Let's look at some examples of converting values to strings:
      </para>
      &show.ghci:showex;
      <para id="x_OB">
        Remember that &ghci; displays results as they would
        be entered into a Haskell program.  So the expression <literal>show 1</literal>
        returns a single-character string containing the digit
        <literal>1</literal>.  That is, the quotes are not part of the string
        itself.  We can make that clear by using
        <literal>putStrLn</literal>:
      </para>
      &show.ghci:printshowex;
      <para id="x_PB">
        You can also use <literal>show</literal> on
        &String;s:
      </para>
      &show.ghci:showstr;
      <para id="x_QB">
        Running <literal>show</literal> on &String;s can be
        confusing.  Since <literal>show</literal> generates a result that
        is suitable for a Haskell literal, <literal>show</literal> adds
        quotes and escaping suitable for inclusion in a Haskell program.
        &ghci; also uses <literal>show</literal> to
        display results, so quotes and escaping get added twice.  Using
        <literal>putStrLn</literal> can help make this difference clear.
      </para>

      <para id="x_RB">
        You can define a <literal>Show</literal> instance for your own types
        easily.  Here's an example:
      </para>

      &eqclasses.hs:show;

      <para id="x_SB">
        This example defines an instance of <literal>Show</literal> for our
        type 
        <literal>Color</literal> (see <xref
          linkend="typeclasses.need"/>).  The implementation is
        simple: we define a function <literal>show</literal> and that's all
        that's needed.
      </para>
      <note>
        <para id="x_kp">&Show; is usually used to define a &String;
        representation for data that is useful for a machine to parse
        back with &Read;.  Haskell programmers generally write custom
        functions to format data in pretty ways for displaying to end
        users, if this representation would be different than expected
        via &Show;.
        </para>
      </note>

    </sect2>

    <sect2 id="typeclasses.wellknown.read">
      <title>Read</title>
      <para id="x_TB">
        The &Read; typeclass is essentially the opposite of &Show;: it
        defines functions that will
        take a &String;, parse it, and return data in any type that is
        a member of &Read;.
        The most useful function in &Read; is &read;.
        You can ask &ghci; for its type like this:
      </para>

      &read.ghci:readtype;

      <para id="x_UB">
        Here's an example illustrating the use of &read; and &show;:
      </para>

      &read.hs:read;

      <remark>FIXME: have we already explained main, do, and
        type annotations on expressions?</remark>

      <para id="x_VB">
        This is a simple example of &read; and &show; together.  Notice that
        we gave an explicit type of &Double; when processing the &read;.
        That's because &read; returns a value of type
        <literal>Read a => a</literal> and &show; expects a value of type
        <literal>Show a => a</literal>.  There are many types that have
        instances
        defined for both &Read; and &Show;.  Without knowing a specific type,
        the compiler must guess from these many types which one is
        needed.  In situations like this, it may often choose &Integer;.  If
        we wanted to accept floating-point input, this wouldn't work, so we
        provided an explicit type.
      </para>
      <tip>
        <para id="x_lp">In most cases, if the explicit &Double; type annotation
        were omitted, the compiler would refuse to guess a
        common type and simply give an error.  The fact that it could
        default to &Integer; here is a special case arising from the
        fact that the literal <literal>2</literal> is treated as an
        &Integer; unless a different type of expected for it.
        </para>
      </tip>
      <para id="x_WB">
        You can see the same effect at work if you try to use &read; on the
        &ghci; command line.  &ghci; internally uses &show; to display
        results, meaning that you can hit this ambiguous typing problem there
        as well.  You'll need to explicitly give types for
        your &read; results in
        &ghci; as shown here:
      </para>
      &read.ghci:readerrors;
      <para id="x_XB">
        Recall the type of &read;:
        <literal>(Read a) => String -&gt; a</literal>.  The
        <literal>a</literal> here is the type of each instance of &Read;.
        Which particular parsing function is called depends upon the type
        that is expected from the return value of &read;.  Let's see how that
        works:
      </para>
      &read.ghci:readtypes;
      <para id="x_YB">
        Notice the error when trying to parse <literal>5.0</literal> as an
        &Integer;.  The interpreter selected a different instance of &Read;
        when the return value was expected to be &Integer; than it did when a
        &Double; was expected.  The &Integer; parser doesn't accept decimal
        points, and caused an exception to be raised.
      </para>
      <para id="x_ZB">
        The &Read; class provides for some fairly complicated parsers.
        You can define a simple parser by providing an implementation for the
        <literal>readsPrec</literal> function.  Your implementation can
        return a list containing exactly one tuple on a successful parse, or
        an empty list on an unsuccessful parse.  Here's an example
        implementation:
      </para>
      &eqclasses.hs:read;
      <para id="x_aB">
        This example handles the known cases for the three colors.  It
        returns an empty list (resulting in a "no parse" message) for others.
        The function is supposed to return the part of the input that was not
        parsed, so that the system can integrate the parsing of different
        types together.  Here's an example of using this new instance of
        &Read;:
      </para>
      &read.ghci:readcolor;
      <para id="x_bB">
        Notice the error on the final attempt.  That's because our parser is
        not smart enough to handle leading spaces yet.  If we modified it to
        accept leading spaces, that attempt would work.  You could
        rectify this by modifying your &Read; instance to discard any
        leading spaces, which is common practice in Haskell programs.
      </para>
      <tip>
        <para id="x_mp">
          While it is possible to build sophisticated parsers using
          the &Read; typeclass, many people find it easier to do so using
          Parsec, and rely on &Read; only for simpler tasks.  Parsec
          is covered in detail in <xref linkend="parsec"/>.
        </para>
      </tip>
    </sect2>

    <sect2 id="typeclasses.wellknown.serialization">
      <title>Serialization with Read and Show</title>
      <para id="x_cB">
        You may often have a data structure in memory that you need to
        store on disk for later retrieval or to send across the network.  The
        process of converting data in memory to a flat series of bits for
        storage is called <emphasis>serialization</emphasis>.
      </para>
      <para id="x_dB">
        It turns out that &read; and &show; make excellent tools for
        serialization.  &show; produces output that is both human-readable and
        machine-readable.  Most &show; output is also syntactically-valid
        Haskell, though it is up to people that write &Show; instances to
        make it so.
      </para>
      <tip>
        <para id="x_np">
          String handling in Haskell is normally lazy, so &read; and
          &show; can be used on quite large data structures without
          incident.  The built-in &read; and &show; instances in
          Haskell are efficient and implemented in pure Haskell.  For
          information on how to handle parsing exceptions, refer to
          <xref linkend="errors"/>.
        </para>
      </tip>
      <para id="x_eB">
        Let's try it out in &ghci;:
      </para>
      &serialization.ghci:ex1;
      <para id="x_fB">
        First, we assign <literal>d1</literal> to be a list.  Next, we print
        out the result of <literal>show d1</literal> so we can see what it
        generates.  Then, we write the result of <literal>show d1</literal>
        to a file named <literal>test</literal>.
      </para>
      <para id="x_gB">
        Let's try reading it back.
        <remark>FIXME: xref to explanation of variable binding in ghci</remark>
      </para>
      &serialization.ghci:ex2;
      <para id="x_hB">
        First, we ask Haskell to read the file back.<footnote><para id="x_iB">As you will see
          in <xref linkend="io.lazy"/>, Haskell doesn't actually
          read the entire file at this point.  But for the purposes of this
          example, we can ignore that distinction.</para></footnote>  Then,
        we try to assign the result of <literal>read input</literal> to
        <literal>d2</literal>.  That generates an error.  The reason is that
        the interpreter doesn't know what type <literal>d2</literal> is meant
        to be, so it doesn't know how to parse the input.  If we give it an
        explicit type, it works, and we can verify that the two sets of data
        are equal.
      </para>
      <para id="x_jB">
        Since so many different types are instances of &Read; and &Show; by
        default (and others can be made instances easily; see <xref
          linkend="typeclasses.auto.derivation"/>), you can use it for
        some really complex data structures.  Here are a few examples of
        slightly more complex data structures:
      </para>
      &serialization.ghci:ex3;
    </sect2>

    <sect2 id="typeclasses.wellknown.numeric">
      <title>Numeric Types</title>
      <remark>FIXME: some of these tables don't render well under sgml2x.
      Will need to verify that they look good under the O'Reilly
      renderer.</remark>
      <para id="x_kB">
        Haskell has a powerful set of numeric types.  You can use everything
        from fast 32-bit or 64-bit integers to arbitrary-precision rational
        numbers.   You probably know that operators such as
        <literal>+</literal> can work with just about all of these.  This
        feature is implemented using typeclasses.  As a side benefit, it
        allows you to define your own numeric types and make them first-class
        citizens in Haskell.
      </para>
      <para id="x_lB">
        Let's begin our discussion of the typeclasses surrounding numeric
        types with an examination of the types themselves.  <xref
          linkend="numerictypes.summary"/> describes the most
        commonly-used numeric types in Haskell.  Note that there are also
        many more numeric types available for specific purposes such as
        interfacing to C.
      </para>
      <table id="numerictypes.summary" tocentry="1">
        <title>Selected Numeric Types</title>
        <tgroup cols='2' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;</entry>
              <entry>Double-precision floating point.  A common choice
              for floating-point data.</entry>
            </row>
            <row>
              <entry>&Float;</entry>
              <entry>Single-precision floating point.  Often used when
              interfacing with C.</entry>
            </row>
            <row>
              <entry>&Int;</entry>
              <entry>Fixed-precision signed integer; minimum range
                [-2^29..2^29-1].  Commonly used.</entry>
            </row>
            <row>
              <entry>&Int8;</entry>
              <entry>8-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int16;</entry>
              <entry>16-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int32;</entry>
              <entry>32-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int64;</entry>
              <entry>64-bit signed integer</entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry>Arbitrary-precision signed integer; range limited only by
                machine resources.  Commonly used.</entry>
            </row>
            <row>
              <entry>&Rational;</entry>
              <entry>Arbitrary-precision rational numbers.  Stored as a
                ratio of two &Integer;s.</entry>
            </row>
            <row>
              <entry>&Word;</entry>
              <entry>Fixed-precision unsigned integer; storage size same as
                &Int;</entry>
            </row>
            <row>
              <entry>&Word8;</entry>
              <entry>8-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word16;</entry>
              <entry>16-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word32;</entry>
              <entry>32-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word64;</entry>
              <entry>64-bit unsigned integer</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="x_mB">
        These are quite a few different numeric types.  There are some
        operations, such as addition, that work with all of them.
        There are others, such as <literal>asin</literal>, that only apply to
        floating-point types.  <xref linkend="numerictypes.funcs"/>
        summarizes the different functions that operate on numeric types,
        and
        <xref linkend="numerictypes.typeclasses"/> matches the types with
        their respective typeclasses.  As you read that table, keep in mind
        that Haskell operators are just functions: you can say either
        <literal>(+) 2 3</literal> or <literal>2 + 3</literal> with the same
        result.  By convention, when referring to an operator as a function,
        it is written in parenthesis as seen in this table.
      </para>

      <table id="numerictypes.funcs" tocentry="1">
        <title>Selected Numeric Functions and Constants</title>
        <tgroup cols='4' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <colspec colname='c3'/>
          <colspec colname='c4'/>
          <thead>
            <row>
              <entry>Item</entry>
              <entry>Type</entry>
              <entry>Module</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>(+)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Addition</entry>
            </row>
            <row>
              <entry><literal>(-)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Subtraction</entry>
            </row>
            <row>
              <entry><literal>(*)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Multiplication</entry>
            </row>
            <row>
              <entry><literal>(/)</literal></entry>
              <entry><literal>Fractional a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Fractional division</entry>
            </row>
            <row>
              <entry><literal>(**)</literal></entry>
              <entry><literal>Floating a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Raise to the power of</entry>
            </row>
            <row>
              <entry><literal>(^)</literal></entry>
              <entry><literal>(Num a, Integral b) => a -> b -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Raise a number to a non-negative,
                  integral power</entry>
            </row>
            <row>
              <entry><literal>(^^)</literal></entry>
              <entry><literal>(Fractional a, Integral b) => a -> b ->
              a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Raise a fractional number to any integral
              power</entry>
            </row>
                
            <row>
              <entry><literal>(%)</literal></entry>
              <entry><literal>Integral a => a -> a -> Ratio a</literal></entry>
              <entry><literal>Data.Ratio</literal></entry>
              <entry>Ratio composition</entry>
            </row>

            <row>
              <entry><literal>(.&amp;.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Data.Bits</literal></entry>
              <entry>Bitwise and</entry>
            </row>
            <row>
              <entry><literal>(.|.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Data.Bits</literal></entry>
              <entry>Bitwise or</entry>
            </row>
            <row>
              <entry><literal>abs</literal></entry>
              <entry><literal>Num a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Absolute value</entry>
            </row>
            <row>
              <entry><literal>approxRational</literal></entry>
              <entry><literal>RealFrac a => a -> a ->
                  Rational</literal></entry>
              <entry><literal>Data.Ratio</literal></entry>
              <entry>Approximate rational composition based on fractional numerators and
                denominators</entry>
            </row>

            <row>
              <entry><literal>cos</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Cosine.  Also provided are <literal>acos</literal>,
                <literal>cosh</literal>, and <literal>acosh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>div</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Integer division always truncated down; see also
                <literal>quot</literal></entry>
            </row>
            <row>
              <entry><literal>fromInteger</literal></entry>
              <entry><literal>Num a => Integer -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Conversion from an &Integer; to any numeric type</entry>
            </row>
            <row>
              <entry><literal>fromIntegral</literal></entry>
              <entry><literal>(Integral a, Num b) => a -> b</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>More general conversion from any &Integral; to
              any numeric type</entry>
            </row>
            <row>
              <entry><literal>fromRational</literal></entry>
              <entry><literal>Fractional a => Rational -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Conversion from a &Rational;.  May be lossy.</entry>
            </row>
            <row>
              <entry><literal>log</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Natural logarithm</entry>
            </row>
            <row>
              <entry><literal>logBase</literal></entry>
              <entry><literal>Floating a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Log with explicit base</entry>
            </row>
            <row>
              <entry><literal>maxBound</literal></entry>
              <entry><literal>Bounded a => a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>The maximum value of a bounded
                  type</entry>
            </row>
            <row>
              <entry><literal>minBound</literal></entry>
              <entry><literal>Bounded a => a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>The minimum value of a bounded
                  type</entry>
            </row>
            <row>
              <entry><literal>mod</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Integer modulus</entry>
            </row>
            <row>
              <entry><literal>pi</literal></entry>
              <entry><literal>Floating a => a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Mathematical constant pi</entry>
            </row>
            <row>
              <entry><literal>quot</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Integer division; fractional part of quotient
                  truncated towards zero</entry>
            </row>
            <row>
              <entry><literal>recip</literal></entry>
              <entry><literal>Fractional a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Reciprocal</entry>
            </row>
            <row>
              <entry><literal>rem</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Remainder of integer division</entry>
            </row>
            <row>
              <entry><literal>round</literal></entry>
              <entry><literal>(RealFrac a, Integral b) => a -> b</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Rounds to nearest integer</entry>
            </row>
            <row>
              <entry><literal>shift</literal></entry>
              <entry><literal>Bits a => a -> Int -> a</literal></entry>
              <entry><literal>Bits</literal></entry>
              <entry>Shift left by the specified number of bits,
                  which may be negative for a right shift.</entry>
            </row>
            <row>
              <entry><literal>sin</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Sine.  Also provided are <literal>asin</literal>,
                <literal>sinh</literal>, and <literal>asinh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>sqrt</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Square root</entry>
            </row>

            <row>
              <entry><literal>tan</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Tangent.  Also provided are <literal>atan</literal>,
                <literal>tanh</literal>, and <literal>atanh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>toInteger</literal></entry>
              <entry><literal>Integral a => a -> Integer</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Convert any &Integral; to an &Integer;</entry>
            </row>
            <row>
              <entry><literal>toRational</literal></entry>
              <entry><literal>Real a => a -> Rational</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Convert losslessly to &Rational;</entry>
            </row>
            <row>
              <entry><literal>truncate</literal></entry>
              <entry><literal>(RealFrac a, Integral b) => a -> b</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Truncates number towards zero</entry>
            </row>
            <row>
              <entry><literal>xor</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Data.Bits</literal></entry>
              <entry>Bitwise exclusive or</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table id="numerictypes.typeclasses" tocentry="1" pgwide="1">
        <title>Typeclass Instances for Numeric Types</title>
        <tgroup cols='9' align='left'>
          <colspec colname='ctype'/>
          <colspec colname='cbits'/>
          <colspec colname='cbounded'/>
          <colspec colname='cfloating'/>
          <colspec colname='cfractional'/>
          <colspec colname='cintegral'/>
          <colspec colname='cnum'/>
          <colspec colname='creal'/>
          <colspec colname='crealfrac'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry><literal>Bits</literal></entry>
              <entry><literal>Bounded</literal></entry>
              <entry><literal>Floating</literal></entry>
              <entry><literal>Fractional</literal></entry>
              <entry><literal>Integral</literal></entry>
              <entry><literal>Num</literal></entry>
              <entry><literal>Real</literal></entry>
              <entry><literal>RealFrac</literal></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;</entry>
              <entry colname="cfloating">X</entry>
              <entry colname="cfractional">X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Float;</entry>
              <entry colname="cfloating">X</entry>
              <entry colname="cfractional">X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Int;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int16;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int32;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int64;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry colname='cbits'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Rational; or any &Ratio;</entry>
              <entry colname='cfractional'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Word;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word16;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word32;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word64;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para id="x_nB">
        Converting between numeric types is another common need.
        <xref linkend="numerictypes.funcs"/> listed many
        functions that can be used for conversion.  However, it is not always
        obvious how to apply them to convert between two arbitrary types.  To
        help you out, <xref linkend="numerictypes.conversion"/> provides
        information on converting between different types.
      </para>
      <table id='numerictypes.conversion' tocentry='1'>
        <title>Conversion Between Numeric Types</title>
        <tgroup cols='5'>
          <colspec colname='source'/>
          <colspec colname='float'/>
          <colspec colname='int'/>
          <colspec colname='integer'/>
          <colspec colname='rational'/>

          <thead>
            <row>
              <entry morerows='1'>Source Type</entry>
              <entry align='center' namest='float' nameend='rational'>Destination
                Type</entry>
            </row>
            <row>
              <entry colname='float'>&Double;, &Float;</entry>
              <entry colname='int'>&Int;, &Word;</entry>
              <entry colname="integer">&Integer;</entry>
              <entry colname="rational">&Rational;</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;, &Float;</entry>
              <entry colname='float'><literal>fromRational . toRational</literal></entry>
              <entry colname='int'><literal>truncate</literal> *</entry>
              <entry colname='integer'><literal>truncate</literal> *</entry>
              <entry colname='rational'><literal>toRational</literal></entry>
            </row>
            <row>
              <entry>&Int;, &Word;</entry>
              <entry colname='float'><literal>fromIntegral</literal></entry>
              <entry colname='int'><literal>fromIntegral</literal></entry>
              <entry colname='integer'><literal>fromIntegral</literal></entry>
              <entry colname='rational'><literal>fromIntegral</literal></entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry colname='float'><literal>fromIntegral</literal></entry>
              <entry colname='int'><literal>fromIntegral</literal></entry>
              <entry colname='integer'>N/A</entry>
              <entry colname='rational'><literal>fromIntegral</literal></entry>
            </row>
            <row>
              <entry>&Rational;</entry>
              <entry colname='float'><literal>fromRational</literal></entry>
              <entry colname='int'><literal>truncate</literal> *</entry>
              <entry colname='integer'><literal>truncate</literal> *</entry>
              <entry colname='rational'>N/A</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="x_op">
        * Instead of <literal>truncate</literal>, you could also use
          <literal>round</literal>, <literal>ceiling</literal>, or
          <literal>floor</literal>.
      </para>


      <para id="x_oL">
        For an extended example demonstrating the use of these numeric
        typeclasses, see <xref linkend="data.num"/>.
      </para>


    </sect2>

    <sect2 id="typeclasses.wellknown.equality">
      <title>Equality, Ordering, and Comparisons</title>
      <para id="x_oB">
        We've already talked about the arithmetic operators such as
        <literal>+</literal> that can be used for all sorts of different
        numbers.  But there are some even more widely-applied operators in
        Haskell.  The most obvious, of course, are the equality tests:
        <literal>==</literal> and <literal>/=</literal>.  These operators are
        defined in the &Eq; class.
      </para>
      <para id="x_pB">
        There are also comparison operators such as <literal>>=</literal> and
        <literal>&lt;=</literal>.  These are declared by the &Ord; typeclass.
        These are in a separate typeclass because there are some types, such
        as &Handle;, where an equality test makes sense, but there is no way
        to express a particular ordering.  Anything that is an instance of
        &Ord; can be sorted by <literal>Data.List.sort</literal>.
      </para>
      <para id="x_qB">
        Almost all Haskell types are instances of &Eq;, and nearly as many
        are instances of &Ord;.
      </para>
      <tip>
        <para id="x_pp">Sometimes, the ordering in &Ord; is arbitrary.  For
        instance, for &Maybe;, &Nothing; sorts before <literal>Just
        x</literal>, but this was a somewhat arbitrary decision.
        </para>
      </tip>

    </sect2>
  </sect1>

  <sect1 id="typeclasses.auto.derivation">
    <title>Automatic Derivation</title>
    <para id="x_rB">
      For many simple data types, the Haskell compiler can
      automatically derive instances of &Read;, &Show;, &Bounded;,
      &Enum;, &Eq;, and &Ord; for us. This saves us the effort of
      having to manually write code to compare or display our own
      types.
    </para>
    &colorderived.hs:all;

    <note>
      <para id="x_HN">The Haskell standard requires compilers to be
	able to automatically derive instances of these specific
	typeclasses. This automation is not available for other
	typeclasses.</para>
    </note>

    <para id="x_sB">
      Let's take a look at how these derived instances work for us:
    </para>
    &derived.ghci:all;
    <para id="x_IN">
      Notice that the sort order for <literal>Color</literal> was
      based on the order that the constructors were defined.
    </para>
    <para id="x_uB">
      Automatic derivation is not always possible.  For instance, if
      you defined a type <literal>data MyType = MyType (Int ->
	Bool)</literal>, the compiler will not be able to derive an
      instance of &Show; because it doesn't know how to render a
      function.  We will get a compilation error in such a situation.
    </para>

    <para id="x_wD1">When we automatically derive an instance of some typeclass,
      the types that we refer to in our &data; declaration must
      also be instances of that typeclass (manually or automatically).</para>

    &AutomaticDerivation.hs:CannotShow;
  </sect1>

  <sect1 id="jsonclass">
    <title>Typeclasses at work: making JSON easier to use</title>

    <para id="x_jz">The <type>JValue</type> type that we introduced in <xref
      linkend="library.jvalue"/> is not especially easy to work with.
      Here is a truncated and tidied snippet of some real JSON data,
      produced by a well known search engine.</para>

    &result.js:result;

    <para id="x_kz">And here's a further slimmed down fragment of that data,
      represented in Haskell.</para>

    &SimpleResult.hs:result;

    <para id="x_lz">Because Haskell doesn't natively support lists that contain
      types of different value, we can't directly represent a JSON
      object that contains values of different types. Instead, we must
      wrap each value with a <type>JValue</type> constructor.  This
      limits our flexibility: if we want to change the number
      <code>3920</code> to a string <code>"3,920"</code>, we must
      change the constructor that we use to wrap it from
      <code>JNumber</code> to <code>JString</code>.</para>

    <para id="x_mz">Haskell's typeclasses offer a tempting solution to this
      problem.</para>

    &JSONClass.hs:class;

    <para id="x_nz">Now, instead of applying a constructor like
      <code>JNumber</code> to a value to wrap it, we apply the
      <function>toJValue</function> function.  If we change a value's
      type, the compiler will choose a suitable implementation of
      <type>toJValue</type> to use with it.</para>

    <para id="x_oz">We also provide a <function>fromJValue</function> function,
      which attempts to convert a <type>JValue</type> into a value of
      our desired type.</para>

    <sect2>
      <title>More helpful errors</title>

      <para id="x_pz">The return type of our <function>fromJValue</function>
	function uses the <type>Either</type> type.  Like
	<type>Maybe</type>, this type is predefined for us, and we'll
	often use it to represent a computation that could
	fail.</para>

      <para id="x_qz">While <type>Maybe</type> is useful for this purpose, it
	gives us no information if a failure occurs: we literally have
	<code>Nothing</code>.  The <type>Either</type> type has a
	similar structure, but instead of <code>Nothing</code>, the
	<quote>something bad happened</quote> constructor is named
	<code>Left</code>, and it takes a parameter.</para>

      &DataEither.hs:Either;

      <para id="x_rz">Quite often, the type we use for the <varname
	  role="type">a</varname> parameter value is
	<type>String</type>, so we can provide a useful description if
	something goes wrong.  To see how we use the
	<type>Either</type> type in practice, let's look at a simple
	instance of our typeclass.</para>

      &JSONClass.hs:Bool;

    </sect2>

    <sect2>
      <title>Making an instance with a type synonym</title>
      
      <para id="x_sz">The Haskell 98 standard does not allow us to write an
	instance of the following form, even though it seems perfectly
	reasonable.</para>

      &JSONClass.hs:String;

      <para id="x_tz">Recall that <type>String</type> is a synonym for
	<type>[Char]</type>, which in turn is the type
	<type>[a]</type> where <type>Char</type> is substituted for
	the type parameter <varname role="type">a</varname>. According
	to Haskell 98's rules, we are not allowed to supply a type in
	place of a type parameter when we write an instance.  In other
	words, it would be legal for us to write an instance for
	<type>[a]</type>, but not for <type>[Char]</type>.</para>

      <para id="x_uz">While &GHC; follows the Haskell 98 standard by default, we
	can relax this particular restriction by placing a specially
	formatted comment at the top of our source file.</para>

      &JSONClass.hs:LANGUAGE;

      <para id="x_vz">This comment is a directive to the compiler, called a
	<emphasis>pragma</emphasis>, which tells it to enable a
	language extension.  The <code>TypeSynonymInstances</code>
	language extension makes the above code legal.  We'll
	encounter a few other language extensions in this chapter, and
	a handful more later in this book.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Living in an open world</title>

    <para id="x_wz">Haskell's typeclasses are intentionally designed to let us
      create new instances of a typeclass whenever we see fit.</para>

    &JSONClass.hs:doubleToJValue;

    <para id="x_xz">We can add new instances anywhere; they are not
      confined to the module where we define a typeclass.  This
      feature of the typeclass system is referred to as its
      <emphasis>open world assumption</emphasis>.  If we had a way to
      express a notion of <quote>the following are the only instances
	of this typeclass that can exist</quote>, we would have a
      <emphasis>closed</emphasis> world.</para>

    <para id="x_yz">We would like to be able to turn
      a list into what JSON calls an array.  We won't worry about
      implementation details just yet, so let's use
      <code>undefined</code> as the bodies of the instance's
      methods.</para>

    &BrokenClass.hs:array;

    <para id="x_zz">It would also be convenient if we could turn a list of
      name/value pairs into a JSON object.</para>

    &BrokenClass.hs:object;

    <sect2>
      <title>When do overlapping instances cause problems?</title>
      
      <para id="x_A01">If we put these definitions into a source file and load
	them into &ghci;, everything initially seems fine.</para>

      &brokenClass.ghci:load;

      <para id="x_B01">However, once we try to <emphasis>use</emphasis> the
	list-of-pairs instance, we run into trouble.</para>

      &brokenClass.ghci:use;

      <para id="x_C01">This problem of <emphasis>overlapping instances</emphasis>
	is a consequence of Haskell's open world assumption.  Here's a
	simpler example that makes it clearer what's going on.</para>

      &Overlap.hs:Borked;

      <para id="x_D01">We have two instances of the typeclass <type>Borked</type>
	for pairs: one for a pair of <type>Int</type>s and another for
	a pair of anything else that's <type>Borked</type>.</para>

      <para id="x_E01">Suppose that we want to <function>bork</function> a pair
	of <type>Int</type> values.  To do so, the compiler must
	choose an instance to use.  Because these instances are right
	next to each other, it may seem that it could simply choose
	the more specific instance.</para>

      <para id="x_F01">However, &GHC; is conservative by default, and insists
	that there must be only one possible instance that it can
	use.  It will thus report an error if we try to use
	<code>bork</code>.</para>

      <note>
	<para id="x_G01">As we mentioned earlier, we can scatter instances of a
	  typeclass across several modules.  &GHC; does not complain
	  about the mere existence of overlapping instances.  Instead,
	  it only complains when we try to use a method of the
	  affected typeclass, when it is forced to make a decision
	  about which instance to use.</para>
      </note>
    </sect2>

    <sect2>
      <title>Relaxing some restrictions on typeclasses</title>

      <para id="x_xD1">Normally, we cannot write an instance of a typeclass for a
	specialized version of a polymorphic type.  The
	<type>[Char]</type> type is the polymorphic type
	<type>[a]</type> specialized to the type <type>Char</type>. We
	are thus prohibited from declaring <type>[Char]</type> to be
	an instance of a typeclass.  This is highly inconvenient,
	since strings are ubiquitous in real code.</para>

      <para id="x_yD1">The <code>TypeSynonymInstances</code> language extension
	removes this restriction, permitting us to write such
	instances.</para>

      <para id="x_H01">&GHC; supports another useful language extension,
	<code>OverlappingInstances</code>, which addresses the problem
	we saw with overlapping instances.  When there are multiple
	overlapping instances to choose from, this extension causes
	the compiler to pick the most specific one.</para>

      <para id="x_I01">We frequently use this extension together with
	<code>TypeSynonymInstances</code>.  Here's an example.</para>

      &SimpleClass.hs:Foo;
    
      <para id="x_zD1">If we apply <function>foo</function> to a
	<type>String</type>, the compiler will use the
	<type>String</type>-specific implementation.  Even though we
	have an instance of <type>Foo</type> for <type>[a]</type> and
	<type>Char</type>, the instance for <type>String</type> is
	more specific, so &GHC; chooses it.  For other types of list,
	we will see the behavior specified for
	<type>[a]</type>.</para>

      <para id="x_J01">With the <code>OverlappingInstances</code>
	extension enabled, &GHC; will still reject code if it finds
	more than one equally specific instance.</para>

      <note>
	<title>When to use the OverlappingInstances extension</title>

	<para id="x_K01">Here's an important point: &GHC; treats
	  <code>OverlappingInstances</code> as affecting the
	  declaration of an instance, <emphasis>not</emphasis> a
	  location where we use the instance.  In other words, when we
	  define an instance that we wish to allow to overlap with
	  another instance, we must enable the extension for the
	  module that contains the definition.  When it compiles the
	  module, &GHC; will record that instance as <quote>can be
	    overlapped with other instances</quote>.</para>

	<para id="x_L01">Once we import this module and use the
	  instance, we <emphasis>won't</emphasis> need to enable
	  <code>OverlappingInstances</code> in the importing module:
	  &GHC; will already know that the instance was marked as
	  <quote>okay to overlap</quote> when it was defined.</para>

	<para id="x_M01">This behaviour is useful when we are writing
	  a library: we can choose to create overlappable instances,
	  but users of our library do not need to enable any special
	  language extensions.</para>
      </note>
    </sect2>

    <sect2>
      <title>How does show work for strings?</title>

      <para id="x_N01">The <code>OverlappingInstances</code> and
	<code>TypeSynonymInstances</code> language extensions are
	specific to &GHC;, and by definition were not present in
	Haskell 98.  However, the familiar <type>Show</type> typeclass
	from Haskell 98 somehow renders a list of <type>Char</type>
	differently from a list of <type>Int</type>.  It achieves this
	via a clever, but simple, trick.</para>

      <para id="x_O01">The <type>Show</type> class defines both a
	<function>show</function> method, which renders one value,
	and a <function>showList</function> method, which renders a
	list of values.  The default implementation of
	<function>showList</function> renders a list using square
	brackets and commas.</para>

      <para id="x_AE1">The instance of <type>Show</type> for <type>[a]</type> is
	implemented using <function>showList</function>.  The instance
	of <type>Show</type> for <type>Char</type> provides a
	special implementation of <function>showList</function> that
	uses double quotes and escapes non-ASCII-printable
	characters.</para>

      <para id="x_BE1">As a result, if someone applies <function>show</function>
	to a <type>[Char]</type> value, the implementation of
	<function>showList</function> will be chosen, and it will
	correctly render the string using quotes.</para>

      <para id="x_P01">At least sometimes, then, we can avoid the need for the
	<code>OverlappingInstances</code> extension with a little bit
	of lateral thinking.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>How to give a type a new identity</title>

    <para id="x_Q01">In addition to the familiar &data; keyword,
      Haskell provides us with another way to create a new type, using
      the &newtype; keyword.</para>

    &Newtype.hs:newtype;

    <para id="x_R01">The purpose of a &newtype; declaration is to rename an
      existing type, giving it a distinct identity.  As we can see, it
      is similar in appearance to a type declared using the &data;
      keyword.</para>

    <note>
      <title>The type and newtype keywords</title>

      <para id="x_CE1">Although their names are similar, the &type; and &newtype;
	keywords have different purposes.  The &type; keyword gives us
	another way of referring to a type, like a nickname for a
	friend.  Both we and the compiler know that
	<type>[Char]</type> and <type>String</type> names refer to the
	same type.</para>

      <para id="x_DE1">In contrast, the &newtype; keyword exists to
	<emphasis>hide</emphasis> the nature of a type.  Consider a
	<type>UniqueID</type> type.</para>

      &Newtype.hs:UniqueID;

      <para id="x_EE1">The compiler treats <type>UniqueID</type> as a different
	type from <type>Int</type>.  As a user of a
	<type>UniqueID</type>, we know only that we have a unique
	identifier; we cannot see that it is implemented as an
	<type>Int</type>.</para>
    </note>

    <para id="x_S01">When we declare a &newtype;, we must choose which
      of the underlying type's typeclass instances we want to expose.
      Here, we've elected to make <type>NewtypeInt</type> provide
      <type>Int</type>'s instances for <type>Eq</type>,
      <type>Ord</type> and <type>Show</type>.  As a result, we can
      compare and print values of type <type>NewtypeInt</type>.</para>

    &newtype.ghci:compare;

    <para id="x_T01">Since we are <emphasis>not</emphasis> exposing
      <type>Int</type>'s <type>Num</type> or <type>Integral</type>
      instances, values of type <type>NewtypeInt</type> are not
      numbers.  For instance, we can't add them.</para>

    &newtype.ghci:num;

    <para id="x_U01">As with the &data; keyword, we can use a
      &newtype;'s value constructor to create a new value, or to
      pattern match on an existing value.</para>

    <para id="x_FE1">If a &newtype; does not use automatic deriving to expose the
      underlying type's implementation of a typeclass, we are free to
      either write a new instance or leave the typeclass
      unimplemented.</para>

    <sect2>
      <title>Differences between data and newtype declarations</title>

      <para id="x_V01">The &newtype; keyword exists to give an
	existing type a new identity, and it has more restrictions on
	its uses than the &data; keyword.  Specifically, a &newtype;
	can only have one value constructor, and that constructor must
	have exactly one field.</para>

      &NewtypeDiff.hs:newtype;

      <para id="x_W01">Beyond this, there's another important
	difference between &data; and &newtype;.   A type created with
	the &data; keyword has a book-keeping cost at runtime, for
	example to track which constructor a value was created with.
	A &newtype; value, on the other hand, can only have one
	constructor, and so does not need this overhead.  This makes
	it more space- and time-efficient at runtime.</para>

      <para id="x_X01">Because a &newtype;'s constructor is used only
	at compile time and does not even exist at runtime, pattern
	matching on &undefined; behaves differently for types defined
	using &newtype; than for those that use &data;.</para>

      <para id="x_Y01">To understand the difference, let's first review what we
	might expect with a normal datatype.  We are already familiar
	with the idea that if &undefined; is evaluated at runtime, it
	causes a crash.</para>
      
      &newtype.ghci:undefined;

      <para id="x_Z01">Here is a pattern match where we construct a
	<type>DataInt</type> using the <code>D</code> constructor, and
	put &undefined; inside.</para>

      &newtype.ghci:D;

      <para id="x_a01">Since our pattern matches against the constructor but
	doesn't inspect the payload, the &undefined; remains
	unevaluated and does not cause an exception to be thrown.</para>

      <para id="x_b01">In this example, we're not using the <code>D</code>
	constructor, so the unprotected &undefined; is evaluated
	when the pattern match occurs, and we throw an exception.</para>

      &newtype.ghci:data;

      <para id="x_c01">When we use the <code>N</code> constructor for
	the <type>NewtypeInt</type> type, we see the same behaviour as
	with the <type>DataInt</type> type's <code>D</code>
	constructor: no exception.</para>

      &newtype.ghci:N;

      <para id="x_d01">The crucial difference arises when we get rid of the
	<code>N</code> constructor from the expression, and match
	against an unprotected &undefined;.</para>

      &newtype.ghci:newtype;

      <para id="x_e01">We don't crash!  Because there's no constructor present at
	runtime, matching against <code>N _</code> is in fact
	equivalent to matching against the plain wild card
	<code>_</code>: since the wild card always matches, the expression
	does not need to be evaluated.</para>

      <tip>
	<title>Another perspective on newtype constructors</title>

	<para id="x_f01">Even though we use the value constructor for
	  a &newtype; in the same way as that of a type defined using
	  the &data; keyword, all it does is coerce a value between
	  its <quote>normal</quote> type and its &newtype;
	  type.</para>

	<para id="x_g01">In other words, when we apply the <code>N</code>
	  constructor in an expression, we coerce an expression from type
	  <type>Int</type> to type <type>NewtypeInt</type> as far as
	  we and the compiler are concerned, but absolutely nothing
	  occurs at runtime.</para>

	<para id="x_h01">Similarly, when we match on the <code>N</code>
	  constructor in a pattern, we coerce an expression from type
	  <type>NewtypeInt</type> to <type>Int</type>, but again
	  there's no overhead involved at runtime.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Summary: the three ways of naming types</title>

      <para id="x_i01">Here's a brief recap of Haskell's three ways to introduce
	new names for types.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_j01">The <code>data</code> keyword introduces a truly new
	    albegraic data type.</para>
	</listitem>
	<listitem>
	  <para id="x_k01">The <code>type</code> keyword gives us a synonym to
	    use for an existing type.  We can use the type and its
	    synonym interchangeably.</para>
	</listitem>
	<listitem>
	  <para id="x_l01">The <code>newtype</code> keyword gives an existing
	    type a distinct identity.  The original type and the new
	    type are <emphasis>not</emphasis> interchangeable.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="jsonclass.instances">
    <title>JSON typeclasses without overlapping instances</title>

    <para id="x_m01">Enabling &GHC;'s support for overlapping
      instances is an effective and quick way to make our JSON code
      happy.  In more complex cases, we will occasionally be faced
      with several equally good instances for some typeclass, in which
      case overlapping instances will not help us and we will need to
      put some &newtype; declarations into place.  To see what's
      involved, let's rework our JSON typeclass instances to use
      &newtype;s instead of overlapping instances.</para>

    <para id="x_n01">Our first task, then, is to help the compiler to
      distinguish between <type>[a]</type>, the representation we use
      for JSON arrays, and <type>[(String,[a])]</type>, which we use
      for objects.  These were the types that gave us problems before
      we learned about <code>OverlappingInstances</code>. We wrap up
      the list type so that the compiler will not see it as a
      list.</para>

    &JSONClass.hs:JAry;

    <para id="x_o01">When we export this type from our module, we'll
      export the complete details of the type.  Our module header will
      look like this:</para>

    &JSONClassExport.hs:module;

    <para id="x_p01">The <quote><code>(..)</code></quote> following the
      <type>JAry</type> name means <quote>export all details of this
	type</quote>.</para>

    <note>
      <title>A slight deviation from normal use</title>

      <para id="x_q01">Usually, when we export a &newtype;, we will
	<emphasis>not</emphasis> export its data constructor, in order
	to keep the details of the type abstract. Instead, we would
	define a function to apply the constructor for us.</para>

      &JSONClass.hs:jary;

      <para id="x_r01">We would then export the type constructor, the
	deconstructor function, and our construction function, but not
	the data constructor.</para>

      &JSONClassExport.hs:abstract;

      <para id="x_s01">When we don't export a type's data constructor,
	clients of our library can only use the functions we provide
	to construct and deconstruct values of that type. This gives
	us, the library authors, the liberty to change our internal
	representation if we need to.</para>

      <para id="x_GE1">If we export the data constructor, clients are likely to
	start depending on it, for instance by using it in patterns.
	If we later wish to change the innards of our type, we'll risk
	breaking any code that uses the constructor.</para>

      <para id="x_t01">In our circumstances here, we have nothing to
	gain by making the array wrapper abstract, so we may as well
	simply export the entire definition of the type.</para>
    </note>

    <para id="x_u01">We provide another wrapper type that hides our
      representation of a JSON object.</para>

    &JSONClass.hs:JObj;

    <para id="x_v01">With these types defined, we make small changes to the
      definition of our <code>JValue</code> type.</para>

    &JSONClass.hs:JValue;

    <para id="x_w01">This change doesn't affect the instances of the
      <type>JSON</type> typeclass that we've already written, but we
      will want to write instances for our new <type>JAry</type> and
      <type>JObj</type> types.</para>

    &JSONClass.hs:instance.JAry;

    <para id="x_x01">Let's take a slow walk through the individual steps of
      converting a <type>JAry a</type> to a <type>JValue</type>. Given
      a list where we know that everything inside is a
      <type>JSON</type> instance, converting it to a list of
      <type>JValue</type>s is easy.</para>

    &JSONClass.hs:listToJValues;

    <para id="x_y01">Taking this and wrapping it to become a <type>JAry
	JValue</type> is just a matter of applying the &newtype;'s
      type constructor.</para>
    
    &JSONClass.hs:jvaluesToJAry;

    <para id="x_z01">(Remember, this has no performance cost.  We're just telling
      the compiler to hide the fact that we're using a list.)  To turn
      this into a <type>JValue</type>, we apply another type
      constructor.</para>

    &JSONClass.hs:jaryOfJValuesToJValue;

    <para id="x_A11">Assemble these pieces using function composition, and we get
      a concise one-liner for converting to a
      <type>JValue</type>.</para>

    &JSONClass.hs:jaryToJValue;

    <para id="x_B11">We have more work to do to convert <emphasis>from</emphasis>
      a <type>JValue</type> to a <type>JAry a</type>, but we'll break
      it into reusable parts.  The basic function is
      straightforward.</para>

    &JSONClass.hs:jaryFromJValue;

    <para id="x_C11">The <function>whenRight</function> function inspects its
      argument: calls a function on it if it was created with the
      <code>Right</code> constructor, and leaves a <code>Left</code>
      value untouched.</para>

    &JSONClass.hs:whenRight;

    <para id="x_D11">More complicated is <function>mapEithers</function>.  It
      acts like the regular <function>map</function> function, but if
      it ever encounters a <code>Left</code> value, it returns that
      immediately, instead of continuing to accumulate a list of
      <code>Right</code> values.</para>

    &JSONClass.hs:mapEithers;

    <para id="x_E11">Because the elements of the list hidden in the
      <type>JObj</type> type have a little more structure, the code to
      convert to and from a <type>JValue</type> is a bit more complex.
      Fortunately, we can reuse the functions that we just
      defined.</para>

    &JSONClass.hs:instance.JObj;

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para id="x_F11">Load the <code>Control.Arrow</code> module into
	      &ghci;, and find out what the
	      <function>second</function> function does.</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para id="x_G11">What is the type of <function>(,)</function>?  When
	      you use it in &ghci;, what does it do?  What about
	      <function>(,,)</function>?</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>The dreaded monomorphism restriction</title>

    <para id="x_H11">The Haskell 98 standard has a subtle feature that can
      sometimes bite us in unexpected circumstances. Here's a simple
      function definition that illustrates the issue.</para>

    &Monomorphism.hs:myShow;

    <para id="x_I11">If we try to load this definition into &ghci;, it issues a
      peculiar complaint.</para>

    &monomorphism.ghci:load;

    <para id="x_J11">The <quote>monomorphism restriction</quote> to which the
      error message refers is a part of the Haskell 98 standard.
      <emphasis>Monomorphism</emphasis> is simply the opposite of
      polymorphism: it indicates that an expression has exactly one
      type.  The <emphasis>restriction</emphasis> lies in the fact
      that Haskell sometimes forces a declaration to be less
      polymorphic than we would expect.</para>

    <para id="x_K11">We mention the monomorphism restriction here because
      although it isn't specifically related to typeclasses, they
      usually provide the circumstances in which it crops up.</para>

    <tip>
      <para id="x_L11">It's possible that you will not run into the monomorphism
	restriction in real code for a long time.  We don't think you
	need to try to remember the details of this section.  It
	should suffice to make a mental note of its existence, until
	eventually &GHC; complains at you with something like the
	above error message. If that occurs, simply remember that you
	read about the error here, and come back for guidance.</para>
    </tip>

    <para id="x_M11">We won't attempt to explain the monomorphism
      restriction<footnote>
	<para id="x_N11">If you simply <emphasis>must</emphasis> read the gory
	  details, see <ulink
	    url="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">section 
	    4.5.5</ulink> of the Haskell 98 Report.</para>
      </footnote>.  The consensus within the Haskell community is that
      it doesn't arise often; it is tricky to explain; it provides
      almost no practical benefit; and so it mostly serves to trip
      people up.  For an example of its trickiness, while the
      definition above falls afoul of it, the following two compile
      without problems.</para>

    &Monomorphism.hs:myShow2;

    <para id="x_O11">As these alternative definitions suggest, if &GHC; complains
      about the monomorphism restriction, we have three easy ways to
      address the error.</para>

    <itemizedlist>
      <listitem>
	<para id="x_P11">Make the function's arguments explicit, instead of
	  leaving them implicit.</para>
      </listitem>
      <listitem>
	<para id="x_Q11">Give the definition an explicit type signature, instead
	  of making the compiler infer its type.</para>
      </listitem>
      <listitem>
	<para id="x_R11">Leave the code untouched, and compile the module with
	  the <code>NoMonomorphismRestriction</code> language
	  extension enabled.  This disables the monomorphism
	  restriction.</para>
      </listitem>
    </itemizedlist>

    <para id="x_S11">Because the monomorphism restriction is unwanted and
      unloved, it will almost certainly be dropped from the next
      revision of the Haskell standard.  This does not quite mean that
      compiling with <code>NoMonomorphismRestriction</code> is always
      the right thing to do: some Haskell compilers (including older
      versions of &GHC;) do not understand this extension, but they'll
      accept either of the other approaches to making the error
      disappear.  If this degree of portability isn't a concern to
      you, then by all means enable the language extension.</para>
  </sect1>

  <sect1 id="typeclasses.conclusion">
    <title>Conclusion</title>
    <remark>FIXME: needs extending to cover JSON</remark>
    <para id="x_JN">In this chapter, you learned about the need for typeclasses and how
      to use them.  We talked about defining our own typeclasses and then
      covered some of the important typeclasses that are defined in the
      Haskell library.  Finally, we showed how to have the Haskell compiler
      automatically derive instances of certain typeclasses for your types.
    </para>
  </sect1>


</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
