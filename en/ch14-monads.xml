<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.monads" revision="unpublished">
  <title>Monads</title>

  <sect1>
    <title>Introduction</title>

    <para>In <xref linkend="hs.io"/>, we talked about the
      <type>IO</type> monad, but we intentionally kept the discussion
      narrowly focused on how to communicate with the outside world.
      We didn't discuss what a monad <emphasis>is</emphasis>.</para>

    <para>Monads have a reputation of being abstract and difficult to
      understand. If you've heard such concerns, please put aside for
      a while any doubts you might have.  Concerning abstraction, we've
      already seen in <xref linkend="hs.io"/> that the <type>IO</type>
      monad is easy to work with.  Notational differences aside,
      writing code in the <type>IO</type> monad isn't much different
      from coding in any other imperative language.</para>

    <para>As for difficulty, we quietly infiltrated monads into
      several earlier chapters of this book, when we had practical
      problems to solve.  What we aim to show you is that, far from
      being difficult to understand, a monad is often an
      <emphasis>obvious</emphasis> and <emphasis>practical</emphasis>
      tool to help solve a problem.  We'll define a few monads in this
      chapter, to show how easy it is.</para>

    <para>In this chapter, we'll reveal where we hid those monads,
      explain what they really are, and discuss each of the most
      widely used monads.</para>
  </sect1>

  <sect1>
    <title>Revisiting earlier code examples</title>

    <sect2>
      <title>Maybe chaining</title>

      <para>Let's take another look at the
	<function>parseP5</function> function that we wrote in <xref
	  linkend="hs.binary"/>.</para>

      &PNM.hs:parseP5.noid;

      <para>That function threatened to march off the right side of
	the page if it got much longer.  We brought the staircasing
	under control using the <function>(&gt;&gt;?)</function>
	function.</para>

      &PNM.hs:bind.noid;

      <para>We carefully chose the type of
	<function>(&gt;&gt;?)</function> to let us chain together
	functions that return <type>Maybe</type>.  So long as the
	result type of one function matches the parameter of the next,
	we can chain functions returning <type>Maybe</type> together
	indefinitely.  The body of <function>(&gt;&gt;?)</function>
	hides the details of whether the functions we pass in are
	actually called.</para>
    </sect2>

    <sect2>
      <title>Implicit state</title>

      <para>Useful as <function>(&gt;&gt;?)</function> was for
	cleaning up the structure of <function>parseP5</function>, we
	had to incrementally consume pieces of a string as we parsed
	it.  This forced us to pass the current value of the string
	down our chain of <type>Maybe</type>s, wrapped up in a tuple.
	Each function in the chain put a result into one element of
	the tuple, and the unconsumed remainder of the string into the
	other.</para>

      &PNM.hs:parseP5_take2.noid;

      <para>Once again, we were faced with a pattern of repeated
	behaviour: consume some string, return a result, and return
	the remaining string for the next function to consume.
	However, this pattern was more insidious: if we wanted to pass
	another piece of information down the chain, we'd have to
	modify nearly every element of the chain, turning each
	two-tuple into a three-tuple!</para>

      <para>We addressed this by moving the responsibility for
	managing the current piece of string out of the individual
	functions in the chain, and into the function that we used to
	chain them together.</para>

      &Parse.hs:bind.noid;

      <para>We also hid the details of the parsing state in the
	<type>ParseState</type> type.  Even the
	<function>getState</function> and
	<function>putState</function> functions don't inspect the
	parsing state, so any modification to <type>ParseState</type>
	will have no effect on any existing code.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Looking for shared patterns</title>

    <para>When we look at the above examples in detail, they don't
      seem to have much in common.  Obviously, they're both concerned
      with chaining functions together, and with hiding details to let
      us write tidier code.  However, let's take a step back and
      consider them in <emphasis>less</emphasis> detail.</para>

    <para>First, let's look at the type definitions.</para>

    &Maybe.hs:Maybe;

    &Parse.hs:Parse.noid;

    <para>The common feature of these two types is that each has a
      single free type variable on the left of the definition, which
      is used somewhere on the right.</para>

    <para>Next, we'll examine the chaining functions that we wrote for
      the two types.</para>

    &monadness.ghci:Maybe;

    &monadness.ghci:Parse;

    <para>These functions have strikingly similar types.  If we were
      to turn those type constructors into a type variable, we'd end
      up with a single more abstract type.</para>

    &Maybe.hs:chain;

    <para>Finally, in each case we have a function that takes a
      <quote>plain</quote> value, and <quote>injects</quote> it into
      the target type.  For <type>Maybe</type>, this function is
      simply the value constructor <code>Just</code>, but the injector
      for <type>Parse</type> is more complicated.</para>

    &Parse.hs:identity.noid;

    <para>Again, it's not the details or complexity that we're
      interested in, it's the fact that each of these types has this
      <quote>injector</quote> function.</para>

    &Maybe.hs:inject;

    <para>It is <emphasis>exactly</emphasis> these three properties,
      and a few rules about how we can use them together, that define
      a monad in Haskell.  Let's revisit the above list in condensed
      form.</para>

    <itemizedlist>
      <listitem>
	<para>A type <varname role="type">m</varname> with one free
	  type variable <varname role="type"></varname>.</para>
      </listitem>
      <listitem>
	<para>A function of type <type>m a -> (a -> m b) -> m b</type>
	  for chaining the output of one function into the input of
	  another.</para>
      </listitem>
      <listitem>
	<para>A function of type <type>a -> m a</type> for injecting a
	  normal value into the chain, i.e. it wraps a type
	  <type>a</type> with the type constructor
	  <type>m</type>.</para>
      </listitem>
    </itemizedlist>

    <para>The properties that make the <type>Maybe</type> type a monad
      are its type constructor <type>Maybe a</type>, our chaining
      function <function>(&gt;&gt;?)</function>, and the injector
      function <function>Just</function>.</para>

    <para>For <type>Parse</type>, the corresponding properties are the
      type constructor <type>Parse a</type>, the chaining function
      <function>(==&gt;)</function>, and the injector function
      <function>identity</function>.</para>

    <para>We have intentionally said nothing about how the chaining
      and injection functions of a monad should behave, and that's
      because it very nearly doesn't matter.  In fact, monads are
      ubiquitous in Haskell code precisely because they are so simple:
      many common programming patterns have a monadic structure.</para>
  </sect1>

  <sect1>
    <title>The Monad typeclass</title>

    <para>We can capture the notions of chaining and injection, and
      the types that we want them to have, in a Haskell typeclass.
      The standard Prelude already defines just such a typeclass,
      named <code>Monad</code>.</para>

    &Maybe.hs:Monad;

    <para>Here, &bind; is our chaining function.  We've already been
      introduced to it in <xref linkend="hs.io.bind"/>.  It's often
      referred to as <quote>bind</quote>, as it binds two adjacent
      functions together so that one uses the result of the
      other.</para>

    <para>Our injection function is &return;.  As we noted in <xref
      linkend="hs.io.return"/>, the choice of the name &return; is a
      little unfortunate.  That name is widely used in imperative
      languages, where it has a fairly well understood meaning.  In
      Haskell, its behaviour is much less constrained.  In particular,
      calling &return; in the middle of a chain of functions won't
      cause the chain to exit early.  It's more helpful to remember it
      as <quote>inject</quote>.</para>

    <para>While &bind; and &return; are the core functions of the
      <code>Monad</code> typeclass, it also defines two other
      functions.  The first is &bind_;.  Like &bind;, it performs
      chaining, but it ignores the value on the left.</para>

    &Maybe.hs:bind_;

    <para>We use this function when we want to perform actions in a
      certain order, but don't care what the result of one is.  This
      might seem pointless: why would we not care what a function's
      return value is?  Consider a function like &print;, which
      returns nothing useful.</para>

    &bind.ghci:print;

    <para>If we use plain &bind;, we have to provide as its right hand
      side a function that ignores its argument.</para>

    &bind.ghci:bind;

    <para>But if we use &bind_;, we can omit the needless
      function.</para>

    &bind.ghci:bind_;

    <para>As we showed above, the default implementation of &bind_; is
      defined in terms of &bind;.</para>

    <para>The second non-core <code>Monad</code> function is &fail;,
      which takes an error message and does something to make the
      chain of functions fail.</para>

    &Maybe.hs:fail;

    <warning>
      <title>Beware of fail</title>

      <para>Many <code>Monad</code> instances don't override the
	default implementation of &fail; that we show here, which
	means that &fail; calls <function>error</function>.  Calling
	<function>error</function> is usually highly undesirable, so
	don't call &fail; unless you know that you're inside a monad
	that implements it to do something more sensible.</para>
    </warning>

    <para>To revisit the parser that we developed in <xref
	linkend="hs.binary"/>, here is its <code>Monad</code>
      instance.</para>

    &Parse.hs:Monad;

  </sect1>

  <sect1>
    <title>And now, a jargon moment</title>

    <para>There are a few terms of jargon around monads that you may
      not be familiar with.  These aren't formal terms, but they're in
      common use, so it's helpful to know about them.</para>

    <itemizedlist>
      <listitem>
	<para><quote>Monadic</quote> simply means <quote>pertaining to
	    monads</quote>.  A monadic <emphasis>type</emphasis> is an
	  instance of the <code>Monad</code> typeclass; a monadic
	  <emphasis>value</emphasis> has a monadic type.</para>
      </listitem>

      <listitem>
	<para>When we say that a type <quote>is a monad</quote>, this
	  is really an shorthand way of saying that it's an instance
	  of the <code>Monad</code> typeclass.  Being an instance of
	  <code>Monad</code> gives us the necessary monadic triple of
	  type constructor, injection function, and chaining
	  function.</para>
      </listitem>

      <listitem>
	<para>In the same way, a reference to <quote>the
	    <type>Foo</type> monad</quote> implies that we're talking
	  about the type named <type>Foo</type>, and that it's an
	  instance of <code>Monad</code>.</para>
      </listitem>

      <listitem>
	<para>An <quote>action</quote> is another name for a monadic
	  value.  This use of the word probably originated with the
	  introduction of monads for I/O, where a monadic value like
	  <code>print "foo"</code> can have an observable side effect.
	  A function with a monadic return type might also be referred
	  to as an action, though this is a little less common.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>Using a new monad: show your work!</title>

    <para>In our introduction to monads, we showed how some
      pre-existing code was already monadic in form.  Now that we are
      beginning to grasp what a monad is, and we've seen the
      <code>Monad</code> typeclass, let's build a monad with
      foreknowledge of what we're doing.  We'll start out by defining
      its interface, then we'll put it to use.  Once we have those out
      of the way, we'll finally build it.</para>

    <para>Pure Haskell code is wonderfully clean to write, but of
      course it can't perform I/O.  Sometimes, though, we'd like to
      have a record of decisions we took.  Let's develop a small
      library to help with this.</para>

    <para>Recall the <function>globToRegex</function> function that we
      developed in <xref linkend="hs.glob.translate"/>.  We will
      modify it so that it keeps a record of each of the special
      pattern sequences that it translates.  We are revisiting
      familiar territory for a reason: it lets us compare non-monadic
      and monadic versions of the same code.</para>

    <para>To start off, we'll wrap our result type with a
      <code>Logger</code> type constructor.</para>

    &Logger.hs:globToRegex.type;

    <sect2>
      <title>Information hiding</title>

      <para>We'll intentionally keep the internals of the
	<type>Logger</type> module abstract.</para>

      &Logger.hs:module;

      <para>Hiding the details like this has two benefits: it grants
	us considerable flexibility in how we implement our monad, and
	more importantly, it gives users a simple interface.</para>

      <para>The <type>Logger</type> type is purely a
	<emphasis>type</emphasis> constructor.  We don't export the
	<emphasis>value</emphasis> constructor that a user would need
	to create a value of this type.  All they can can use
	<type>Logger</type> for is writing type signatures.</para>

      <para>The <type>Log</type> type is just a synonym for a list of
	strings, to make a few signatures more readable.  We're using
	a list of strings to keep the implementation simple.</para>

      &Logger.hs:Log;

      <para>Instead of giving our users a value constructor, we
	provide them with a function, <function>execLogger</function>,
	that evaluates a logged action.  This returns both the result
	of an action and whatever was logged while the result was
	being computed.</para>

      &Logger.hs:execLogger.type;

    </sect2>

    <sect2>
      <title>Controlled escape</title>

      <para>The <code>Monad</code> typeclass doesn't provide any means
	for values to escape their monadic shackles.  We can inject a
	value into a monad using &return;.  We can extract a value
	from a monad using &bind; but the function on the right that
	can see an unwrapped value has to wrap its own result back up
	again.</para>

      <para>Most monads have one or more
	<function>execLogger</function>-like functions.  The notable
	exception is of course <type>IO</type>, which we usually only
	escape from by exiting a program.</para>

      <para>A monad execution function runs the code inside the monad
	and unwraps its result.  Such a function are usually the only
	means provided for a value to escape from its monadic wrapper.
	The author of a monad thus has complete control over how
	whatever happens inside the monad gets out.</para>

      <para>Some monads have several execution functions.  In our
	case, we can imagine a few alternatives to
	<function>execLogger</function>: one might only return the log
	messages, while another might return just the result and drop
	the log messages.</para>
    </sect2>

    <sect2>
      <title>Leaving a trace</title>

      <para>When executing inside a <type>Logger</type> action, user
	code calls <function>record</function> to record
	something.</para>

      &Logger.hs:record.type;

      <para>Again, most monads provide helper functions that add
	functionality on top of the base <code>Monad</code>
	typeclass.</para>

      <para>Our module also defines the <code>Monad</code> instance
	for the <type>Logger</type> type.  These definitions are all
	that a client module needs in order to be able to use this
	monad.</para>

      <para>We'll use &ghci; to produce a simple example of our monad
	in use.</para>

      &logger.ghci:simple;

      <para>When we run the logged action using
	<function>execLogger</function>, we get back a two-tuple.  The
	first element is the result, and the second is the list of
	items logged while the action executed.  We haven't logged
	anything, so the list is empty.  Let's fix that.</para>

      &logger.ghci:logged;

    </sect2>

    <sect2>
      <title>Using the Logger monad</title>

      <para>Here's how we kick off our glob-to-regexp conversion
	inside the <type>Logger</type> monad.</para>

      &Logger.hs:rooted;

      <para>Remember the type of &bind;: it extracts the value on the
	left from its <type>Logger</type> wrapper, and passes the
	unwrapped value to the function on the right.  The function on
	the right must, in turn, wrap <emphasis>its</emphasis> result
	with the <type>Logger</type> wrapper.  This is exactly what
	&return; does.</para>

      &logger.ghci:bind.type;

      <para>There are a few coding style issues worth mentioning here.
	The body of the function starts on the line after its name. By
	doing this, we gain some horizontal white space.  We've also
	<quote>hung</quote> the parameter of the anonymous function at
	the end of the line. This is common practice in monadic
	code.</para>

      <para>Even when we write a function that does almost nothing, we
	must call <function>return</function> to wrap the result with
	the correct type.</para>

      &Logger.hs:eof;

      <para>When we call <function>record</function> to save a log
	entry, we use &bind_; instead of &bind; to chain it with the
	following action.</para>

      &Logger.hs:question;

      <para>Recall that this is a variant of &bind; that ignores the
	result on the left.  We know that the result of
	<function>record</function> will always be <code>()</code>, so
	there's no point in capturing it.</para>

      <para>We can use &do; notation, which we first encountered in
	<xref linkend="hs.io.bind"/>, to somewhat tidy up our
	code.</para>

      &Logger.hs:asterisk;

      <para>The choice of &do; notation versus explicit &bind; with
	anonymous functions is mostly a matter of taste. There is one
	significant difference between the two, though, which we'll
	return to in <xref linkend="hs.monads.do"/>.</para>

      <para>Parsing a character class mostly follows the same pattern
	that we've already seen.</para>

      &Logger.hs:class;

      <para>The interesting exception is in the final clause above.
	Where we called <function>error</function> in
	<xref linkend="hs.glob.translate"/>, we now call
	<function>fail</function> from the <code>Monad</code>
	typeclass instead.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.monads.liftM">
    <title>Mixing pure and monadic code</title>

    <para>Based on the code we've seen so far, monads seem to have a
      substantial shortcoming: the type constructor that wraps a
      monadic value makes it tricky to use a normal, pure function on
      a value trapped inside a monadic wrapper.  Here's a simple
      illustration of the apparent problem.  Let's say we have a
      trivial piece of code that runs in the <type>Logger</type> monad
      and returns a string.</para>

    &logger.ghci:m;

    <para>If we want to find out the length of that string, we can't
      simply call <function>length</function>: the string is wrapped,
      so the types don't match up.</para>

    &logger.ghci:m.length;

    <para>What we've done so far to work around this is something like
      the following.</para>

    &logger.ghci:m.length2;

    <para>We use &bind; to unwrap the string, then write a small
      anonymous function that calls <function>length</function> and
      rewraps the result using <function>return</function>.</para>

    <para>This need crops up so often in Haskell code that we won't be
      surprised to learn that a shorthand already exists.  We reuse
      the <emphasis>lifting</emphasis> technique that we introduced
      for functors in <xref linkend="hs.binary.functor"/>.  Lifting a
      pure function into a functor usually involves unwrapping the
      value inside the functor, calling the function on it, and
      rewrapping the result with the same constructor.</para>

    <para>We do exactly the same thing with a monad.  Because the
      <code>Monad</code> typeclass already provides the &bind; and
      &return; functions that know how to wrap and unwrap a value, the
      <function>liftM</function> function doesn't need any details of
      a monad's implementation.</para>

    &Logger.hs:liftM;

    <para>When we declare a type to be an instance of the
      <code>Functor</code> typeclass, we have to write our own version
      of <function>fmap</function> specially tailored to that type. By
      contrast, <function>liftM</function> doesn't need to know
      anything of a monad's internals, because they're abstracted by
      &bind; and &return;.  We only need to write it once, with the
      appropriate type constraint.</para>

    <para>The <function>liftM</function> function is predefined for us
      in the standard <code>Control.Monad</code> module.</para>

    <para>To see how <function>liftM</function> can help readability,
      we'll compare two otherwise identical pieces of code. First, the
      familiar kind that does not use
      <function>liftM</function>.</para>

    &Logger.hs:charClass_wordy;

    <para>Now we can eliminate the &bind; and anonymous function cruft
      with <function>liftM</function>.</para>

    &Logger.hs:charClass;

    <para>As with <function>fmap</function>, we often use
      <function>liftM</function> in infix form.  An easy way to read
      such an expression is <quote>apply the pure function on the left
	to the result of the monadic action on the
	right</quote>.</para>

    <para>So useful is <function>liftM</function> that
      <code>Control.Monad</code> defines several variants that combine
      longer chains of actions.  We can see one in the last clause of
      our <function>globToRegex'</function> function.</para>

    &Logger.hs:last;

    <para>The <function>liftM2</function> function that it uses is
      defined as follows.</para>

    &Logger.hs:liftM2;

    <para>It executes the first action, then the second, then combines
      their results using the pure function <varname>f</varname>, and
      wraps that result.  In addition to <function>liftM2</function>,
      the variants in <code>Control.Monad</code> go up to
      <function>liftM5</function>.</para>
  </sect1>

  <sect1>
    <title>Putting a few misconceptions to rest</title>

    <para>We've now seen enough examples of monads in action to have
      some feel for what's going on.  Before we continue, there are a
      few oft-repeated myths about monads that we're going to address.
      You're bound to encounter these assertions <quote>in the
	wild</quote>, so you might as well be prepared with a few good
      retorts.</para>

    <itemizedlist>
      <listitem>
	<para><emphasis>Monads are hard to understand.</emphasis>
	  We've already shown that monads <quote>fall out
	    naturally</quote> from several problems.  We've found that
	  the best key to understanding them is to explain several
	  concrete examples, then talk about what they have in
	  common.</para>
      </listitem>

      <listitem>
	<para><emphasis>Monads are only useful for I/O and imperative
	    coding.</emphasis> While we use monads for I/O in Haskell,
	  they're valuable for many other purposes besides.  We've
	  already used them for short-circuiting a chain of
	  computations, hiding complicated state, and logging.  Even
	  so, we've barely scratched the surface.</para>
      </listitem>

      <listitem>
	<para><emphasis>Monads are unique to Haskell.</emphasis>
	  Haskell is probably the language that makes the most
	  explicit use of monads, but people write them in other
	  languages, too, ranging from C++ to OCaml.</para>
      </listitem>

      <listitem>
	<para><emphasis>Monads are for controlling the order of
	    evaluation.</emphasis></para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>Building the Logger monad</title>
    
    <para>The definition of our <type>Logger</type> type is very
      simple.</para>

    &Logger.hs:Logger;

    <para>It's a two-tuple, where the first element is the result of
      an action, and the second is a list of messages logged while
      that action was run.</para>

    <para>We've wrapped the tuple in a &newtype; to make it a distinct
      type.  The <function>runLogger</function> function extracts the
      tuple from its wrapper.  The function that we're exporting to
      execute a logged action, <function>execLogger</function>, is
      just a synonym for <function>runLogger</function>.</para>

    &Logger.hs:execLogger;

    <para>Our <function>record</function> helper function creates a
      singleton list of the message we pass it.  The result of this
      action is <code>()</code>, so that's the value we put in the
      result slot.</para>

    <para>Let's begin our <code>Monad</code> instance with &return;,
      which is trivial: it logs nothing, and stores its input in the
      return slot of the tuple.</para>

    &Logger.hs:return;

    <para>Slightly more interesting is &bind;, which is the heart of
      the monad.  It combines an action and a monadic function to give
      a new result and a new log.</para>

    &Logger.hs:bind;

    <para>Let's spell out explicitly what is going on. We use
      <function>runLogger</function> to extract the result
      <varname>a</varname> from the action <varname>m</varname>, and
      we pass it to the monadic function <varname>k</varname>.  We
      extract the result <varname>b</varname> from that in turn, and
      put it into the result slot of the final action.  We concatenate
      the logs <varname>w</varname> and <varname>x</varname> to give
      the new log.</para>

    <sect2>
      <title>Sequential logging, not sequential evaluation</title>

      <para>Our definition of &bind; ensures that messages logged on
	the left will appear in the new log before those on the right.
	However, it says nothing about when the values
	<varname>a</varname> and <varname>b</varname> are evaluated:
	&bind; is lazy.</para>

      <para>Like most other aspects of a monad's behaviour, strictness
	is under the control of the monad's implementor.  It's not a
	constant that's shared by all monads.  Indeed, some monads
	come in multiple flavours, each with different levels of
	strictness.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>The Maybe monad</title>

    <para>The <type>Maybe</type> type is very nearly the simplest
      instance of <code>Monad</code>.  It represents a computation
      that might not produce a result.</para>

    &Maybe.hs:instance;

    <para>When we chain together a number of computations over
      <type>Maybe</type> using &bind; or &bind_;, and any returns
      <code>Nothing</code>, then we don't evaluate any of the
      remaining computations.</para>

    <para>Note, though, that the chain is not completely
      short-circuited.  Each &bind; or &bind_; in the chain will still
      match a <code>Nothing</code> on its left, and produce a
      <function>Nothing</function> on its right, all the way to the
      end.  It's easy to forget this point: when a computation in the
      chain fails, the subsequent production, chaining, and
      consumption of <code>Nothing</code> values is cheap at runtime,
      but it's not free.</para>

    <sect2>
      <title>Executing the Maybe monad</title>

      <para>A function suitable for executing the <type>Maybe</type>
	monad is <function>maybe</function>.  (Remember that
	<quote>executing</quote> a monad involves evaluating it and
	returning a result that's had the monad's type wrapper
	removed.)</para>

      &Maybe.hs:maybe;

      <para>Its first parameter is the value to return if the result
	is <code>Nothing</code>.  The second is a function to call on
	a result wrapped in the <code>Just</code> constructor; the
	result of that application is then returned.</para>

      <para>Since the <type>Maybe</type> ADT is so simple, it's about
	as common to simply pattern-match on a <type>Maybe</type>
	value as it is to call <function>maybe</function>.  Each one
	is more readable in different circumstances.</para>
    </sect2>

    <sect2>
      <title>Maybe at work, and good API design</title>

      <para>Here's an example of <type>Maybe</type> in use as a monad.
	Given a customer's name, we want to find the billing address
	of their mobile phone carrier.</para>

      &Carrier.hs:findCarrierBillingAddress;

      <para>Our first version is the dreaded ladder of code marching
	off the right of the screen, with many boilerplate &case;
	expressions.</para>

      &Carrier.hs:variation1;

      <para>The <code>Data.Map</code> module's
	<function>lookup</function> function has a monadic return
	type.</para>

      &carrier.ghci:lookup;

      <para>In other words, if the given key is present in the map,
	<function>lookup</function> injects it into the monad using
	&return;.  Otherwise, it calls &fail;.  This is a lovely piece
	of API design!  The behaviours of success and failure are
	automatically customised to our needs, based on the monad
	we're calling <function>lookup</function> from.  Better yet,
	<function>lookup</function> itself doesn't know or care what
	those behaviours are.</para>

      <para>The &case; expressions above typecheck because we're
	comparing the result of <function>lookup</function> against
	values of type <type>Maybe</type>.  But the code is horrible;
	let's make more sensible use of <type>Maybe</type>'s status as
	a monad.</para>

      &Carrier.hs:variation2;

      <para>If any of these lookups fails, the definitions of &bind;
	and &bind_; mean that the result of the function as a whole
	will be <code>Nothing</code>, just as it was for our first
	attempt that used &case; explicitly.</para>

      <para>This version is much tidier.  That being said, the
	&return; isn't necessary.  Stylistically, it makes the code
	look more regular, and perhaps more familiar to the eyes of an
	imperative programmer, but behaviourally it's redundant.
	Here's an equivalent piece of code.</para>

      &Carrier.hs:variation2a;

      <para>When we introduced maps, we mentioned in <xref
	linkend="hs.barcode.map.partial"/> that the type signatures of
	functions in the <code>Data.Map</code> module often make them
	awkward to partially apply.  The <function>lookup</function>
	function is a good example.  If we <function>flip</function>
	its arguments, we can write the function body as a
	one-liner.</para>
	  
      &Carrier.hs:variation3;

    </sect2>
  </sect1>

  <sect1>
    <title>The list monad</title>

    <para>While the <code>Maybe</code> type can represent either no
      value or one one, there are many situations where we might want
      to return more than one result.  Obviously, a list is well
      suited to this purpose. The type of a list suggests that we
      might be able to use it as a monad, because its type constructor
      has one free variable.  And sure enough, we can use a list as a
      monad.</para>

    <para>Rather than simply present the Prelude's <code>Monad</code>
      instance for the list type, let's try to figure out what the
      instance <emphasis>ought</emphasis> to look like.  This is easy
      to do: we'll look at the types of &bind; and &return;, and
      perform some substitutions, and see if we can use a few familiar
      list functions.</para>

    <para>The more obvious of the two functions is &return;.  We know
      that it takes a type <varname role="type">a</varname>, and wraps
      it in a type constructor <varname role="type">m</varname> to
      give the type <varname role="type">m a</varname>.  We also know
      that the type constructor here is <type>[]</type>.  Substituting
      this type constructor for the type variable <varname
	role="type">m</varname> gives us the type <type>[] a</type>
      (yes, this really is valid notation!), which we can rewrite in
      more familiar form as <type>[a]</type>.</para>

    <para>We now know that &return; for lists should have the type
      <code>a &larrow; [a]</code>.  There are only a few sensible
      possibilities for an implementation of this function.  It might
      return the empty list, a singleton list, or an infinite list.
      The most appealing behaviour, based on what we know so far about
      monads, is the singleton list: it doesn't throw information
      away, nor does it repeat it infinitely.</para>

    &ListMonad.hs:returnSingleton;

    <para>If we perform the same substitution trick on the type of
      &bind; as we did with &return;, we discover that it should have
      the type <code>[a] &rarrow; (a &rarrow; [b]) &rarrow;
      [b]</code>.  This seems close to the type of
      <function>map</function>.</para>

    &listmonad.ghci:map;

    <para>The ordering of the types in <function>map</function>'s
      arguments doesn't match, but that's easy to fix.</para>

    &listmonad.ghci:flipMap;

    <para>We've still got a problem: the second argument of <code>flip
	map</code> has the type <code>a &rarrow; b</code>, whereas the
      second argument of &bind; for lists has the type <code>a
      &rarrow; [b]</code>.  What do we do about this?</para>

    <para>Let's do a little more substitution and see what happens
      with the types.  The function <code>flip map</code> can return
      any type <varname role="type">b</varname> as its result.  If we
      substitute <varname role="type">[b]</varname> for <varname
	role="type">b</varname> in both places where it appears in
      <code>flip map</code>'s type signature, its type signature reads
      as <code>a &rarrow; (a &rarrow; [b]) &rarrow; [[b]]</code>.  In
      other words, if we map a function that returns a list over a
      list, we get a list of lists back.</para>

    &listmonad.ghci:flipMapApp;

    <para>Interestingly, we haven't really changed how closely our
      type signatures match.  The type of &bind; is <code>[a] &rarrow;
      (a &rarrow; [b]) &rarrow; [b]</code>, while that of <code>flip
	map</code> when the mapped function returns a list is
      <code>[a] &rarrow; (a &rarrow; [b]) &rarrow; [[b]]</code>.
      There's still a mismatch in one type term; we've just moved that
      term from the middle of the type signature to the end.  However,
      our juggling wasn't in vain: we now need a function that takes a
      <type>[[b]]</type> and returns a <type>[b]</type>, and one
      readily suggests itself in the form of
      <function>concat</function>.</para>

    &listmonad.ghci:concat;

    <para>The types suggest that we should flip the arguments to
      <function>map</function>, then <function>concat</function> the
      results to give a single list.</para>

    &listmonad.ghci:bind;

    <para>This is exactly the definition of &bind; for lists.</para>

    &ListMonad.hs:instance;

    <para>It applies <varname>f</varname> to every element in the list
      <varname>xs</varname>, and concatenates the results to return a
      single list.</para>

    <para>With our two core <code>Monad</code> definitions in hand,
      the implementations of the non-core definitions that remain,
      &bind_; and &fail;, ought to be obvious.</para>

    &ListMonad.hs:rest;

    <sect2>
      <title>Understanding the list monad</title>

      <para>The list monad is similar to a familiar Haskell tool, the
	list comprehension.  We can illustrate the similarity by
	computing the Cartesian product of two lists.  First, we'll
	write a list comprehension.</para>

      &CartesianProduct.hs:comprehensive;

      <para>For once, we'll use explicit notation for the monadic code
	instead of block notation.  This will highlight how
	structurally similar the monadic code is to the list
	comprehension.</para>

      &CartesianProduct.hs:monadic;

      <para>The only real difference is that the value we're
	constructing comes at the end of the sequence of expressions,
	instead of the beginning as in the list comprehension. Also,
	the results of the two functions are identical.</para>
      
      &cartesian.ghci:comparison;

      <para>It's easy to be baffled by the list monad early on, so
	let's walk through our monadic Cartesian product code again in
	more detail.  This time, we'll rearrange the function to use
	layout instead of explicit notation.</para>

      &CartesianProduct.hs:blockyDo;
      
      <para>For every element in the list <varname>xs</varname>, the
	rest of the function is evaluated once, with
	<varname>x</varname> bound to a different value from the list
	each time.  Then for every element in the list
	<varname>ys</varname>, the remainder of the function is
	evaluated once, with <varname>y</varname> bound to a different
	value from the list each time.</para>

      <para>What we really have here is a doubly nested loop!  This
	highlights an important fact about monads: you
	<emphasis>cannot</emphasis> predict how a block of monadic
	code will behave unless you know what monad it will execute
	in.</para>

      <para>We'll now walk through the code even more explicitly, but
	first let's get rid of the &do; notation, to make the
	underlying structure clearer.  We've indented the code a
	little unusually to make the loop nesting more obvious.</para>

      &CartesianProduct.hs:blockyPlain;

      <para>If <varname>xs</varname> has the value
	<code>[1,2,3]</code>, the two lines that follow are evaluated
	with <varname>x</varname> bound to <code>1</code>, then to
	<code>2</code>, and finally to <varname>3</varname>. If
	<varname>ys</varname> has the value <code>[True,
	  False]</code>, the final line is evaluated
	<emphasis>six</emphasis> times: once with <varname>x</varname>
	as <code>1</code> and <varname>y</varname> as
	<code>True</code>; again with <varname>x</varname> as
	<code>1</code> and <varname>y</varname> as <code>False</code>;
	and so on.  The &return; expression wraps each tuple in a
	single-element list.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.monads.do">
    <title>Desugaring of do blocks</title>

    <para>Haskell's &do; syntax is an example of <emphasis>syntactic
	sugar</emphasis>: it provides an alternative way of writing
      monadic code, without using &bind; and anonymous functions.
      <emphasis>Desugaring</emphasis> is the translation of syntactic
      sugar back to the core language.</para>

    <para>The rules for desugaring a &do; block are easy to follow. We
      can think of a compiler as applying these rules mechanically and
      repeatedly to a &do; block until no more &do; keywords
      remain.</para>

    <para>A &do; keyword followed by a single action is translated to
      that action by itself.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation1;</entry>
	    <entry>&Do.hs:translated1;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>A &do; keyword followed by more than one action is
      translated to the first action, then &bind_;, followed by a &do;
      keyword and the remaining actions.  When we apply this rule
      repeatedly, the entire &do; block ends up chained together by
      applications of &bind_;.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation2;</entry>
	    <entry>&Do.hs:translated2;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>The &larrow; notation has a translation that's worth paying
      close attention to.  On the left of the &larrow; is a normal
      Haskell pattern. This can be a single variable or something more
      complicated.  A guard expression is not allowed.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation3;</entry>
	    <entry>&Do.hs:translated3;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>This pattern is translated into a &let; binding that
      declares a local function with a unique name (we're just using
      <varname>f</varname> as an example above).  The action on the
      right of the &larrow; is then chained with this function using
      &bind;.</para>

    <para>What's noteworthy about this translation is that if the
      pattern match fails, the local function calls the monad's &fail;
      implementation. Here's an example using the <type>Maybe</type>
      monad.</para>

    &Do.hs:robust;

    <para>The &fail; implementation in the <type>Maybe</type> monad
      simply returns <code>Nothing</code>.  If the pattern match in
      the above function fails, we thus get <code>Nothing</code> as
      our result.</para>

    &do.ghci:robust;

    <para>Finally, when we write a &let; expression in a &do; block,
      we can omit the usual &in; keyword.  Subsequent actions in the
      block must be lined up with the &let; keyword.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation4;</entry>
	    <entry>&Do.hs:translated4;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2>
      <title>Monads as a programmable semicolon</title>

      <para>Back in <xref linkend="hs.funcstypes.block"/>, we
	mentioned that layout is the norm in Haskell, but it's not
	<emphasis>required</emphasis>.  We can write a &do; block
	using explicit structure instead of layout.</para>

      <informaltable role="comparison">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>&Do.hs:semicolon;</entry>
	      <entry>&Do.hs:semicolonTranslated;</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Even though this use of explicit structure is rare, the
	fact that it uses semicolons to separate expressions has given
	rise to an apt slogan: monads are a kind of
	<quote>programmable semicolon</quote>, because the behaviours
	of &bind_; and &bind; are different in each monad.</para>
    </sect2>

    <sect2 id="hs.monads.do.avoid">
      <title>Why go sugar-free?</title>

      <para>When we write &bind; explicitly in our code, it reminds us
	that we're calling stitching functions together using
	combinators, not simply sequencing actions.</para>

      <para>As long as you feel like a novice with monads, we think
	you should prefer to explicitly write &bind; over the
	syntactic sugar of &do; notation.  The repeated reinforcement
	of what's really happening seems, for many programmers, to
	help to keep things clear. (It can be easy for an imperative
	programmer to relax a little too much from exposure to the
	<type>IO</type> monad, and assume that a &do; block means
	nothing more than a simple sequence of actions.)</para>

      <para>Once you're feeling more familiar with monads, you can
	choose whichever style seems more appropriate for writing a
	particular function.  Indeed, when you read other people's
	monadic code, you'll see that it's unusual, but by no means
	rare, to mix <emphasis>both</emphasis> &do; notation and
	&bind; in a single function.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Monads and functors</title>

    <para>fmap! join!</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
