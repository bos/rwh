<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.monads" revision="unpublished">
  <title>Monads</title>

  <sect1>
    <title>Introduction</title>

    <para>In <xref linkend="hs.io"/>, we talked about the
      <type>IO</type> monad, but we intentionally kept the discussion
      narrowly focused on how to communicate with the outside world.
      We didn't discuss what a monad <emphasis>is</emphasis>.</para>

    <para>Monads have a reputation of being abstract and difficult to
      understand. If you've heard such concerns, please put aside for
      a while any doubts you might have.  Concerning abstraction, we've
      already seen in <xref linkend="hs.io"/> that the <type>IO</type>
      monad is easy to work with.  Notational differences aside,
      writing code in the <type>IO</type> monad isn't much different
      from coding in any other imperative language.</para>

    <para>As for difficulty, we quietly infiltrated monads into
      several earlier chapters of this book, when we had practical
      problems to solve.  What we aim to show you is that, far from
      being difficult to understand, a monad is often an
      <emphasis>obvious</emphasis> and <emphasis>practical</emphasis>
      tool to help solve a problem.  We'll define a few monads in this
      chapter, to show how easy it is.</para>

    <para>In this chapter, we'll reveal where we hid those monads,
      explain what they really are, and discuss each of the most
      widely used monads.</para>
  </sect1>

  <sect1>
    <title>Revisiting earlier code examples</title>

    <sect2>
      <title>Maybe chaining</title>

      <para>Let's take another look at the
	<function>parseP5</function> function that we wrote in <xref
	  linkend="hs.binary"/>.</para>

      &PNM.hs:parseP5.noid;

      <para>That function threatened to march off the right side of
	the page if it got much longer.  We brought the staircasing
	under control using the <function>(&gt;&gt;?)</function>
	function.</para>

      &PNM.hs:bind.noid;

      <para>We carefully chose the type of
	<function>(&gt;&gt;?)</function> to let us chain together
	functions that return <type>Maybe</type>.  So long as the
	result type of one function matches the parameter of the next,
	we can chain functions returning <type>Maybe</type> together
	indefinitely.  The body of <function>(&gt;&gt;?)</function>
	hides the details of whether the functions we pass in are
	actually called.</para>
    </sect2>

    <sect2>
      <title>Implicit state</title>

      <para>Useful as <function>(&gt;&gt;?)</function> was for
	cleaning up the structure of <function>parseP5</function>, we
	had to incrementally consume pieces of a string as we parsed
	it.  This forced us to pass the current value of the string
	down our chain of <type>Maybe</type>s, wrapped up in a tuple.
	Each function in the chain put a result into one element of
	the tuple, and the unconsumed remainder of the string into the
	other.</para>

      &PNM.hs:parseP5_take2.noid;

      <para>Once again, we were faced with a pattern of repeated
	behaviour: consume some string, return a result, and return
	the remaining string for the next function to consume.
	However, this pattern was more insidious: if we wanted to pass
	another piece of information down the chain, we'd have to
	modify nearly every element of the chain, turning each
	two-tuple into a three-tuple!</para>

      <para>We addressed this by moving the responsibility for
	managing the current piece of string out of the individual
	functions in the chain, and into the function that we used to
	chain them together.</para>

      &Parse.hs:bind.noid;

      <para>We also hid the details of the parsing state in the
	<type>ParseState</type> type.  Even the
	<function>getState</function> and
	<function>putState</function> functions don't inspect the
	parsing state, so any modification to <type>ParseState</type>
	will have no effect on any existing code.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Looking for shared patterns</title>

    <para>When we look at the above examples in detail, they don't
      seem to have much in common.  Obviously, they're both concerned
      with chaining functions together, and with hiding details to let
      us write tidier code.  However, let's take a step back and
      consider them in <emphasis>less</emphasis> detail.</para>

    <para>First, let's look at the type definitions.</para>

    &Maybe.hs:Maybe;

    &Parse.hs:Parse;

    <para>The common feature of these two types is that each has a
      single free type variable on the left of the definition, which
      is used somewhere on the right.</para>

    <para>Next, we'll examine the chaining functions that we wrote for
      the two types.</para>

    &monadness.ghci:Maybe;

    &monadness.ghci:Parse;

    <para>These functions have strikingly similar types.  If we were
      to turn those type constructors into a type variable, we'd end
      up with a single more abstract type.</para>

    &Maybe.hs:chain;

    <para>Finally, in each case we have a function that takes a
      <quote>plain</quote> value, and <quote>injects</quote> it into
      the target type.  For <type>Maybe</type>, this function is
      simply the value constructor <code>Just</code>, but the injector
      for <type>Parse</type> is more complicated.</para>

    &Parse.hs:identity;

    <para>Again, it's not the details or complexity that we're
      interested in, it's the fact that each of these types has this
      <quote>injector</quote> function.</para>

    &Maybe.hs:inject;

    <para>It is <emphasis>exactly</emphasis> these three properties,
      and a few rules about how we can use them together, that define
      a monad in Haskell.  Let's revisit the above list in condensed
      form.</para>

    <itemizedlist>
      <listitem>
	<para>A type <varname role="type">m</varname> with one free
	  type variable <varname role="type"></varname>.</para>
      </listitem>
      <listitem>
	<para>A function of type <type>m a -> (a -> m b) -> m b</type>
	  for chaining the output of one function into the input of
	  another.</para>
      </listitem>
      <listitem>
	<para>A function of type <type>a -> m a</type> for injecting a
	  normal value into the chain, i.e. it wraps a type
	  <type>a</type> with the type constructor
	  <type>m</type>.</para>
      </listitem>
    </itemizedlist>

    <para>The properties that make the <type>Maybe</type> type a monad
      are its type constructor <type>Maybe a</type>, our chaining
      function <function>(&gt;&gt;?)</function>, and the injector
      function <function>Just</function>.</para>

    <para>For <type>Parse</type>, the corresponding properties are the
      type constructor <type>Parse a</type>, the chaining function
      <function>(==&gt;)</function>, and the injector function
      <function>identity</function>.</para>

    <para>We have intentionally said nothing about how the chaining
      and injection functions of a monad should behave, and that's
      because it very nearly doesn't matter.  In fact, monads are
      ubiquitous in Haskell code precisely because they are so simple:
      many common programming patterns have a monadic structure.</para>
  </sect1>

  <sect1>
    <title>The Monad typeclass</title>

    <para>We can capture the notions of chaining and injection, and
      the types we want them to have, in a Haskell typeclass.  The
      standard Prelude already defines just such a typeclass, named
      <code>Monad</code>.</para>

    &Maybe.hs:Monad;

    <para>Here, &bind; is our chaining function.  We've already been
      introduced to it in <xref linkend="hs.io.bind"/>.  It's often
      referred to as <quote>bind</quote>, as it binds two adjacent
      functions together so that one uses the result of the
      other.</para>

    <para>Our injection function is &return;.  As we noted in <xref
      linkend="hs.io.return"/>, the choice of the name &return; is a
      little unfortunate.  That name is widely used in imperative
      languages, where it has a fairly well understood meaning.  In
      Haskell, its behaviour is much less constrained.  In particular,
      calling &return; in the middle of a chain of functions won't
      cause the chain to exit early.  It's more helpful to remember it
      as <quote>inject</quote>.</para>

    <para>While &bind; and &return; are the core functions of the
      <code>Monad</code> typeclass, it also defines two other
      functions.  The first is &bind_;.  Like &bind;, it performs
      chaining, but it ignores the value on the left.</para>

    &Maybe.hs:bind_;

    <para>We use this function for sequencing, when we want to perform
      actions in a certain order, but don't care what the result of
      one is.  As we show above, the default implementation for
      &bind_; is in terms of <function>&bind;</function>.</para>

    <para>The second non-core <code>Monad</code> function is &fail;,
      which takes an error message and does something to make the
      chain of functions fail.</para>

    &Maybe.hs:fail;

    <warning>
      <title>Beware of fail</title>

      <para>Many <code>Monad</code> instances don't override the
	default implementation of &fail; that we show here, which
	means that &fail; calls <function>error</function>.  Calling
	<function>error</function> is usually highly undesirable, so
	don't call &fail; unless you know that you're using a monad
	that implements it to do something more sensible.</para>
    </warning>

    <para>To revisit the parser that we developed in <xref
	linkend="hs.binary"/>, here is its <code>Monad</code>
      instance.</para>

    &Parse.hs:Monad;

  </sect1>

  <sect1>
    <title>Building a monad: show your work!</title>

    <para>In our introduction to monads, we showed how some
      pre-existing code was already monadic in form.  Now that we are
      beginning to grasp what a monad is, and we've seen the
      <code>Monad</code> typeclass, let's build a monad with
      foreknowledge of what we're doing.</para>

    <para>Pure Haskell code is wonderfully clean to write, but of
      course it can't perform I/O.  Sometimes, though, we'd like to
      have a record of decisions we took.  Let's develop a small
      library to help with this.</para>

    <para>Recall the <function>globToRegex</function> function that we
      developed in <xref linkend="hs.glob.translate"/>.  Let's modify
      it so that it keeps a record of each of the special pattern
      sequences that it translates.  To do this, we'll add a
      <code>Logger</code> type constructor to our result type.</para>

    &Logger.hs:globToRegex.type;

    <para>Before we get into the details of the <type>Logger</type>
      monad, we'll show how we use it.</para>

    <sect2>
      <title>Information hiding</title>

      <para>We'll intentionally keep the internals of the
	<type>Logger</type> module abstract, and provide our users
	with a simple interface.</para>

      &Logger.hs:module;

      <para>Hiding the details like this grants us considerable
	flexibility in how we implement our monad.</para>

      <para>The <type>Logger</type> type is purely a
	<emphasis>type</emphasis> constructor.  We don't export the
	<emphasis>value</emphasis> constructor that a user would need
	to create a value of this type.  All they can do is write type
	signatures.</para>

      <para>The <type>Log</type> type is just a synonym, to make a few
	signatures more readable.</para>

      &Logger.hs:Log;

      <para>To evaluate a logged action, users call the
	<function>execLogger</function> function.  This returns both
	the result of an action and whatever was logged while the
	result was being computed.</para>

      &Logger.hs:execLogger.type;

      <para>Most monads have an <function>execLogger</function>-like
	function, which is responsible for starting off execution of
	the monad and extracting its result.  The notable exception to
	this rule is <type>IO</type>.</para>

      <para>When executing inside a <type>Logger</type> action, user
	code calls <function>record</function> to record
	something.</para>

      &Logger.hs:record.type;

      <para>Again, most monads provide helper functions that add
	functionality on top of the base <code>Monad</code>
	typeclass.</para>

      <para>Our module also defines the <code>Monad</code> instance
	for the <type>Logger</type> type.  These definitions are all
	that a client module needs in order to be able to use this
	monad.</para>
    </sect2>

    <sect2>
      <title>Using the Logger monad</title>

      <para>Here's how we kick off our glob-to-regexp conversion
	inside the <type>Logger</type> monad.</para>

      &Logger.hs:rooted;

      <para>Remember the type of &bind;; it extracts the value on the
	left from its <type>Logger</type> wrapper, and passes the
	unwrapped value to the function on the right.  The function on
	the right must, in turn, wrap <emphasis>its</emphasis> result
	with the <type>Logger</type> wrapper.  This is exactly what
	&return; does.</para>

      &logger.ghci:bind.type;

      <para>There are a few coding style issues worth mentioning here.
	The body of the function starts on the line after its name. By
	doing this, we gain some horizontal white space.  We've also
	<quote>hung</quote> the parameter of the anonymous function at
	the end of the line. This is common practice in monadic
	code.</para>

      <para>Even when we write a function that does almost nothing, we
	must call <function>return</function> to wrap the result with
	the correct type.</para>

      &Logger.hs:eof;

      <para>When we call <function>record</function> to save a log
	entry, we use &bind_; instead of &bind; to chain it with the
	following action.</para>

      &Logger.hs:question;

      <para>Recall that this is a variant of &bind; that ignores the
	result on the left.  We know that the result of
	<function>record</function> will always be <code>()</code>, so
	there's no point in capturing it.</para>

      <para>We can use &do; notation, which we first encountered in
	<xref linkend="hs.io.bind"/>, to somewhat tidy up our
	code.</para>

      &Logger.hs:asterisk;

      <para>The choice of &do; notation versus explicit &bind; with
	anonymous functions is mostly a matter of taste. There is one
	significant difference between the two, though, which we'll
	return to in <xref linkend="hs.monads.do"/>.</para>

      <remark>huh?</remark>
    </sect2>
  </sect1>

  <sect1>
    <title>Putting a few misconceptions to rest</title>

    <para>We've now seen enough examples of monads in action to have a
      feeling for what's going on.  Before we continue, there are a
      few oft-repeated myths about monads that we're going to
      address.  You're bound to encounter these assertions <quote>in
      the wild</quote>, so you might as well be prepared with a few
      good retorts.</para>

    <itemizedlist>
      <listitem>
	<para><emphasis>Monads are only useful for I/O.</emphasis>
	  While we use monads for I/O in Haskell, they're valuable for
	  many other purposes besides.  We've already used them for
	  short-circuiting a chain of computations, hiding complicated
	  state, and logging.  Even so, we've barely scratched the
	  surface.</para>
      </listitem>

      <listitem>
	<para><emphasis>Monads are unique to Haskell.</emphasis>
	  Haskell is probably the language that makes the most
	  explicit use of monads, but people write them in other
	  languages, too, ranging from C++ to OCaml.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="hs.monads.do">
    <title>Desugaring of do blocks</title>
    <para>Blorp.</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
