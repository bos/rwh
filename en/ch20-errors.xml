<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="errors" revision="alpha;beta">
  <title>Error handling</title>

  <para id="x_xy">
    Error handling is one of the most important&emdash;and overlooked&emdash;topics for programmers, regardless of the language used.  In
    Haskell, you will find two major types of error handling employed:
    "pure" error handling and exceptions.
  </para>
  <para id="x_yy">
    When we speak of "pure" error handling, we are referring to
    algorithms that do not require anything from the &IO; monad.
    We can often implement error handling for them by simply using
    Haskell's expressive data type system to our advantage.  Haskell
    also has an exception system.  Due to the complexities of lazy
    evaluation, exceptions in Haskell can be raised anywhere, but only
    caught within the &IO; monad.  In this chapter, we'll consider
    both.
  </para>
  <sect1 id="errors.nonexception">
    <title>Error Handling with Data Types</title>
    <para id="x_zy">
      Let's begin our discussion of error handling with a very simple
      function.  Let's say that we wish to perform division on a
      series of numbers.  We have a constant numerator, but wish to
      vary the denominator.  We might come up with a function like
      this:
    </para>
    &divby1.hs:all;
    <para id="x_Az">
      Very simple, right?  We can play around with this a bit in
      &ghci;:
    </para>
    &divby1.ghci:ex1;
    <para id="x_Bz">
      This behaves as expected: <literal>50 / 1</literal> is
      <literal>50</literal>, <literal>50 / 2</literal> is
      <literal>25</literal>, and so forth.
      <footnote><para id="x_Cz">
          We're using integral division here, so <literal>50 /
            8</literal> shows as <literal>6</literal> instead of
      <literal>6.25</literal>.  We're not using floating-point
      arithmetic in this example because division by zero with a
          &Double; produces the special value
      <literal>Infinity</literal> rather than an error.
        </para>
      </footnote>  This even worked with the infinite list
      <literal>[1..]</literal>.
      What happens if we sneak a
      <literal>0</literal> into our list somewhere?
    </para>
    &divby1.ghci:ex2;
    <para id="x_Dz">
      Isn't that interesting?  &ghci; started displaying the output,
      then stopped with an exception when it got to the zero.  That's
      lazy evaluation at work&emdash;it calculated results as needed.
    </para>
    <para id="x_Ez">
      As we will see later in this chapter, in the absence of an
      explicit exception handler, this exception will crash the
      program.  That's obviously not desirable, so let's consider
      better ways we could indicate an error in this pure function.
    </para>
    <sect2 id="errors.maybe">
      <title>Use of Maybe</title>
      <para id="x_Fz">
        One immediately-recognizable easy way to indicate failure is
        to use &Maybe;.<footnote><para id="x_Gz">For an introduction to &Maybe;,
        refer to <xref linkend="deftypes.morecontrolled"/>.</para>
        </footnote>  Instead of just returning a list and raising
        an exception on failure, we can return &Nothing; if the input
        list contained a zero anywhere, or &Just; with the results
        otherwise.  Here's an implementation of such an algorithm:
      </para>
      &divby2.hs:all;
      <para id="x_Hz">
        If you try it out in &ghci;, you'll see that it works:
      </para>
      &divby2.ghci:ex1;
      <para id="x_Iz">
        The function that calls <literal>divBy</literal> can now use a
        <literal>case</literal> statement to see if the call was
        successful, just as <literal>divBy</literal> does when it
        calls itself.
      </para>
      <sect3 id="errors.maybe.laziness">
        <title>Loss and Preservation of Laziness</title>
        <para id="x_Jz">
          The use of &Maybe; was convenient, but has come at a cost.
          <literal>divBy</literal> can no longer handle infinite lists
          as input.  Since the result is <literal>Maybe [a]</literal>,
          the entire input list must be examined before we can be sure
          that we won't be returning <literal>Nothing</literal> due to a
          zero somewhere in it.  You can verify this is the case by
          attempting one of our earlier examples:
        </para>
        &divby2.ghci:ex2;
        <para id="x_Kz">
          Note that you don't start seeing partial output here; you get
          <emphasis>no</emphasis> output.  Notice that at each step in
          <literal>divBy</literal> (except for the case of an empty
          input list or a zero at the start of the list), the results
          from every subsequent element must be known before the results
          from the current element can be known.  Thus this algorithm
          can't work on infinite lists, and it is also not very
          space-efficient for large finite lists.
        </para>
        <para id="x_Lz">
          Having said all that, &Maybe; is often a fine choice.  In this
          particular case, we don't know whether there will be a problem
          until we get into evaluating the entire input.  Sometimes we
          know of a problem up front.  For instance, saying
          <literal>tail []</literal> in &ghci; produces an exception.
          We could easly write an infinite-capable &tail; that doesn't
          have this problem:
        </para>
        &safetail.hs:all;
        <para id="x_Mz">
          This simply returns &Nothing; if given an empty input list,
          or &Just; with the result for anything else.  Since we only
          have to make sure the list is non-empty before knowing
          whether or not we have an error, using &Maybe; here doesn't
          reduce our laziness. We can test this out in &ghci; and see how it compares with
          regular &tail;:
        </para>
        &safetail.ghci:ex1;
        <para id="x_Nz">
          Here, we can see our <literal>safeTail</literal> performed
          as expected.  But what about infinite lists?  We don't want
          to print out an infinite number of results, so we can test
          with <literal>take 5 (tail [1..])</literal> and a similar
          construction with <literal>safeTail</literal>:
        </para>
        &safetail.ghci:ex2;
        <para id="x_Oz">
          Here you can see that both &tail; and
          <literal>safeTail</literal> handled infinite lists just
          fine.  Note that we were able to deal better with an empty
          input list; instead of raising an exception, we decided to
          return &Nothing; in that situation.  We were able to achieve
          error handling at no expense to laziness.
        </para>
        <para id="x_Pz">
          But how do we apply this to our <literal>divBy</literal>
          example?  Let's consider the situation there: failure is a
          property of an individual bad input, not of the input list
          itself.  How about making failure a property of an
          individual output element, rather than the output list
          itself?  That is, instead of a function of type <literal>a
          -> [a] -> Maybe [a]</literal>, instead we will have
          <literal>a -> [a] -> [Maybe a]</literal>.  This will have
          the benefit of preserving laziness, plus the caller will be
          able to determine exactly where in the list the problem was
         &emdash;or even just filter out the problem results if desired.
          Here's an implementation:
        </para>
        &divby3.hs:all;
        <para id="x_Qz">
          Take a look at this function.  We're back to using &map;,
          which is a good thing for both laziness and simplicity.  We
          can try it out in &ghci; and see that it works for finite
          and infinite lists just fine:
        </para>
        &divby3.ghci:ex1;
        <para id="x_Rz">
          We hope that you can take from this discussion the point
          that there is a distinction between the input not being
          well-formed (as in the case of <literal>safeTail</literal>)
          and the input potentially containing some bad data, as in
          the case of <literal>divBy</literal>.  These two cases can
          often justify different handling of the results.
        </para>
      </sect3>
      <sect3 id="errors.maybe.monad">
        <title>Usage of the Maybe Monad</title>
        <para id="x_Sz">
          Back in <xref linkend="errors.maybe"/>, we had an example
          program named <literal>divby2.hs</literal>.  This example
          didn't preserve laziness, but returned a value of type
          <literal>Maybe [a]</literal>.  The exact same algorithm
          could be expressed using a monadic style.  For more
          information and important background on monads, please refer
          to <xref linkend="monads"/>.  Here's our new monadic-style
          algorithm:
        </para>
        &divby4.hs:all;
        <para id="x_Tz">
          The &Maybe; monad has made the expression of this algorithm
          look nicer.  For the &Maybe; monad, &return; is the same as
          &Just;, and <literal>fail _ = Nothing</literal>, so our
          error explanation string is never actually seen anywhere.
          We can test this algorithm with the same tests we used
          against <literal>divby2.hs</literal> if we want:
        </para>
        &divby4.ghci:ex1;
        <para id="x_Uz">
          The code we wrote actually isn't specific to the &Maybe;
          monad.  By simply changing the type, we can make it work for
          <emphasis>any</emphasis> monad.  Let's try it:
        </para>
        &divby5.hs:all;
        <para id="x_Vz">
          The function <literal>divByGeneric</literal> contains the
          same code as <literal>divBy</literal> did before; we just
          gave it a more general type.  This is, in fact, the type
          that &ghci; infers if no type would be given.  We also
          defined a convenience function <literal>divBy</literal> with
          a more specific type.
        </para>
        <para id="x_Wz">
          Let's try this out in &ghci;.
        </para>
        &divby5.ghci:ex1;
        <para id="x_Xz">
          The first two examples both produce the same output we see
          before.  Since <literal>divByGeneric</literal> doesn't have
          a specific return type, we must either give one or let the
          interpreter infer one from the environment.  If we don't
          give a specific return type, &ghci; infers the &IO; monad.
          You can see that in the third and fourth examples.  The &IO;
          monad converts &fail; into an exception, as you can see with
          the fourth example.
        </para>
        <para id="x_Yz">
          The <literal>Control.Monad.Error</literal> module in the
          <literal>mtl</literal> package makes <literal>Either String</literal> into a monad
          as well.  If you use &Either;, you can get a pure result
          that preserves the error message, like so:
        </para>
        &divby5.ghci:ex2;
        <para id="x_Zz">
          This leads us into our next topic of discussion: using
          &Either; for returning error information.
        </para>
      </sect3>
    </sect2>
    <sect2 id="errors.either">
      <title>Use of Either</title>
      <para id="x_az">
        The &Either; type is similar to the &Maybe; type, with one key
        difference: it can carry attached data both for an error and a
        success.  <footnote><para id="x_bz">For more information on &Either;,
        refer to <xref linkend="glob.errapi"/>.</para>
        </footnote>  Although the language imposes no restrictions, by
        convention, a function returning an &Either; uses a &Left;
        return value to indicate an error, and &Right; to indicate
        success.  If it helps you remember, you can think of getting
    the &Right; answer.  We can start with our <literal>divby2.hs</literal>
        example from the earlier section on &Maybe; and adapt it to
        work with &Either;:
      </para>
      &divby6.hs:all;
      <para id="x_cz">
        This code is almost identical to the &Maybe; code; we've
        substituted &Right; for every &Just;.  &Left; compares to
        &Nothing;, but now it can carry a message.  Let's check it out
        in &ghci;:
      </para>
      &divby6.ghci:ex1;
      <sect3>
        <title>Custom Data Types for Errors</title>
        <para id="x_dz">
          While a &String; indicating the cause of an error
          may be useful to humans down the road, it's often helpful to
          define a custom error type that we can use to programmatically
          decide on a course of action based upon exactly what the
          problem was.  For instance, let's say that for some reason,
          besides 0, we also don't want to divide by 10 or 20.  We could
          define a custom error type like so:
        </para>
        &divby7.hs:all;
        <para id="x_ez">
          Now, in the event of an error, the &Left; data could be
          inspected to find the exact cause.  Or, it could simply be
          printed out with &show;, which will generate a reasonable idea
          of the problem as well.  Here's this function in action:
        </para>
        &divby7.ghci:ex1;
        <warning>
          <para id="x_fz">
            All of these &Either; examples suffer from the lack of
            laziness that our early &Maybe; examples suffered from.  We
            address that with an exercise question at the end of this
            chapter.
          </para>
        </warning>
      </sect3>
      <sect3>
        <title>Monadic Use of Either</title>
        <para id="x_gz">
          Back in <xref linkend="errors.maybe.monad"/>, we showed you
          how to use &Maybe; in a monad.  &Either; can be used in a
          monad too, but can be slightly more complicated.  The reason
          is that &fail; is hard-coded to accept only a &String; as
          the failure code, so we have to have a way to map such a
          string into whatever type we used for &Left;.  As you saw
          earlier, <literal>Control.Monad.Error</literal> provides
          built-in support for <literal>Either String a</literal>,
          which involves no mapping for the argument to &fail;.
          Here's how we can set up our example to work with &Either;
          in the monadic style:
        </para>
        &divby8.hs:all;
        <para id="x_hz">
          Here, we needed to turn on the
          <literal>FlexibleContexts</literal> language extension in
          order to provide the type signature for
          <literal>divByGeneric</literal>.  The
          <literal>divBy</literal> function works exactly the same as
          before.  For <literal>divByGeneric</literal>, we make
          <literal>divByError</literal> a member of the
          <literal>Error</literal> class, by defining what happens
          when someone calls <literal>fail</literal> (the
          <literal>strMsg</literal> function).  We also convert
          &Right; to &return; and &Left; to
          <literal>throwError</literal> to enable this to be generic.
        </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="errors.exceptions">
    <title>Exceptions</title>
    <para id="x_U11">
      Exception handling is found in many programming languages,
      including Haskell.  It can be useful because, when a problem
      occurs, it can provide an easy way of handling it, even if it
      occurred several layers down through a chain of function calls.
      With exceptions, it's not necessary to check the return value of
      every function call to check for errors, and take care to
      produce a return value that reflects the error, as C programmers
      must do.
      In Haskell, thanks to monads and the &Either; and &Maybe; types,
      you can often achieve the same effects in pure code without
      the need to use exceptions and exception handling.  
    </para>
    <para id="x_V11">
      Some problems&emdash;especially those involving I/O&emdash;call for
      working with exceptions.  In Haskell, exceptions may be raised
      from any location in the program.  However, due to the
    unspecified evaluation order, they can only be caught in the &IO; monad.  Haskell
      exception handling doesn't involve special syntax as it does in
      Python or Java.  Rather, the mechanisms to catch and handle
      exceptions are&emdash;surprise&emdash;functions.
    </para>
    <sect2 id="errors.exceptions.firststeps">
      <title>First Steps with Exceptions</title>
      <para id="x_W11">
        In the <literal>Control.Exception</literal> module, various
        functions and types relating to exceptions are defined.  There
        is an &Exception; type defined there; all exceptions are of
        type &Exception;.  There are also functions for catching and
        handling exceptions.  Let's start by looking at &try;, which
        has type <literal>IO a -&gt; IO (Either Exception
        a)</literal>.  This wraps an &IO; action with exception
        handling.  If an exception was raised, it will return a &Left;
        value with the exception; otherwise, a &Right; value with the
        original result.  Let's try this out in &ghci;.  We'll first
        trigger an unhandled exception, and then try to catch it.
      </para>
      &exc.ghci:try1;
      <para id="x_X11">
        Notice that no exception was
        raised by the &let; statements.  That's to be expected due to
        lazy evaluation; the division by zero won't be attempted until
        it is demanded by the attempt to print out
        <literal>x</literal>.  Also, notice that there were two lines
        of output from <literal>try (print y)</literal>.  The first
        line was produced by <literal>print</literal>, which displayed
        the digit 5 on the terminal.  The second was produced by
        &ghci;, which is showing you that <literal>print y</literal>
        returned <literal>()</literal> and didn't raise an exception.
      </para>
    </sect2>
    <sect2 id="errors.exceptions.lazy">
      <title>Laziness and Exception Handling</title>
      <para id="x_Y11">
        Now that you know how &try; works, let's try another
        experiment.  Let's say we want to catch the result of
        <literal>try</literal> for future evaluation, so we can handle
        the result of division.  Perhaps we
        would do it like this:
      </para>
      &exc.ghci:try2;
      <para id="x_Z11">
        What happened here?  Let's try to piece it together, and
        illustrate with another attempt:
      </para>
      &exc.ghci:try3;
      <para id="x_a11">
        As before, assigning &undefined; to <literal>z</literal> was
        not a problem.  The key to this puzzle, and to the division
        puzzle, lies with lazy evaluation.  Specifically, it lies with
        &return;, which does not force the evaluation of its argument;
        it only wraps it up.  So, the result of <literal>try (return
        undefined)</literal> would be <literal>Right
        undefined</literal>.  Now, &ghci; wants to display this result
        on the terminal.  It gets as far as printing out
        <literal>"Right "</literal>, but you can't print out
        &undefined; (or the result of division by zero).  So when you
        see the exception message, it's coming from &ghci;, not your
        program.
      </para>
      <para id="x_b11">
        This is a key point.  Let's think about why our earlier
        example worked and this one didn't.  Earlier, we put
        <literal>print x</literal> inside &try;.  Printing the value
        of something, of course, requires it to be evaluated, so the
        exception was detected at the right place.  But simply using
        &return; does not force evaluation.  To solve this problem,
        the <literal>Control.Exception</literal> module defines the
        &evaluate; function.  It behaves just like &return;, but
        forces its argument to be evaluated immediately.  Let's try
        it:
      </para>
      &exc.ghci:try4;
      <para id="x_c11">
        There, that's what was expected.  This worked for both
        &undefined; and our division by zero example.
      </para>
      <tip>
        <para id="x_d11">
          Remember: whenever you are trying to catch exceptions raised
          by pure code, use &evaluate; instead of &return; inside your
          exception-catching function.
        </para>
      </tip>
    </sect2>

    <sect2 id="errors.exceptions.handle">
      <title>Using handle</title>
      <para id="x_e11">
        Often, you may wish to perform one action if a piece of code
        completes without an exception, and a different action
        otherwise.  For situations like this, there's a function
        called &handle;.  This function has type <literal>(Exception
        -&gt; IO a) -&gt; IO a -&gt; IO a</literal>.  That is, it
        takes two parameters: the first is a function to call in the
        event there is an exception while performing the second.
        Here's one way we could use it:
      </para>
      &exc.ghci:handle1;
      <para id="x_f11">
        This way, we can print out a nice message if there is an error
        in the calculations.  It's nicer than having the program crash
        with a division by zero error, for sure.
      </para>
    </sect2>
        

    <sect2 id="errors.exceptions.selective">
      <title>Selective Handling of Exceptions</title>
      <para id="x_g11">
        One problem with the above example is that it prints
        <literal>"Error calculating result"</literal> for
        <emphasis>any</emphasis> exception.  There may have been an
        exception other than a division by zero exception.  For
        instance, there may have been an error displaying the output,
        or some other exception could have been raised by the pure
        code.
      </para>
      <para id="x_h11">
        There's a function &handleJust; for these situations.  It
        lets you specify a test to see whether you are interested in a
        given exception.  Let's take a look:
      </para>
      &hj1.hs:all;
      <para id="x_i11">
        <literal>catchIt</literal> defines a function that decides
        whether or not we're interested in a given exception.  It
        returns &Just; if so, and &Nothing; if not.  Also, the value
        attached to &Just; will be passed to our handler.  We can now
        use <literal>safePrint</literal> nicely:
      </para>
      &exc.ghci:handleJust1;
      <para id="x_j11">
        The <literal>Control.Exception</literal> module also presents
        a number of functions that we can use as part of the test in 
        &handleJust; to narrow down the kinds of exceptions we care
        about.  For instance, there is a function
        <literal>arithExceptions</literal> of type <literal>Exception
        -&gt; Maybe ArithException</literal> that will pick out any
        <literal>ArithException</literal>, but ignore any other one.
        We could use it like this:
      </para>
      &hj2.hs:all;
      <para id="x_k11">
        In this way, we can catch all types of
        <literal>ArithException</literal>, but still let other
        exceptions pass through unmodified and uncaught.  We can see
        it work like so:
      </para>
      &exc.ghci:handleJust2;
      <para id="x_l11">
        Of particular interest, you might notice the
        <literal>ioErrors</literal> test, which corresponds to the
        large class of I/O-related exceptions.
      </para>
    </sect2>

    <sect2 id="errors.exceptions.io">
      <title>I/O Exceptions</title>
      <para id="x_m11">
        Perhaps the largest source of exceptions in any program is
        I/O.  All sorts of things can go wrong when dealing with the
        outside world: disks can be full, networks can go down, or
        files can be empty when you expect them to have data.  In
        Haskell, an I/O exception is just like any other exception in
        that can be represented by the &Exception; data type.  On the
        other hand, because there are so many types of I/O exceptions,
        a special module&emdash;<literal>System.IO.Error</literal> exists
        for dealing with them.
      </para>
      <para id="x_n11">
        <literal>System.IO.Error</literal> defines two functions:
        &catch; and &try; which, like their counterparts in
        <literal>Control.Exception</literal>, are used to deal with
        exceptions.  Unlike the <literal>Control.Exception</literal>
        functions, however, these functions will only trap I/O errors,
        and will pass all other exceptions through uncaught.  In
        Haskell, I/O errors all have type <literal>IOError</literal>,
        which is defined as the same as
        <literal>IOException</literal>.
      </para>
      <warning>
	<title>Be careful which names you use</title>
        <para id="x_o11">
          Because both <literal>System.IO.Error</literal> and
          <literal>Control.Exception</literal> define functions with
          the same names, if you import both in your program, you will
          get an error message about an ambiguous reference to a
          function.  You can import one or the other module
          <literal>qualified</literal>, or hide the symbols from one
          module or the other.</para>

	<para id="x_D31">Note that <literal>Prelude</literal> exports
          <literal>System.IO.Error</literal>'s version of &catch;,
          <emphasis>not</emphasis> the version provided by
          <code>Control.Exception</code>.  Remember that the former
          can only catch I/O errors, while the latter can catch all
          exceptions.  In other words, the &catch; in
          <code>Control.Exception</code> is almost always the one you
          will want, but it is <emphasis>not</emphasis> the one you
          will get by default.
        </para>
      </warning>
      <para id="x_p11">
        Let's take a look at one approach to using exceptions in the
        I/O system to our benefit.  Back in <xref
        linkend="io.files"/>, we presented a program that used an
        imperative style to read lines from a file one by one.
        Although we subsequently demonstrated more compact, "Haskelly"
        ways to solve that problem, let's revisit that example here.
        In the <literal>mainloop</literal> function, we had to
        explicitly test if we were at the end of the input file before
        each attempt to read a line from it.  Instead, we could check
        if the attempt to read a line resulted in an EOF error, like
        so:
      </para>
      &toupper-impch20.hs:all;
      <para id="x_q11">
        Here, we use the <literal>System.IO.Error</literal> version of
        &try; to check whether <literal>hGetLine</literal> raised an
        &IOError;.  If it did, we use <literal>isEOFError</literal>
        (defined in <literal>System.IO.Error</literal>) to see if the
        raised exception indicated that we reached the end of the
        file.  If it did, we exit the loop.  If the exception was
        something else, we call &ioError; to re-raise it.
      </para>
      <para id="x_r11">
        There are many such tests and ways to extract information from
        &IOError; defined in <literal>System.IO.Error</literal>.  We
        recommend that you consult that page in the library reference
        when you need to know about them.
      </para>
    </sect2>

    <sect2 id="errors.exceptions.raising">
      <title>Raising Exceptions</title>
      <para id="x_s11">
        Thus far, we have talked in detail about handling exceptions.
        There is another piece to the puzzle: raising exceptions.  In
        the examples we have visited so far in this chapter, the
        Haskell system raises exceptions for you.  However, it is
        possible to raise any exception yourself.  We'll show you how.
      </para>
      <para id="x_t11">
        You'll notice that most of these function appear to return a
        value of type <literal>a</literal> or <literal>IO
        a</literal>.  This means that the function can appear to
        return a value of any type.  In fact, because these functions
        raise exceptions, they never "return" anything in the normal
        sense.  These return values let you use these functions in
        various contexts where various different types are expected.
      </para>
      <para id="x_u11">
        Let's start our tour of ways to raise exceptions with the
        functions in <literal>Control.Exception</literal>.  The
        most generic function is &throw;, which has type
        <literal>Exception -&gt; a</literal>.  This function can throw
        any &Exception;, and can do so in a pure context.  There is a
        companion function &throwIO; with type <literal>Exception
        -&gt; IO a</literal> that raises an exception in the &IO;
        monad.  Both of these functions require you to craft an
        &Exception; by hand&emdash;or to have already have one on hand to
        raise, perhaps from a handler called by &handle;.
      </para>
      <para id="x_v11">
        There is also a function &ioError;, which is defined
        identically in both <literal>Control.Exception</literal> and
        <literal>System.IO.Error</literal> with type <literal>IOError
        -&gt; IO a</literal>.  This is used when you want to generate
        an arbitrary I/O-related exception.
      </para>
      <para id="x_w11">
        Perhaps most useful are two shortcut functions: &error; and
        &fail;.  When used in the &IO; monad, &fail; could be thought
        of like this:
      </para>
      <programlisting>
fail :: String -> IO a
fail = ioError . userError
      </programlisting>
      <para id="x_x11">
        So, &fail; is useful for generating an exception with an
        arbitrary error message in the &IO; monad.  For pure code, you
        can use &error;, which is defined like this:
      </para>
      <programlisting>
error :: String -> a
error = throw . ErrorCall
      </programlisting>
      <remark>FIXME: do we need examples here?</remark>
    </sect2>

    <sect2 id="errors.exceptions.dynamic">
      <title>Dynamic Exceptions</title>
      <para id="x_y11">
        While &fail; and &error; are often quite useful, you may not
        want to use them often in reusable code.  Since they take only
        arbitrary strings as arguments, it can be difficult to
        represent complex error data.  Sometimes the built-in
        exception mechanism isn't enough for you, either.  In these
        cases, you can use Haskell's dynamic exception support.
      </para>
      <para id="x_z11">
        This makes use of two little-used Haskell modules:
        <literal>Data.Dynamic</literal> and
        <literal>Data.Typeable</literal>.  We will not go into a great
        level of detail on those modules here, but will give you the
        tools you need to craft and use your own dynamic exception
        type.
      </para>
      <para id="x_A21">
        In <xref linkend="databases"/>, you will see that the HDBC
        database library uses dynamic exceptions to indicate errors
        from SQL databases back to applications.  Errors from database
        engines often have three components: an integer that
        represents an error code, a state, and a human-readable error
        message.  We will build up our own implementation of the HDBC
        <literal>SqlError</literal> type here in this chapter.  Let's
        start with the data structure representing the error itself:
      </para>
      &dynexc.hs:sqlerror;
      <para id="x_B21">
        Next, we define a bit of infrastructure to make the error type
        participate in Haskell's dynamic typing system.  Note that the
        argument to <literal>mkTyCon</literal> must be unique
        throughout your entire application.
      </para>
      &dynexc.hs:dynamic;
      <para id="x_C21">
        Now, let's define a <literal>catchSql</literal> and a
        <literal>handleSql</literal> that can be used to catch an
        exception that is an <literal>SqlError</literal>.  Note that
        the regular &catch; and &handle; functions cannot catch our
        <literal>SqlError</literal>, because it is not a type of
        &Exception;.
      </para>
      &dynexc.hs:catch;
      <para id="x_D21">
        These functions are simply thin wrappers around &catchDyn;,
        which has type <literal>Typeable exception =&gt; IO a -&gt;
        (exception -&gt; IO a) -&gt; IO a</literal>.  We here simply
        restrict the type of this so that it catches only SQL
        exceptions.
      </para>
      <para id="x_E21">
        Normally, when an exception is raised, but not caught
        anywhere, the program will crash and will display the
        exception to standard error.  With a dynamic exception,
        however, the system will not know how to display this, so you
        will simply see an unhelpful "unknown exception" message.  We
        can provide a utility so that application writers can simply
        say <literal>main = handleSqlError $ do ...</literal>, and
        have confidence that any exceptions raised (in that thread)
        will be displayed.  Here's how to write
        <literal>handleSqlError</literal>:
      </para>
      &dynexc.hs:handleSqlError;
      <para id="x_F21">
        Finally, let's give you an example of how to raise an
        <literal>SqlError</literal> as an exception.  Here's a
        function that will do just that:
      </para>
      &dynexc.hs:throwSql;
      <para id="x_G21">
        This completes our dynamic exception support.  That was a lot
        of code, and you may not have needed that much, but we wanted
        to give you an example of the dynamic exception itself and the
        utilities that often go with it.  In fact, these examples
        reflect almost exactly what is present in the HDBC library.
        Let's play with these in &ghci; for a bit:
      </para>
      &dynexc.ghci:e1;
      <para id="x_H21">
        From this, you can see that &ghci; doesn't know how to display
        an SQL error by itself.  Howerver, you can also see that our
        <literal>handleSqlError</literal> function helped out with
        that, but also passed through other errors unmodified.  Let's
        finally try out a custom handler:
      </para>
      &dynexc.ghci:e2;
      <para id="x_I21">
        Here we defined a custom error handler that raised a new
        exception consisting of the message in the
        <literal>seErrorMsg</literal> field of the
        <literal>SqlError</literal>.  You can see that it worked as
        intended.
      </para>
    </sect2>
  </sect1>

  <sect1 id="errors.exercises">
    <title>Exercises</title>
    <orderedlist>
      <listitem><para id="x_iz">
          Take the &Either; example and made it work with laziness in
          the style of the &Maybe; example.
        </para>
      </listitem>
    </orderedlist>
  </sect1>

  <sect1>
    <title>Error handling in monads</title>

    <para id="x_E31">Because we must catch exceptions in the &IO; monad, if we
      try to use them inside a monad, or in a stack of monad
      transformers, we'll get bounced out to the &IO; monad.  This is
      almost never what we would actually like.</para>

    <para id="x_F31">We defined a <type>MaybeT</type> transformer in
      <xref linkend="monadtrans.maybet"/>, but it is more useful as an
      aid to understanding than a programming tool.  Fortunately, a
      dedicated&emdash;and more useful&emdash;monad transformer
      already exists: <type>ErrorT</type>, which is defined in the
      <code>Control.Monad.Error</code> module.</para>

    <para id="x_G31">The <type>ErrorT</type> transformer lets us add exceptions
      to a monad.  It gives us some interesting capabilities.</para>

    <itemizedlist>
      <listitem>
	<para id="x_H31">Following the naming pattern of other monad
	  transformers, the execution function is named
	  <function>runErrorT</function>. If we do not catch an
	  exception, it stops propagating upwards when it reaches
	  <function>runErrorT</function>. We will not be kicked out to
	  the &IO; monad.</para>
      </listitem>
      <listitem>
	<para id="x_I31">We get to choose the type an exception can have.</para>
      </listitem>
    </itemizedlist>

    <para id="x_J31">As with other <code>mtl</code> monads, the interface that
      <type>ErrorT</type> provides is defined by a typeclass.</para>

    &MonadError.hs:MonadError;

    <para id="x_K31">The type variable <varname role="type">e</varname>
      represents the error type we want to use.  Whatever our error
      type is, we must make it an instance of the <type>Error</type>
      typeclass.</para>

    &MonadError.hs:Error;
    
    <para id="x_L31">The <function>strMsg</function> function is used by
      <type>ErrorT</type>'s implementation of
      <function>fail</function>.  It throws
      <function>strMsg</function> as an exception, passing it the
      string argument it received.  As for <function>noMsg</function>,
      it is used to provide an <function>mzero</function>
      implementation for the <type>MonadPlus</type> typeclass.</para>

    <para id="x_M31">To support the <function>strMsg</function> and
      <function>noMsg</function> functions, our
      <type>ParseError</type> type has a <code>Chatty</code>
      constructor. This will be used as the constructor if, for
      example, someone calls <function>fail</function> in our
      monad.</para>

    <para id="x_N31">One last piece of plumbing that we need to know about is the
      type of the execution function <type>runErrorT</type>.</para>

    &parseInt.ghci:runErrorT;

    <sect2>
      <title>A tiny parsing framework</title>

      <para id="x_O31">To illustrate the use of <type>ErrorT</type>, let's
	develop the bare bones of a parsing library similar to
	Parsec.</para>

      &ParseInt.hs:ParseError;

      <para id="x_P31">For our parser's state, we will create a very small monad
	transformer stack. A <type>State</type> monad carries around
	the <type>ByteString</type> to parse, and stacked on top is
	<type>ErrorT</type> to provide error handling.</para>

      &ParseInt.hs:Parser;

      <para id="x_Q31">As usual, we have wrapped our monad stack in a &newtype;.
	This costs us nothing in performance, but adds type safety. We
	have deliberately avoided deriving an instance of
	<type>MonadState B.ByteString</type>.  This means that users
	of the <type>Parser</type> monad will not be able to use
	<function>get</function> or <function>put</function> to query
	or modify the parser's state.  As a result, we force ourselves
	to do some manual lifting to get at the <type>State</type>
	monad in our stack.  This is, however, very easy to do.</para>

      &ParseInt.hs:liftP;

      <para id="x_R31">The <function>catchError</function> function is useful for
	tasks beyond simple error handling.  For instance, we can
	easily defang an exception, turning it into a more friendly
	form.</para>

      &ParseInt.hs:optional;

      <para id="x_S31">Our execution function merely plugs together the various
	layers, and rearranges the result into a tidier form.</para>

      &ParseInt.hs:runParser;

      <para id="x_T31">If we load this into &ghci;, we can put it through its
	paces.</para>
    </sect2>

    <sect2>
      <title>Exercises</title>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_U31">Write a <function>many</function> parser, with type
	      <type>Parser a -&gt; Parser [a]</type>.  It should apply
	      a parser until it fails.</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para id="x_V31">Use <function>many</function> to write an
	      <function>int</function> parser, with type <type>Parser
		Int</type>.  It should accept negative as well as
		positive integers.</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para id="x_W31">Modify your <function>int</function> parser to throw
	      a <code>NumericOverflow</code> exception if it detects a
	      numeric overflow while parsing.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
