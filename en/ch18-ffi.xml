<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="ffi" revision="alpha;beta">
  <title>Interfacing with C: the FFI</title>

<!-- introduction to why FFIs exist -->

<para>
Programming languages do not exist in perfect isolation. They inhabit an
ecosystem of tools and libraries, built up over decades, and often written in
a range of programming languages. Good engineering practice suggests we reuse
that effort. The Haskell Foreign Function Interface (the "FFI") is the means
by which Haskell code can use, and be used by, code written in other
languages. In this chapter we'll look at how the FFI works, and how to
produce a Haskell binding to a C library, including how to use an FFI
preprocessor to automate much of the work. The challenge: take PCRE, the
standard Perl-compatible regular expression library, and make it usable from
Haskell in an efficient and functional way. Throughout, we'll seek to
abstract out manual effort required by the C implementation, delegating that
work to Haskell, making the interface more robust, and yielding a clean, high
level binding.  We assume only some basic familiarity with regular
expressions.
</para>

<!-- dicuss the foreign function interface standard -->

<para>
Binding one language to another is a non-trivial task. The binding language
needs to understand the calling conventions, type system, data structures,
memory allocation mechanisms and linking strategy of the target language,
just to get things working. The task is to carefully align the semantics of
both languages, so that the both languages can understand the data that
passes between them.
</para>

<para>
Beyond low level compatibility, a certain amount of syntactic sugar and tool
support has to be put in place to make a foreign function interface usable by
mere mortals. Good syntactic and tool support eases the burden on the
programmer by simplifying and automating common tasks. Finally, a set of
libraries and idioms need to be developed to cover the everyday jobs a
programmer writing a new binding will encounter.
</para>

<para>
For Haskell, this technology stack is specified by <ulink url="http://www.cse.unsw.edu.au/~chak/haskell/ffi/">the Foreign Function Interface addendum</ulink> to
the Haskell report. The FFI report describes how to correctly bind code to
and from Haskell and C, and how to extend bindings to other languages. The
standard is designed to be portable, so that FFI bindings will work reliably
across Haskell implementations, operating systems and C compilers.
</para>

<para>
All implementations of Haskell support the FFI, and it is a key enabling
technology: it dramatically reduces the work required to use Haskell in a
field. Instead of reimplementing the standard libraries in a domain, we can
just bind to existing ones written in languages other than Haskell.
</para>

<para>
The FFI adds a new dimension of flexibility to the language: if we need to
access raw hardware for some reason (say we're programming new hardware, or
implementing an operating system), the FFI lets us get access to that
hardware. It also gives us a performance escape hatch: if we can't get a code
hot spot fast enough, there's always the option of trying again in C.  So
let's look at what the FFI actually means for writing code. 
</para>

<!-- some simple examples: the cmath library -->

<sect1>
  <title>Foreign language bindings: the basics</title>

<para>
The most common operation we'll want to do, unsurprisingly, is call a C
function from Haskell. So let's do that, by binding to some functions
from the standard C math library. We'll put the binding in a source file, and
then compile it into a Haskell binary that makes use of the C code.
</para>

<para>
To start with, we need to enable the foreign function interface extension,
as the FFI isn't part of the Haskell 98 standard. We do this, as always, via
a <code>LANGUAGE</code> pragma, at the top of our source file:
</para>

&SimpleFFI.hs:pragma;

<para>
The <code>LANGUAGE</code> pragmas indicate which extension to Haskell 98 a
module uses. We bring just the FFI extension in play this time. It is important
to track which extensions to the language you need. Less extensions generally
means more portable, more robust code. Indeed, it is common for Haskell
programs written more than a decade ago to compile perfectly well today,
thanks to standardisation, and despite radical innovations in the language.
</para>

<para>
The next step is to import the <code>Foreign</code> modules, which provide
useful types (such as pointers, numerical types, arrays) and utility
functions (such as <code>malloc</code> and <code>alloc</code>), for writing
bindings to other languages:
</para>

&SimpleFFI.hs:imports;

<para>
For extensive work with foreign libraries, a good knowlege of the
<code>Foreign</code> modules becomes essential. Other useful modules include
<code>Foreign.C.String</code>, <code>Foreign.Ptr</code> and
<code>Foreign.Marshal.Array</code>.
</para>

<para>
Now we can get down to work actually calling C functions. To do this, we need
to know three things: the name of the C function; its type, and what header
it lives in. Additionally, for code that isn't provided by the standard C
library, we'll need to know what the library name is, for linking purposes.
The actual binding work is done with a <code>foreign import</code>
declaration, like so:
</para>

&SimpleFFI.hs:binding;

<para>
This defines a new Haskell function, <code>c_sin</code>, whose concrete
implementation is in C, via the <code>sin</code> function. When
<code>c_sin</code> is called, a call to the actual <code>sin</code> will be
made. The Haskell runtime passes control to C, which returns its results back
to Haskell. The result is then wrapped up as a Haskell value of type
<code>CDouble</code>.
</para>

<para>
A common idiom when writing FFI bindings is to expose the C function with the
prefix "c_", distinguishing it from more user friendly, higher level
functions. The C function is specified by the <code>math.h</code> header,
where it is has type:
</para>

&math.c:type;

<para>
When writing the binding, the programmer has to translate C type signatures
like this into their Haskell FFI equivalents, making sure data
representations match up. For example, <code>double</code> in C corresponds
to <code>CDouble</code> in Haskell. We need to be careful here, since if a
mistake is made in the translation the Haskell compiler will happily generate
incorrect code to call C! The poor Haskell compiler doesn't know anything
about what types the C function actually requires, so if instructed to, it
will call the C function with the wrong arguments.  At best this will lead to
C compiler warnings, and more likely, it will end with in a runtime crash. At
worse the error will silently go unnoticed until some critical failure
occurs. So make sure you use the correct FFI types!
<footnote><para>Some more advanced binding tools provide greater degrees of
type checking. For example, <code>c2hs</code> is able to parse the C
header, and generate the binding definition for you, and is especially
suited for large projects where the full API is specified. 
</para>
</footnote>
</para>

<para> 
The most important primitive C types are represented in Haskell with the
somewhat intuitive names: <code>CChar</code>, <code>CUChar</code>, <code>CInt</code>,
<code>CUInt</code>, <code>CLong</code>, <code>CULong</code>,
<code>CSize</code>, <code>Float</code>, <code>CDouble</code>. More are
defined in the FFI standard, and can be found in the Haskell base library
under <code>Foreign.C.Types</code>.  It is also possible to define your own
Haskell-side representation types for C, as we'll see later.
</para>

<sect2>
  <title>Be careful of side effects</title>

<para>
One point to note is that we bound <code>sin</code> as a pure function in Haskell, 
one with no side effects. That's fine in this case, since the <code>sin</code>
function in C is referentially transparent. By binding pure C functions to
pure Haskell functions, the Haskell compiler is taught something about the C
code, namely that it has no side effects, making optimisations easier. Pure
code is also more flexible code for the Haskell programmer, as it is naturally
persistant and threadsafe. However, while pure Haskell code is always
threadsafe this is harder to guarantee of C. Even if the documentation
indicates the function is likely to expose no side effects, there's little to
ensure it is also threadsafe, unless explicitly documented as "reentrant".
Pure, threadsafe C code is rare, but valuable, for these reasons. It is the
easiest flavour of C to use from Haskell.
</para>

<para>
Of course, side effecting code is more more common in imperative languages,
where the explicit sequencing of statements encourages the use of effects. It
is much more common in C for functions to return different values, given the
same arguments, due to changes in global or local state, or to have other
side effects. Typically this is signalled in C by the function returning only
a status value, or some void type, rather than a useful result value.  This
indicates that the real work of the function was in its side effects. For
such functions, we'll need to capture those side effects in the IO monad (by
changing the return type to <code>IO CDouble</code>, for example).
</para>

</sect2>

<sect2>
  <title>A high level wrapper</title>

<para>
With the foreign imports out of the way, the next step is to convert the C
types we pass to and from the foreign language call into native Haskell
types, wrapping the binding so it appears as a normal Haskell function:
</para>

&SimpleFFI.hs:highlevel;

<para>
The main thing to remember when writing convenient wrappers over
bindings like this is to correctly convert input and output back to normal
Haskell types. To convert between floating point values, we can use
<code>realToFrac</code>, which lets us translate different floating point values
to each other. For integer values <code>fromIntegral</code> is available.
For other common C data types, such as arrays, we may need to unpack the data
to a more workable Haskell type (such as a list), or possibly leave the C
data opaque, and operate on it only indirectly (perhaps via a
<code>ByteString</code>. The choice to be made depends on how costly the
transformation operation is, and what functions are available on the source
and destination types.
</para>

<para>
We can now go ahead and use the bound function in a program. For
example, we can apply the C <code>sin</code> function to a Haskell list of
tenths:
</para>

&SimpleFFI.hs:use;

<para>
A simple program that prints each result as it is computed.
Putting the complete binding in a file, <code>SimpleFFI.hs</code> we can run
it in <code>GHCi</code>:
</para>

<screen>
$ ghci SimpleFFI.hs
*Main> main
0.0
9.983341664682815e-2
0.19866933079506122
0.2955202066613396
0.3894183423086505
0.479425538604203
0.5646424733950354
0.644217687237691
0.7173560908995227
0.7833269096274833
0.8414709848078964
</screen>

<para>
Alternatively, we can compile the code to a binary:
</para>

<screen>
<prompt>$ </prompt><userinput>ghc -O --make SimpleFFI.hs</userinput>
[1 of 1] Compiling Main             ( SimpleFFI.hs, SimpleFFI.o )
Linking SimpleFFI ...
</screen>

<para>
and then run that:
</para>

<screen>
$ ./SimpleFFI 
0.0
9.983341664682815e-2
0.19866933079506122
0.2955202066613396
0.3894183423086505
0.479425538604203
0.5646424733950354
0.644217687237691
0.7173560908995227
0.7833269096274833
0.8414709848078964
</screen>

<para>
We're well on our way now, with a full program, statically linked against
C, which interleaves C and Haskell code, and passes data across the language
boundary.  Simple bindings like the above are almost trivial, as the standard
<code>Foreign</code> library provides convenient aliases for common types,
like <code>CDouble</code>. In the next section we'll look at a larger
engineering task: binding to the PCRE library.  which brings up issues of
memory management and type safety. A larger problem to tackle.
</para>

<!-- unsafe/ safe calls -->

<!-- a more complicated engineering task: pcre -->

</sect2>

</sect1>

<sect1>
  <title>Regular expressions for Haskell: a binding for PCRE</title>

<!-- linking -->

<!-- motivate regular expressions -->

<para>
As we've seen in previous sections, Haskell programs have something of a bias
towards lists as a foundational data structure.  List functions are a core
part of the base library, and convenient syntax for constructing and taking
apart list structures is wired into the language. Strings are, of course,
simply lists of characters (rather than, for example, flat arrays of characters).
This flexibility is all well and good, but it results in a tendency for the
standard library to favour polymorphic list operations at the expense of
string-specific operations.
</para>

<para>
Indeed, many useful jobs can be solved via regular expression-based
string processing, yet support for regular expressions isn't part of the
Haskell <literal>Prelude</literal>. So let's look at how we'd take an
off-the-shelf regular expression library, PCRE, and provide a natural,
convenient Haskell binding to it, giving us useful regular expressions for
Haskell.
</para>

<para>
PCRE itself is a ubiquitous C library implementing Perl-style regular expressions.
It is widely available, and preinstalled on many systems. If not it can be
found at <ulink url="http://www.pcre.org/">http://www.pcre.org/</ulink>. The following
sections we'll assume the PCRE library and headers are available on the
machine.
</para>

<!-- expose C constants -->

<sect2>
  <title>Simple tasks: using CPP</title>

<para>
The simplest task when setting out to write a new FFI binding from C to
Haskell is to bind constants defined in C headers to equivalent Haskell
values. For example, PCRE provides a set of flags for modifying how the core
pattern matching system works (such as ignoring case, or allowing matching on
newlines).  These flags appear as numeric constants in the PCRE header files:
</para>

&PCRE.h:constants;

<para>
To export these values to Haskell we need to insert them into a Haskell
source file somehow. One obvious way to do this is by using the C
preprocessor to substitute definitions from C into the Haskell source, which we
then compile as a normal Haskell source file. Using the preprocessor we can
even declare simple constants, via textual substitutions on the Haskell
source file:
</para>

&Enum1.hs:cpp;

<para>
This works much as for C source (with CPP run for us by the Haskell compiler,
when it spots the <code>LANGUAGE</code> pragma), resulting in program
output:
</para>

<screen>
<prompt>$ </prompt><userinput>runhaskell Enum.hs</userinput>
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
</screen>
  
<para>  
However, relying on CPP is a rather fragile approach. The C preprocessor
isn't aware it is processing a Haskell source file, and will happily include
text, or transform source, in such a way as to make our Haskell code invalid.
We need to be careful not to confuse CPP. If we were to include C headers we
risk substituting unwanted symbols, or inserting C type information and
prototypes into the Haskell source, resulting in a broken mess.
</para>
  
<para>
To solve these problems, a binding preprocessor, <code>hsc2hs</code> is
distributed with GHC. It provides a convenient syntax for including C binding
information in Haskell, as well as letting us safely operate with headers and
the preprocessor. It is the tool of choice for the majority of Haskell
FFI bindings.
</para>
</sect2>

<sect2>
  <title>
Binding Haskell to C with hsc2hs
  </title>

<para>
To use hsc2hs as an intelligent binding tool for Haskell, we need to create
an <code>.hsc</code> file, <code>Regex.hsc</code>, which will hold the Haskell source for our
binding, along with hsc2hs processing rules, C headers and C type
information. To start off, we need some pragmas and imports:
</para>

&Regex-hsc.hs:headers;

<para>
The module begins with a typical preamble for an FFI binding: enable CPP,
enable the foreign function interface syntax, declare a module name, and then
import some things from the base library. The unusual item is the final line,
where we include the C header for PCRE. This wouldn't be valid in a
<code>.hs</code> source file, but is fine in <code>.hsc</code> code.
</para>
</sect2>

<sect2>
  <title>
   Adding type safety to PCRE
  </title>

<para>
Next we need a type to represent PCRE compile time flags. In C, these are
integer flags to the <code>compile</code> function, so we could just use
<code>CInt</code> to represent them. All we know about the flags is that
they're C numeric constants, so <code>CInt</code> is the isomorphic
representation.
</para>

<para>
As a Haskell library writer though, this feels sloppy. The type of values
that can be used as regex flags contains fewer values than <code>CInt</code>
allows for.  Nothing would prevent the end user passing illegal integer
values as arguments, or mixing up flags that should be passed only at regex
compile time, with runtime flags. It is also possible to do arbitrary math on
flags, or make other mistakes where integers and flags are confused. We
really need to more precisely specify that the type of flags is distinct from
its runtime representation as a numeric value. If we can do this, we can
statically prevent a class of bugs relating to misuse of flags.
</para>

<para>
Adding such a layer of type safey is relatively easy, and a great use case for
<code>newtype</code>, the seemingly obscure type introduction declaration.
What <code>newtype</code> lets us do is create a type with an indentical
runtime representation type to another type, but which is treated as a separate
type at compile time. We can represent flags at runtime as <code>CInt</code>
values at runtime, but at compile time, they'll be tagged distinctly for the
type checker. This makes it a type error to use invalid flag values (as we
specify only those valid flags, and prevent access to the type constructor),
or to pass flags to functions expecting integers. We get use the Haskell type
system to introduce a layer of type safety to the C PCRE API.
</para>

<para>
To do this, we define a <code>newtype</code> for PCRE compile time options,
whose representation is actually that of a <code>CInt</code> value, like so:
</para>

&Regex-hsc.hs:newtype;

<para>
The type name is <code>PCREOption</code>, and it has a single constructor,
also named <code>PCREOption</code>, which lifts a <code>CInt</code> value
into a new type by wrapping it in a constructor. We can also happily define
an accessor, <code>unPCREOption</code>, using the Haskell record syntax, to the underlying
<code>CInt</code>. That's a lot of convenience in one line. While we're here,
we can also derive some useful type class operations for flags (equality,
comparison, printing and parsing).
</para>

</sect2>

<sect2>
  <title>
Binding to constants
  </title>

<para>
Now we've pulled in the required modules, turned on the language features we
need, and defined a type to represent PCRE options, we need to actually
define some Haskell values corresponding to those PCRE constants.
</para>

<para>
We can do this in two ways with hsc2hs. The first, easy way, is to use the
<code>#const</code> keyword hsc2hs provides. This lets us name constants to
be provided by the C preprocessor. We can bind to the constants manually, by
listing the CPP symbols for them using the <code>#const</code> keyword:
</para>

&Regex-hsc-const.hs:constoptions;

<para>
This introduces three new constants on the Haskell side,
<code>caseless</code>, <code>dollar_endonly</code> and <code>dotall</code>,
corresponding to the similary named C definitions. We immediately wrap the
constants in a newtype constructor, so they're exposed to the programmer as
abstract <code>PCREOption</code> types only.
</para>

<para>
This is the first step, creating a <code>.hsc</code> file. We now need to
actually create a Haskell source file, with the C preprocessing done. Time
to run <code>hsc2hs</code> over the <code>.hsc</code> file:
</para>

<screen>
$ hsc2hs Regex.hsc
</screen>

<para>
This creates a new output file, <code>Regex.hs</code>, where the CPP
variables have been expanded, yielding valid Haskell code:
</para>

&Regex-hsc-const-generated.hs:generatedconsts;

<para>
Notice also how the original line in the <code>.hsc</code> is listed next
to each expanded definition via the <code>LINE</code> pragma. The compiler
uses this information to report errors in terms of their source, in the
original file, rather than the generated one.  We can load this generated
<code>.hs</code> file into the interpreter, and play with the results:
</para>

<screen>
<prompt>$ </prompt><userinput>ghci Regex.hs</userinput>
<prompt>*Regex> </prompt><userinput>caseless</userinput>
PCREOption {unPCREOption = 1}
<prompt>*Regex> </prompt><userinput>unPCREOption caseless</userinput>
1
<prompt>*Regex> </prompt><userinput>unPCREOption caseless + unPCREOption caseless</userinput>
2
<prompt>*Regex> </prompt><userinput>caseless + caseless</userinput>
interactive>:1:0:
    No instance for (Num PCREOption)
</screen>

<para>
So things are working as expected. The values are opaque, we get type errors
if we try to break the abstraction, and we can unwrap them and operate on
them if needed. The <code>unPCREOption</code> accessor is used to unwrap the
boxes.  That's a good start, but let's see how we can simplify this task
further.
</para>

</sect2>

<sect2>
  <title>
Automating the binding
  </title>

<para>
Clearly, manually listing all the C defines, and wrapping them is tedious,
and error prone. The work of wrapping all the literals in
<code>newtype</code> constructors is also annoying. This kind of binding is
such a common task that <code>hsc2hs</code> provides convenient syntax to
automate it: the <code>#enum</code> construct.
</para>

<para>
We can replace our list of top level bindings with the equivalent:
</para>

&Regex-hsc.hs:constants;

<para>
This is much more concise! The <code>#enum</code> construct gives us three
fields to work with. The first is the name of the type we'd like the C
defines to be treated as. This lets us pick something other than just
<code>CInt</code> for the binding. We chose <code>PCREOption</code>'s to
construct.
</para>

<para>
The second field is an optional constructor to place in front of the symbols.
This is specifically for the case we want to construct <code>newtype</code>
values, and where much of the grunt work is saved. The final part of the
<code>#enum</code> syntax is self explantory: it just defines Haskell names
for constants to be filled in via CPP.
</para>

<para>
Running this code through hsc2hs, as before, generates a Haskell file with
the following binding code produced:
</para>

&Regex.hs:result;

<para>
Perfect. Now we can do something in Haskell with these values. Our aim here
is to treat flags as abstract types, not as bit fields in integers in C.
Passing multiple flags in C would be done by bitwise or-ing multiple flags 
together. For an abstract type though, that would expose too much
information. Preserving the abstraction, and giving it a Haskell flavour,
we'd prefer users passed in flags in a list that the library itself combined.
This is achievable with a simple fold: </para>

&Regex.hs:bitwise;

<para>
A simple loop, starting with an initial value of 0, it unpacks each flag, and
uses bitwise-or, <code>(.|.)</code>, to combine each value with the loop
accumulator. The final accumulated state is then wrapped up in the
<code>PCREOption</code> constructor.
</para>

<para>
Let's turn now to actually compiling some regular expressions.
</para>
  
</sect2>

</sect1>

<sect1>
  <title>Passing string data between Haskell and C</title>

<para>
The next task is to write a binding to the PCRE regular expression
<code>compile</code> function. Let's look at its type, straight from the
<code>pcre.h</code> header file:
</para>

&PCRE-compile.h:pcre_compile;

<para>
This function compiles a regular expression pattern into some internal
format, taking the pattern as an argument, along with some flags, and some
variables for returning status information.
</para>

<para>
We need to work out what Haskell types to represent each argument with. Most
of these types are covered by equivalents defined for us by the FFI standard,
and available in <code>Foreign.C.Types</code>. The first argument, the
regular expression itself, is passed as a null-terminated char pointer to C,
equivalent to the Haskell <code>CString</code> type. PCRE compile time
options we've already chosen to represent as the abstract
<code>PCREOption</code> newtype, whose runtime representation is a
<code>CInt</code>. As the representations are guaranteed to be identical, we
can pass the <code>newtype</code> safely. The other arguments are a little
more complicated and require some work to construct and take apart.
</para>

<para>
The third argument, a pointer to a C string, will be used as a reference  to
any error message generated when compiling the expression. The value of the
pointer will be modified by the C function to point to a custom error string.
This we can represent with a <code>Ptr CString</code> type. Pointers in
Haskell are heap allocated containers for raw addresses, and can be created
and operated on with a number of allocation primitives in the FFI library.
For example, we can represnt a pointer to a C <code>int</code> as <code>Ptr
CInt</code>, and a (constant) pointer to an unsigned char as a <code>Ptr
Word8</code>.
</para>

<note>
  <title>A note about pointers</title>

<para>
Once we have a Haskell <code>Ptr</code> value handy, we can do various
pointer-like things with it. We can compare it for equality with the null
pointer, represented with the special <code>nullPtr</code> constant. We can
cast a pointer from one type to a pointer to another, or we can increment a
pointer by an integral amount, with <code>plusPtr</code>. We can even modify
the value pointed to, using <code>poke</code>, and of course dereference a
pointer, yielding that which it points to, with <code>peek</code>.
In the majority of circumstances, a Haskell programmer doesn't need to
operate on pointers directly, but when they are needed these tools come in
handy.
</para>
</note>

<para>
The question then is how to represent abstract <code>pcre</code> pointer returned 
when we compile the regex. We can use a trick here, since the structure is
abstract, and we'll never look at it's internals. We can assign the data any
heap-allocated Haskell type, as long as it has few or no operations on it!
This is a common trick for arbitrarily typed foreign data. 
A simple type used to represent ounknown data is the <code>()</code> type. We
can use a type synomnym to remember the binding:
</para>

&PCRE-compile.hs:unit;

<para>
That is, the foreign data is some unknown, opaque object, and we'll just
treat it as a pointer to <code>()</code>, knowing full well that we'll never
actually dereference that pointer. This gives us the following foreign import
binding for <code>pcre_compile</code>:
</para>

&PCRE-compile.hs:pcre_compile;

<sect2>
  <title>
    Typed pointers
  </title>

<para>
Another common trick is, instead of using the <code>()</code> type, to use
a "typed pointer": a unique type, distinct from the unit type, that has no
valid values. A type for which no data can be constructed, making
dereferencing it a type error. One good way to build such provably
uninspectable data types is with a nullary data type:
</para>

&PCRE-nullary.hs:nullary;

<para>
This requires the <code>EmptyDataDecls</code> language extension. This type
clearly contains no values! We can only ever construct pointers to values of
this type, as there are no concrete values (other than bottom) that have this
type.
</para>

<para>
We can also achieve the same thing, without requiring a language extension, 
using a recursive <code>newtype</code>:
</para>

&PCRE-recursive.hs:nullary;

<para>
Again, we can't really do anything with a value of this type, as it has no
actual runtime representation. Using typed pointers like this is
another way to add safety to a Haskell layer over what C. What would require
discipline on the part of the C programmer to ensure correctness,
(remembering never to dereferene a PCRE pointer) can be enforced statically
in the type system of the Haskell binding. If this code compiles, the type
checker has given us a proof that the PCRE objects returned by C are never
dereferenced on the Haskell side.
</para>

<para>
We have the foreign import declaration sorted out now, the next step is to
marshal data into the right form, so that we can finally call the C code.
</para>

</sect2>

<!-- foreign pointers -->

<!-- memory management -->

<sect2>
  <title>
    Memory management: let the garbage collector do the work
  </title>

<para>
One question that isn't resolved yet is how to manage the memory associated
with the abstract <code>PCRE</code> structure returned by the C library. The
caller didn't have to allocate it: the library took care of that. But at some
point we'll need to deallocate it. This, again, is an opportunity to abstract
out some of the tedium of using the C library inside the Haskell binding.
</para>

<para>
We'll use the Haskell garbage collector to automatically deallocate the C
structure once it is no longer in use. To do this, we'll make use of Haskell
garbage collector finalizers, and the <code>ForeignPtr</code> type.
</para>

<para>
We don't want users to have to manually deallocate the <code>Ptr PCRE</code>
value by the foreign call. This structure
is allocated on the C side with <code>malloc</code>, and needs to be freed
when no longer in use, or we risk leaking memory. The Haskell garbage
collector already goes to great lengths to automate the task of managing
memory for Haskell values. Cleverly, we can also assign our hardworking
garbage collector the task of looking after C's memory! The trick is to
associate a piece of Haskell data with the foreign allocator data, and give
the Haskell garbage collector a function to deallocate the C resource, once
it notices that the Haskell data is done with.
</para>

<para>
We have two tools at our disposal here, the opaque <code>ForeignPtr</code>
data type, and the <code>newForeignPtr</code> function, which has type:
</para>

&ForeignPtr.hs:newForeignPtr;

<para>
The function takes two arguments, a finalizer to run when the data goes out
of scope, and a pointer to the C allocated object. It returns a new managed
pointer which will have the associated finalizer run once the garbage
collector decides the data is no longer in use. What a lovely abstraction!
</para>

<para>
These finalizable pointers are appropriate whenever a C library requires the
user to explicitly deallocate, or otherwise clean up a resource, when it is
no longer in use. It is a simple piece of equipment that goes a long way
towards making the C library binding more natural and "functional" in
flavour.
</para>

<para>
So with this in mind, we can hide the manually managed <code>Ptr PCRE</code>
type inside a automatically managed data structure, yielding us the actual
data type used to represent regular expressions:
</para>

&PCRE-compile.hs:data;

<para>
This new <code>Regex</code> data types consists of two parts. The first is
an abstract <code>ForeignPtr</code>, that we'll use to manage the underlying
<code>PCRE</code> data allocated in C. The second component is a strict
<code>ByteString</code>, which is the string representation of the regular
expression that we compiled. By keeping it handy, it'll be easier to print
user friendly error messages, or to show the <code>Regex</code> in a
meaningful way.
</para>

</sect2>

<sect2>
  <title>
    A high level interface: marshalling data
  </title>

<para>
The challenge when writing FFI bindings, once the Haskell types have been
decided upon, is to convert regular data types a Haskell programmer will be
familiar with into low level pointers to arrays and other C types. What would
an ideal Haskell interface to regular expression compilation look like?
We have some design intuition to guide us.
</para>

<para>
For starters, the act of compilation should be a referentially transparent
operation: passing the same regex string will yield the same compiled
pattern, each time. We should be able to represent it as a pure function at
the very least. The ability to represent a C function in Haskell as a pure
operation is a key step towards flexibility, and a sign the interface will be
easy to use (as it won't require complicated state to be initialised
beforehand).
</para>

<para>
Despite being pure, the function can still fail. If the regular expression
input provided by the user is ill-formed an error string is returned. A good
data type to represent optional failure, with an error value, is
<code>Either</code>. That is, either we return a valid compiled regular
expression, or we'll return an error string. Encoding the results of a C
function in a familiar, foundational Haskell type is another step we can make
towards usability.
</para>

<para>
For the user supplied parameters, we've already decided to pass compilation
flags in as a list. We can choose to pass the input regular expression either
as an efficient <code>ByteString</code>, or as a regular <code>String</code>.
An appropriate data type, then, for referentially transparent success with a
value, or failure with an error string, would be:
</para>

&PCRE-compile.hs:compiletype;

<para>
The input is a <code>ByteString</code>, available from the
<code>Data.ByteString.Char8</code> module (and we'll import this
<code>qualified</code> to avoid name clashes), containing the regular
expression, and a list of flags (or the empty list if there are no flags to
pass). The result is either an error string, or a new, compiled. regular
expression.
</para>

</sect2>

<sect2>
  <title>Mashalling ByteStrings</title>

<para>
Given this type, we can sketch out the <code>compile</code> function. At
its heart, it will call <code>c_pcre_compile</code>. Before it does that,
it has to marshall the input <code>ByteString</code> into a
<code>CString</code>. This is done with the <code>ByteString</code> library's
<code>useAsCString</code> function:
</para>

&ForeignPtr.hs:useAsCString;

<para>
This function takes a <code>ByteString</code> as input, and the second
argument is a user-defined function that will run with the resulting
<code>CString</code>. That is, a closure! We see here another useful idiom:
data marshalling functions that are naturally scoped via closures. Our
<code>useAsCString</code> function will convert the input data to a C string,
which we can then pass to C, and all we need to do is supply it with a
chunk of code to actually call C. Code in this style is often written in a
dangling "do-block" notation. The following pseudocode illustrates this
structure:
</para>

&DoBlock.hs:doblock;

<para>
The second argument here is an anonymous function, a lambda, with a monadic
"do" block for a body. It is common to use the simple <code>($)</code>
application operator, to avoid the need for parenthesis to delimit the code
block argument. A useful idiom to remember for parameterised code blocks like
this.
</para>

</sect2>

<sect2>
  <title>Allocating local C data: the Storable class</title>

<para> 
We can happily marshal <code>ByteString</code> data to C compatible types,
but the <code>pcre_compile</code> function also needs some pointers and
arrays in which to place its other return values. These should only exist
briefly, so we don't need complicated allocation strategies. Such
short-lifetime C data can be created with the <code>alloc</code> function:
</para>

&ForeignPtr.hs:alloc;

<para>
This function takes a code block accepting a pointer to some C type as an
argument, and arranges to call that function with the correct data, allocated
freshly. The allocated memory is then released once the argument function
exits. In this way we get lexically scoped C data allocation, guaranteed to
be released once the local scope is exited. We can use it to allocate any
data types that are instances of the <code>Storable</code> class, a type
class. This also means that the actual data type allocated can be determined
soley based on type information, or even inferred based on use! Haskell will
know what to allocate for C by what functions we use on that data.
</para>

<para>
To allocate a pointer to a <code>CString</code>, for example, which will be
updated to pointed to a particular <code>CString</code> by the called
function, we would call <code>alloc</code>, in pseudocode as:
</para>

&DoBlock.hs:alloc;

<para>
This locally allocates a <code>Ptr CString</code>, and applies
the code block to that pointer, which then calls a C function to modify the
pointer contents. Finally, we dereference the pointer with the
<code>Storable</code> class <code>peek</code> function, yielding a
<code>CString</code>.
</para>

<para>
We can now put it all together, to complete our high level PCRE compilation
wrapper.
</para>

</sect2>

<sect2>
  <title>Putting it all together</title>

<para>
We've decided what Haskell type to represent the C function with, what the
result data will be represented by, and how its memory will be managed. We've
chosen a representation for flags to the <code>pcre_compile</code> function,
and worked out how to get C strings to and from code inspecting it. So let's
write the complete function for compiling PCRE regular expressions from
Haskell:
</para>

&PCRE-compile.hs:compileReal;

<!-- woot, the dreaded unsafePerformIO -->

<para>
That's it. Let's carefully walk through the details here, since it is rather
dense in concepts. The first thing that stands out is the use of
<code>unsafePerformIO</code>, a rather infamous function, with a very unusual
type:
</para>

&ForeignPtr.hs:unsafePerformIO;

<para>
This function does something rather odd: it takes an IO value and
converts it to a pure one! After warning about the danger of effects for so
long, here we have the epitome of dangerous effects in one line. Used
unwisely, this function lets us side step all safety guarantees regarding
purity the Haskell type system provides, inserting arbitrary effects into a
Haskell program, anywhere. The dangers in doing this are significant: we can
break optimisations, modify arbitrary locations in memory, remove files on
the user's machine, or launch nuclear missles inside our fibonacci functions.
So why does this function exist at all?
</para>

<para>
It exists precisely to enable Haskell code to bind to C code that we know to
be referentially transparent, but can't prove the case to the Haskell type system.
It lets us say to the compiler, "I know what I'm doing - this
code really is pure". For regular expression compilation, we know this to be
the case: given the same pattern, we should get the same regular expression
matcher every time. However, proving that to the compiler is beyond the
Haskell type system, at the time of writing, so we're forced to assert that
this code is pure. Using <code>unsafePerformIO</code> allows us to do just that.
</para>

<!-- say more about the risks and benefits ? -->

<para>
The argument to <code>unsafePerformIO</code> is the actual body of our
compilation function, which consists of four parts: marshalling Haskell data
to C form; calling into the C library; checking the return values; and
finally, constructing a Haskell value from the results.
</para>

<!-- the wrapper -->

<para>
We marshal with <code>useAsCString</code> and <code>alloc</code>, setting
up the data we need to pass to C, and use <code>combineOptions</code>, to
collapse the list of flags into a single <code>CInt</code>. Once that's all
in place, we can finally call <code>c_pcre_compile</code> with the pattern,
flags, and pointers for the results. We can use <code>nullPtr</code> for the
character encoding table, which is unused in this scenario.
</para>

<para>
The result returned from the C call is a pointer to the abstract
<code>PCRE</code> structure. We then test this against the
<code>nullPtr</code>. If there was a problem with the regular expression, 
we have to dereference the error pointer, yielding a <code>CString</code>. We
then unpack that to a normal Haskell list with the library function,
<code>peekCString</code>. The final result of the error path is a value of
<code>Left err</code>, indicating failure to the caller.
</para>

<para>
If the call succeeded, however, we allocate a new storage-managed pointer,
with the C function using a <code>ForeignPtr</code>. The special value,
<code>finalizerFree</code>, is bound as the finalizer for this data, which
means that the standard C <code>free</code> will be used to deallocate the
data, as the PCRE library requires. This is then wrapped as an opaque
<code>Regex</code> value. The successful result is tagged as such with
<code>Right</code>, and returned to the user. And now we're done!
</para>

<para>
We need to process our source file with hsc2hs, and then load the function in GHCi.
However, doing this results in an error on the first attempt:
</para>

<screen>
<prompt>$ </prompt><userinput>hsc2hs Regex.hsc</userinput>
<prompt>$ </prompt><userinput>ghci Regex.hs</userinput>

During interactive linking, GHCi couldn't find the following symbol:
  pcre_compile
This may be due to you not asking GHCi to load extra object files,
archives or DLLs needed by your current session.  Restart GHCi, specifying
the missing library using the -L/path/to/object/dir and -lmissinglibname
flags, or simply by naming the relevant files on the GHCi command line.
</screen>

<para>
A little scary. However, this is just because we didn't actaully link in the
C library with all the code we want to call.  Assuming the PCRE library has
been installed on the system in the default C library location, we can let
GHCi know about it by adding <code>-lpcre</code> to the GHCi command line,
and then we can try it the code on some regular expressions, looking at
success and error case:
</para>

<screen>
<prompt>$ </prompt><userinput>ghci Regex.hs -lpcre</userinput>
<prompt>*Regex> </prompt><userinput>:m + Data.ByteString.Char8</userinput>
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>compile (pack "a.*b") []</userinput>
Right (Regex 0x00000000028882a0 "a.*b")
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>compile (pack "a.*b[xy]+(foo?)") []</userinput>
Right (Regex 0x0000000002888860 "a.*b[xy]+(foo?)")
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>compile (pack "*") []</userinput>
Left "nothing to repeat"
</screen>

<para>
The regular expressions are packed into byte strings, marshalled to C, and
compiled by the PCRE library. The result is then shuffled back to Haskell,
where we display the structure, using the default <code>Show</code> instance.
Our next step is to pattern match some strings with these compiled regular
expressions.
</para>

</sect2>

</sect1>

<sect1>
    <title>Matching on strings</title>

<para>
The second part of a good regular expression library is the matching
function. Given a compiled regular expression, this actually matches our
regex against some input, and indiciates whether it matched, and if so, what
parts of the string matched. In PCRE this function is <code>pcre_exec</code>, 
which has type:
</para>

&PCRE-compile.h:pcre_exec;

<para>
The most important arguments are the input <code>pcre</code> pointer
structure, which we obtained from <code>pcre_compile</code>, and the subject
string. The other flags let us provide bookkeeping for these structures, and
space for return values. We can directly translate this type to the Haskell
import declaration:
</para>

&RegexExec.hs:pcreexec;

<para>
We use the same method as before to create typed pointers for
the   <code>PCREExtra</code> structure, and a <code>newtype</code> to
represent flags passed at regex execution time. This lets us ensure users
don't pass compile time flags incorrectly at runtime.
</para>

<sect2>
  <title>Extracting information about the pattern</title>

<para>
The main complication involved in calling <code>pcre_exec</code> is the
array of <code>int</code> pointers used to hold the offsets of any matched
substrings found by the regular expression. These offsets are held in an
offset vector, whose required size is determined by analysing the input
regular expression for the number of captured patterns it contains. PCRE
provides a function, <code>pcre_fullinfo</code>, for determining information
about the regular expression, including the number of patterns. Now, we can
just write down directly the Haskell type, which is given by,
</para>

&RegexExec.hs:pcrefullinfo;

<para>
The most important arguments to this function are the compiled regular expression,
and the <code>PCREInfo</code> flag, indicating which information we're
interested in, in this case, the captured pattern count. Which information
we'll receive is determined by this numeric value, and we'll need to use the
<code>PCRE_INFO_CAPTURECOUNT</code> constant. There's a range of other
constants which determine what result type we receive, and we can bind to those
using the <code>#enum</code> construct as before. The final argument is a
pointer to a location to store the information about the pattern (whose size
depends on the flag we pass in!).
</para>

<para>
Calling <code>pcre_fullinfo</code> to determine the captured pattern count
is pretty easy now:
</para>

&RegexExec.hs:captured;

<para>
This takes a raw PCRE pointer, allocates space for the <code>CInt</code>
count of the matched patterns. We then call the information function, and
peek into the result structure, finding a <code>CInt</code>. Finally, we
convert this to a normal Haskell <code>Int</code> and pass it back to the
user.
</para>


</sect2>

<sect2>
  <title>Pattern matching with substrings</title>

<para>
Let's write the regex matching function. The Haskell type for matching
is similar to that for compiling regular expressions:
</para>

&RegexExec.hs:exectype;

<para>
This function is how users will match strings against compiled regular
expressions. Again, the main design point is that it is a pure function.
Matching is a pure function: given the same input regular expression and
subject string, it will always return the same matched substrings. So we can
convey this to the user by using a pure type.
</para>

<para>
The arguments are a compiled <code>Regex</code>, a strict
<code>ByteString</code>, containing the input data, and a list of
matching-time flags to modify the regular expression engine. The result is
either no match at all, given by <code>Nothing</code>, or just a list of
matched substrings. By using strict <code>ByteString</code>s for the input
data, we can extract matched substrings in constant time, without copying,
making the interface rather efficient. If substrings are matched in the
input, the offset vector is populated with pairs of integer offsets into the
subject string. We'll need to loop over this result vector, reading offsets,
and building <code>ByteString</code> slices as we go.
</para>

<para>
The matching function implementation can be broken into three parts.
At the top level, our function takes apart the compiled <code>Regex</code>
structure, yielding the underlying <code>PCRE</code> pointer
</para>

&RegexExec.hs:matchtop;

<para>
As it is pure, we can use <code>unsafePerformIO</code> to hide any allocation
effects internally. To take apart the <code>ForeignPtr</code> that hides our
C-allocated PCRE structure, we have to use <code>withForeignPtr</code>. This
holds the Haskell data associated with the PCRE value while the call is being
made, preventing it from being collected for at least the time it is used by
this call. We then call the information helper function, and use that value
to compute the size of the offset vector (the formula for which is given in
the PCRE documentation). The number of bytes we need is the number of
elements multiplied by the size of a <code>CInt</code> on this machine. To
portably compute C type sizes, the <code>Storable</code> class provides a
<code>sizeOf</code> function, that takes some arbitrary value of the required
type (and we can use the <code>undefined</code> value here, as it is a member
of every type).
</para>

<para>
The next step is to allocate an offset vector of the size we computed, to
convert the input <code>ByteString</code> into a pointer to a C
<code>char</code> array. Finally, we call <code>pcre_exec</code> with all the
required arguments:
</para>

&RegexExec.hs:alloc;

<!-- matching -->

<para>
For the offset vector, we use <code>allocBytes</code> to control exactly
the size of the allocated array. It is like <code>alloc</code>, but rather
than using the <code>Storable</code> class to determine the required size,
it takes an explicit size. Taking apart <code>ByteString</code>'s, yielding
the underlying pointer to memory they contain, is done with
<code>toForeignPtr</code>, which convets our nice <code>ByteString</code>
type into a managed pointer. Using <code>withForeignPtr</code> on the result
gives us a raw <code>Ptr CChar</code>, which is exactly what we need to pass
the input string to C. Programming in Haskell is often just a type puzzle!
</para>

<!-- taking substrings -->

<para>
We then just call <code>c_pcre_exec</code> with the raw PCRE pointer, the
input string pointer at the correct offset, its length, and the result vector
pointer. A status code is returned.
</para>

<para>
Finally, we analyse the result:
</para>
  
&RegexExec.hs:results;

<para>
If the result value was less than zero, then there was an error, or no match,
so we return <code>Nothing</code> to the user. Otherwise, we need a loop to 
peeking pairs of offsets from the offset vector (via <code>peekElemOff</code>), 
and constructing the substrings at those offsets. To build substrings we use
a helper function that, given a start and end offset, drops the surrounding
portions of the subject string, yielding just the matched portion. The loop 
runs until it has extracted the number of substrings we were told about in
the return value.
</para>

<para>
The substrings are accumulated in a tail recursive loop, building up a
reverse list of each string. Before returning the substrings ot the user,
we need to flip that list around, and wrap it in a successful
<code>Just</code> tag. Let's try it out!
</para>

</sect2>

<sect2>
  <title>The real deal: compiling and matching regular expressions</title>

<para>
If we take this function, and its surrounding hsc2hs definitions, and data
wrappers, and process it with hsc2hs, we can load the resulting Haskell file
in GHCi, and try out our code (we need to import
<code>Data.ByteString.Char8</code> so we can build <code>ByteString</code>s
from string literals):
</para>

<screen>
<prompt>$ </prompt><userinput>hsc2hs Regex.hsc</userinput>
<prompt>$ </prompt><userinput>ghci Regex.hs -lpcre</userinput>
<prompt>*Regex> </prompt><userinput>:t compile</userinput>
compile :: ByteString -> [PCREOption] -> Either String Regex
<prompt>*Regex> </prompt><userinput>:t match</userinput>
match :: Regex -> ByteString -> Maybe [ByteString]
</screen>

<para>
Things seem to be in order, now let's try some compilation and matching.
First, something easy:
</para>

<screen>
<prompt>*Regex> </prompt><userinput>:m + Data.ByteString.Char8</userinput>
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>let Right r = compile (pack "the quick brown fox") []</userinput>
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>match r (pack "the quick brown fox")</userinput>
Just ["the quick brown fox"]
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>match r (pack "The Quick Brown Fox")</userinput>
Nothing
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>match r (pack "What do you know about the quick brown fox?")</userinput>
Just ["the quick brown fox"]
</screen>

<para>
Or we can be more adventurous:
</para>

<screen>
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>let Right r = compile (pack "a*abc?xyz+pqr{3}ab{2,}xy{4,5}pq{0,6}AB{0,}zz") []</userinput>
<prompt>*Regex Data.ByteString.Char8> </prompt><userinput>match r (pack "abxyzpqrrrabbxyyyypqAzz")</userinput>
Just ["abxyzpqrrrabbxyyyypqAzz"]
</screen>

<para>
That's pretty awesome. The full power of Perl regular expressions, in Haskell at your fingertips.
</para>

</sect2>

<!-- summaries: how well does it integrate into Haskell: pattern guards -->

<!-- a String interface -->

<!-- capturing monadic failure -->

<!-- questions/ thoughts, further work -->

</sect1>

</chapter>

<!--

Interfacing to C:

            - allocation
            - ForeignPtr
                    - managing C resources with the Haskell storage manager
            - marshalling
            - Storable
   
    * compiling.

    * foreign export
            - quick example

  -->

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
