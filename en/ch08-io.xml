<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="io" revision="alpha;beta">
  <title>I/O</title>

  <para id="x_xB">
    It should be obvious that most, if not all, programs are devoted
    to gathering data from outside, processing it, and providing
    results back to the outside world.  That is, input and output are
    key.
  </para>

  <para id="x_yB">
    Haskell's I/O system is powerful and expressive.  It is easy to work
    with and important to understand.  Haskell strictly separates pure
    code from code that could cause things to occur in the world.
    That is, it provides a complete isolation from side-effects in
    pure code.  Besides helping programmers to reason about the
    correctness of their code, it also permits compilers to
    automatically 
    introduce optimizations and parallelism.
  </para>

  <para id="x_zB">
    We'll begin this chapter with simple, standard-looking I/O in Haskell.
    Then we'll discuss some of the more powerful options as well as provide
    more detail on how I/O fits into the pure, lazy, functional Haskell
    world.
  </para>

  <sect1 id="io.basics">
    <title>Classic I/O in Haskell</title>
    <para id="x_AC">
      Let's get started with I/O in Haskell by looking at a program that looks
      surprisingly similar to I/O in other languages such as C or Perl.
    </para>
    &basicio.hs:all;
    <para id="x_BC">
      You can compile this program to a standalone executable, run it with
      &runghc;, or invoke &main; from within &ghci;.
      Here's a sample session using &runghc;:
    </para>
    <screen>
$ <userinput>runghc basicio.hs</userinput>
Greetings!  What is your name?
<userinput>John</userinput>
Welcome to Haskell, John!
</screen>
    <para id="x_CC">
      That's a fairly simple, obvious result.  You can see that &putStrLn;
      writes out a &String;, followed by an end-of-line character.  &getLine;
      reads a line from standard input.  The &larrow; syntax may be new to
      you.  Put simply, that binds the result from executing an
      I/O action to a name. 
      <footnote><para id="x_DC">You will later see that it has a more
        broad application, but it is sufficient to think of it in these terms
        for now.</para></footnote>
      We use the simple list concatenation operator
      <literal>++</literal> to join the input string with our own text.
    </para>

    <para id="x_GC">
      Let's take a look at the types of &putStrLn; and &getLine;.  You can
      find that information in the library reference, or just ask &ghci;:
    </para>
    &basicio.ghci:all;
    <para id="x_HC">
      Notice that both of these types have &IO; in their return value.  That
      is your key to knowing that they may have side effects, or that
      they may return different values even when called with the same
      arguments, or both.  The type of &putStrLn; looks like
      a function.  It takes a parameter of type &String; and returns
      value of type
      <literal>IO ()</literal>.  Just what is an <literal>IO ()</literal>
      though?
    </para>
    <para id="x_IC">
      Anything that is type <literal>IO
        <replaceable>something</replaceable></literal> is an I/O
      <emphasis>action</emphasis>.  You can store it and nothing
      will happen.  I could say <literal>writefoo = putStrLn
        "foo"</literal> and nothing happens right then.  But if I
      later use <literal>writefoo</literal> in the middle of
      another I/O action, the <literal>writefoo</literal> action
      will be executed when its parent action is executed -- I/O
      actions can be glued together to form bigger I/O actions.  The
      <literal>()</literal> is an empty tuple (pronounced
      <quote>unit</quote>), indicating that there is no return value
      from &putStrLn;.  This is similar to <literal>void</literal>
      in Java or C.<footnote><para id="x_KN">The type of the value
          <literal>()</literal> is also <literal>()</literal>.</para>
      </footnote>
    </para>
    <tip>
      <para id="x_qp">
        Actions can be created, assigned, and passed anywhere.
        However, they may only be performed (executed) from within
        another I/O action.  
      </para>
    </tip>
    <para id="x_LN">Let's look at this with
      &ghci;:
    </para>
    &basicio.ghci:putStrLn;
    <para id="x_JC">
      In this example, the output <literal>foo</literal> is not a return
      value from &putStrLn;.  Rather, it's the side effect of &putStrLn; actually
      writing <literal>foo</literal> to the terminal.
    </para>
    <para id="x_MN">
      Notice one other thing: &ghci; actually executed
      <literal>writefoo</literal>.  This means that, when given an I/O
      action, &ghci; will perform it for you on the spot.
    </para>
    <note>
      <title>What Is An I/O Action?</title>
      <para id="x_NN">
        Actions:
      </para>
      <itemizedlist>
        <listitem><para id="x_ON">Have the type <literal>IO <replaceable>t</replaceable></literal></para>
        </listitem>
        <listitem><para id="x_PN">Are first-class values in Haskell
        and fit seamlessly with Haskell's type system
          </para>
        </listitem>
        <listitem><para id="x_QN">Produce an effect when
        <emphasis>performed</emphasis>, but not when
        <emphasis>evaluated</emphasis>.  That is, they only produce an
        effect when called by something else in an I/O context.
          </para>
        </listitem>
        <listitem><para id="x_RN">Any expression may produce an action as its
        value, but the action will not perform I/O until it is
        executed inside another I/O action (or it is <literal>main</literal>)</para>
        </listitem>
        <listitem><para id="x_SN">Performing (executing) an action of type <literal>IO
        t</literal> may perform I/O and will ultimately deliver a
        result of type <literal>t</literal></para>
        </listitem>
      </itemizedlist>
    </note>
    <para id="x_KC">
      The type of &getLine; may look strange to you.  It looks like a value,
      rather than a function.  And in fact, that is one way to look at it:
      &getLine; is storing an I/O action.  When that action is
      performed,
      you get
      a &String;.  The &larrow; operator is used to "pull out" the result
      from performing an I/O action and store it in a
      variable.
    </para>
    <para id="x_LC">
      &main; itself is an I/O action with type <literal>IO
        ()</literal>.  You can only perform I/O actions from
      within other I/O actions.  All I/O in Haskell programs is driven
      from the top at &main;, which is where execution of every Haskell
      program begins.  This, then, is the mechanism that provides
      isolation from side effects in Haskell: you perform I/O in
      your <literal>IO</literal> actions, and call pure (non-I/O) functions
      from there.  Most Haskell code is pure; the I/O actions perform
        I/O and call that pure code.
    </para>


    <para id="x_EC">
      &do; is a convenient way to define a sequence of actions.  As you'll
      see later, there are other ways.  When you use &do; in this way,
      indentation is significant; make sure you line up your actions
      properly.
    </para>
    <para id="x_FC">
      You only need to use &do; if you have more than one action that you need
      to perform.  The value of a &do; block is the value
      of the last action executed.  For a complete description of &do;
      syntax, see <xref linkend="monads.do"/>.
    </para>


    <para id="x_MC">
      Let's consider an example of calling pure code from within
      an I/O action:
    </para>

    &callingpure.hs:all;

    <para id="x_NC">
      Notice the <literal>name2reply</literal> function in this example.  It
      is a regular Haskell function and obeys all the rules we've told you
      about: it always returns the same result when given the same input, it
      has no side effects, and it operates lazily.  It uses other Haskell
      functions: <literal>(++)</literal>, <literal>show</literal>, and
      <literal>length</literal>.
    </para>
    <para id="x_OC">
      Down in <literal>main</literal>, we bind the result of
      <literal>name2reply inpStr</literal> to <literal>outStr</literal>.
      When you're working in a &do; block, you use &larrow; to get
      results from &IO; actions and &let; to get results from pure
      code.  When used in a &do; block, you should not put
      <literal>in</literal> after your &let; statement.
    </para>
    <para id="x_PC">
      You can see here how we read the person's name from the keyboard.
      Then, that data got passed to a pure function, and its result was
      printed.  In fact, the last two lines of &main; could have been replaced
      with <literal>putStrLn (name2reply inpStr)</literal>.  So, while &main;
      did have side effects&emdash;it caused things to appear on the terminal,
      for instance&emdash;<literal>name2reply</literal> did not and
      could not.  That's because <literal>name2reply</literal> is a pure
      function, not an action.
    </para>
    <para id="x_QC">
      Let's examine this with &ghci;:
    </para>

    &callingpure.ghci:all;

    <para id="x_RC">
      The <literal>\n</literal> within the string is the end-of-line
      (newline) character, which causes the terminal to begin a new line in
      its output.  Just calling <literal>name2reply "John"</literal> in
      &ghci; will show you the <literal>\n</literal> literally, because it is
      using &show; to display the return value.  But using &putStrLn; sends
      it to the terminal, and the terminal interprets <literal>\n</literal>
      to start a new line.
    </para>
    <para id="x_SC">
      What do you think will happen if you simply type
      <userinput>main</userinput> at the &ghci; prompt?  Give it a try.
    </para>

    <para id="x_TC">
      After looking at these example programs, you may be wondering if Haskell
      is really imperative rather than pure, lazy, and functional.
        Some of these examples look like a sequence
        of actions to be followed in order.  There's more to it than that,
        though.  We'll discuss that question later in this chapter in 
        <xref
          linkend="io.imperative"/> and <xref linkend="io.lazy"/>.
    </para>

    <sect2 id="io.purevsimpure">
      <title>Pure vs. I/O</title>
      <para id="x_UN">
        As a way to help with understanding the differences between
        pure code and I/O, here's a comparison table.  When we
        speak of pure code, we are talking about Haskell functions
        that always return the same result when given the same input
        and have no side effects.  In Haskell, only the execution of
        I/O actions avoid these rules.
      </para>
      <table id="io.purevsimpure.table">
        <title>Pure vs. Impure</title>
        <tgroup cols='2' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <thead>
            <row>
              <entry>Pure</entry>
              <entry>Impure</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Always produces the same result when given the
                same parameters</entry>
              <entry>May produce different results for the same
                parameters</entry>
            </row>
            <row>
              <entry>Never has side effects</entry>
              <entry>May have side effects</entry>
            </row>
            <row>
              <entry>Never alters state</entry>
              <entry>May alter the global state of the program,
              system, or world</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>
                

    <sect2 id="io.purity">
      <title>Why Purity Matters</title>
      <para id="x_VN">
        In this section, we've discussed how Haskell draws a clear
        distinction between pure code and I/O actions.  Most languages
        don't draw this distinction.  In languages such as C or Java, 
        there is no such thing as a function that is guaranteed by the
        compiler to
        always return the same result for the same arguments, or a
        function that is guaranteed to never have side effects.  The
        only way to know if a given function has side effects is to
        read its documentation and hope that it's accurate.
      </para>
      <para id="x_WN">
        Many bugs in programs are caused by unanticipated side
        effects.  Still more are caused by misunderstanding
        circumstances in which functions may return different results
        for the same input.  As multithreading and other forms of
        parallelism grow increasingly common, it becomes more
        difficult to manage global side effects.
      </para>
      <para id="x_XN">
        Haskell's method of isolating side effects into I/O actions
        provides a clear boundary.  You can always know which parts of
        the system may alter state and which won't.  You can always be
        sure that the pure parts of your program aren't having
        unanticipated results.  This helps you to think about the
        program.  It also helps the compiler to think about it.
        Recent versions of &ghc;, for instance, can provide a level of
        automatic parallelism for the pure parts of your code --
        something of a holy grail for computing.
      </para>
      <remark>FIXME: discussion of the problem of logging from pure code</remark>
      <para id="x_YN">
        For more discussion on this topic, refer to <xref
        linkend="io.sideeffects"/>.</para>
    </sect2>
  </sect1>

  <sect1 id="io.files">
    <title>Working With Files and Handles</title>
    <remark>FIXME: deleting files, renaming them, directory contents</remark>
    <para id="x_VC">
      So far,  you've seen how to interact with the user at the
      computer's terminal.  Of course, you'll
      often need to manipulate specific files.  That's easy to do, too.  
    </para>

    <para id="x_UC">
      Haskell defines quite a few basic functions for I/O, many of
      which are similar to functions seen in other programming
      languages.  The library
      reference for <literal>System.IO</literal> provides a good summary of
      all the basic I/O functions, should you need one that we aren't touching upon
      here. 
    </para>

    <para id="x_WC">
      You will
      generally begin by using &openFile;, which will give you a file &Handle;.
      That &Handle; is then used to perform specific operations on the file.
      Haskell provides functions such as &hPutStrLn; that work just like
      &putStrLn; but take an additional argument&emdash;a &Handle;&emdash;that
      specifies which file to operate upon.  When you're done, you'll use
      &hClose; to close the &Handle;.  These functions are all defined
      in <literal>System.IO</literal>, so you'll need to import that module
      when working with files.  There are "h" functions corresponding to
      virtually all of the non-"h" functions; for instance, there is &print;
      for printing to the screen and &hPrint; for printing to a file.
    </para>

    <para id="x_XC">
      Let's start with an imperative way to read and write files.
 This should
      seem similar to a <literal>while</literal> loop that you may
      find in other languages.  This isn't the best way to write it in
      Haskell; later, you'll see examples of more Haskellish approaches.
    </para>

    &toupper-imp.hs:all;

    <para id="x_YC">
      Like every Haskell program, execution of this program begins with
      <literal>main</literal>.  Two files are opened:
      <literal>input.txt</literal> is opened for reading, and
      <literal>output.txt</literal> is opened for writing.  Then we call
      <literal>mainloop</literal> to process the file.
    </para>
    <para id="x_ZC">
      <literal>mainloop</literal> begins by checking to see if we're
      at the end of file (EOF) for the input.  If not, we read a line
      from the input.  We write out the same line to the output, after
      first converting it to uppercase.  Then we recursively call
      <literal>mainloop</literal> again to continue processing the
      file.<footnote><para id="x_ZN">Imperative programmers might be
      concerned that such a recursive call would consume large amounts
      of stack space.  In Haskell, recursion is a common idiom, and
      the compiler is smart enough to avoid consuming much stack by
      optimizing tail-recursive functions.</para>
      </footnote>
    </para>
    <para id="x_aC">
      Notice that &return; call.  This is not really the same as &return; in
      C or Python.  In those languages, &return; is used to terminate
      execution of the current function immediately, and to return a value to
      the caller.  In Haskell, &return; is the opposite of &larrow;.  That
      is, &return; takes a pure value and wraps it inside &IO;.  Since every
      I/O action must return some &IO; type, if your result came from pure
      computation, you must use &return; to wrap it in &IO;.  As an
      example, if <literal>7</literal> is an &Int;, then
      <literal>return 7</literal> would create an action stored in a 
      value of type
      <literal>IO Int</literal>.  When executed, that action would
      produce the result <literal>7</literal>.  For more
      details on &return;, see <xref linkend="io.return"/>.  
    </para>
    <para id="x_bC">
      Let's try running the program.  We've got a file named
      <literal>input.txt</literal> that looks like this:
    </para>
    <programlisting>
This is ch08/input.txt

Test Input
I like Haskell
Haskell is great
I/O is fun

123456789
    </programlisting>
    <para id="x_cC">
      Now, you can use <literal>runghc toupper-imp.hs</literal> and you'll
      find <literal>output.txt</literal> in your directory.  It should look
      like this:
    </para>
    <programlisting>
THIS IS CH08/INPUT.TXT

TEST INPUT
I LIKE HASKELL
HASKELL IS GREAT
I/O IS FUN

123456789
    </programlisting>
    <sect2 id="io.files.openFile">
      <title>More on openFile</title>
      <para id="x_dC">
        Let's use &ghci; to check on the type of &openFile;:
      </para>
      &openFile.ghci:all;
      <para id="x_eC">
        &FilePath; is simply another name for &String;.  It is used in the
        types of I/O functions to help clarify that the parameter is being
        used as a filename, and not as regular data.
      </para>
      <para id="x_fC">
        &IOMode; specifies how the file is to be managed.  The possible
        values for &IOMode; are listed in <xref
          linkend="io.files.openFile.IOModes"/>.
      </para>
      <remark>FIXME: check formatting on this table for final book; openjade
      doesn't render it well</remark>
      <table id="io.files.openFile.IOModes" tocentry="1">
        <title>Possible IOMode Values</title>
        <tgroup cols='4' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <colspec colname='c3'/>
          <colspec colname='c4'/>
          <colspec colname='c5'/>
          <thead>
            <row>
              <entry>&IOMode;</entry>
              <entry>Can read?</entry>
              <entry>Can write?</entry>
              <entry>Starting position</entry>
              <entry>Notes</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&ReadMode;</entry>
              <entry>Yes</entry>
              <entry>No</entry>
              <entry>Beginning of file</entry>
              <entry>File must exist already</entry>
            </row>
            <row>
              <entry>&WriteMode;</entry>
              <entry>No</entry>
              <entry>Yes</entry>
              <entry>Beginning of file</entry>
              <entry>File is truncated (completely emptied) if it already existed</entry>
            </row>
            <row>
              <entry>&ReadWriteMode;</entry>
              <entry>Yes</entry>
              <entry>Yes</entry>
              <entry>Beginning of file</entry>
              <entry>File is created if it didn't exist; otherwise, existing
                data is left intact</entry>
            </row>
            <row>
              <entry>&AppendMode;</entry>
              <entry>No</entry>
              <entry>Yes</entry>
              <entry>End of file</entry>
              <entry>File is created if it didn't exist; otherwise, existing
                data is left intact.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="x_gC">
        While we are mostly working with text examples in this chapter,
        binary files can also be used in Haskell.  If you are working with a
        binary file, you should use &openBinaryFile; instead of &openFile;.
        Operating systems such as Windows process files differently if they
        are opened as binary instead of as text.  On operating systems such
        as Linux, both &openFile; and &openBinaryFile; perform the same
        operation.  Nevertheless, for portability, it is still wise to always
        use &openBinaryFile; if you will be dealing with binary data.
      </para>

    </sect2>

    <sect2 id="io.files.closing">
      <title>Closing Handles</title>
      <para id="x_hC">
        You've already seen that &hClose; is used to close file handles.
        Let's take a moment and think about why this is important.
      </para>
      <para id="x_iC">
        As you'll see in <xref linkend="io.buffering"/>, Haskell maintains
        internal buffers for files.  This provides an important performance
        boost.  However, it means that until you call &hClose; on a
        file that is open for writing, your data may not be flushed
        out to the operating system.  
      </para>
      <para id="x_jC">
        Another reason to make sure to &hClose; files is that open files take
        up resources on the system.  If your program runs for a long time, and
        opens many files but fails to close them, it is conceivable that your
        program could even crash due to resource exhaustion.  All of
        this is no different in Haskell than in other languages.
      </para>
      <para id="x_kC">
        When a program exits, Haskell will normally take care of closing any
        files that remain open.  However, there are some circumstances in
        which this may not happen<footnote><para id="x_lC">If there was a bug in the C
            part of a hybrid program, for instance</para></footnote>, so once
        again, it is best to be responsible and call &hClose; all the time.
      </para>
      <para id="x_aN">
        Haskell provides several tools for you to use to easily ensure
        this happens, regardless of whether errors are present.  
        You can read about <literal>finally</literal> in <xref
        linkend="io.example"/> and <literal>bracket</literal> in
        <xref linkend="find.acquire.use.release"/>.
      </para>
    </sect2>

    <sect2 id="io.files.seeking">
      <title>Seek and Tell</title>
      <para id="x_mC">
        When reading and writing from a &Handle; that corresponds to
        a file on disk, the operating system maintains
        an internal record of the current position.  Each time you do another
        read, the operating system returns the next chunk of data that begins
        at the current position, and increments the position to reflect the
        data that you read.
      </para>
      <para id="x_nC">
        You can use &hTell; to find out your current position in the file.
        When the file is initially created, it is empty and your position
        will be 0.  After you write out 5 bytes, your position will be
        5, and so on.  &hTell; takes a &Handle; and returns an <literal>IO
          Integer</literal> with your position.
      </para>
      <para id="x_oC">
        The companion to &hTell; is &hSeek;.  &hSeek; lets you change the
        file position.  It takes three parameters: a &Handle;, a &SeekMode;,
        and a position.
      </para>
      <para id="x_pC">
        &SeekMode; can be one of three different values, which specify how
        the given position is to be interpreted.  &AbsoluteSeek; means that
        the position is a precise location in the file.  This is the same
        kind of information that &hTell; gives you.  &RelativeSeek; means to
        seek from the current position.  A positive number requests going 
        forwards in the file, and a negative number means going backwards.
        Finally, &SeekFromEnd; will seek to the specified number of bytes
        before the end of the file.  <literal>hSeek handle SeekFromEnd
          0</literal> will take you to the end of the file.
        For an example of &hSeek;, refer to <xref linkend="io.example"/>.
      </para>
      <para id="x_qC">
        Not all &Handle;s are seekable.  A &Handle; usually corresponds to a
        file, but it can also correspond to other things such as network
        connections, tape drives, or terminals.  You can use &hIsSeekable; to
        see if a given &Handle; is seekable.
      </para>
    </sect2>

    <sect2 id="io.files.stdin">
      <title>Standard Input, Output, and Error</title>
      <para id="x_rC">
        Earlier, we pointed out that for each non-"h" function, there is
        usually also a corresponding "h" function that works on any &Handle;.
        In fact, the non-"h" functions are nothing more than shortcuts for
        their "h" counterparts.
      </para>
      <para id="x_sC">
        There are three pre-defined &Handle;s in
        <literal>System.IO</literal>.  These &Handle;s are always available
        for your use.
        They are &stdin;, which corresponds to standard input; &stdout; for
        standard output; and &stderr; for standard error.  Standard input
        normally refers to the keyboard, standard output to the monitor, and
        standard error also normally goes to the monitor.
      </para>
      <para id="x_uC">
        Functions such as &getLine; can thus be trivially defined like this:
      </para>
<programlisting>
getLine = hGetLine stdin
putStrLn = hPutStrLn stdout
print = hPrint stdout
</programlisting>
      <tip>
        <para id="x_bN">We're using partial application here.  If this isn't
        making sense, consult
          <xref linkend="fp.partialapp"/> for a refresher.
        </para>
      </tip>
      <para id="x_vC">
        Earlier, we told you what the three standard file handles "normally"
        correspond to.  That's because some operating systems let you
        redirect the file handles to come from (or go to) different places&emdash;files, devices, or even other programs.  This feature is used
        extensively in shell scripting on POSIX (Linux, BSD, Mac)
        operating systems, but can
        also be used on Windows.
      </para>
      <para id="x_wC">
        It often makes sense to use standard input and output instead of
        specific files.  This lets you interact with a human at the terminal.
        But it also lets you work with input and output files&emdash;or even
        combine your code with other programs&emdash;if that's
        what's requested.<footnote><para id="x_cN">For more information on
        interoperating with other programs with pipes, see <xref linkend="systems.piping"/>.</para>
        </footnote>
      </para>
      <para id="x_xC">
        As an example, we can provide input to
        <literal>callingpure.hs</literal> in advance like this:
      </para>
      <screen>
$ <userinput>echo John|runghc callingpure.hs</userinput>
Greetings once again.  What is your name?
Pleased to meet you, John.
Your name contains 4 characters.
      </screen>
      <para id="x_yC">
        While <literal>callingpure.hs</literal> was running, it did not wait
        for input at the keyboard; instead it received
        <literal>John</literal> from the <literal>echo</literal> program.
        Notice also that the output didn't contain the word
        <literal>John</literal> on a separate line as it did when this
        program was run at the keyboard.  The terminal normally echoes
        everything you type back to you, but that is technically input, and
        is not included in the output stream.
      </para>
    </sect2>

    <sect2 id="io.files.ops">
      <title>Deleting and Renaming Files</title>
      <para id="x_zC">
        So far in this chapter, we've discussed the contents of the files.
        Let's now talk a bit about the files themselves.
      </para>
      <para id="x_AD">
        &System.Directory; provides two functions you may find useful.
        &removeFile; takes a single argument, a filename, and deletes that
        file.<footnote><para id="x_BD">POSIX programmers may be interested to know that
            this corresponds to <literal>unlink()</literal> in
            C.</para></footnote>  &renameFile; takes two filenames: the first
        is the old name and the second is the new name.  If the new filename
        is in a different directory, you can also think of this as a move.
        The old filename must exist prior to the call to &renameFile;.  If
        the new file already exists, it is removed before the rename takes
        place.
      </para>
      <para id="x_rp">
        Like many other functions that take a filename, if the "old"
        name doesn't exist, &renameFile; will raise an exception.
        More information on exception handling can be found in <xref
        linkend="errors"/>.
      </para>
      <para id="x_CD">
        There are many other functions in &System.Directory; for doing things
        such as creating and removing directories, finding lists of files in
        directories, and testing for file existence.  These are discussed in
        <xref linkend="systems.directories"/>.
      </para>
    </sect2>

    <sect2 id="io.files.temp">
      <title>Temporary Files</title>
      <para id="x_DD">
        Programmers frequently need temporary files.  These files
        may be used to store large amounts of data needed for computations, data to be
        used by other programs, or any number of other uses.
      </para>
      <para id="x_ED">
        While you could craft a way to manually open files with unique names,
        the details of doing this in a secure way differ from platform to
        platform.  Haskell provides a convenient function called
        &openTempFile; (and a corresponding &openBinaryTempFile;) to handle
        the difficult bits for you.
      </para>
      <para id="x_FD">
        &openTempFile; takes two parameters: the directory in which to create
        the file, and a "template" for naming the file.  The directory could
        simply be <literal>"."</literal> for the current working directory.
        Or you could use
        <literal>System.Directory.getTemporaryDirectory</literal> to find the
        best place for temporary files on a given machine.  The template is used
        as the basis for the file name; it will have some random characters
        added to it to ensure that the result is truly unique.  It
        guarantees that it will be working on a unique filename, in fact.
      </para>
      <para id="x_GD">
        The return type of &openTempFile; is <literal>IO (FilePath,
          Handle)</literal>.  The first part of the tuple is the name of the
        file created, and the second is a &Handle; opened in &ReadWriteMode;
        over that file.  When you're done with the file, you'll want to
        &hClose; it and then call &removeFile; to delete it.  See the
        following example for a sample function to use.
      </para>
        
    </sect2>
  </sect1>

  <sect1 id="io.example">
    <title>Extended Example: Functional I/O and Temporary Files</title>
    <para id="x_HD">
      Here's a larger example that puts together some concepts from this
      chapter, from some earlier chapters, and a few you haven't seen yet.
      Take a look at the program and see if you can figure out what it does
      and how it works.
    </para>

    &tempfile.hs:all;

    <para id="x_ID">
      Let's start looking at this program from the end.  The
      <literal>withTempFile</literal> function demonstrates that Haskell
      doesn't forget its functional nature when I/O is introduced.  This
      function takes a &String; and another function.  The function
      passed to <literal>withTempFile</literal> is invoked with the
      name and &Handle; of a temporary file.  When that function
      exits, the temporary file is closed and deleted.  So even when
      dealing with I/O, we can still find the idiom of passing
      functions as parameters to be convenient.  Lisp programmers
      might find our <literal>withTempFile</literal> function similar
      to Lisp's <literal>with-open-file</literal> function.
    </para>
    <para id="x_JD">
      There is some exception handling going on to make the program more
      robust in the face of errors.  You normally want the temporary files to
      be deleted after processing completes, even if something went wrong.  So we make sure
      that happens.  For more on exception handling, see <xref linkend="errors"/>.
    </para>
    <para id="x_KD">Let's return to the start of the program.  &main; is defined simply
      as <literal>withTempFile "mytemp.txt" myAction</literal>.
      <literal>myAction</literal>, then, will be invoked with the name and
      &Handle; of the temporary file.
    </para>
    <para id="x_LD">
      <literal>myAction</literal> displays some information to the terminal,
      writes some data to the file, seeks to the beginning of the file, 
      and reads the data back with
      &hGetContents;.<footnote><para id="x_MD">&hGetContents; will be discussed in
          <xref linkend="io.lazy"/></para></footnote>  It then displays
      the contents of the file byte-for-byte, and also as a Haskell literal
      via <literal>print c</literal>.  That's the same as <literal>putStrLn
        (show c)</literal>.
    </para>
    <para id="x_ND">
      Let's look at the output:
    </para>
    <screen>
$ <userinput>runhaskell tempfile.hs</userinput>
Welcome to tempfile.hs
I have a temporary file at /tmp/mytemp8572.txt
My initial position is 0
Writing one line containing 22 bytes: [1,2,3,4,5,6,7,8,9,10]
After writing, my new position is 23
The file content is:
[1,2,3,4,5,6,7,8,9,10]

Which could be expressed as this Haskell literal:
"[1,2,3,4,5,6,7,8,9,10]\n"
    </screen>
    <para id="x_OD">
      Every time you run this program, your temporary file name should be
      slightly different since it contains a randomly-generated component.
      Looking at this output, there are a few questions that might occur to
      you:
    </para>
    <orderedlist>
      <listitem><para id="x_PD">Why is your position 23 after writing a line with 22
          bytes?</para></listitem>
      <listitem><para id="x_QD">Why is there an empty line after the file content
          display?</para></listitem>
      <listitem><para id="x_RD">Why is there a <literal>\n</literal> at the end of the
          Haskell literal display?</para></listitem>
    </orderedlist>
    <para id="x_SD">
      You might be able to guess that the answers to all three questions are
      related.  See if you can work out the answers for a moment.  If you
      need some help, here are the explanations:
    </para>
    <orderedlist>
      <listitem><para id="x_TD">That's because we used &hPutStrLn; instead of &hPutStr;
          to write the data.  &hPutStrLn; always terminates the line by
          writing a <literal>\n</literal> at the end, which didn't appear in
          <literal>tempdata</literal>.</para></listitem>
      <listitem><para id="x_UD">We used <literal>putStrLn c</literal> to display the
          file contents <literal>c</literal>.  Because the data was written
          originally with &hPutStrLn;, <literal>c</literal> ends with the
          newline character, and &putStrLn; adds a second newline character.
          The result is a blank line.</para></listitem>
      <listitem><para id="x_VD">The <literal>\n</literal> is the newline character from
          the original &hPutStrLn;.</para></listitem>
    </orderedlist>
    <para id="x_dN">
      As a final note, the byte counts may be different on some
      operating systems.  Windows, for instance, uses the two-byte sequence
      <literal>\r\n</literal> as the end-of-line marker, so you may
      see differences on that platform.
    </para>
  </sect1>

  <sect1 id="io.lazy">
    <title>Lazy I/O</title>
    <para id="x_WD">
      So far in this chapter, you've seen examples of fairly traditional I/O.
      Each line, or block of data, is requested individually and processed
      individually.
    </para>
    <para id="x_XD">
      Haskell has another approach available to you as well.  Since Haskell
      is a lazy language, meaning that any given piece of data is only
      evaluated when its value must be known, there are some novel ways of
      approaching I/O.
    </para>
    <sect2 id="io.lazy.hGetContents">
      <title>hGetContents</title>
      <para id="x_YD">
        One novel way to approach I/O is the &hGetContents; function.<footnote><para id="x_ZD">There is
            also a shortcut function &getContents; that operates on standard
            input.</para></footnote>  &hGetContents; has the type
        <literal>Handle -> IO String</literal>.  The &String; it returns
        represents all of the data in the file given by the
        &Handle;.<footnote><para id="x_aD">More precisely, it is the entire data from the
            current position of the file pointer to the end of the
            file.</para></footnote>
      </para>
      <para id="x_bD">
        In a strictly-evaluated language, using such a function is often a bad idea.
        It may be fine to read the entire contents of a 2KB file, but if you
        try to read the entire contents of a 500GB file, you are likely to
        crash due to lack of RAM to store all that data.  In these
        languages, you would traditionally use mechanisms such as 
        loops to process the file's entire data.
      </para>
      <para id="x_cD">
        But &hGetContents; is different.  The &String; it returns is evaluated
        lazily.  At the moment you call &hGetContents;, nothing is actually
        read.  Data is only read from the &Handle; as the elements (characters)
        of the list are processed.  As elements of the &String; are no longer
        used, Haskell's garbage collector automatically frees that
        memory.  
        All of this happens
        completely transparently to you.  And since you have what looks like&emdash;and, really, is&emdash;a pure &String;, you can pass it to pure (non-&IO;)
        code.
      </para>
      <remark>FIXME: suggestion for a graphic from Eric Lavigne: Following Peter's (2007-09-27) comment, with which I strongly agree, I suggest a picture that uses colored boxes to represent lines in the file: red for no longer in scope, green for line being used right now, and yellow for not yet accessed. Explain that a Haskell program can be doing something with the green block while the red blocks are no longer taking up memory (due to garbage collection) and the yellow blocks haven't been read from the file yet (due to laziness).</remark>
      <para id="x_dD">
        Let's take a quick look at an example.  Back in
        <xref linkend="io.files"/>, you saw an imperative program
        that converted the entire content of a file to uppercase.  Its
        imperative algorithm was similar to what you'd see in many other
        languages.  Here now is the much simpler algorithm that
        exploits lazy evaluation:
      </para>
      &toupper-lazy1.hs:all;
      <para id="x_eD">
        Notice that &hGetContents; handled <emphasis>all</emphasis> of the
        reading for us.  Also, take a look at <literal>processData</literal>.
        It's a pure function since it has no side effects and always returns
        the same result each time it is called.  It has no need to know&emdash;and no way to tell&emdash;that its input is being read lazily from a file
        in this case.  It can work perfectly well with a 20-character literal
        or a 500GB data dump on disk.
      </para>
      <para id="x_fD">
        You can even verify that with &ghci;:
      </para>
      &toupper-lazy1.ghci:all;
      <warning>
        <para id="x_sp">
          If we had tried to hang on to <literal>inpStr</literal> in
          the above example, past the one place where it was used (the
          call to <literal>processData</literal>), the program would
          have lost its memory efficiency.  That's because the
          compiler would have been forced to keep
          <literal>inpStr</literal>'s value in memory for future use.
          Here it knows that <literal>inpStr</literal> will never be
          reused, and frees the memory as soon as it is done with it.
          Just remember: memory is only freed after its last use.
        </para>
      </warning>
      <para id="x_gD">
        This program was a bit verbose to make it clear that there was pure
        code in use.  Here's a bit more concise version, which we will build
        on in the next examples:
      </para>
      &toupper-lazy2.hs:all;
      <para id="x_hD">
        You are not required to ever consume all the data from the input file
        when using &hGetContents;.  Whenever the Haskell system determines
        that the entire string &hGetContents; returned can be garbage collected
       &emdash;which means it will never again be used&emdash;the file is closed
        for you automatically.  The same principle applies to data read from
        the file.  Whenever a given piece of data will never again be
        needed, the Haskell environment releases the memory it was stored
        within.  Strictly speaking, we wouldn't have to call
        <literal>hClose</literal> at all in this example program.
        However, it is still a good practice to get into, as later
        changes to a program could make the call to
        <literal>hClose</literal> important.
      </para>
      <warning>
        <para id="x_eN">
          When using &hGetContents;, it is important to remember that
          even though you may never again explicitly reference &Handle;
          directly in the rest of the program, you must not close the
          &Handle; until you have finished consuming its results via
          &hGetContents;.  Doing so would cause you to miss on some or
          all of the file's data.  Since Haskell is lazy, you generally
          can assume that you have consumed input only after you have
          output the result of the computations involving the input.
        </para>
      </warning>
    </sect2>
    <sect2 id="io.lazy.readFile">
      <title>readFile and writeFile</title>
      <para id="x_iD">
        Haskell programmers use &hGetContents; as a filter quite often.  They
        read from one file, do something to the data, and write the result
        out elsewhere.  This is so common that there are some shortcuts for
        doing it.  &readFile; and &writeFile; are shortcuts for working with
        files as strings.  They handle all the details of opening files,
        closing files, reading data, and writing data.  &readFile; uses
        &hGetContents; internally.
      </para>
      <para id="x_jD">
        Can you guess the Haskell types of these functions?  Let's check with
        &ghci;:
      </para>
      &readfile.ghci:all;
      <para id="x_tp">
        Now, here's an example program that uses &readFile; and
        &writeFile;:
      </para>
      &toupper-lazy3.hs:all;
      <para id="x_kD">
        Look at that&emdash;the guts of the program take up only two lines!
        &readFile; returned a lazy &String;, which we stored in
        <literal>inpStr</literal>.  We then took that, processed it, and
        passed it to &writeFile; for writing.
      </para>
      <para id="x_fN">
        Neither &readFile; nor &writeFile; ever provide a &Handle; for
        you to work with, so there is nothing to ever &hClose;.
        &readFile; uses &hGetContents; internally, and the underlying
        &Handle; will be closed when the returned &String; is
        garbage-collected or all the input has been consumed.
        &writeFile; will close its underlying &Handle; when the entire
        &String; supplied to it has been written.
      </para>
    </sect2>
    <sect2 id="io.lazy.output">
      <title>A Word On Lazy Output</title>
      <para id="x_lD">
        By now, you should understand how lazy input works in Haskell.  But
        what about laziness during output?
      </para>
      <para id="x_mD">
        As you know, nothing in Haskell is evaluated before its value is
        needed.  Since functions such as &writeFile; and &putStr; write out the entire
        &String; passed to them, that entire &String; must be evaluated.  So
        you are guaranteed that the argument to &putStr; will be evaluated in
        full.<footnote><para id="x_nD">Excepting I/O errors such as a full
            disk, of course.</para></footnote> 
      </para>
      <para id="x_oD">
        But what does that mean for laziness of the input?  In the examples
        above, will the call to &putStr; or &writeFile; force the entire
        input string to be loaded into memory at once, just to be written
        out?
      </para>
      <para id="x_pD">
        The answer is no.  &putStr; (and all the similar output functions)
        write out data as it becomes available.  They also have no need for
        keeping around data already written, so as long as nothing else in
        the program needs it, the memory can be freed immediately.  In
        a sense, you can think of the &String; between &readFile; and
        &writeFile; as a pipe linking the two.  Data goes in one end,
        is transformed some way, and flows back out the other.
      </para>
      <para id="x_qD">
        You can verify this yourself by generating a large
        <literal>input.txt</literal> for <literal>toupper-lazy3.hs</literal>.
        It may take a bit to process, but you should see a constant&emdash;and
        low&emdash;memory usage while it is being processed.
      </para>
    </sect2>

    <sect2 id="io.lazy.interact">
      <title>interact</title>
      <para id="x_rD">
        You learned that &readFile; and &writeFile; address the common situation of
        reading from one file, making a conversion, and writing to a
        different file.  There's a situation that's even more common than
        that: reading from standard input, making a conversion, and writing
        the result to standard output.  For that situation, there is a
        function called &interact;.  The type of &interact; is
        <literal>(String -> String) -> IO ()</literal>.   That is, it
        takes one argument: a
        function of type <literal>String -> String</literal>.  That function
        is passed the result of <literal>getContents</literal>&emdash;that is,
        standard input read lazily.  The result of that function is sent to
        standard output.
      </para>
      <para id="x_sD">
        We can convert our example program to operate on standard input
        and standard output by using <literal>interact</literal>.  Here's one
        way to do that:
      </para>
      &toupper-lazy4.hs:all;
      <para id="x_tD">
        Look at that&emdash;<emphasis>one</emphasis> line of code to achieve our
        transformation!  To achieve the same effect as with the previous
        examples, you could run this one like this:
      </para>
      <screen>
$ <userinput>runghc toupper-lazy4.hs &lt; input.txt &gt; output.txt</userinput>
      </screen>
      <para id="x_uD">
        Or, if you'd like to see the output printed to the screen, you could
        type:
      </para>
      <screen>
$ <userinput>runghc toupper-lazy4.hs &lt; input.txt</userinput>
      </screen>
      <para id="x_vD">
        If you want to see that Haskell output truly does write out chunks of
        data as soon as they are received, run <literal>runghc
          toupper-lazy4.hs</literal> without any other command-line
        parameters.  You should see each character echoed back out as soon as
        you type it, but in uppercase.  Buffering may change this behavior;
        see <xref linkend="io.buffering"/> later in this chapter for more
        on buffering.  If you see each line echoed as soon as you type it, or
        even nothing at all for awhile, buffering is causing this behavior.
      </para>
      <para id="x_wD">
        You can also write simple interactive programs using &interact;.  Let's
        start with a simple example: adding a line of text before the
        uppercase output.
      </para>
      &toupper-lazy5.hs:all;
        <tip><para id="x_gN">If the use of the <literal>.</literal> operator is
        confusing, you might wish to refer to <xref
        linkend="fp.compose"/>.
          </para>
        </tip>
      <para id="x_xD">
        Here we add a string at the beginning of the output.  Can you spot
        the problem, though?
      </para>
      <para id="x_yD">
        Since we're calling &map; on the <emphasis>result</emphasis> of
        <literal>(++)</literal>, that header itself will appear in uppercase.
        We can fix that in this way:
      </para>
      &toupper-lazy6.hs:all;
      <para id="x_zD">
        This moved the header outside of the &map;.
      </para>
      <sect3>
        <title>Filters with interact</title>
        <para id="x_AE">
          Another common use of &interact; is filtering.  Let's say that you
          want to write a program that reads a file and prints out every line
          that contains the character "a".  Here's how you might do that with
          &interact;:
        </para>
        &filter.hs:all;
        <para id="x_BE">
          This may have introduced three functions that you aren't familiar
          with yet.  Let's inspect their types with &ghci;:
        </para>
        &filter.ghci:all;
        <para id="x_CE">
          Can you guess what these functions do just by looking at
          their types?
          If not, you can find them explained in <xref
          linkend="fp.splitlines"/> and <xref
          linkend="fp.lists.strings"/>. 
          You'll frequently see &lines; and
          &unlines; used with I/O.  Finally, &elem; takes a element and a list
          and returns &True; if that element occurs anywhere in the list.
        </para>
        <para id="x_EE">
          Try running this over our standard example input:
        </para>
        <screen>
  $ <userinput>runghc filter.hs &lt; input.txt</userinput>
  I like Haskell
  Haskell is great
        </screen>
        <para id="x_FE">
          Sure enough, you got back the two lines that contain an "a".  
          Lazy filters are a powerful way to use Haskell.  When you think
          about it, a filter&emdash;such as the standard Unix program
          <command>grep</command>&emdash;sounds a lot like a function.  It takes
          some input, applies some computation, and generates a predictable
          output.
        </para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="io.monad">
    <title>The IO Monad</title>
    <para id="x_GE">
      You've seen a number of examples of I/O in Haskell by this point.
      Let's take a moment to step back and think about how I/O relates to the
      broader Haskell language.
    </para>
    <para id="x_HE">
      You may recall from <remark>FIXME: add ref</remark> that Haskell is a
      pure language.  That is, if you give a certain function a specific
      argument, the function will return the same result every time you give
      it that argument.  Moreover, the function will not change anything
      about the program's overall state.
    </para>
    <para id="x_IE">
      You may be wondering, then, how I/O fits into this picture.  Surely if
      you want to read a line of input from the keyboard, the function to
      read input can't possibly return the same result every time it is run,
      right?  Moreover, I/O is all about changing state.  I/O could cause
      pixels on a terminal to light up, to cause paper to start coming out of
      a printer, or even to cause a package to be shipped from a warehouse on
      a different continent.  I/O doesn't just change the state of a program.
      You can think of I/O as changing the state of the world.
    </para>
    <sect2 id="io.monad.actions">
      <title>Actions</title>
      <para id="x_JE">
        Most languages do not make a distinction between a pure function and an
        impure one.  Haskell has functions in the mathematical sense: they are
        purely computations which cannot be altered by anything external.
        Moreover, the computation can be performed at any time&emdash;or even
        never, if its result is never needed.
      </para>
      <para id="x_KE">
        Clearly, then, we need some other tool to work with I/O.  That tool in
        Haskell is called <emphasis>actions</emphasis>.  Actions resemble
        functions.  They do nothing when they are defined, but perform some
        task when they are invoked.  I/O actions are defined within the &IO;
        monad.  Monads are a powerful way of chaining functions
        together
        purely and are covered in <xref linkend="monads"/>.  It's not
        necessary to understand monads in order to understand I/O.  Just
        understand that the result type of actions is "tagged" with 
        &IO;.  Let's take a look at some types:
      </para>
      &basicio.ghci:all.noid;
      <para id="x_LE">
        The type of &putStrLn; is just like any other function.  The function takes
        one parameter and returns an <literal>IO ()</literal>.  This
        <literal>IO ()</literal> is the action.  You can store and pass actions
        in pure code if you wish, though this isn't frequently done.  An action doesn't do
        anything until it is invoked.  Let's look at an example of this:
      </para>
      &actions.hs:all;
      <para id="x_ME">
        <literal>str2action</literal> is a function that takes one parameter
        and returns an <literal>IO ()</literal>.  As you can see at the end of
        &main;, you could use this directly in another action and it will print
        out a line right away.  Or, you can store&emdash;but not execute&emdash;the
        action from pure code.  You can see an example of that in
        <literal>list2actions</literal>&emdash;we use &map; over
        <literal>str2action</literal> and return a list of actions, just like
        we would with other pure data.  You can see that everything up through
        <literal>printitall</literal> is built up with pure tools.
      </para>
      <para id="x_NE">
        Although we define <literal>printitall</literal>, it doesn't get
        executed until its action is evaluated somewhere else.  Notice in
        <literal>main</literal> how we use <literal>str2action</literal> as
        an I/O action to be executed, but earlier we used it outside of the I/O
        monad and assembled results into a list.
      </para>
      <para id="x_OE">
        You could think of it this way: every statement, except &let;, in a &do; block must
        yield an I/O action which will be executed.
      </para>
      <para id="x_PE">
        The call to <literal>printitall</literal> finally executes all those actions.  Actually,
        since Haskell is lazy, the actions aren't generated until here either.
      </para>
      <para id="x_QE">
        When you run the program, your output will look like this:
      </para>
      <screen>
Data: Start of the program
Data: 1
Data: 2
Data: 3
Data: 4
Data: 5
Data: 6
Data: 7
Data: 8
Data: 9
Data: 10
Data: Done!
      </screen>
      <para id="x_RE">
        We can actually write this in a much more compact way.  Consider this
        revision of the example:
      </para>
      &actions2.hs:all;
      <para id="x_SE">
        Notice in <literal>str2action</literal> the use of the standard
        function composition operator.  In &main;, there's a call to &mapM_;.
        This function is similar to &map;.  It takes a function and a list.
        The function supplied to &mapM_; is an I/O action that is executed for
        every item in the list.  &mapM_; throws out the result of the function,
        though you can use &mapM; to return a list of I/O results if you want
        them.  Take a look at their types:
      </para>
      &map.ghci:all;
      <tip>
        <para id="x_TE">
          These functions actually work for more than just I/O; they work for any
          &Monad;.  For now, wherever you see "M", just think "IO".
          Also, functions that end with an underscore typically
          discard their result.
        </para>
      </tip>
      <para id="x_UE">
        Why a &mapM; when we already have &map;?  Because &map; is a pure
        function that returns a list.  It doesn't&emdash;and can't&emdash;actually
        execute actions directly.  &mapM; is a utility that lives in the
        &IO; monad and thus can actually execute the
        actions.<footnote><para id="x_hN">Technically speaking, &mapM; combines
        a bunch of separate I/O actions into one big action.  The
        separate actions are executed when the big action is.</para>
        </footnote>
      </para>
      <para id="x_VE">
        Going back to &main;, &mapM_; applies 
        <literal>(str2action . show)</literal> to every element in
        <literal>numbers</literal>.  &show; converts each number to a &String;
        and <literal>str2action</literal> converts each &String; to an action.
        &mapM_; combines these individual actions into one big
        action that prints out lines.
      </para>
    </sect2>
    <sect2 id="io.bind">
      <title>Sequencing</title>
      <para id="x_WE">
        &do; blocks are actually shortcut notations for joining
        together actions.  There are two operators that you can use instead of &do;
        blocks: &rr; and &rre;.  Let's look at their types in &ghci;:
      </para>
      &sequence.ghci:all;
      <para id="x_XE">
        The &rr; operator sequences two actions together: the first action is performed,
        then the second.  The result of the computation is the result of the
        second action.  The result of the first action is thrown away.  This is similar to
        simply having a line in a &do; block.  You might write
        <literal>putStrLn "line 1" &rr; putStrLn "line 2"</literal> to
        test this out.  It will print out two lines, discard the
        result from the first <literal>putStrLn</literal>, and provide
        the result from the second.
      </para>
      <para id="x_YE">
        The &rre; operator runs an action, then passes its result to a
        function that returns an
        action.  That second action is run as well, and the result of the entire
        expression is the result of that second action.  As an
        example, you could write <literal>getLine &rre;
        putStrLn</literal>, which would read a line from the keyboard
        and then display it back out.
      </para>
      <para id="x_ZE">
        Let's re-write one of our examples to avoid &do; blocks.  Remember
        this example from the start of the chapter?
      </para>
      &basicio.hs:all.noid;
      <para id="x_aE">
        Let's write that without a &do; block:
      </para>
      &basicio-nodo.hs:all;
      <para id="x_bE">
        The Haskell compiler internally performans a translation just like
        this when you define a &do; block.
      </para>
      <tip>
        <para id="x_iN">Forgetting how to use <literal>\</literal> (lambda
        expressions)?  See <xref linkend="fp.anonymous"/>.
        </para>
      </tip>
    </sect2>
    <sect2 id="io.return">
      <title>The True Nature of Return</title>
      <para id="x_jN">
        Earlier in this chapter, we mentioned that &return; is probably not
        what it looks like.  Many languages have a keyword named &return;
        that aborts execution of a function immediately and returns a value
        to the caller.
      </para>
      <para id="x_kN">
        The Haskell &return; function is quite different.  In Haskell,
        &return; is used to wrap data in a monad.  When speaking about I/O,
        &return; is used to take pure data and bring it into the IO monad.
      </para>
      <para id="x_lN">
        Now, why would we want to do that?  Remember that anything whose
        result depends on I/O must be within the IO monad.  So if we are
        writing a function that performs I/O, then a pure computation, we
        will need to use &return; to make this pure computation the proper
        return value of the function.  Otherwise, a type error would
        occur.  Here's an example:
      </para>
      &return1.hs:all;
      <para id="x_mN">
        We have a pure computation that yields a &Bool;.  That computation is
        passed to &return;, which puts it into the &IO; monad.  Since it is
        the last value in the &do; block, it becomes the return value of
        <literal>isGreen</literal>, but this is not because we used the
        &return; function.
      </para>
      <para id="x_nN">
        Here's a version of the same program with the pure computation broken
        out into a separate function.  This helps keep the pure code
        separate, and can also make the intent more clear.
      </para>
      &return2.hs:all;
      <para id="x_oN">
        Finally, here's a contrived example to show that &return; truly does
        not have to occur at the end of a &do; block.  In practice, it
        usually is, but it need not be so.
      </para>
      &return3.hs:all;
      <para id="x_pN">
        Notice that we used &larrow; in combination with &return;, but &let;
        in combination with the simple literal.  That's because we needed
        both values to be pure in order to add them, and &larrow; pulls
        things out of monads, effectively reversing the effect of &return;.
        Run this in &ghci; and you'll see <literal>3</literal> displayed, as
        expected.
      </para>
    </sect2>


  </sect1>

  <sect1 id="io.imperative">
    <title>Is Haskell Really Imperative?</title>
    <remark>FIXME: I don't really like this explanation</remark>
    <para id="x_cE">
      These &do; blocks may look a lot like an imperative language.  After
      all, you're giving commands to run in sequence most of the time.
    </para>
    <para id="x_dE">
      But Haskell remains a lazy language at its core.  While it is necessary
      to sequence actions for I/O at times, this is done using tools that are
      part of Haskell already.  Haskell achieves a nice separation of I/O
      from the rest of the language through the &IO; monad as well.
    </para>
  </sect1>

  <sect1 id="io.sideeffects">
    <title>Side Effects with Lazy I/O</title>
    <para id="x_eE">
      Earlier in this chapter, you read about &hGetContents;.
      We explained that the &String; it returns can be used in pure code.
    </para>
    <para id="x_fE">
      We need to get a bit more specific about what side effects are.  When
      we say Haskell has no side-effects, what exactly does that mean?
    </para>
    <para id="x_gE">
      At a certain level, side-effects are always possible.  A poorly-written
      loop, even if written in pure code, could cause the system's RAM to be
      exhausted and the machine to crash.  Or it could cause data to be
      swapped to disk.
    </para>
    <para id="x_hE">
      When we speak of no side effects, we mean that pure code in Haskell
      can't run commands that trigger side effects.  Pure functions 
      can't modify a global variable, request I/O, or run a command to take
      down a system.
    </para>
    <para id="x_iE">
      When you have a &String; from &hGetContents; that is passed to a pure
      function, the function has no idea that this &String; is backed by a
      disk file.  It will behave just as it always would, but processing that
      &String; may cause the environment to issue I/O commands.  The pure
      function isn't issuing them; they are happening as a result of the
      processing the pure function is doing, just as with the example of
      swapping RAM to disk.
    </para>
    <para id="x_jE">
      In some cases, you may need more control over exactly when your I/O
      occurs.  Perhaps you are reading data interactively from the user, or
      via a pipe from another program, and need to communicate directly with
      the user.  In those cases, &hGetContents; will probably not be
      appropriate.
    </para>
  </sect1>

  <sect1 id="io.buffering">
    <title>Buffering</title>
    <para id="x_kE">
      The I/O subsystem is one of the slowest parts of a modern
      computer.  
      Completing a
      write to disk can take thousands of times as long as a write to memory.
      A write over the network can be hundreds or thousands of times slower
      yet.  Even if your operation doesn't directly communicate with the disk&emdash;perhaps because the data is cached&emdash;I/O still involves a system call,
      which slows things down by itself.
    </para>
    <para id="x_lE">
      For this reason, modern operating systems and programming languages
      both provide  tools to help programs perform better where I/O is
      concerned.  The operating system typically performs caching&emdash;storing
      frequently-used pieces of data in memory for faster access.
    </para>
    <para id="x_mE">
      Programming languages typically perform buffering.  This means that
      they may request one large chunk of data from the operating system,
      even if the code underneath is processing data one character at a time.
      By doing this, they can achieve remarkable performance gains because
      each request for I/O to the operating system carries a
      processing cost.  Buffering allows us to read the same amount of
      data with far fewer I/O requests.
    </para>
    <para id="x_nE">
      Haskell, too, provides buffering in its I/O system.
      In many cases, it is even on by
      default.  Up till now, we have pretended it isn't there.  Haskell
      usually is good about picking a good default buffering mode.  But this
      default is rarely the fastest.  If you have speed-critical I/O code,
      changing buffering could make a significant impact on your program.
    </para>
    <sect2>
      <title>Buffering Modes</title>
      <para id="x_oE">
        There are three different buffering modes in Haskell.  They are
        defined as the &BufferMode; type: &NoBuffering;,
        &LineBuffering;, and &BlockBuffering;.
      </para>
      <para id="x_pE">&NoBuffering;
        does just what it sounds like&emdash;no buffering.  Data read via functions
        like &hGetLine; will be read from the OS one character at a time.  Data
        written will be written immediately, and also often will be written one
        character at a time.  For this reason, &NoBuffering; is usually a very
        poor performer and not suitable for general-purpose use.
      </para>
      <para id="x_qE">
        &LineBuffering; causes the output buffer to be written whenever the
        newline character is output, or whenever it gets too large.  On
        input, it will usually attempt to read whatever data is available in
        chunks until it first sees the newline character.  When reading from
        the terminal, it should return data immediately after each press of
        Enter.  It is often a reasonable default.
      </para>
      <para id="x_rE">
        &BlockBuffering; causes Haskell to read or write data in fixed-size
        chunks when possible.  This is the best performer when processing
        large amounts of data in batch, even if that data is line-oriented.
        However, it is unusable for interactive programs because it will
        block input until a full block is read.  &BlockBuffering; accepts one
        parameter of type <literal>Maybe</literal>: if &Nothing;, it will use an implementation-defined buffer
        size.  Or, you can use a setting such as <literal>Just 4096</literal> to 
        set the buffer to 4096 bytes.
      </para>
      <para id="x_sE">
        The default buffering mode is dependent upon the operating system and
        Haskell implementation.    You can
        ask the system for the current buffering mode by calling
        &hGetBuffering;.  The current mode can be set with
        &hSetBuffering;, which accepts a &Handle; and &BufferMode;.  As an example, you can say 
        <literal>hSetBuffering stdin (BlockBuffering Nothing)</literal>.
      </para>
    </sect2>
    <sect2>
      <title>Flushing The Buffer</title>
      <para id="x_tE">
        For any type of buffering, you may sometimes want to force Haskell to
        write out any data that has been saved up in the buffer.
        There are a few
        times when this will happen automatically: a call to &hClose;, for
        instance.  Sometimes you may want to instead call &hFlush;, which
        will force any pending data to be written immediately.  This
        could be useful when the &Handle; is a network socket and you
        want the data to be transmitted immediately, or when you want
        to make the data on disk available to other programs that
        might be reading it concurrently.
      </para>
    </sect2>
  </sect1>

  <sect1 id="io.args">
    <title>Reading Command-Line Arguments</title>
    <para id="x_uE">
      Many command-line programs are interested in the parameters passed on
      the command line.  <literal>System.Environment.getArgs</literal>
      returns <literal>IO [String]</literal> listing each argument.
      This is the same as <literal>argv</literal> in C, starting with
      <literal>argv[1]</literal>.  The program name
      (<literal>argv[0]</literal> in C) is available from <literal>System.Environment.getProgName</literal>.
    </para>
    <para id="x_wE">
      The <literal>System.Console.GetOpt</literal> module provides some tools
      for parsing command-line options.  If you have a program with complex
      options, you may find it useful.  You can find an example of its
      use in <xref linkend="stm.urlcheck.parseArgs"/>.
    </para>
  </sect1>

  <sect1 id="io.environ">
    <title>Environment Variables</title>
    <para id="x_xE">
      If you need to read environment variables, you can use one of two
      functions in <literal>System.Environment</literal>: &getEnv; or
      &getEnvironment;.  &getEnv; looks for a specific variable and raises an
      exception if it doesn't exist.  &getEnvironment; returns the whole
      environment as a <literal>[(String, String)]</literal>, and then you
      can use functions such as &lookup; to find the environment entry you
      want.
    </para>
    <para id="x_yE">
      Setting environment variables is not defined in a cross-platform way in
      Haskell.  If you are on a POSIX platform such as Linux, you can use
      <literal>putEnv</literal> or <literal>setEnv</literal> from the
      <literal>System.Posix.Env</literal> module.  Environment setting is not
      defined for Windows.
    </para>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
