<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="monadcase" revision="alpha;beta">
  <title>Programming with monads</title>

  <sect1 id="monadcase.urlencoded">
    <title>Golfing practice: association lists</title>

    <para id="x_ki">Web clients and servers often pass information around as a
      simple textual list of key-value pairs.</para>

    <programlisting>name=Attila+%42The+Hun%42&amp;occupation=Khan</programlisting>

    <para id="x_li">The encoding is named
      <code>application/x-www-form-urlencoded</code>, and it's easy to
      understand.  Each key-value pair is separated by an
      <quote><code>&amp;</code></quote> character.  Within a pair, a
      key is a series of characters, followed by an
      <quote><code>=</code></quote>, followed by a value.</para>

    <para id="x_mi">We can obviously represent a key as a <type>String</type>,
      but the HTTP specification is not clear about whether a key must
      be followed by a value.  We can capture this ambiguity by
      representing a value as a <type>Maybe String</type>.  If we use
      <code>Nothing</code> for a value, then there was no value
      present.  If we wrap a string in <code>Just</code>, then there
      was a value.  Using <type>Maybe</type> lets us distinguish
      between <quote>no value</quote> and <quote>empty
	value</quote>.</para>

    <para id="x_ni">Haskell programmers use the name <emphasis>association
	list</emphasis> for the type <type>[(a, b)]</type>, where we
      can think of each element as an association between a key and a
      value.  The name originates in the Lisp community, where it's
      usually abbreviated as an <emphasis>alist</emphasis>.  We could
      thus represent the above string as the following Haskell
      value.</para>

    &MovieReview.hs:attila;

    <para id="x_oi">In <xref linkend="applicative.urlencoded"/>, we'll parse an
      <code>application/x-www-form-urlencoded</code> string, and
      represent the result as an alist of <type>[(String, Maybe
	String)]</type>.  Let's say we want to use one of these alists
      to fill out a data structure.</para>

    &MovieReview.hs:MovieReview;

    <para id="x_pi">We'll begin by belabouring the obvious with a naive
      function.</para>

    &MovieReview.hs:simpleReview;

    <para id="x_qi">It only returns a <type>MovieReview</type> if the alist
      contains all of the necessary values, and they're all non-empty
      strings.  However, the fact that it validates its inputs is its
      only merit: it suffers badly from the <quote>staircasing</quote>
      that we've learned to be wary of, and it knows the intimate
      details of the representation of an alist.</para>

    <para id="x_ri">Since we're now well acquainted with the <type>Maybe</type>
      monad, we can tidy up the staircasing.</para>

    &MovieReview.hs:maybeReview;

    <para id="x_si">Although this is much tidier, we're still repeating
      ourselves.  We can take advantage of the fact that the
      <code>MovieReview</code> constructor acts as a normal, pure
      function by <emphasis>lifting</emphasis> it into the monad, as
      we discussed in <xref linkend="monads.liftM"/>.</para>

    &MovieReview.hs:liftedReview;
  </sect1>

  <sect1 id="monadcase.ap">
    <title>Generalised lifting</title>

    <para id="x_ti">Although using <function>liftM3</function> tidies up our
      code, we can't use a <function>liftM</function>-family function
      to solve this sort of problem in general, because they're only
      defined up to <function>liftM5</function>.  If we had a
      constructor or pure function that took, say, ten parameters, you
      might think we'd be out of luck.</para>

    <para id="x_ui">Of course, our toolbox isn't yet empty.  In
      <code>Control.Monad</code>, there's a function named
      <function>ap</function> with a slightly odd type
      signature.</para>

    &ap.ghci:ap;

    <para id="x_vi">You might wonder who would put a single-argument pure
      function inside a monad, and why.  Recall, however, that
      <emphasis>all</emphasis> Haskell functions really take only one
      argument, and you'll begin to see how this might relate to the
      <code>MovieReview</code> constructor.</para>

    &ap.ghci:MovieReview;

    <para id="x_wi">We can just as easily write that type as <type>String -&gt;
	(String -&gt; (String -&gt; MovieReview))</type>.  If we use
      plain old <function>liftM</function> to lift
      <code>MovieReview</code> into the <code>Maybe</code> monad,
      we'll have a value of type <type>Maybe (String -&gt; (String
	-&gt; (String -&gt; MovieReview)))</type>.  We can now see
      that this type is suitable as an argument for
      <function>ap</function>, in which case the result type will be
      <type>Maybe (String -&gt; (String -&gt; MovieReview))</type>. We
      can pass this, in turn, to <function>ap</function>, and continue
      to chain until we end up with this definition.</para>

    &MovieReview.hs:apReview;

    <para id="x_xi">We can chain applications of <function>ap</function> like
      this as many times as we need to, and thereby to avoid the hard
      limit of 5 on the <function>liftM</function> family of
      functions.</para>

    <para id="x_yi">Another helpful way to look at <function>ap</function> is
      that it's the monadic equivalent of the familiar
      <function>($)</function> operator.  We can see this clearly when
      we compare the type signatures of the two functions.</para>

    &ap.ghci:types;

  </sect1>

  <sect1 id="monadcase.monadplus">
    <title>Looking for alternatives</title>

    <para id="x_zi">Here's a simple representation of a person's phone
      numbers.</para>

    &VCard.hs:numbers;

    <para id="x_Aj">Suppose we want to get in touch with someone to make a
      personal call.  We don't want their business number, and we'd
      prefer to use their home number (if they have one) instead of
      their mobile number, because the call will be cheaper.</para>

    &VCard.hs:personalPhone;

    <para id="x_Bj">Of course, if we use <type>Maybe</type> as the result type,
      we can't accommodate the possibility that someone might have
      more than one number that meet our criteria.  For that, we
      switch to a list.</para>

    &VCard.hs:businessPhones;

    <para id="x_Cj">Notice that these two functions structure their &case;
      expressions similarly: one alternative handles the case where
      the first lookup returns an empty result, while the other
      handles the non-empty case.</para>

    &vcard.ghci:simple;
    
    <para id="x_Dj">Haskell's <code>Control.Monad</code> module defines a
      typeclass, <type>MonadPlus</type>, that lets us abstract the
      common pattern out of our &case; expressions.</para>

    &VCard.hs:MonadPlus;

    <para id="x_Ej">The value <code>mzero</code> represents an empty result,
      while <function>mplus</function> combines two results into one.
      Here are the standard definitions of <code>mzero</code> and
      <function>mplus</function> for <type>Maybe</type> and
      lists.</para>

    &VCard.hs:instances;

    <para id="x_Fj">We can now use <function>mplus</function> to get rid of our
      &case; expressions entirely.</para>

    &VCard.hs:caseless;

    <para id="x_Gj">In these functions, because we know that
      <function>lookup</function> returns a value of type
      <type>Maybe</type>, and <function>filter</function> returns a
      list, it's obvious which version of <function>mplus</function>
      is going to be used in each case.</para>

    <para id="x_Hj">What's more interesting is that we can use
      <code>mzero</code> and <function>mplus</function> to write
      functions that will be useful for <emphasis>any</emphasis>
      <type>MonadPlus</type> instance.  As an example, here's the
      standard <function>lookup</function> function, which returns a
      value of type <type>Maybe</type>.</para>

    &VCard.hs:lookup;

    <para id="x_Ij">We can easily generalise the result type to any instance of
      <type>MonadPlus</type> as follows.</para>

    &VCard.hs:lookupM;

    <para id="x_Jj">This lets us get either no result or one, if our result type
      is <type>Maybe</type>; all results, if our result type is a
      list; or something of appropriate for some other exotic instance
      of <type>MonadPlus</type>.</para>

    <sect2>
      <title>The name mplus does not imply addition</title>

      <para id="x_Kj">Even though the <function>mplus</function> function
	contains the text <quote>plus</quote>, you should not think of
	it as necessarily implying that we're trying to add two
	values.</para>

      <para id="x_Lj">Depending on the monad we're working in,
	<function>mplus</function> <quote>may</quote> implement an
	operation that looks like addition.  For example,
	<function>mplus</function> in the list monad is implemented as
	the <function>(++)</function> operator.</para>

      &monadPlus.ghci:list.mplus;

      <para id="x_Mj">However, if we switch to another monad, the obvious
	similarity to addition falls away.</para>

      &monadPlus.ghci:maybe.mplus;

    </sect2>

    <sect2>
      <title>Rules for working with MonadPlus</title>

      <para id="x_Nj">Instances of the <type>MonadPlus</type> typeclass must
	follow a few  simple rules, in addition to the usual monad
	rules.</para>

      <para id="x_Oj">An instance must <emphasis>short circuit</emphasis> if
	<code>mzero</code> appears on the left of a bind expression.
	In other words, an expression <code>mzero &gt;&gt;= f</code>
	must evaluate to the same result as <code>mzero</code>
	alone.</para>

      &MonadPlus.hs:shortcircuitLeft;

      <para id="x_Pj">An instance must short circuit if <code>mzero</code>
	appears on the <emphasis>right</emphasis> of a sequence
	expression.</para>

      &MonadPlus.hs:shortcircuitRight;

    </sect2>

    <sect2>
      <title>Failing safely with MonadPlus</title>

      <para id="x_Qj">When we introduced the &fail; function in <xref
	  linkend="monads.class"/>, we took pains to warn against its
	use: in many monads, it's implemented as a call to &error;,
	which has disastrous consequences.</para>

      <para id="x_Rj">The <type>MonadPlus</type> typeclass gives us a gentler
	way to fail a computation, without &fail; or &error; blowing
	up in our faces.  The rules that we introduced above allow us
	to introduce a <code>mzero</code> into our code wherever we
	need to, and computation will short circuit at that
	point.</para>

      <para id="x_Sj">In the <code>Control.Monad</code> module, the standard
	function <function>guard</function> packages up this idea in a
	convenient form.</para>

      &MonadPlus.hs:guard;

      <para id="x_Tj">As a simple example, here's a function that takes a number
	<varname>x</varname> and computes its value modulo some other
	number <varname>n</varname>.  If the result is zero, it
	returns <varname>x</varname>, otherwise the current monad's
	<code>mzero</code>.</para>

      &MonadPlus.hs:zeroMod;
    </sect2>
  </sect1>

  <sect1>
    <title>Adventures in hiding the plumbing</title>

    <para>In <xref linkend="monads.state.random"/>, we showed how to
      use the <type>State</type> monad to give ourselves access to
      random numbers in a way that is easy to use.</para>

    <para>A drawback of the code we developed is that it's
      <emphasis>leaky</emphasis>: someone who uses it knows that
      they're executing inside the <type>State</type> monad.  This
      means that they can inspect and modify the state of the random
      number generator just as easily as we, the authors, can.</para>

    <para>Human nature dictates that if we leave our internal workings
      exposed, someone will surely come along and monkey with them.
      For a sufficiently small program, this may be fine, but in a
      larger software project, when one consumer of a library modifies
      its internals in a way that other consumers are not prepared
      for, the resulting bugs can be among the hardest of all to track
      down.  These bugs occur at a level where we're unlikely to
      question our basic assumptions about a library until long after
      we've exhausted all other avenues of inquiry.</para>

    <para>Even worse, once we leave our implementation exposed for a
      while, and some well-intentioned person inevitably bypasses our
      APIs and uses the implementation directly, we create a nasty
      quandary for ourselves if we need to fix a bug or make an
      enhancement.  Either we can modify our internals, and break code
      that depends on them; or we're stuck with our existing
      internals, and must try to find some other way to make the
      change we need.</para>

    <para>How can we revise our random number monad so that the fact
      that we're using the <type>State</type> monad is hidden?  We
      need to somehow prevent our users from being able to call
      <code>get</code> or <code>put</code>.  This is not difficult to
      do, and it introduces some tricks that we'll reuse often in
      day-to-day Haskell programming.</para>

    <para>To widen our scope, we'll move beyond random numbers, and
      implement a monad that supplies unique values of
      <emphasis>any</emphasis> kind.  The name we'll give to our monad
      is <type>Supply</type>.  We'll provide the execution function,
      <function>runSupply</function>, with a list of values; it will
      be up to us to ensure that each one is unique.</para>

    &Supply.hs:runSupply.type;

    <para>The monad won't care what the values are: they might be
      random numbers, or names for temporary files, or identifiers for
      HTTP cookies.</para>

    <para>Within the monad, every time a consumer asks for a value,
      the <function>next</function> action will take the next one from
      the list and give it to the consumer.  Each value is wrapped in
      a <type>Maybe</type> constructor in case the list isn't long
      enough to satisfy the demand.</para>

    &Supply.hs:next.type;

    <para>To hide our plumbing, in our module declaration we only
      export the type constructor, the execution function, and the
      <function>next</function> action.</para>

    &Supply.hs:module;

    <para>Since a module that imports the library can't see the
      internals of the monad, it can't manipulate them.</para>

    <para>Our plumbing is exceedingly simple.  We use a &newtype;
      declaration to wrap the existing <type>State</type>
      monad.</para>

    &Supply.hs:Supply;

    <para>The <varname role="type">s</varname> parameter is the type
      of the unique values we are going to supply, and <varname
	role="type">a</varname> is the usual free type variable that
      we must provide in order to make our type a monad.</para>

    <para>Our <type>Supply</type> type and our module header join
      forces to prevent our clients from using the <type>State</type>
      monad's <function>get</function> and <function>set</function>
      actions.  Because our module does not export the <code>S</code>
      data constructor, clients have no programmatic way to see that
      we're wrapping the <type>State</type> monad, or to access
      it.</para>

    <para>At this point, we've got a type, <type>Supply</type>, that
      we need to make an instance of the <type>Monad</type> type
      class.  We could follow the usual pattern of defining &bind; and
      &return;, but this would be pure boilerplate code.  All we'd be
      doing is wrapping and unwrapping the <type>State</type> monad's
      versions of &bind; and &return; using our <code>S</code> data
      constructor.</para>

    <para>Haskell programmers are not fond of boilerplate, and sure
      enough, &GHC; has a lovely language extension that eliminates
      the work. To use it, we add the following directive to the top
      of our source file, before the module header.</para>

    &Supply.hs:LANGUAGE;

    <para>Usually, we can only automatically derive instances of a
      handful of standard type classes, such as <type>Show</type> and
      <type>Eq</type>.  As its name suggests, the
      <code>GeneralizedNewtypeDeriving</code> extension broadens our
      ability to derive type class instances, and it is specific to
      &newtype; declarations.  If the type we're wrapping is an
      instance of any type class, the extensions lets us can
      automatically make our new type an instance of that type class
      as follows.</para>

    &Supply.hs:deriving;

    <para>This takes the underlying type's implementations of &bind;
      and &return;, adds the necessary wrapping and unwrapping with
      our <code>S</code> data constructor, and uses the new versions
      of those functions to derive a <type>Monad</type> instance for
      us.</para>

    <para>What we gain here is very useful beyond just this example.
      We can use &newtype; to wrap any underlying type; we selectively
      expose only those type class instances that we want; and we
      expend almost no effort to create these narrower, more
      specialised types.</para>

    <para>Now that we've seen the
      <code>GeneralizedNewtypeDeriving</code> technique, all that
      remains is to provide definitions of <function>next</function>
      and <function>runSupply</function>.</para>

    &Supply.hs:code;

    <para>If we load our module into &ghci;, we can try it out in a few
      simple ways.</para>

    &supply.ghci:simple;

    <para>We can also verify that the <type>State</type> monad has not
      somehow leaked out.</para>

    &supply.ghci:browse;

    <sect2>
      <title>Supplying random numbers</title>

      <para>If we want to use our <type>Supply</type> monad as a
	source of random numbers, we have a small difficulty to face.
	Ideally, we'd like to be able to provide it with an infinite
	stream of random numbers.  We can get a <type>StdGen</type> in
	the <type>IO</type> monad, but we must <quote>put back</quote>
	a different <type>StdGen</type> when we're done.  If we don't,
	the next piece of code to get a <type>StdGen</type> will get
	the same state as we did.  This means it will generate the
	same random numbers as we did, which is potentially
	catastrophic.</para>

      <para>From the parts of the <code>System.Random</code> module
	we've seen so far, it's difficult to reconcile these demands.
	We can use <function>getStdRandom</function> to ensure that
	when we get a <type>StdGen</type>, we put one back.  We can
	use <function>random</function> to get back a new
	<type>StdGen</type> when they give us a random number.  And we
	can use <function>randoms</function> to get an infinite list
	of random numbers.  But how do we get both an infinite list of
	random numbers <emphasis>and</emphasis> a new
	<type>StdGen</type>?</para>

      <para>The answer lies with the <type>RandomGen</type> type
	class's <function>split</function> function, which takes one
	random number generator, and turns it into two generators.
	Splitting a random generator like this is a most unusual thing
	to be able to do: it's obviously tremendously useful in a pure
	functional setting, but essentially never either necessary or
	provided by an impure language.</para>

      <para>Using the <function>split</function> function, we can use
	one <type>StdGen</type> to generate an infinite list of random
	numbers to feed to <function>runSupply</function>, while we
	give the other back to the <type>IO</type> monad.</para>

      &RandomSupply.hs:randomsIO;

      <para>If we save the above definition in a file
	<filename>RandomSupply.hs</filename> and load it into &ghci;,
	we can try our <function>randomsIO</function> function out.
	If we've written it properly, our example ought to print a
	different random number on each invocation.</para>

      &randomSupply.ghci:random;

      <para>Recall that our <function>runSupply</function> function
	returns both the result of executing the monadic action and
	the unconsumed remainder of the list.  Since we passed it an
	infinite list of random numbers, we compose with
	<function>fst</function> to ensure that we don't get drowned
	in random numbers when &ghci; tries to print the
	result.</para>
    </sect2>

    <sect2>
      <title>Another round of golf</title>

      <para>The pattern of applying a function to one element of a
	pair, and constructing a new pair with the other original
	element untouched, is common enough in Haskell code that it
	has been turned into standard code.</para>

      <para>In the <code>Control.Arrow</code> module are two
	functions, <function>first</function> and
	<function>second</function>, that perform this
	operation.</para>

      &randomSupply.ghci:first;

      <para>Now that we know about these functions, we can use one to
	golf our definition of <function>randomsIO</function>, turning
	it into a one-liner.</para>

      &RandomGolf.hs:randomsIO_golfed;
      
    </sect2>
  </sect1>

  <sect1>
    <title>Separating interface from implementation</title>

    <para>In the previous section, we saw how to hide the fact that
      we're using a <type>State</type> monad to hold the state for our
      <type>Supply</type> monad.</para>

    <para>Another important way to make code more modular involves
      separating its <emphasis>interface</emphasis>&emdash;what the
      code can do&emdash;from its
      <emphasis>implementation</emphasis>&emdash;how it does
      it.</para>

    <para>The standard random number generator in
      <code>System.Random</code> is known to be quite slow. If we use
      our <function>randomsIO</function> function to provide it with
      random numbers, then our <function>next</function> action will
      not perform well.</para>

    <para>One simple and effective way that we could deal with this is
      to provide <type>Supply</type> with a better source of random
      numbers.  Let's set this idea aside, though, and consider an
      alternative approach, one that is useful in many settings.  We
      will separate the actions we can perform with the monad from how
      it works using a type class.</para>

    &SupplyClass.hs:class;

    <para>This type class bears careful inspection, since it uses
      several unfamiliar Haskell language extensions.  We will cover
      each one in the sections that follow.</para>

    <sect2 id="monadcase.mptc">
      <title>Multi-parameter type classes</title>

      <para>How should we read the snippet <code>MonadSupply s
	  m</code> in the type class?  If we add parentheses, an
	equivalent expression is <code>(MonadSupply s) m</code>, which
	is a little clearer.  In other words, given some type variable
	<varname>m</varname> that is a <type>Monad</type>, we can make
	it an instance of the type class <type>MonadSupply s</type>:
	unlike a regular type class, this one has a
	<emphasis>parameter</emphasis>.</para>

      <para>These type classes with parameters are the first of our
	language extensions.  As the extension allows a type class to
	have more than one parameter, the name of this extension is
	<code>MultiParamTypeClasses</code>.  The parameter
	<varname>s</varname> serves the same purpose as the
	<type>Supply</type> type's parameter of the same name: it
	represents the type of the values handed out by the
	<function>next</function> function.</para>

      <para>Notice that we don't need to mention &bind; or &return; in
	the definition of <type>MonadSupply s</type>, since the type
	class's context requires that a <type>MonadSupply s</type>
	must already be a <type>Monad</type>.</para>
    </sect2>

    <sect2>
      <title>Functional dependencies</title>

      <para>To revisit a snippet that we ignored earlier, <code>| m
	  -&nbsp; s</code> is a <emphasis>functional
	  dependency</emphasis>, often called a
	<emphasis>fundep</emphasis>.  We can read the vertical bar
	<code>|</code> as <quote>such that</quote>, and the arrow
	<code>-&gt;</code> as <quote>uniquely determines</quote>.  Our
	functional dependency establishes a
	<emphasis>relationship</emphasis> between <varname>m</varname>
	and <varname>s</varname></para>

      <para>The availability of functional dependencies is governed by
	the <code>FunctionalDependencies</code> language pragma.</para>

      <para>The purpose behind us declaring a relationship is to help
	the type checker.  Recall that a Haskell type checker is
	essentially a theorem prover, and that it is convervative in
	how it operates: it insists that its proofs must terminate. A
	non-terminating proof results in the compiler either giving up
	or getting stuck in an infinite loop.</para>

      <para>With our functional dependency, we are telling the type
	checker that every time it sees some monad
	<varname>m</varname> being used in the context of a
	<type>MonadSupply s</type>, the type <varname>s</varname> is
	the only acceptable type to use with it.  If we were to omit
	the functional dependency, the type checker would simply give
	up with an error message.</para>

      <para>It's hard to picture what the relationship between
	<varname>m</varname> and <varname>s</varname> really means, so
	let's look at an instance of this type class.</para>

      &SupplyClass.hs:instance;

      <para>Here, the type variable <varname>m</varname> is replaced
	by the type <type>S.Supply s</type>.  Thanks to our functional
	dependency, the type checker now knows that when it sees a
	type <type>S.Supply s</type>, the type can be used as an
	instance of the type class <type>MonadSupply s</type>.</para>

      <para>If we didn't have a functional dependency, the type
	checker would not be able to figure out the relationship
	between the type parameter of the class <type>MonadSupply
	  s</type> and that of the type <type>Supply s</type>, and it
	would abort compilation with an error.  The definition itself
	would compile; the type error would not arise until the first
	time we tried to use it.</para>

      <para>To strip away one final layer of abstraction, consider the
	type <type>S.Supply Int</type>.  Without a functional
	dependency, we could declare this an instance of
	<type>MonadSupply s</type>.  However, if we tried to write
	code using this instance, the compiler would not be able to
	figure out that the type's <type>Int</type> parameter needs to
	be the same as the type class's <varname>s</varname>
	parameter, and it would report an error.</para>

      <para>Functional dependencies can be tricky to understand, and
	once we move beyond simple uses, they often prove difficult to
	work with in practice.  Fortunately, the most frequent use of
	functional dependencies is in situations as simple as ours,
	where they cause little trouble.  We will have more to say
	about them in XXX.</para>
      
      <remark>Insert forward reference to fundep material
	here.</remark>
    </sect2>

    <sect2>
      <title>Rounding out our module</title>

      <para>If we save our type class and instance in a source file
	named <filename>SupplyClass.hs</filename>, we'll need to add
	a module header such as the following.</para>

      &SupplyClass.hs:module;

      <para>The <code>FlexibleInstances</code> extension is necessary
	so that the compiler will accept our instance declaration.
	This extension relaxes the normal rules for writing instances
	in some circumstances, in a way that still lets the compiler's
	type checker guarantee that it will terminate.  Our need for
	<code>FlexibleInstances</code> here is caused by our use of
	functional dependencies, but the details are unfortunately
	beyond the scope of this book.</para>

      <tip>
	<title>How to know when a language extension is needed</title>

	<para>If &GHC; cannot compile a piece of code because it would
	  require some language extension to be enabled, it will tell
	  us which extension we should use.  For example, if it
	  decides that our code needs flexible instance support, it
	  will suggest that we try compiling with the
	  <option>-XFlexibleInstances</option> option.  A
	  <option>-X</option> option has the same effect as a
	  <code>LANGUAGE</code> directive: it enables a particular
	  extension.</para>
      </tip>

      <para>Finally, notice that we're re-exporting the
	<function>runSupply</function> and <type>Supply</type> names
	from this module. It's perfectly legal to export a name from
	one module even though it's defined in another.  In our case,
	it means that client code only needs to import the
	<code>SupplyClass</code> module, without also importing the
	<code>Supply</code> module.  This reduces the number of
	<quote>moving parts</quote> that a user of our code needs to
	keep in mind.</para>

      <para>Before we show how to use our new type class, we'll
	introduce a monad that we can use it with.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>The reader monad</title>

    <para>The <type>State</type> monad lets us plumb a piece of
      mutable state through our code.  Sometimes, we would like to be
      able to pass some <emphasis>immutable</emphasis> state around,
      such as a program's configuration data.  We could use the
      <type>State</type> monad for this purpose, but we could then
      find ourselves accidentally modifying data that should remain
      unchanged.</para>

    <para>Let's forget about monads for a moment and think about what
      a <emphasis>function</emphasis> with our desired characteristics
      ought to do.  it should accept a value of some type <varname
	role="type">i</varname> that represents the configuration data
      (or whatever) that we're passing in, and return a value of some
      other type <varname role="type">a</varname> as its result.  The
      overall type we want is <type>i -&gt; a</type>.</para>

    <para>To turn this type into a convenient <type>Monad</type>
      instance, we'll wrap it in a &newtype;.</para>

    &SupplyInstance.hs:Reader;

    <para>Turning this into a <type>Monad</type> instance doesn't take
      much work.</para>

    &SupplyInstance.hs:Monad;

    <para>We can think of our vaue of type <varname
	role="type">i</varname> as an <quote>environment</quote> in
      which we're evaluating some expression.  The &return; action
      should have the same effect no matter what the environment is,
      so our version ignores its environment.</para>

    <para>Our definition of &bind; is a little more complicated, but
      only because we have to make the environment&emdash;here the
      variable <varname>r</varname>&emdash; available both in the
      current computation and in the computation we're chaining
      into.</para>

    <para>How does a piece of code executing in this monad find out
      what's in its environment?  It simply has to
      <function>ask</function>.</para>

    &SupplyInstance.hs:ask;

    <para>Within a given chain of actions, every invocation of
      <function>ask</function>  will return the same value.  Our code
      is easy to test in &ghci;.</para>

    &supply.ghci:instance;

    <para>The <type>Reader</type> monad is included in the standard
      <code>mtl</code> library, which is usually bundled with &GHC;.
      You can find it in the <code>Control.Monad.Reader</code> module.
      The motivation for this monad may initially seem a little thin,
      because it is most often useful in complicated code.  We'll
      quite often need to access a piece of configuration information
      deep in the bowels of a program; passing that information in as
      a normal parameter would require a painful restructuring of our
      code.  By hiding this information in our monad's plumbing,
      intermediate functions that don't care about the configuration
      information don't need to see it.</para>

    <para>The clearest motivation for the <type>Reader</type> monad
      will come in section XXX, when we discuss combining several
      monads to build a new monad.  There, we'll see how to gain finer
      control over state, so that our code can modify some values via
      the <type>State</type> monad, while other values remain
      immutable courtesy of the <type>Reader</type> monad.</para>
  </sect1>

  <sect1>
    <title>A return to automated deriving</title>

    <para>Now that we know about the <type>Reader</type> monad, let's
      use it to create an instance of our <type>MonadSupply</type>
      type class.  In the interest of creating a simple example, we'll
      violate the spirit of <type>MonadSupply</type> here: our
      <function>next</function> action will always return the same
      value, instead of always returning a different value.</para>

    <para>It would be a bad idea to directly make the
      <type>Reader</type> type an instance of the
      <type>MonadSupply</type> class, because then
      <emphasis>any</emphasis> <type>Reader</type> could act as a
      <type>MonadSupply</type>.  This would usually not make any
      sense.</para>

    <para>Instead, we create a &newtype;, and make it an instance of
      both of the type classes we care about.  With the
      <code>GeneralizedNewtypeDeriving</code> extension enabled, &GHC;
      will do all the hard work for us.</para>

    &SupplyInstance.hs:MySupply;

    <para>Notice that we must make our type an instance of
      <type>MonadSupply i</type>, not <type>MonadSupply</type>.  If we
      omit the type variable, the compiler will complain.</para>

    <para>To try out our <type>MySupply</type> type, we'll first
      contrive a simple function that should work with any
      <type>MonadSupply</type> instance.</para>

    &SupplyInstance.hs:xy;

    <para>If we use this with our <type>Supply</type> monad and
      <function>randomsIO</function> function, we get a different
      answer every time, as we expect.</para>

    &supply.ghci:xy1;

    <para>Because our <type>MySupply</type> monad has two layers of
      &newtype; wrapping, we can make it easier to use by writing a
      custom execution function for it.</para>

    &SupplyInstance.hs:runMS;

    <para>When we apply our <function>xy</function> action using this
      execution function, we get the same answer every time.</para>

    &supply.ghci:xy2;

    <para>Like our <type>MonadSupply</type> type class and
      <type>Supply</type> monad, almost all of the common Haskell
      monads are built with a split between interface and
      implementation.  For example, the <function>get</function> and
      <function>put</function> functions that we introduced as
      <quote>belonging to</quote> the <type>State</type> monad are
      actually methods of the <type>MonadState</type> type class; the
      <type>State</type> type is an instance of this class.</para>

    <para>Similarly, the standard <type>Reader</type> monad is an
      instance of the <type>MonadReader</type> type class, which
      specifies the <function>ask</function> method.</para>

    <para>While the separation of interface and implementation that
      we've discussed above is appealing for its architectural
      cleanliness, it has important practical applications that will
      become clearer later. When we start combining monads in section
      XXX, we will save a lot of effort through the use of
      <code>GeneralizedNewtypeDeriving</code> and type classes.</para>
  </sect1>

  <sect1>
    <title>Hiding the IO monad</title>

    <para>The blessing and curse of the <type>IO</type> monad is that
      it is extremely powerful.  If we believe that careful use of
      types helps us to avoid programming mistakes, then the
      <type>IO</type> monad should be a great source of unease.
      Because the <type>IO</type> monad imposes no restrictions on
      what we can do, it leaves us vulnerable to all kinds of
      accidents.</para>

    <para>How can we tame its power?  Let's say that we would like to
      guarantee to ourselves that a piece of code can read and write
      files on the local filesystem, but that it will not access the
      network.  We can't use the plain <type>IO</type> monad, because
      it won't restrict us.</para>

    <sect2>
      <title>Using a newtype</title>

      <para>Let's create a module that provides a small set of
	functionality for reading and writing files.</para>

      &HandleIO.hs:module;

      <para>Our first approach to creating a restricted version of
	<type>IO</type> is to wrap it with a &newtype;.</para>

      &HandleIO.hs:newtype;

      <para>We do the by-now familiar trick of exporting the type
	constructor and the <function>runHandleIO</function> execution
	function from our module, but not the data constructor.  This
	will prevent code running within the <type>HandleIO</type>
	monad from getting hold of the <type>IO</type> monad that it
	wraps.</para>

      <para>All that remains is for us to wrap each of the actions we
	want our monad to allow.  This is a simple matter of wrapping
	each <type>IO</type> with a <type>HandleIO</type> data
	constructor.</para>

      &HandleIO.hs:actions;

      <para>We can now use our restricted <type>HandleIO</type> monad
	to perform I/O.</para>

      &HandleIO.hs:safeHello;

      <para>To run this action, we use
	<function>runHandleIO</function>.</para>

      &handleIO.ghci:HandleIO;

      <para>If we try to sequence an action that runs in the
	<type>HandleIO</type> monad with one that is not permitted,
	the type system forbids it.</para>

      &handleIO.ghci:bad;
    </sect2>

    <sect2>
      <title>Designing for unexpected uses</title>

      <para>There's one small, but significant, problem with our
	<type>HandleIO</type> monad: it doesn't take into account the
	possibility that we might occasionally need an escape hatch.
	If we define a monad like this, it is likely that we will
	occasionally need to perform an I/O action that isn't allowed
	for by the design of our monad.</para>

      <para>Our purpose in defining a monad like this is to make it
	easier for us to write solid code in the common case, not to
	make corner cases impossible.   Let's thus give ourselves a
	way out.</para>

      <para>The <code>Control.Monad.Trans</code> module defines a
	<quote>standard escape hatch</quote>, the <type>MonadIO</type>
	type class.  This defines a single function,
	<function>liftIO</function>, which lets us embed an
	<type>IO</type> action in another monad.</para>

      &monadio.ghci:MonadIO;

      <para>Our implementation of this type class is trivial: we just
	wrap <type>IO</type> with our data constructor.</para>

      &HandleIO.hs:MonadIO;
      
      <para>With judicious use of <function>liftIO</function>, we can
	escape our shackles and invoke <type>IO</type> actions where
	necessary.</para>

      &HandleIO.hs:tidyHello;

      <tip>
	<title>Automatic derivation and MonadIO</title>

	<para>We could have had the compiler automatically derive an
	  instance of <type>MonadIO</type> for us by adding the type
	  class to the <code>deriving</code> clause of
	  <type>HandleIO</type>.  In fact, in production code, this
	  would be our usual strategy.  We avoided that here simply to
	  separate the presentation of the earlier material from that
	  of <type>MonadIO</type>.</para>
      </tip>
    </sect2>

    <sect2 id="monadcase.io.class">
      <title>Using type classes</title>

      <para>The disadvantage of hiding <type>IO</type> in another
	monad is that we're still tied to a concrete implementation.
	If we want to swap <type>HandleIO</type> for some other monad,
	we must change the type of every action that uses
	<type>HandleIO</type>.</para>

      <para>As an alternative, we can create a type class that
	specifies the interface we want from a monad that manipulates
	files.</para>

      &MonadHandle.hs:MonadHandle;

      <para>Here, we've chosen to abstract away both the type of the
	monad and the type of a file handle.  To satisfy the type
	checker, we've added a functional dependency: for any instance
	of <type>MonadHandle</type>, there is exactly one handle type
	that we can use.  When we make the <type>IO</type> monad an
	instance of this class, we use a regular
	<type>Handle</type>.</para>

      &MonadHandle.hs:IO;

      <para>Because any <type>MonadHandle</type> must also be a
	<type>Monad</type>, we can write code that manipulates files
	using normal &do; notation, without caring what monad it will
	finally execute in.</para>

      &MonadHandle.hs:safeHello;

      <para>Because we made <type>IO</type> an instance of this type
	class, we can execute this action from &ghci;.</para>

      &monadHandle.ghci:IO;

      <para>The beauty of the type class approach is that we can swap
	one underlying monad for another without touching our code at
	all, as our code doesn't know or care about the
	implementation.  For instance, we could replace
	<type>IO</type> with a monad that compresses files as it
	writes them out.</para>
    </sect2>

    <sect2>
      <title>Isolation and testing</title>

      <para>In fact, because our <function>safeHello</function>
	function doesn't use the <type>IO</type> type, we can even use
	a monad that <emphasis>can't</emphasis> perform I/O.  This
	allows us to test code that would normally have side effects
	in a completely pure, controlled environment.</para>

      <para>To do this, we will create a monad that doesn't perform
	I/O, but instead logs every file-related event for later
	processing.</para>

      &MonadHandle.hs:Event;

      <para>Although we already developed a <type>Logger</type> type
	in <xref linkend="monads.logger"/>, here we'll use the
	standard, and more general, <type>Writer</type> monad. Like
	other <code>mtl</code> monads, the API provided by
	<type>Writer</type> is defined in a type class, in this case
	<type>MonadWriter</type>.  Its most useful method is
	<function>tell</function>, which logs a value.</para>

      &monadwriter.ghci:tell;

      <para>The values we log can be of any <type>Monoid</type> type.
	Since the list type is a <type>Monoid</type>, we'll log to a
	list of <type>Event</type>.</para>

      <para>We could make <type>Writer [Event]</type> an instance of
	<type>MonadHandle</type>, but it's cheap, easy, and safer to
	make a special-purpose monad.</para>

      &MonadHandle.hs:WriterIO;

      <para>Our execution function simply removes the &newtype;
	wrapper we added, then calls the normal <type>Writer</type>
	monad's execution function.</para>

      &MonadHandle.hs:runWriterIO;

      <para>When we try this code out in &ghci;, it gives us a log of
	the function's file activities.</para>

      &monadHandle.ghci:Writer;

    </sect2>

    <sect2 id="monadcase.writer.dlist">
      <title>The writer monad and lists</title>

      <para>The writer monad uses the monoid's
	<function>mappend</function> function every time we use
	<function>tell</function>.  Because
	<function>mappend</function> for lists is
	<function>(++)</function>, lists are not a good practical
	choice for use with <type>Writer</type>: repeated appends are
	expensive.  We are using lists above purely for
	simplicity.</para>

      <para>In production code, if you want to use the
	<type>Writer</type> monad and you need list-like behaviour,
	use a type with better  append characteristics. One such type
	is the difference list, which we introduced in <xref
	  linkend="data.dlist"/>.  You don't need to roll your own
	difference list implementation: a well tuned library is
	available for download from Hackage, the Haskell package
	database.</para>
    </sect2>

    <sect2>
      <title>Arbitrary I/O revisited</title>

      <para>If we use the type class approach to restricting
	<type>IO</type>, we may still want to retain the ability to
	perform arbitrary I/O actions.  We might try adding
	<type>MonadIO</type> as a constraint on our type class.</para>

      &MonadHandle.hs:tidierHello;

      <para>This approach has a problem, though: the added
	<type>MonadIO</type> constraint loses us the ability to test
	our code in a pure environment, because we can no longer tell
	whether a test might have damaging side effects.  The
	alternative is to move this constraint from the type class,
	where it <quote>infects</quote> all functions, to only those
	functions that really need to perform I/O.</para>

      &MonadHandle.hs:tidyHello;

      <para>We can use pure property tests on the functions that lack
	<type>MonadIO</type> constraints, and traditional unit tests
	on the rest.</para>

      <para>Unfortunately, we've substituted one problem for another:
	we can't invoke code with both <type>MonadIO</type> and
	<type>MonadHandle</type> constraints from code that has the
	<type>MonadHandle</type> constraint alone.  If we find that
	somewhere deep in our <type>MonadHandle</type>-only code, we
	really need the <type>MonadIO</type> constraint, we must add
	it to all the code paths that lead to this point.</para>

      <para>Allowing arbitrary I/O is risky, and has a profound effect
	on how we develop and test our code.  When we have to choose
	between being permissive on the one hand, and easier reasoning
	and testing on the other, we usually opt for the
	latter.</para>
    </sect2>

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Using QuickCheck, write a test for an action in the
	      <type>MonadHandle</type> monad, to see if it tries to
	      write to a file handle that is not open.  Try it
	      out on <function>safeHello</function>.</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para>Write an action that tries to write to a file handle
	      that it has closed.  Does your test catch this
	      bug?</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
