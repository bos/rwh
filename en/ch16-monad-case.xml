<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="monadcase" revision="alpha;beta">
  <title>Programming with monads</title>

  <sect1 id="monadcase.urlencoded">
    <title>Golfing practice: association lists</title>

    <para id="x_ki">Web clients and servers often pass information around as a
      simple textual list of key-value pairs.</para>

    <programlisting>name=Attila+%42The+Hun%42&amp;occupation=Khan</programlisting>

    <para id="x_li">The encoding is named
      <code>application/x-www-form-urlencoded</code>, and it's easy to
      understand.  Each key-value pair is separated by an
      <quote><code>&amp;</code></quote> character.  Within a pair, a
      key is a series of characters, followed by an
      <quote><code>=</code></quote>, followed by a value.</para>

    <para id="x_mi">We can obviously represent a key as a <type>String</type>,
      but the HTTP specification is not clear about whether a key must
      be followed by a value.  We can capture this ambiguity by
      representing a value as a <type>Maybe String</type>.  If we use
      <code>Nothing</code> for a value, then there was no value
      present.  If we wrap a string in <code>Just</code>, then there
      was a value.  Using <type>Maybe</type> lets us distinguish
      between <quote>no value</quote> and <quote>empty
	value</quote>.</para>

    <para id="x_ni">Haskell programmers use the name <emphasis>association
	list</emphasis> for the type <type>[(a, b)]</type>, where we
      can think of each element as an association between a key and a
      value.  The name originates in the Lisp community, where it's
      usually abbreviated as an <emphasis>alist</emphasis>.  We could
      thus represent the above string as the following Haskell
      value.</para>

    &MovieReview.hs:attila;

    <para id="x_oi">In <xref linkend="applicative.urlencoded"/>, we'll parse an
      <code>application/x-www-form-urlencoded</code> string, and
      represent the result as an alist of <type>[(String, Maybe
	String)]</type>.  Let's say we want to use one of these alists
      to fill out a data structure.</para>

    &MovieReview.hs:MovieReview;

    <para id="x_pi">We'll begin by belabouring the obvious with a naive
      function.</para>

    &MovieReview.hs:simpleReview;

    <para id="x_qi">It only returns a <type>MovieReview</type> if the alist
      contains all of the necessary values, and they're all non-empty
      strings.  However, the fact that it validates its inputs is its
      only merit: it suffers badly from the <quote>staircasing</quote>
      that we've learned to be wary of, and it knows the intimate
      details of the representation of an alist.</para>

    <para id="x_ri">Since we're now well acquainted with the <type>Maybe</type>
      monad, we can tidy up the staircasing.</para>

    &MovieReview.hs:maybeReview;

    <para id="x_si">Although this is much tidier, we're still repeating
      ourselves.  We can take advantage of the fact that the
      <code>MovieReview</code> constructor acts as a normal, pure
      function by <emphasis>lifting</emphasis> it into the monad, as
      we discussed in <xref linkend="monads.liftM"/>.</para>

    &MovieReview.hs:liftedReview;
  </sect1>

  <sect1 id="monadcase.ap">
    <title>Generalised lifting</title>

    <para id="x_ti">Although using <function>liftM3</function> tidies up our
      code, we can't use a <function>liftM</function>-family function
      to solve this sort of problem in general, because they're only
      defined up to <function>liftM5</function>.  If we had a
      constructor or pure function that took, say, ten parameters, you
      might think we'd be out of luck.</para>

    <para id="x_ui">Of course, our toolbox isn't yet empty.  In
      <code>Control.Monad</code>, there's a function named
      <function>ap</function> with a slightly odd type
      signature.</para>

    &ap.ghci:ap;

    <para id="x_vi">You might wonder who would put a single-argument pure
      function inside a monad, and why.  Recall, however, that
      <emphasis>all</emphasis> Haskell functions really take only one
      argument, and you'll begin to see how this might relate to the
      <code>MovieReview</code> constructor.</para>

    &ap.ghci:MovieReview;

    <para id="x_wi">We can just as easily write that type as <type>String -&gt;
	(String -&gt; (String -&gt; MovieReview))</type>.  If we use
      plain old <function>liftM</function> to lift
      <code>MovieReview</code> into the <code>Maybe</code> monad,
      we'll have a value of type <type>Maybe (String -&gt; (String
	-&gt; (String -&gt; MovieReview)))</type>.  We can now see
      that this type is suitable as an argument for
      <function>ap</function>, in which case the result type will be
      <type>Maybe (String -&gt; (String -&gt; MovieReview))</type>. We
      can pass this, in turn, to <function>ap</function>, and continue
      to chain until we end up with this definition.</para>

    &MovieReview.hs:apReview;

    <para id="x_xi">We can chain applications of <function>ap</function> like
      this as many times as we need to, and thereby to avoid the hard
      limit of 5 on the <function>liftM</function> family of
      functions.</para>

    <para id="x_yi">Another helpful way to look at <function>ap</function> is
      that it's the monadic equivalent of the familiar
      <function>($)</function> operator.  We can see this clearly when
      we compare the type signatures of the two functions.</para>

    &ap.ghci:types;

  </sect1>

  <sect1 id="monadcase.monadplus">
    <title>Looking for alternatives</title>

    <para id="x_zi">Here's a simple representation of a person's phone
      numbers.</para>

    &VCard.hs:numbers;

    <para id="x_Aj">Suppose we want to get in touch with someone to make a
      personal call.  We don't want their business number, and we'd
      prefer to use their home number (if they have one) instead of
      their mobile number, because the call will be cheaper.</para>

    &VCard.hs:personalPhone;

    <para id="x_Bj">Of course, if we use <type>Maybe</type> as the result type,
      we can't accommodate the possibility that someone might have
      more than one number that meet our criteria.  For that, we
      switch to a list.</para>

    &VCard.hs:businessPhones;

    <para id="x_Cj">Notice that these two functions structure their &case;
      expressions similarly: one alternative handles the case where
      the first lookup returns an empty result, while the other
      handles the non-empty case.</para>

    &vcard.ghci:simple;
    
    <para id="x_Dj">Haskell's <code>Control.Monad</code> module defines a
      typeclass, <type>MonadPlus</type>, that lets us abstract the
      common pattern out of our &case; expressions.</para>

    &VCard.hs:MonadPlus;

    <para id="x_Ej">The value <code>mzero</code> represents an empty result,
      while <function>mplus</function> combines two results into one.
      Here are the standard definitions of <code>mzero</code> and
      <function>mplus</function> for <type>Maybe</type> and
      lists.</para>

    &VCard.hs:instances;

    <para id="x_Fj">We can now use <function>mplus</function> to get rid of our
      &case; expressions entirely.</para>

    &VCard.hs:caseless;

    <para id="x_Gj">In these functions, because we know that
      <function>lookup</function> returns a value of type
      <type>Maybe</type>, and <function>filter</function> returns a
      list, it's obvious which version of <function>mplus</function>
      is going to be used in each case.</para>

    <para id="x_Hj">What's more interesting is that we can use
      <code>mzero</code> and <function>mplus</function> to write
      functions that will be useful for <emphasis>any</emphasis>
      <type>MonadPlus</type> instance.  As an example, here's the
      standard <function>lookup</function> function, which returns a
      value of type <type>Maybe</type>.</para>

    &VCard.hs:lookup;

    <para id="x_Ij">We can easily generalise the result type to any instance of
      <type>MonadPlus</type> as follows.</para>

    &VCard.hs:lookupM;

    <para id="x_Jj">This lets us get either no result or one, if our result type
      is <type>Maybe</type>; all results, if our result type is a
      list; or something of appropriate for some other exotic instance
      of <type>MonadPlus</type>.</para>

    <sect2>
      <title>The name mplus does not imply addition</title>

      <para id="x_Kj">Even though the <function>mplus</function> function
	contains the text <quote>plus</quote>, you should not think of
	it as necessarily implying that we're trying to add two
	values.</para>

      <para id="x_Lj">Depending on the monad we're working in,
	<function>mplus</function> <quote>may</quote> implement an
	operation that looks like addition.  For example,
	<function>mplus</function> in the list monad is implemented as
	the <function>(++)</function> operator.</para>

      &monadPlus.ghci:list.mplus;

      <para id="x_Mj">However, if we switch to another monad, the obvious
	similarity to addition falls away.</para>

      &monadPlus.ghci:maybe.mplus;

    </sect2>

    <sect2>
      <title>Rules for working with MonadPlus</title>

      <para id="x_Nj">Instances of the <type>MonadPlus</type> typeclass must
	follow a few  simple rules, in addition to the usual monad
	rules.</para>

      <para id="x_Oj">An instance must <emphasis>short circuit</emphasis> if
	<code>mzero</code> appears on the left of a bind expression.
	In other words, an expression <code>mzero &gt;&gt;= f</code>
	must evaluate to the same result as <code>mzero</code>
	alone.</para>

      &MonadPlus.hs:shortcircuitLeft;

      <para id="x_Pj">An instance must short circuit if <code>mzero</code>
	appears on the <emphasis>right</emphasis> of a sequence
	expression.</para>

      &MonadPlus.hs:shortcircuitRight;

    </sect2>

    <sect2>
      <title>Failing safely with MonadPlus</title>

      <para id="x_Qj">When we introduced the &fail; function in <xref
	  linkend="monads.class"/>, we took pains to warn against its
	use: in many monads, it's implemented as a call to &error;,
	which has disastrous consequences.</para>

      <para id="x_Rj">The <type>MonadPlus</type> typeclass gives us a gentler
	way to fail a computation, without &fail; or &error; blowing
	up in our faces.  The rules that we introduced above allow us
	to introduce a <code>mzero</code> into our code wherever we
	need to, and computation will short circuit at that
	point.</para>

      <para id="x_Sj">In the <code>Control.Monad</code> module, the standard
	function <function>guard</function> packages up this idea in a
	convenient form.</para>

      &MonadPlus.hs:guard;

      <para id="x_Tj">As a simple example, here's a function that takes a number
	<varname>x</varname> and computes its value modulo some other
	number <varname>n</varname>.  If the result is zero, it
	returns <varname>x</varname>, otherwise the current monad's
	<code>mzero</code>.</para>

      &MonadPlus.hs:zeroMod;
    </sect2>
  </sect1>

  <sect1>
    <title>Adventures in hiding the plumbing</title>

    <para>In <xref linkend="monads.state.random"/>, we showed how to
      use the <type>State</type> monad to give ourselves access to
      random numbers in a way that is easy to use.</para>

    <para>A drawback of the code we developed is that it's
      <emphasis>leaky</emphasis>: someone who uses it knows that
      they're executing inside the <type>State</type> monad.  This
      means that they can inspect and modify the state of the random
      number generator just as easily as we, the authors, can.</para>

    <para>Human nature dictates that if we leave our internal workings
      exposed, someone will surely come along and monkey with them.
      For a sufficiently small program, this may be fine, but in a
      larger software project, when one consumer of a library modifies
      its internals in a way that other consumers are not prepared
      for, the resulting bugs can be among the hardest of all to track
      down.  These bugs occur at a level where we're unlikely to
      question our basic assumptions about a library until long after
      we've exhausted all other avenues of inquiry.</para>

    <para>Even worse, once we leave our implementation exposed for a
      while, and some well-intentioned person inevitably bypasses our
      APIs and uses the implementation directly, we create a nasty
      quandary for ourselves if we need to fix a bug or make an
      enhancement.  Either we can modify our internals, and break code
      that depends on them; or we're stuck with our existing
      internals, and must try to find some other way to make the
      change we need.</para>

    <para>How can we revise our random number monad so that the fact
      that we're using the <type>State</type> monad is hidden?  We
      need to somehow prevent our users from being able to call
      <code>get</code> or <code>put</code>.  This is not difficult to
      do, and it introduces some tricks that we'll reuse often in
      day-to-day Haskell programming.</para>

    <para>To widen our scope, we'll move beyond random numbers, and
      implement a monad that supplies unique values of
      <emphasis>any</emphasis> kind.  The name we'll give to our monad
      is <type>Supply</type>.  We'll provide the execution function,
      <function>runSupply</function>, with a list of values; it will
      be up to us to ensure that each one is unique.</para>

    &Supply.hs:runSupply.type;

    <para>The monad won't care what the values are: they might be
      random numbers, or names for temporary files, or identifiers for
      HTTP cookies.</para>

    <para>Within the monad, every time a consumer asks for a value,
      the <function>next</function> action will take the next one from
      the list and give it to the consumer.  Each value is wrapped in
      a <type>Maybe</type> constructor in case the list isn't long
      enough to satisfy the demand.</para>

    &Supply.hs:next.type;

    <para>To hide our plumbing, in our module declaration we only
      export the type constructor, the execution function, and the
      <function>next</function> action.</para>

    &Supply.hs:module;

    <para>Since a module that imports the library can't see the
      internals of the monad, it can't manipulate them.</para>

    <para>Our plumbing is exceedingly simple.  We use a &newtype;
      declaration to wrap the existing <type>State</type>
      monad.</para>

    &Supply.hs:Supply;

    <para>The <varname role="type">s</varname> parameter is the type
      of the unique values we are going to supply, and <varname
	role="type">a</varname> is the usual free type variable that
      we must provide in order to make our type a monad.</para>

    <para>Our <type>Supply</type> type and our module header join
      forces to prevent our clients from using the <type>State</type>
      monad's <function>get</function> and <function>set</function>
      actions.  Because our module does not export the <code>S</code>
      data constructor, clients have no programmatic way to see that
      we're wrapping the <type>State</type> monad, or to access
      it.</para>

    <para>At this point, we've got a type, <type>Supply</type>, that
      we need to make an instance of the <type>Monad</type> type
      class.  We could follow the usual pattern of defining &bind; and
      &return;, but this would be pure boilerplate code.  All we'd be
      doing is wrapping and unwrapping the <type>State</type> monad's
      versions of &bind; and &return; using our <code>S</code> data
      constructor.</para>

    <para>Haskell programmers are not fond of boilerplate, and sure
      enough, &GHC; has a lovely language extension that eliminates
      the work. To use it, we add the following directive to the top
      of our source file, before the module header.</para>

    &Supply.hs:LANGUAGE;

    <para>Usually, we can only automatically derive instances of a
      handful of standard type classes, such as <type>Show</type> and
      <type>Eq</type>.  As its name suggests, the
      <code>GeneralizedNewtypeDeriving</code> extension broadens our
      ability to derive type class instances, and it is specific to
      &newtype; declarations.  If the type we're wrapping is an
      instance of any type class, the extensions lets us can
      automatically make our new type an instance of that type class
      as follows.</para>

    &Supply.hs:deriving;

    <para>This takes the underlying type's implementations of &bind;
      and &return;, adds the necessary wrapping and unwrapping with
      our <code>S</code> data constructor, and uses the new versions
      of those functions to derive a <type>Monad</type> instance for
      us.</para>

    <para>What we gain here is very useful beyond just this example.
      We can use &newtype; to wrap any underlying type; we selectively
      expose only those type class instances that we want; and we
      expend almost no effort to create these narrower, more
      specialised types.</para>

    <para>Now that we've seen the
      <code>GeneralizedNewtypeDeriving</code> technique, all that
      remains is to provide definitions of <function>next</function>
      and <function>runSupply</function>.</para>

    &Supply.hs:code;

    <para>If we load our module into &ghci;, we can try it out in a few
      simple ways.</para>

    &supply.ghci:simple;

    <para>We can also verify that the <type>State</type> monad has not
      somehow leaked out.</para>

    &supply.ghci:browse;

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
