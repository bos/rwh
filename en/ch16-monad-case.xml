<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="monadcase" revision="alpha;beta">
  <title>Programming with monads</title>

  <sect1 id="monadcase.urlencoded">
    <title>Golfing practice: association lists</title>

    <para id="x_ki">Web clients and servers often pass information around as a
      simple textual list of key-value pairs.</para>

    <programlisting>name=Attila+%42The+Hun%42&amp;occupation=Khan</programlisting>

    <para id="x_li">The encoding is named
      <code>application/x-www-form-urlencoded</code>, and it's easy to
      understand.  Each key-value pair is separated by an
      <quote><code>&amp;</code></quote> character.  Within a pair, a
      key is a series of characters, followed by an
      <quote><code>=</code></quote>, followed by a value.</para>

    <para id="x_mi">We can obviously represent a key as a <type>String</type>,
      but the HTTP specification is not clear about whether a key must
      be followed by a value.  We can capture this ambiguity by
      representing a value as a <type>Maybe String</type>.  If we use
      <code>Nothing</code> for a value, then there was no value
      present.  If we wrap a string in <code>Just</code>, then there
      was a value.  Using <type>Maybe</type> lets us distinguish
      between <quote>no value</quote> and <quote>empty
	value</quote>.</para>

    <para id="x_ni">Haskell programmers use the name <emphasis>association
	list</emphasis> for the type <type>[(a, b)]</type>, where we
      can think of each element as an association between a key and a
      value.  The name originates in the Lisp community, where it's
      usually abbreviated as an <emphasis>alist</emphasis>.  We could
      thus represent the above string as the following Haskell
      value.</para>

    &MovieReview.hs:attila;

    <para id="x_oi">In <xref linkend="applicative.urlencoded"/>, we'll parse an
      <code>application/x-www-form-urlencoded</code> string, and
      represent the result as an alist of <type>[(String, Maybe
	String)]</type>.  Let's say we want to use one of these alists
      to fill out a data structure.</para>

    &MovieReview.hs:MovieReview;

    <para id="x_pi">We'll begin by belabouring the obvious with a naive
      function.</para>

    &MovieReview.hs:simpleReview;

    <para id="x_qi">It only returns a <type>MovieReview</type> if the alist
      contains all of the necessary values, and they're all non-empty
      strings.  However, the fact that it validates its inputs is its
      only merit: it suffers badly from the <quote>staircasing</quote>
      that we've learned to be wary of, and it knows the intimate
      details of the representation of an alist.</para>

    <para id="x_ri">Since we're now well acquainted with the <type>Maybe</type>
      monad, we can tidy up the staircasing.</para>

    &MovieReview.hs:maybeReview;

    <para id="x_si">Although this is much tidier, we're still repeating
      ourselves.  We can take advantage of the fact that the
      <code>MovieReview</code> constructor acts as a normal, pure
      function by <emphasis>lifting</emphasis> it into the monad, as
      we discussed in <xref linkend="monads.liftM"/>.</para>

    &MovieReview.hs:liftedReview;

    <para>We still have some repetition here, but it is dramatically
      reduced, and also more difficult to remove.</para>
  </sect1>

  <sect1 id="monadcase.ap">
    <title>Generalised lifting</title>

    <para id="x_ti">Although using <function>liftM3</function> tidies up our
      code, we can't use a <function>liftM</function>-family function
      to solve this sort of problem in general, because they're only
      defined up to <function>liftM5</function> by the standard
      libraries.  We could write variants up to whatever number we
      pleased, but that would amount to drudgery.</para>

    <para>If we had a constructor or pure function that took, say, ten
      parameters, and decided to stick with the standard libraries you
      might think we'd be out of luck.</para>

    <para id="x_ui">Of course, our toolbox isn't yet empty.  In
      <code>Control.Monad</code>, there's a function named
      <function>ap</function> with an interesting type
      signature.</para>

    &ap.ghci:ap;

    <para id="x_vi">You might wonder who would put a single-argument pure
      function inside a monad, and why.  Recall, however, that
      <emphasis>all</emphasis> Haskell functions really take only one
      argument, and you'll begin to see how this might relate to the
      <code>MovieReview</code> constructor.</para>

    &ap.ghci:MovieReview;

    <para id="x_wi">We can just as easily write that type as <type>String -&gt;
	(String -&gt; (String -&gt; MovieReview))</type>.  If we use
      plain old <function>liftM</function> to lift
      <code>MovieReview</code> into the <code>Maybe</code> monad,
      we'll have a value of type <type>Maybe (String -&gt; (String
	-&gt; (String -&gt; MovieReview)))</type>.  We can now see
      that this type is suitable as an argument for
      <function>ap</function>, in which case the result type will be
      <type>Maybe (String -&gt; (String -&gt; MovieReview))</type>. We
      can pass this, in turn, to <function>ap</function>, and continue
      to chain until we end up with this definition.</para>

    &MovieReview.hs:apReview;

    <para id="x_xi">We can chain applications of
      <function>ap</function> like this as many times as we need to,
      thereby bypassing the <function>liftM</function> family of
      functions.</para>

    <para id="x_yi">Another helpful way to look at
      <function>ap</function> is that it's the monadic equivalent of
      the familiar <function>($)</function> operator: think of
      pronouncing <function>ap</function> as
      <emphasis>apply</emphasis>.  We can see this clearly when we
      compare the type signatures of the two functions.</para>

    &ap.ghci:types;

    <para>In fact, <function>ap</function> is usually defined as
      either <code>liftM2 id</code> or <code>liftM2 ($)</code>.</para>

  </sect1>

  <sect1 id="monadcase.monadplus">
    <title>Looking for alternatives</title>

    <para id="x_zi">Here's a simple representation of a person's phone
      numbers.</para>

    &VCard.hs:numbers;

    <para id="x_Aj">Suppose we want to get in touch with someone to make a
      personal call.  We don't want their business number, and we'd
      prefer to use their home number (if they have one) instead of
      their mobile number.</para>

    &VCard.hs:personalPhone;

    <para id="x_Bj">Of course, if we use <type>Maybe</type> as the result type,
      we can't accommodate the possibility that someone might have
      more than one number that meet our criteria.  For that, we
      switch to a list.</para>

    &VCard.hs:businessPhones;

    <para id="x_Cj">Notice that these two functions structure their &case;
      expressions similarly: one alternative handles the case where
      the first lookup returns an empty result, while the other
      handles the non-empty case.</para>

    &vcard.ghci:simple;
    
    <para id="x_Dj">Haskell's <code>Control.Monad</code> module defines a
      typeclass, <type>MonadPlus</type>, that lets us abstract the
      common pattern out of our &case; expressions.</para>

    &VCard.hs:MonadPlus;

    <para id="x_Ej">The value <code>mzero</code> represents an empty result,
      while <function>mplus</function> combines two results into one.
      Here are the standard definitions of <code>mzero</code> and
      <function>mplus</function> for <type>Maybe</type> and
      lists.</para>

    &VCard.hs:instances;

    <para id="x_Fj">We can now use <function>mplus</function> to get
      rid of our &case; expressions entirely.  For variety, let's
      fetch one business and all personal phone numbers.</para>

    &VCard.hs:caseless;

    <para id="x_Gj">In these functions, because we know that
      <function>lookup</function> returns a value of type
      <type>Maybe</type>, and <function>filter</function> returns a
      list, it's obvious which version of <function>mplus</function>
      is going to be used in each case.</para>

    <para id="x_Hj">What's more interesting is that we can use
      <code>mzero</code> and <function>mplus</function> to write
      functions that will be useful for <emphasis>any</emphasis>
      <type>MonadPlus</type> instance.  As an example, here's the
      standard <function>lookup</function> function, which returns a
      value of type <type>Maybe</type>.</para>

    &VCard.hs:lookup;

    <para id="x_Ij">We can easily generalise the result type to any instance of
      <type>MonadPlus</type> as follows.</para>

    &VCard.hs:lookupM;

    <para id="x_Jj">This lets us get either no result or one, if our result type
      is <type>Maybe</type>; all results, if our result type is a
      list; or something more appropriate for some other exotic instance
      of <type>MonadPlus</type>.</para>

    <para>For small functions, such as those we present above, there's
      little benefit to using <function>mplus</function>.  The
      advantage lies in more complex code and in code that is
      independent of the monad in which it executes.  Even if you
      don't find yourself needing <type>MonadPlus</type> for your own
      code, you are likely to encounter it in other people's
      projects.</para>

    <sect2>
      <title>The name mplus does not imply addition</title>

      <para id="x_Kj">Even though the <function>mplus</function> function
	contains the text <quote>plus</quote>, you should not think of
	it as necessarily implying that we're trying to add two
	values.</para>

      <para id="x_Lj">Depending on the monad we're working in,
	<function>mplus</function> <emphasis>may</emphasis> implement an
	operation that looks like addition.  For example,
	<function>mplus</function> in the list monad is implemented as
	the <function>(++)</function> operator.</para>

      &monadPlus.ghci:list.mplus;

      <para id="x_Mj">However, if we switch to another monad, the obvious
	similarity to addition falls away.</para>

      &monadPlus.ghci:maybe.mplus;

    </sect2>

    <sect2>
      <title>Rules for working with MonadPlus</title>

      <para id="x_Nj">Instances of the <type>MonadPlus</type> typeclass must
	follow a few  simple rules, in addition to the usual monad
	rules.</para>

      <para id="x_Oj">An instance must <emphasis>short circuit</emphasis> if
	<code>mzero</code> appears on the left of a bind expression.
	In other words, an expression <code>mzero &gt;&gt;= f</code>
	must evaluate to the same result as <code>mzero</code>
	alone.</para>

      &MonadPlus.hs:shortcircuitLeft;

      <para id="x_Pj">An instance must short circuit if <code>mzero</code>
	appears on the <emphasis>right</emphasis> of a sequence
	expression.</para>

      &MonadPlus.hs:shortcircuitRight;

    </sect2>

    <sect2>
      <title>Failing safely with MonadPlus</title>

      <para id="x_Qj">When we introduced the &fail; function in <xref
	  linkend="monads.class"/>, we took pains to warn against its
	use: in many monads, it's implemented as a call to &error;,
	which has unpleasant consequences.</para>

      <para id="x_Rj">The <type>MonadPlus</type> typeclass gives us a gentler
	way to fail a computation, without &fail; or &error; blowing
	up in our faces.  The rules that we introduced above allow us
	to introduce an <code>mzero</code> into our code wherever we
	need to, and computation will short circuit at that
	point.</para>

      <para id="x_Sj">In the <code>Control.Monad</code> module, the standard
	function <function>guard</function> packages up this idea in a
	convenient form.</para>

      &MonadPlus.hs:guard;

      <para id="x_Tj">As a simple example, here's a function that takes a number
	<varname>x</varname> and computes its value modulo some other
	number <varname>n</varname>.  If the result is zero, it
	returns <varname>x</varname>, otherwise the current monad's
	<code>mzero</code>.</para>

      &MonadPlus.hs:zeroMod;
    </sect2>
  </sect1>

  <sect1>
    <title>Adventures in hiding the plumbing</title>

    <para id="x_wq">In <xref linkend="monads.state.random"/>, we showed how to
      use the <type>State</type> monad to give ourselves access to
      random numbers in a way that is easy to use.</para>

    <para id="x_xq">A drawback of the code we developed is that it's
      <emphasis>leaky</emphasis>: someone who uses it knows that
      they're executing inside the <type>State</type> monad.  This
      means that they can inspect and modify the state of the random
      number generator just as easily as we, the authors, can.</para>

    <para id="x_yq">Human nature dictates that if we leave our internal workings
      exposed, someone will surely come along and monkey with them.
      For a sufficiently small program, this may be fine, but in a
      larger software project, when one consumer of a library modifies
      its internals in a way that other consumers are not prepared
      for, the resulting bugs can be among the hardest of all to track
      down.  These bugs occur at a level where we're unlikely to
      question our basic assumptions about a library until long after
      we've exhausted all other avenues of inquiry.</para>

    <para id="x_zq">Even worse, once we leave our implementation exposed for a
      while, and some well-intentioned person inevitably bypasses our
      APIs and uses the implementation directly, we create a nasty
      quandary for ourselves if we need to fix a bug or make an
      enhancement.  Either we can modify our internals, and break code
      that depends on them; or we're stuck with our existing
      internals, and must try to find some other way to make the
      change we need.</para>

    <para id="x_Ar">How can we revise our random number monad so that the fact
      that we're using the <type>State</type> monad is hidden?  We
      need to somehow prevent our users from being able to call
      <code>get</code> or <code>put</code>.  This is not difficult to
      do, and it introduces some tricks that we'll reuse often in
      day-to-day Haskell programming.</para>

    <para id="x_Br">To widen our scope, we'll move beyond random numbers, and
      implement a monad that supplies unique values of
      <emphasis>any</emphasis> kind.  The name we'll give to our monad
      is <type>Supply</type>.  We'll provide the execution function,
      <function>runSupply</function>, with a list of values; it will
      be up to us to ensure that each one is unique.</para>

    &Supply.hs:runSupply.type;

    <para id="x_Cr">The monad won't care what the values are: they might be
      random numbers, or names for temporary files, or identifiers for
      HTTP cookies.</para>

    <para id="x_Dr">Within the monad, every time a consumer asks for a value,
      the <function>next</function> action will take the next one from
      the list and give it to the consumer.  Each value is wrapped in
      a <type>Maybe</type> constructor in case the list isn't long
      enough to satisfy the demand.</para>

    &Supply.hs:next.type;

    <para id="x_Er">To hide our plumbing, in our module declaration we only
      export the type constructor, the execution function, and the
      <function>next</function> action.</para>

    &Supply.hs:module;

    <para id="x_Fr">Since a module that imports the library can't see the
      internals of the monad, it can't manipulate them.</para>

    <para id="x_Gr">Our plumbing is exceedingly simple: we use a &newtype;
      declaration to wrap the existing <type>State</type>
      monad.</para>

    &Supply.hs:Supply;

    <para id="x_Hr">The <varname role="type">s</varname> parameter is the type
      of the unique values we are going to supply, and <varname
	role="type">a</varname> is the usual type parameter that
      we must provide in order to make our type a monad.</para>

    <para id="x_Ir">Our use of &newtype; for the <type>Supply</type>
      type and our module header join forces to prevent our clients
      from using the <type>State</type> monad's
      <function>get</function> and <function>set</function> actions.
      Because our module does not export the <code>S</code> data
      constructor, clients have no programmatic way to see that we're
      wrapping the <type>State</type> monad, or to access it.</para>

    <para id="x_Jr">At this point, we've got a type, <type>Supply</type>, that
      we need to make an instance of the <type>Monad</type> type
      class.  We could follow the usual pattern of defining &bind; and
      &return;, but this would be pure boilerplate code.  All we'd be
      doing is wrapping and unwrapping the <type>State</type> monad's
      versions of &bind; and &return; using our <code>S</code> value
      constructor.  Here is how such code would look.</para>

    &AltSupply.hs:unwrapS;

    <para id="x_Kr">Haskell programmers are not fond of boilerplate, and sure
      enough, &GHC; has a lovely language extension that eliminates
      the work. To use it, we add the following directive to the top
      of our source file, before the module header.</para>

    &Supply.hs:LANGUAGE;

    <para id="x_Lr">Usually, we can only automatically derive instances of a
      handful of standard typeclasses, such as <type>Show</type> and
      <type>Eq</type>.  As its name suggests, the
      <code>GeneralizedNewtypeDeriving</code> extension broadens our
      ability to derive typeclass instances, and it is specific to
      &newtype; declarations.  If the type we're wrapping is an
      instance of any typeclass, the extensions can
      automatically make our new type an instance of that typeclass
      as follows.</para>

    &Supply.hs:deriving;

    <para id="x_Mr">This takes the underlying type's implementations of &bind;
      and &return;, adds the necessary wrapping and unwrapping with
      our <code>S</code> data constructor, and uses the new versions
      of those functions to derive a <type>Monad</type> instance for
      us.</para>

    <para id="x_Nr">What we gain here is very useful beyond just this example.
      We can use &newtype; to wrap any underlying type; we selectively
      expose only those typeclass instances that we want; and we
      expend almost no effort to create these narrower, more
      specialised types.</para>

    <para id="x_Or">Now that we've seen the
      <code>GeneralizedNewtypeDeriving</code> technique, all that
      remains is to provide definitions of <function>next</function>
      and <function>runSupply</function>.</para>

    &Supply.hs:code;

    <para id="x_Pr">If we load our module into &ghci;, we can try it out in a few
      simple ways.</para>

    &supply.ghci:simple;

    <para id="x_Qr">We can also verify that the <type>State</type> monad has not
      somehow leaked out.</para>

    &supply.ghci:browse;

    <sect2>
      <title>Supplying random numbers</title>

      <para id="x_Rr">If we want to use our <type>Supply</type> monad as a
	source of random numbers, we have a small difficulty to face.
	Ideally, we'd like to be able to provide it with an infinite
	stream of random numbers.  We can get a <type>StdGen</type> in
	the <type>IO</type> monad, but we must <quote>put back</quote>
	a different <type>StdGen</type> when we're done.  If we don't,
	the next piece of code to get a <type>StdGen</type> will get
	the same state as we did.  This means it will generate the
	same random numbers as we did, which is potentially
	catastrophic.</para>

      <para id="x_Sr">From the parts of the <code>System.Random</code>
	module we've seen so far, it's difficult to reconcile these
	demands. We can use <function>getStdRandom</function>, whose
	type ensures that when we get a <type>StdGen</type>, we put
	one back.</para>

      &randomSupply.ghci:getStdRandom;

      <para>We can use <function>random</function> to get back a new
	<type>StdGen</type> when they give us a random number.  And we
	can use <function>randoms</function> to get an infinite list
	of random numbers.  But how do we get both an infinite list of
	random numbers <emphasis>and</emphasis> a new
	<type>StdGen</type>?</para>

      <para id="x_Tr">The answer lies with the <type>RandomGen</type> type
	class's <function>split</function> function, which takes one
	random number generator, and turns it into two generators.
	Splitting a random generator like this is a most unusual thing
	to be able to do: it's obviously tremendously useful in a pure
	functional setting, but essentially never either necessary or
	provided by an impure language.</para>

      <para id="x_Ur">Using the <function>split</function> function, we can use
	one <type>StdGen</type> to generate an infinite list of random
	numbers to feed to <function>runSupply</function>, while we
	give the other back to the <type>IO</type> monad.</para>

      &RandomSupply.hs:randomsIO;

      <para id="x_Vr">If we've written this function properly, our
	example ought to print a different random number on each
	invocation.</para>

      &randomSupply.ghci:random;

      <para id="x_Wr">Recall that our <function>runSupply</function> function
	returns both the result of executing the monadic action and
	the unconsumed remainder of the list.  Since we passed it an
	infinite list of random numbers, we compose with
	<function>fst</function> to ensure that we don't get drowned
	in random numbers when &ghci; tries to print the
	result.</para>
    </sect2>

    <sect2>
      <title>Another round of golf</title>

      <para id="x_Xr">The pattern of applying a function to one element of a
	pair, and constructing a new pair with the other original
	element untouched, is common enough in Haskell code that it
	has been turned into standard code.</para>

      <para id="x_Yr">In the <code>Control.Arrow</code> module are two
	functions, <function>first</function> and
	<function>second</function>, that perform this
	operation.</para>

      &randomSupply.ghci:first;

      <para id="x_Zr">(Indeed, we already encountered
	<function>second</function>, in <xref
	  linkend="jsonclass.instances"/>.)  We can use
	<function>first</function> to golf our definition of
	<function>randomsIO</function>, turning it into a
	one-liner.</para>

      &RandomGolf.hs:randomsIO_golfed;
      
    </sect2>
  </sect1>

  <sect1>
    <title>Separating interface from implementation</title>

    <para id="x_ar">In the previous section, we saw how to hide the fact that
      we're using a <type>State</type> monad to hold the state for our
      <type>Supply</type> monad.</para>

    <para id="x_br">Another important way to make code more modular involves
      separating its <emphasis>interface</emphasis>&emdash;what the
      code can do&emdash;from its
      <emphasis>implementation</emphasis>&emdash;how it does
      it.</para>

    <para id="x_cr">The standard random number generator in
      <code>System.Random</code> is known to be quite slow. If we use
      our <function>randomsIO</function> function to provide it with
      random numbers, then our <function>next</function> action will
      not perform well.</para>

    <para id="x_dr">One simple and effective way that we could deal with this is
      to provide <type>Supply</type> with a better source of random
      numbers.  Let's set this idea aside, though, and consider an
      alternative approach, one that is useful in many settings.  We
      will separate the actions we can perform with the monad from how
      it works using a typeclass.</para>

    &SupplyClass.hs:class;

    <para id="x_er">This typeclass defines the interface that any
      supply monad must implement. It bears careful inspection, since it
      uses several unfamiliar Haskell language extensions.  We will
      cover each one in the sections that follow.</para>

    <sect2 id="monadcase.mptc">
      <title>Multi-parameter typeclasses</title>

      <para id="x_fr">How should we read the snippet <code>MonadSupply s
	  m</code> in the typeclass?  If we add parentheses, an
	equivalent expression is <code>(MonadSupply s) m</code>, which
	is a little clearer.  In other words, given some type variable
	<varname>m</varname> that is a <type>Monad</type>, we can make
	it an instance of the typeclass <type>MonadSupply s</type>.
	unlike a regular typeclass, this one has a
	<emphasis>parameter</emphasis>.</para>

      <para id="x_gr">As this language extension allows a typeclass to
	have more than one parameter, its name is
	<code>MultiParamTypeClasses</code>.  The parameter
	<varname>s</varname> serves the same purpose as the
	<type>Supply</type> type's parameter of the same name: it
	represents the type of the values handed out by the
	<function>next</function> function.</para>

      <para id="x_hr">Notice that we don't need to mention &bind; or
	&return; in the definition of <type>MonadSupply s</type>,
	since the type class's context (superclass) requires that a
	<type>MonadSupply s</type> must already be a
	<type>Monad</type>.</para>
    </sect2>

    <sect2>
      <title>Functional dependencies</title>

      <para id="x_ir">To revisit a snippet that we ignored earlier, <code>| m
	  -&gt; s</code> is a <emphasis>functional
	  dependency</emphasis>, often called a
	<emphasis>fundep</emphasis>.  We can read the vertical bar
	<code>|</code> as <quote>such that</quote>, and the arrow
	<code>-&gt;</code> as <quote>uniquely determines</quote>.  Our
	functional dependency establishes a
	<emphasis>relationship</emphasis> between <varname>m</varname>
	and <varname>s</varname>.</para>

      <para id="x_jr">The availability of functional dependencies is governed by
	the <code>FunctionalDependencies</code> language pragma.</para>

      <para id="x_kr">The purpose behind us declaring a relationship is to help
	the type checker.  Recall that a Haskell type checker is
	essentially a theorem prover, and that it is conservative in
	how it operates: it insists that its proofs must terminate. A
	non-terminating proof results in the compiler either giving up
	or getting stuck in an infinite loop.</para>

      <para id="x_lr">With our functional dependency, we are telling the type
	checker that every time it sees some monad
	<varname>m</varname> being used in the context of a
	<type>MonadSupply s</type>, the type <varname>s</varname> is
	the only acceptable type to use with it.  If we were to omit
	the functional dependency, the type checker would simply give
	up with an error message.</para>

      <para id="x_mr">It's hard to picture what the relationship between
	<varname>m</varname> and <varname>s</varname> really means, so
	let's look at an instance of this typeclass.</para>

      &SupplyClass.hs:instance;

      <para id="x_nr">Here, the type variable <varname>m</varname> is replaced
	by the type <type>S.Supply s</type>.  Thanks to our functional
	dependency, the type checker now knows that when it sees a
	type <type>S.Supply s</type>, the type can be used as an
	instance of the typeclass <type>MonadSupply s</type>.</para>

      <para id="x_or">If we didn't have a functional dependency, the type
	checker would not be able to figure out the relationship
	between the type parameter of the class <type>MonadSupply
	  s</type> and that of the type <type>Supply s</type>, and it
	would abort compilation with an error.  The definition itself
	would compile; the type error would not arise until the first
	time we tried to use it.</para>

      <para id="x_pr">To strip away one final layer of abstraction, consider the
	type <type>S.Supply Int</type>.  Without a functional
	dependency, we could declare this an instance of
	<type>MonadSupply s</type>.  However, if we tried to write
	code using this instance, the compiler would not be able to
	figure out that the type's <type>Int</type> parameter needs to
	be the same as the typeclass's <varname>s</varname>
	parameter, and it would report an error.</para>

      <para id="x_qr">Functional dependencies can be tricky to understand, and
	once we move beyond simple uses, they often prove difficult to
	work with in practice.  Fortunately, the most frequent use of
	functional dependencies is in situations as simple as ours,
	where they cause little trouble.</para>
    </sect2>

    <sect2>
      <title>Rounding out our module</title>

      <para id="x_rr">If we save our typeclass and instance in a source file
	named <filename>SupplyClass.hs</filename>, we'll need to add
	a module header such as the following.</para>

      &SupplyClass.hs:module;

      <para id="x_sr">The <code>FlexibleInstances</code> extension is necessary
	so that the compiler will accept our instance declaration.
	This extension relaxes the normal rules for writing instances
	in some circumstances, in a way that still lets the compiler's
	type checker guarantee that it will terminate.  Our need for
	<code>FlexibleInstances</code> here is caused by our use of
	functional dependencies, but the details are unfortunately
	beyond the scope of this book.</para>

      <tip>
	<title>How to know when a language extension is needed</title>

	<para id="x_tr">If &GHC; cannot compile a piece of code because it would
	  require some language extension to be enabled, it will tell
	  us which extension we should use.  For example, if it
	  decides that our code needs flexible instance support, it
	  will suggest that we try compiling with the
	  <option>-XFlexibleInstances</option> option.  A
	  <option>-X</option> option has the same effect as a
	  <code>LANGUAGE</code> directive: it enables a particular
	  extension.</para>
      </tip>

      <para id="x_ur">Finally, notice that we're re-exporting the
	<function>runSupply</function> and <type>Supply</type> names
	from this module. It's perfectly legal to export a name from
	one module even though it's defined in another.  In our case,
	it means that client code only needs to import the
	<code>SupplyClass</code> module, without also importing the
	<code>Supply</code> module.  This reduces the number of
	<quote>moving parts</quote> that a user of our code needs to
	keep in mind.</para>
    </sect2>

    <sect2>
      <title>Programming to a monad's interface</title>
      
      <para>Here is a simple function that fetches two values from
	our <type>Supply</type> monad, formats them as a string, and
	returns them.</para>

      &Supply.hs:showTwo;

      <para>This code is tied by its result type to our
	<type>Supply</type> monad.  We can easily generalize to any
	monad that implements our <type>MonadSupply</type> interface
	by modifying our function's type.  Notice that the body of the
	function remains unchanged.</para>

      &SupplyClass.hs:showTwo_class;

    </sect2>
  </sect1>

  <sect1>
    <title>The reader monad</title>

    <para id="x_wr">The <type>State</type> monad lets us plumb a piece of
      mutable state through our code.  Sometimes, we would like to be
      able to pass some <emphasis>immutable</emphasis> state around,
      such as a program's configuration data.  We could use the
      <type>State</type> monad for this purpose, but we could then
      find ourselves accidentally modifying data that should remain
      unchanged.</para>

    <para id="x_xr">Let's forget about monads for a moment and think about what
      a <emphasis>function</emphasis> with our desired characteristics
      ought to do.  It should accept a value of some type <varname
	role="type">e</varname> (for <emphasis>environment</emphasis>)
	that represents the data
      that we're passing in, and return a value of some
      other type <varname role="type">a</varname> as its result.  The
      overall type we want is <type>e -&gt; a</type>.</para>

    <para id="x_yr">To turn this type into a convenient <type>Monad</type>
      instance, we'll wrap it in a &newtype;.</para>

    &SupplyInstance.hs:Reader;

    <para id="x_zr">Making this into a <type>Monad</type> instance doesn't take
      much work.</para>

    &SupplyInstance.hs:Monad;

    <para id="x_As">We can think of our value of type <varname
	role="type">e</varname> as an <emphasis>environment</emphasis>
      in which we're evaluating some expression.  The &return; action
      should have the same effect no matter what the environment is,
      so our version ignores its environment.</para>

    <para id="x_Bs">Our definition of &bind; is a little more complicated, but
      only because we have to make the environment&emdash;here the
      variable <varname>r</varname>&emdash;available both in the
      current computation and in the computation we're chaining
      into.</para>

    <para id="x_Cs">How does a piece of code executing in this monad find out
      what's in its environment?  It simply has to
      <function>ask</function>.</para>

    &SupplyInstance.hs:ask;

    <para id="x_Ds">Within a given chain of actions, every invocation of
      <function>ask</function>  will return the same value, since the
      value stored in the environment doesn't change.  Our code
      is easy to test in &ghci;.</para>

    &supply.ghci:instance;

    <para id="x_Es">The <type>Reader</type> monad is included in the standard
      <code>mtl</code> library, which is usually bundled with &GHC;.
      You can find it in the <code>Control.Monad.Reader</code> module.
      The motivation for this monad may initially seem a little thin,
      because it is most often useful in complicated code.  We'll
      often need to access a piece of configuration information
      deep in the bowels of a program; passing that information in as
      a normal parameter would require a painful restructuring of our
      code.  By hiding this information in our monad's plumbing,
      intermediate functions that don't care about the configuration
      information don't need to see it.</para>

    <para id="x_Fs">The clearest motivation for the
      <type>Reader</type> monad will come in <xref
	linkend="monadtrans"/>, when we discuss
      combining several monads to build a new monad.  There, we'll see
      how to gain finer control over state, so that our code can
      modify some values via the <type>State</type> monad, while other
      values remain immutable, courtesy of the <type>Reader</type>
      monad.</para>
  </sect1>

  <sect1>
    <title>A return to automated deriving</title>

    <para id="x_Gs">Now that we know about the <type>Reader</type>
      monad, let's use it to create an instance of our
      <type>MonadSupply</type> typeclass.  To keep our example simple,
      we'll violate the spirit of <type>MonadSupply</type> here: our
      <function>next</function> action will always return the same
      value, instead of always returning a different value.</para>

    <para id="x_Hs">It would be a bad idea to directly make the
      <type>Reader</type> type an instance of the
      <type>MonadSupply</type> class, because then
      <emphasis>any</emphasis> <type>Reader</type> could act as a
      <type>MonadSupply</type>.  This would usually not make any
      sense.</para>

    <para id="x_Is">Instead, we create a &newtype; based on
      <type>Reader</type>.  The &newtype; hides the fact that we're
      using <type>Reader</type> internally.  We must now make our type
      an instance of both of the typeclasses we care about.  With the
      <code>GeneralizedNewtypeDeriving</code> extension enabled, &GHC;
      will do most of the hard work for us.</para>

    &SupplyInstance.hs:MySupply;

    <para id="x_Js">Notice that we must make our type an instance of
      <type>MonadSupply e</type>, not <type>MonadSupply</type>.  If we
      omit the type variable, the compiler will complain.</para>

    <para id="x_Ks">To try out our <type>MySupply</type> type, we'll first
      create a simple function that should work with any
      <type>MonadSupply</type> instance.</para>

    &SupplyInstance.hs:xy;

    <para id="x_Ls">If we use this with our <type>Supply</type> monad and
      <function>randomsIO</function> function, we get a different
      answer every time, as we expect.</para>

    &supply.ghci:xy1;

    <para id="x_Ms">Because our <type>MySupply</type> monad has two layers of
      &newtype; wrapping, we can make it easier to use by writing a
      custom execution function for it.</para>

    &SupplyInstance.hs:runMS;

    <para id="x_Ns">When we apply our <function>xy</function> action
      using this execution function, we get the same answer every
      time.  Our code remains the same, but because we are executing
      it in a different implementation of <type>MonadSupply</type>,
      its behavior has changed.</para>

    &supply.ghci:xy2;

    <para id="x_Os">Like our <type>MonadSupply</type> typeclass and
      <type>Supply</type> monad, almost all of the common Haskell
      monads are built with a split between interface and
      implementation.  For example, the <function>get</function> and
      <function>put</function> functions that we introduced as
      <quote>belonging to</quote> the <type>State</type> monad are
      actually methods of the <type>MonadState</type> typeclass; the
      <type>State</type> type is an instance of this class.</para>

    <para id="x_Ps">Similarly, the standard <type>Reader</type> monad is an
      instance of the <type>MonadReader</type> typeclass, which
      specifies the <function>ask</function> method.</para>

    <para id="x_Qs">While the separation of interface and implementation that
      we've discussed above is appealing for its architectural
      cleanliness, it has important practical applications that will
      become clearer later. When we start combining monads in <xref
      linkend="monadtrans"/>, we will save a lot of effort through the use of
      <code>GeneralizedNewtypeDeriving</code> and typeclasses.</para>
  </sect1>

  <sect1>
    <title>Hiding the IO monad</title>

    <para id="x_Rs">The blessing and curse of the <type>IO</type> monad is that
      it is extremely powerful.  If we believe that careful use of
      types helps us to avoid programming mistakes, then the
      <type>IO</type> monad should be a great source of unease.
      Because the <type>IO</type> monad imposes no restrictions on
      what we can do, it leaves us vulnerable to all kinds of
      accidents.</para>

    <para id="x_Ss">How can we tame its power?  Let's say that we would like to
      guarantee to ourselves that a piece of code can read and write
      files on the local filesystem, but that it will not access the
      network.  We can't use the plain <type>IO</type> monad, because
      it won't restrict us.</para>

    <sect2>
      <title>Using a newtype</title>

      <para id="x_Ts">Let's create a module that provides a small set of
	functionality for reading and writing files.</para>

      &HandleIO.hs:module;

      <para id="x_Us">Our first approach to creating a restricted version of
	<type>IO</type> is to wrap it with a &newtype;.</para>

      &HandleIO.hs:newtype;

      <para id="x_Vs">We do the by-now familiar trick of exporting the type
	constructor and the <function>runHandleIO</function> execution
	function from our module, but not the data constructor.  This
	will prevent code running within the <type>HandleIO</type>
	monad from getting hold of the <type>IO</type> monad that it
	wraps.</para>

      <para id="x_Ws">All that remains is for us to wrap each of the actions we
	want our monad to allow.  This is a simple matter of wrapping
	each <type>IO</type> with a <type>HandleIO</type> data
	constructor.</para>

      &HandleIO.hs:actions;

      <para id="x_Xs">We can now use our restricted <type>HandleIO</type> monad
	to perform I/O.</para>

      &HandleIO.hs:safeHello;

      <para id="x_Ys">To run this action, we use
	<function>runHandleIO</function>.</para>

      &handleIO.ghci:HandleIO;

      <para id="x_Zs">If we try to sequence an action that runs in the
	<type>HandleIO</type> monad with one that is not permitted,
	the type system forbids it.</para>

      &handleIO.ghci:bad;
    </sect2>

    <sect2>
      <title>Designing for unexpected uses</title>

      <para id="x_as">There's one small, but significant, problem with our
	<type>HandleIO</type> monad: it doesn't take into account the
	possibility that we might occasionally need an escape hatch.
	If we define a monad like this, it is likely that we will
	occasionally need to perform an I/O action that isn't allowed
	for by the design of our monad.</para>

      <para id="x_bs">Our purpose in defining a monad like this is to make it
	easier for us to write solid code in the common case, not to
	make corner cases impossible.   Let's thus give ourselves a
	way out.</para>

      <para id="x_cs">The <code>Control.Monad.Trans</code> module defines a
	<quote>standard escape hatch</quote>, the <type>MonadIO</type>
	typeclass.  This defines a single function,
	<function>liftIO</function>, which lets us embed an
	<type>IO</type> action in another monad.</para>

      &monadio.ghci:MonadIO;

      <para id="x_ds">Our implementation of this typeclass is trivial: we just
	wrap <type>IO</type> with our data constructor.</para>

      &HandleIO.hs:MonadIO;
      
      <para id="x_es">With judicious use of <function>liftIO</function>, we can
	escape our shackles and invoke <type>IO</type> actions where
	necessary.</para>

      &HandleIO.hs:tidyHello;

      <tip>
	<title>Automatic derivation and MonadIO</title>

	<para id="x_fs">We could have had the compiler automatically derive an
	  instance of <type>MonadIO</type> for us by adding the type
	  class to the <code>deriving</code> clause of
	  <type>HandleIO</type>.  In fact, in production code, this
	  would be our usual strategy.  We avoided that here simply to
	  separate the presentation of the earlier material from that
	  of <type>MonadIO</type>.</para>
      </tip>
    </sect2>

    <sect2 id="monadcase.io.class">
      <title>Using typeclasses</title>

      <para id="x_gs">The disadvantage of hiding <type>IO</type> in another
	monad is that we're still tied to a concrete implementation.
	If we want to swap <type>HandleIO</type> for some other monad,
	we must change the type of every action that uses
	<type>HandleIO</type>.</para>

      <para id="x_hs">As an alternative, we can create a typeclass that
	specifies the interface we want from a monad that manipulates
	files.</para>

      &MonadHandle.hs:MonadHandle;

      <para id="x_is">Here, we've chosen to abstract away both the type of the
	monad and the type of a file handle.  To satisfy the type
	checker, we've added a functional dependency: for any instance
	of <type>MonadHandle</type>, there is exactly one handle type
	that we can use.  When we make the <type>IO</type> monad an
	instance of this class, we use a regular
	<type>Handle</type>.</para>

      &MonadHandleIO.hs:IO;

      <para id="x_js">Because any <type>MonadHandle</type> must also be a
	<type>Monad</type>, we can write code that manipulates files
	using normal &do; notation, without caring what monad it will
	finally execute in.</para>

      &SafeHello.hs:safeHello;

      <para id="x_ks">Because we made <type>IO</type> an instance of this type
	class, we can execute this action from &ghci;.</para>

      &monadHandle.ghci:IO;

      <para id="x_ls">The beauty of the typeclass approach is that we
	can swap one underlying monad for another without touching
	much code, as most of our code doesn't know or care about the
	implementation. For instance, we could replace <type>IO</type>
	with a monad that compresses files as it writes them
	out.</para>

      <para>Defining a monad's interface through a typeclass has a
	further benefit.  It lets other people hide our implementation
	in a &newtype; wrapper, and automatically derive instances of
	just the typeclasses they want to expose.</para>
    </sect2>

    <sect2>
      <title>Isolation and testing</title>

      <para id="x_ms">In fact, because our <function>safeHello</function>
	function doesn't use the <type>IO</type> type, we can even use
	a monad that <emphasis>can't</emphasis> perform I/O.  This
	allows us to test code that would normally have side effects
	in a completely pure, controlled environment.</para>

      <para id="x_ns">To do this, we will create a monad that doesn't perform
	I/O, but instead logs every file-related event for later
	processing.</para>

      &WriterIO.hs:Event;

      <para id="x_os">Although we already developed a <type>Logger</type> type
	in <xref linkend="monads.logger"/>, here we'll use the
	standard, and more general, <type>Writer</type> monad. Like
	other <code>mtl</code> monads, the API provided by
	<type>Writer</type> is defined in a typeclass, in this case
	<type>MonadWriter</type>.  Its most useful method is
	<function>tell</function>, which logs a value.</para>

      &monadwriter.ghci:tell;

      <para id="x_ps">The values we log can be of any <type>Monoid</type> type.
	Since the list type is a <type>Monoid</type>, we'll log to a
	list of <type>Event</type>.</para>

      <para id="x_qs">We could make <type>Writer [Event]</type> an instance of
	<type>MonadHandle</type>, but it's cheap, easy, and safer to
	make a special-purpose monad.</para>

      &WriterIO.hs:WriterIO;

      <para id="x_rs">Our execution function simply removes the &newtype;
	wrapper we added, then calls the normal <type>Writer</type>
	monad's execution function.</para>

      &WriterIO.hs:runWriterIO;

      <para id="x_ss">When we try this code out in &ghci;, it gives us a log of
	the function's file activities.</para>

      &monadHandle.ghci:Writer;

    </sect2>

    <sect2 id="monadcase.writer.dlist">
      <title>The writer monad and lists</title>

      <para id="x_ts">The writer monad uses the monoid's
	<function>mappend</function> function every time we use
	<function>tell</function>.  Because
	<function>mappend</function> for lists is
	<function>(++)</function>, lists are not a good practical
	choice for use with <type>Writer</type>: repeated appends are
	expensive.  We use lists above purely for
	simplicity.</para>

      <para id="x_us">In production code, if you want to use the
	<type>Writer</type> monad and you need list-like behaviour,
	use a type with better  append characteristics. One such type
	is the difference list, which we introduced in <xref
	  linkend="data.dlist"/>.  You don't need to roll your own
	difference list implementation: a well tuned library is
	available for download from Hackage, the Haskell package
	database.  Alternatively, you can use the <type>Seq</type>
	type from the <code>Data.Sequence</code> module, which we
	introduced in <xref linkend="data.seq"/>.</para>
    </sect2>

    <sect2>
      <title>Arbitrary I/O revisited</title>

      <para id="x_vs">If we use the typeclass approach to restricting
	<type>IO</type>, we may still want to retain the ability to
	perform arbitrary I/O actions.  We might try adding
	<type>MonadIO</type> as a constraint on our typeclass.</para>

      &MonadHandleIO.hs:tidierHello;

      <para id="x_ws">This approach has a problem, though: the added
	<type>MonadIO</type> constraint loses us the ability to test
	our code in a pure environment, because we can no longer tell
	whether a test might have damaging side effects.  The
	alternative is to move this constraint from the typeclass,
	where it <quote>infects</quote> all functions, to only those
	functions that really need to perform I/O.</para>

      &MonadHandleIO.hs:tidyHello;

      <para id="x_xs">We can use pure property tests on the functions that lack
	<type>MonadIO</type> constraints, and traditional unit tests
	on the rest.</para>

      <para id="x_ys">Unfortunately, we've substituted one problem for another:
	we can't invoke code with both <type>MonadIO</type> and
	<type>MonadHandle</type> constraints from code that has the
	<type>MonadHandle</type> constraint alone.  If we find that
	somewhere deep in our <type>MonadHandle</type>-only code, we
	really need the <type>MonadIO</type> constraint, we must add
	it to all the code paths that lead to this point.</para>

      <para id="x_zs">Allowing arbitrary I/O is risky, and has a profound effect
	on how we develop and test our code.  When we have to choose
	between being permissive on the one hand, and easier reasoning
	and testing on the other, we usually opt for the
	latter.</para>
    </sect2>

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para id="x_At">Using QuickCheck, write a test for an action in the
	      <type>MonadHandle</type> monad, to see if it tries to
	      write to a file handle that is not open.  Try it
	      out on <function>safeHello</function>.</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para id="x_Bt">Write an action that tries to write to a file handle
	      that it has closed.  Does your test catch this
	      bug?</para>
	  </question>
	</qandaentry>
	<qandaentry>
	  <question>
	    <para>In a form-encoded string, the same key may appear
	      several times, with or without values, e.g.
	      <code>key&amp;key=1&amp;key=2</code>.  What type might
	      you use to represent the values associated with a key in
	      this sort of string?  Write a parser that correctly
	      captures all of the information.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
