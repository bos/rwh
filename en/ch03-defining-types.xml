<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="deftypes">
  <title>Defining Types, Streamlining Functions</title>

  <sect1 id="deftypes.data">
    <title>Defining a new data type</title>
      
    <para id="x_C4">Although lists and tuples are useful, we'll often
      want to construct new data types of our own.  This allows us to
      add structure to the values in our programs.  Instead of using
      an anonymous tuple, we can give a collection of related values a
      name and a distinct type.  Defining our own types also improves
      the type safety of our code: Haskell will not allow us to
      accidentally mix values of two types that are structurally
      similar but have different names.</para>

    <para id="x_Cf">For motivation, we'll consider a few kinds of data that a
      small online bookstore might need to manage.  We won't make any
      attempt at complete or realistic data definitions, but at least
      we're tying them to the real world.</para>

    <para id="x_Df">We define a new data type using the <code>data</code>
      keyword.</para>

    &BookStore.hs:BookInfo;

    <para id="x_D4">The <type>BookInfo</type> after the
      <code>data</code> keyword is the name of our new type. We call
      <type>BookInfo</type> a <emphasis>type constructor</emphasis>.
      Once we have defined a type, we will use its type
      constructor to refer to it.
      As we've already mentioned, a type name, and hence a type
      constructor, must start with a capital letter.</para>

    <para id="x_pB1">The <code>Book</code> that follows is the name of the
      <emphasis>value constructor</emphasis> (sometimes called a data
      constructor).  We use this to create a value of the
      <type>BookInfo</type> type.  A value constructor's name must
      also start with a capital letter.</para>

    <para id="x_Ef">After <code>Book</code>, the <type>Int</type>,
      <type>String</type>, and <type>[String]</type> that follow are
      the <emphasis>components</emphasis> of the type.  A component
      serves the same purpose in Haskell as a field in a structure or
      class would in another language: it's a <quote>slot</quote>
      where we keep a value.  (We'll often refer to components as
      fields.)</para>

    <para id="x_Ff">In this example, the <type>Int</type> represents a book's
      identifier (e.g. in a stock database), <type>String</type> its
      title, and <type>[String]</type> the names of its authors.</para>

    <para id="x_Gf">To make the link to a concept we've already seen, the
      <type>BookInfo</type> type contains the same components as a
      3-tuple of type <type>(Int, String, [String])</type>, but it has
      a distinct type.  We can't accidentally (or deliberately) use
      one in a context where the other is expected.  For instance, a
      bookstore is also likely to carry magazines.</para>

    &BookStore.hs:MagazineInfo;

    <para id="x_qB1">Even though this <type>MagazineInfo</type> type has the same
      structure as our <type>BookInfo</type> type, Haskell treats the
      types as distinct because their type and value constructors have
      different names.</para>

    <note>
      <title>Deriving what?</title>

      <para id="x_E4">We'll explain the full meaning of <code>deriving
	  (Show)</code> later, in
	<xref linkend="typeclasses.wellknown.show"/>.  For now, it's
	enough to know that we need to tack this onto a type
	declaration so that &ghci; will automatically know how to
	print a value of this type.</para>
    </note>

    <para id="x_F4">We can create a new value of type
      <type>BookInfo</type> by treating <function>Book</function> as a
      function, and applying it with arguments of types
      <type>Int</type>, <type>String</type>, and
      <type>[String]</type>.</para>

    &BookStore.hs:myInfo;

    <para id="x_G4">Once we have defined a type, we can experiment
      with it in &ghci;.  We begin by using the
      <command>:load</command> command to load our source file.</para>

    &bookstore.ghci:load;

    <para id="x_H4">Remember the <code>myInfo</code> variable we
      defined in our source file?  Here it is.</para>

    &bookstore.ghci:myInfo;

    <para id="x_I4">We can construct new values interactively in
      &ghci;, too.</para>

    &bookstore.ghci:newValue;

    <para id="x_AL">The &ghci; command <command>:type</command> lets
      us see what the type of an expression is.</para>

    &bookstore.ghci:valueType;

    <para id="x_rB1">Remember that if we want to define a new variable inside
      &ghci;, the syntax is slightly different from that of a Haskell
      source file: we need to put a &let; in front.</para>

    &bookstore.ghci:newVar;

    <para id="x_J4">To find out more about a type, we can use some of
      &ghci;'s browsing capabilities.  The <command>:info</command>
      command gets &ghci; to tell us everything it knows about a
      name.</para>
    
    &bookstore.ghci:info;

    <para id="x_K4">We can also find out why we use
      <function>Book</function> to construct a new value of type
      <type>BookStore</type>.</para>

    &bookstore.ghci:type;

    <para id="x_L4">We can treat a value constructor as just another
      function, one that happens to create and return a new value of
      the type we desire.</para>

    <sect2>
      <title>Naming types and values</title>

      <para id="x_Hf">When we introduced the type <type>BookStore</type>, we
	deliberately chose to give the type constructor
	<type>BookStore</type> a different name from the value
	constructor <code>Book</code>, purely to make it obvious which
	was which.</para>

      <para id="x_If">However, in Haskell, the names of types and
	values are independent of each other.  We only use a type
	constructor (i.e. the type's name) in a type declaration or a
	type signature.  We only use a value constructor in actual
	code.  Because these uses are distinct, there is no ambiguity
	if we give a type constructor and a value constructor the same
	name.  If we are writing a type signature, we must be
	referring to a type constructor.  If we are writing an
	expression, we must be using the value constructor.</para>

      &BookStore.hs:BookReview;

      <para id="x_Kf">This definition says that the type named
	<type>BookReview</type> has a value constructor that is also
	named <code>BookReview</code>.</para>

      <para id="x_Lf">Not only is it <emphasis>legal</emphasis> for a
	value constructor to have the same name as its type
	constructor, it's <emphasis>normal</emphasis>: you'll see this
	all the time in regular Haskell code.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.alias">
    <title>Type synonyms</title>

    <para id="x_Mf">We can introduce a <emphasis>synonym</emphasis> for an
      existing type at any time, to give a type a more
      descriptive name.  For example, the <type>String</type> in our
      <type>BookReview</type> type doesn't tell us what the string is
      for, but we can clarify this.</para>

    &BookStore.hs:BetterReview;

    <para id="x_Nf">The &type; keyword introduces a type synonym.  The new name
      is on the left of the <code>=</code>, with the existing name on
      the right.  The two names identify the same type, so type
      synonyms are <emphasis>purely</emphasis> for making code more
      readable.</para>

    <para id="x_Of">We can also use a type synonym to create a shorter name for
      a verbose type.</para>

    &BookStore.hs:BookRecord;

    <para id="x_Pf">This states that we can use
      <type>BookRecord</type> as a synonym for the tuple
      <type>(BookInfo, BookReview)</type>.  A type synonym only
      creates a new name that refers to an existing type<footnote>
	<para id="x_sB1">If you are familiar with C or C++, it is analogous to a
	  <code>typedef</code>.</para>
      </footnote>.  We still use the same value constructors to create
      a value of the type.</para>
  </sect1>

  <sect1 id="deftypes.adt">
    <title>Algebraic data types</title>

    <para id="x_M4">The familiar <type>Bool</type> is the simplest
      common example of a category of type called an
      <emphasis>algebraic data type</emphasis>. An algebraic data type
      can have more than one value constructor.</para>

      &Bool.hs:Bool;

    <para id="x_N4">The <type>Bool</type> type has two value
      constructors, <code>True</code> and <code>False</code>. Each
      value constructor is separated in the definition by a
      <literal>|</literal> character, which we can read as
      <quote>or</quote>: we can construct a <type>Bool</type> that has
      the value <code>True</code>, or the value <code>False</code>.
      When a type has more than one value constructor, they are
      usually referred to as <emphasis>alternatives</emphasis> or
      <emphasis>cases</emphasis>.  We can use any one of the
      alternatives to create a value of that type.</para>

    <note>
      <title>A note about naming</title>

      <para id="x_Qf">Although the phrase <quote>algebraic data
	  type</quote> is long, we're being careful to avoid using the
	acronym <quote>ADT</quote>.  That acronym is already widely
	understood to stand for <quote><emphasis>abstract</emphasis>
	  data type</quote>.  Since Haskell supports both algebraic
	and abstract data types, we'll be explicit and avoid the
	acronym entirely.</para>
    </note>

    <para id="x_O4">Each of an algebraic data type's value
      constructors can take zero or more arguments.  As an example,
      here's one way we might represent billing information.</para>

    &BookStore.hs:BillingInfo;

    <para id="x_P4">Here, we're saying that we support three ways to
      bill our customers.  If they want to pay by credit card, they
      must supply a card number, the holder's name, and the holder's
      billing address as arguments to the <code>CreditCard</code>
      value constructor.  Alternatively, they can pay the person who
      delivers their shipment.  Since we don't need to store any extra
      information about this, we specify no arguments for the
      <code>CashOnDelivery</code> constructor. Finally, we can send an
      invoice to the specified customer, in which case we need their
      <type>CustomerID</type> as an argument to the
      <code>Invoice</code> constructor.</para>
      
    <para id="x_Rf">When we use a value constructor to create a
      value of type <type>BillingInfo</type>, we must supply the
      arguments that it requires.</para>

    &bookstore.ghci:billingInfo;

    <para id="x_bO1">The <code>No instance</code> error message arose because we
      did not supply an argument to the <code>Invoice</code>
      constructor.  As a result, we were trying to print the
      <code>Invoice</code> constructor itself.  That constructor
      requires an argument and returns a value, so it is a function.
      We cannot print functions in Haskell, which is ultimately why
      the interpreter complained.</para>

    <sect2>
      <title>Tuples, algebraic data types, and when to use
	each</title>

      <para id="x_Sf">There is some overlap between tuples and user-defined
	algebraic data types.  If we wanted to, we could represent our
	<type>BookInfo</type> type from earlier as an <type>(Int,
	  String, [String])</type> tuple.</para>

      &bookstore.ghci:tuple;

      <para id="x_Tf">Algebraic data types allow us to distinguish
      between otherwise identical pieces of information.
	Two tuples with elements of the same type are structurally
	identical, so they have the same type.</para>

      &Distinction.hs:tuples;

      <para id="x_tB1">Since they have different names, two algebraic data types
	have distinct types, even if they are otherwise structurally
	equivalent.</para>

      &Distinction.hs:data;

      <para id="x_uB1">This lets us bring the type system to bear in writing
	programs with fewer bugs.  With the tuples we defined above,
	we could conveivably pass a description of a whale to a
	function expecting a chair, and the type system could not help
	us.  With the algebraic data types, there is no such
	possibility of confusion.</para>

      <para id="x_vB1">Here is a more subtle example.  Consider the following
	representations of a two-dimensional vector.</para>

      &AlgebraicVector.hs:types;

      <para id="x_Uf">The Cartesian and polar forms use the same types
	for their two elements.  However, the
	<emphasis>meanings</emphasis> of the elements are different.
	Because <type>Cartesian2D</type> and <type>Polar2D</type> are
	distinct types, the type system will not let us accidentally
	use a <type>Cartesian2D</type> value where a
	<type>Polar2D</type> is expected, or vice versa.</para>

      &algebraicvector.ghci:typed;

      <para id="x_Vf">The <function>(==)</function> operator requires its
	arguments to have the same type.</para>

	<tip>
	  <title>Comparing for equality</title>

	  <para id="x_cf">Notice that in the <code>deriving</code>
	  clause for our vector types, we added another word,
	  <code>Eq</code>.  This causes the Haskell implementation to
	  generate code that lets us compare the values for
	  equality.</para>
	</tip>


      <para id="x_Wf">If we used tuples to represent these values, we could
	quickly land ourselves in hot water by mixing the two
	representations inappropriately.</para>

      &algebraicvector.ghci:tupled;

      <para id="x_Xf">The type system can't rescue us here: as far as
	it's concerned, we're comparing two <type>(Double,
	  Double)</type> pairs, which is a perfectly valid thing to
	do.  Indeed, we cannot tell by inspection which of these
	values is supposed to be polar or Cartesian, but
	<code>(1,2)</code> has a different meaning in each
	representation.</para>

      <para id="x_Yf">There is no hard and fast rule for deciding when
	it's better to use a tuple or a distinct data type, but here's
	a rule of thumb to follow. If you're using compound values
	widely in your code (as almost all non-trivial programs do),
	adding &data; declarations will benefit you in both type
	safety and readability. For smaller, localised uses, a tuple
	is usually fine.</para>
    </sect2>

    <sect2 id="deftypes.adt.comp">
      <title>Analogues to algebraic data types in other
	languages</title>

      <para id="x_Q4">Algebraic data types provide a single powerful
	way to describe data types.  Other languages often need
	several different features to achieve the same degree of
	expressiveness.  Here are some analogues from C and C++, which
	might make it clearer what we can do with algebraic data
	types, and how they relate to concepts that might be more
	familiar.</para>

      <sect3>
	<title>The structure</title>

	<para id="x_R4">With just one constructor, an algebraic data
	  type is similar to a tuple: it groups related values
	  together into a compound value. It corresponds to a
	  <code>struct</code> in C or C++, and its components
	  correspond to the fields of a <code>struct</code>. Here's a
	  C equivalent of the <type>BookInfo</type> type that we
	  defined earlier.</para>

	&types.c:book_info;

	<para id="x_Zf">The main difference between the two is that the fields
	  in the Haskell type are anonymous and positional.</para>

	&BookStore.hs:BookInfo.noid;

	<para id="x_af">By <emphasis>positional</emphasis>, we mean that the
	  section number is in the first field of the Haskell type,
	  and the title is in the second.  We refer to them by
	  location, not by name.</para>

	<para id="x_bf">In <xref linkend="deftypes.pattern"/>, we'll see how to access the
	  fields of a <type>BookStore</type> value.  In <xref
	  linkend="deftypes.record"/>, we'll introduce an alternate
	  syntax for defining data types that looks a little more
	  C-like.</para>

      </sect3>

      <sect3>
	<title>The enumeration</title>

	<para id="x_U4">Algebraic data types also serve where we'd use
	  an <code>enum</code> in C or C++, to represent a range of
	  symbolic values. Such algebraic data types are sometimes
	  referred to as enumeration types.  Here's an example from
	  C.</para>

	&types.c:roygbiv;

	<para id="x_EL">And here's a Haskell equivalent.</para>

	&Roygbiv.hs:Roygbiv;

	<para id="x_wB1">We can try these out in &ghci;.</para>

	&roygbiv.ghci:using;

	<para id="x_df">In C, the elements of an <code>enum</code> are integers.
	  We can use an integer in a context where an
	  <code>enum</code> is expected, and vice versa: a C compiler
	  will automatically convert values between the two types.
	  This can be a source of nasty bugs.  In Haskell, this kind
	  of problem does not occur.  For example, we cannot use a
	  <type>Roygbiv</type> value where an <code>Int</code> is
	  expected.</para>

	&roygbiv.ghci:types;
      </sect3>

      <sect3>
	<title>The discriminated union</title>

	<para id="x_S4">If an algebraic data type has multiple
	  alternatives, we can think of it as similar to a
	  <code>union</code> in C or C++.  A big difference between
	  the two is that a union doesn't tell us which alternative is
	  actually present; we have to explicitly and manually track
	  which alternative we're using, usually in another field of
	  an enclosing struct.  This means that unions can be sources
	  of nasty bugs, where our notion of which alternative we
	  should be using is incorrect.</para>

	&types.c:shape;

	<para id="x_ef">In the example above, the <code>union</code> can contain
	  valid data for either a <code>struct circle</code> or a
	  <code>struct poly</code>. We have to use the <code>enum
	    shape_type</code> by hand to indicate which kind of value
	  is currently stored in the <code>union</code>.</para>

	<para id="x_ff">The Haskell version of this code is both dramatically
	  shorter and safer than the C equivalent.</para>

	&ShapeUnion.hs:Shape;

	<para id="x_T4">If we create a <type>Shape</type> value using
	  the <code>Circle</code> constructor, the fact that we
	  created a <code>Circle</code> is stored.  When we later use
	  a <code>Circle</code>, we can't accidentally treat it as a
	  <code>Square</code>.  We will see why in <xref
	  linkend="deftypes.pattern"/></para>

      <tip>
	<title>A few notes</title>

	<para id="x_V4">From reading the preceding sections, it should
	  now be clear that <emphasis>all</emphasis> of the data types
	  that we define with the <code>data</code> keyword are
	  algebraic data types. Some may have just one alternative,
	  while others have several, but they're all using the same
	  machinery.</para>
      </tip>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="deftypes.pattern">
    <title>Pattern matching</title>

    <para id="x_Z5">Now that we've seen how to construct values with
      algebraic data types, let's discuss how we work with these
      values.  If we have a value of some type, there are two things
      we would like to be able to do.</para>

    <itemizedlist>
      <listitem>
	<para id="x_gf">If the type has more than one value constructor, we need
	  to be able to tell which value constructor was used to
	  create the value.</para>
      </listitem>
      <listitem>
	<para id="x_hf">If the value constructor has data components, we need to
	  be able to extract those values.</para>
      </listitem>
    </itemizedlist>

    <para id="x_if">Haskell has a simple, but tremendously useful,
      <emphasis>pattern matching</emphasis> facility that lets us do
      both of these things.</para>

    <para id="x_a5">A pattern lets us look inside a value and bind
      variables to the data it contains.  Here's an example of pattern
      matching in action on a <type>Bool</type> value: we're going to
      reproduce the <function>not</function> function.</para>

    &add.hs:myNot;

    <para id="x_e5">It might seem that we have two functions named
      <function>myNot</function> here, but Haskell lets us define a
      function as a <emphasis>series of equations</emphasis>: these
      two clauses are defining the behavior of the same function for
      different patterns of input.  On each line, the patterns are the
      items following the function name, up until the <code>=</code>
      sign.</para>

    <para id="x_jf">To understand how pattern matching works, let's step through
      an example, say <code>myNot False</code>.</para>

    <para id="x_kf">When we apply <function>myNot</function>, the
      Haskell runtime checks the value we supply against the value
      constructor in the first pattern.  This does not match, so it
      tries against the second pattern.  That match succeeds, so it
      uses the right hand side of that equation as the result of the
      function application.</para>

    <para id="x_xB1">Here is a slightly more extended example.  This function
      adds together the elements of a list.</para>

    &add.hs:sumList;

    <para id="x_yB1">Let us step through the evaluation of <code>sumList
	[1,2]</code>. The list notation <code>[1,2]</code> is
      shorthand for the expression <code>(1:(2:[]))</code>. We begin
      by trying to match the pattern in the first equation of the
      definition of <code>sumList</code>.   In the <code>(x:xs)</code>
      pattern, the <quote><code>:</code></quote> is the familiar list
      constructor, <function>(:)</function>. We are now using it to
      match against a value, not to construct one. The value
      <code>(1:(2:[]))</code> was constructed with <code>(:)</code>,
      so the constructor in the value matches the constructor in the
      pattern.  We say that the pattern <emphasis>matches</emphasis>,
      or that the match <emphasis>succeeds</emphasis>.</para>

    <para id="x_zB1">The variables <varname>x</varname> and <varname>xs</varname>
      are now <quote>bound to</quote> the constructor's arguments, so
      <varname>x</varname> is given the value <code>1</code>, and
      <code>xs</code> the value <code>2:[]</code>.</para>

    <para id="x_lf">The expression we are now evaluating is <code>1 +
	sumList (2:[])</code>.  We must now recursively apply
      <function>sumList</function> to the value <code>2:[]</code>.
      Once again, this was constructed using <code>(:)</code>, so the
      match succeeds.  In our recursive application of
      <function>sumList</function>, <varname>x</varname> is now bound
      to <code>2</code>, and <varname>xs</varname> to
      <code>[]</code>.</para>

    <para id="x_d5">We are now evaluating <code>1 + (2 + sumList
	[])</code>.  In this recursive application of
      <function>sumList</function>, the value we are matching against
      is <code>[]</code>.  The value's constructor does not match the
      constructor in the first pattern, so we skip this equation.
      Instead, we <quote>fall through</quote> to the next pattern,
      which matches.  The right hand side of this equation is thus
      chosen as the result of this application.</para>

    <para id="x_mf">The result of <code>sumList [1,2]</code> is thus
      <code>1 + (2 + (0))</code>, or <code>3</code>.</para>

    <note>
      <title>Ordering is important</title>

      <para id="x_m5">As we have already mentioned, a Haskell
	implementation checks patterns for matches in the order in
	which we specify them in our equations. Matching proceeds from
	top to bottom, and stops at the first success.  Equations
	below a successful match have no effect.</para>
    </note>

    <para id="x_nf">As a final note, there already exists a standard function,
      <function>sum</function>, that performs this sum-of-a-list
      for us.  Our <function>sumList</function> is purely for
      illustration.</para>

    <sect2>
      <title>Construction and deconstruction</title>

      <para id="x_of">Let's step back and take a look at the relationship
	between constructing a value and pattern matching on
	it.</para>

      <para id="x_pf">We apply a value constructor to build a value.
	The expression <code>Book 9 "Close Calls" ["John Long"]</code>
	applies the <function>Book</function> constructor to the
	values <code>9</code>, <code>"Close Calls"</code>, and
	<code>["John Long"]</code> to produce a new value of type
	<type>BookInfo</type>.</para>

      <para id="x_qf">When we pattern match against the
	<function>Book</function> constructor, we
	<emphasis>reverse</emphasis> the construction process.  First
	of all, we check to see if the value was created using that
	constructor. If it was, we inspect it to obtain the individual
	values that we originally supplied to the constructor when we
	created the value.</para>

      <para id="x_rf">Let's consider what happens if we match the pattern
	<code>(Book id name authors)</code> against our example
	expression.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_sf">The match will succeed, because the constructor in the
	    value matches the one in our pattern.</para>
	</listitem>
	<listitem>
	  <para id="x_tf">The variable <varname>id</varname> will be bound to
	    <code>9</code>.</para>
	</listitem>
	<listitem>
	  <para id="x_uf">The variable <varname>name</varname> will be bound to
	    <code>"Close Calls"</code>.</para>
	</listitem>
	<listitem>
	  <para id="x_vf">The variable <varname>authors</varname> will be bound
	    to <code>["John Long"]</code>.</para>
	</listitem>
      </itemizedlist>
      
      <para id="x_wf">Because pattern matching acts as the inverse of
	construction, it's sometimes referred to as
	<emphasis>de</emphasis>construction.</para>

      <note>
	<title>Deconstruction doesn't destroy anything</title>

	<para id="x_xf">If you're steeped in object oriented programming jargon,
	  don't confuse deconstruction with destruction! Matching a
	  pattern has no effect on the value we're examining: it just
	  lets us <quote>look inside</quote> it.</para>
      </note>
    </sect2>

    <sect2>
      <title>Further adventures</title>

      <para id="x_f5">The syntax for pattern matching on a tuple is
	similar to the syntax for constructing a tuple.  Here's a
	function that returns the last element of a 3-tuple.</para>

      &Tuple.hs:third;

      <para id="x_g5">There's no limit on how <quote>deep</quote>
	within a value a pattern can look.  This definition looks both
	inside a tuple and inside a list within that tuple.</para>

      &Tuple.hs:complicated;

      <para id="x_h5">We can try this out interactively.</para>

      &tuple.ghci:complicated;

      <para id="x_i5">Wherever a literal value is present in a pattern
	(<literal>True</literal> and <literal>5</literal> in the tuple
	pattern above), that value must match exactly for the pattern
	match to succeed.  If every pattern within a series of
	equations fails to match, we get a runtime error.</para>

      &tuple.ghci:nomatch;

      <para id="x_yf">For an explanation of this error message, skip forward a
	little, to <xref
	  linkend="deftypes.patterns.nonexhaustive"/>.</para>

      <para id="x_j5">We can pattern match on an algebraic data type
	using its value constructors.  Recall the
	<type>BookInfo</type> type we defined earlier: we
	can extract the values from a <type>BookInfo</type> as follows.</para>

      &BookStore.hs:accessors;

      <para id="x_k5">Let's see it in action.</para>

      &bookstore.ghci:unwrap;

      <para id="x_l5">The compiler can infer the types of the accessor
	functions based on the constructor we're using in our
	pattern.</para>

      &bookstore.ghci:unwrap.types;

      <para id="x_IL">If we use a literal value in a pattern, the
	corresponding part of the value we're matching against must contain
	an identical value. For instance, the pattern <code>(3:xs)</code> first of all
	checks that a value is a non-empty list, by matching against
	the <function>(:)</function> constructor. It also ensures that
	the head of the list has the exact value
	<literal>3</literal>.  If both of these conditions hold, the
	tail of the list will be bound to the variable
	<varname>xs</varname>.</para>
    </sect2>

    <sect2>
      <title>Variable naming in patterns</title>

      <para id="x_zf">As you read functions that match on lists, you'll
	frequently find that the names of the variables inside a
	pattern resemble <code>(x:xs)</code> or <code>(d:ds)</code>.
	This is a popular naming convention. The idea is that the name
	<varname>xs</varname> has an <quote><code>s</code></quote> on
	the end of its name as if it's the <quote>plural</quote> of
	<varname>x</varname>, because <varname>x</varname> contains
	the head of the list, and <varname>xs</varname> the remaining
	elements.</para>
    </sect2>

    <sect2 id="deftypes.wildcard">
      <title>The wild card pattern</title>

      <para id="x_o5">We can indicate that we don't care what  is
	present in part of a pattern. The notation for this is the
	underscore character <quote><code>_</code></quote>, which we
	call a <emphasis>wild card</emphasis>.  We use it as
	follows.</para>

      &BookStore.hs:niceAccessors;

      <para id="x_p5">Here, we have tidier versions of the
	accessor functions we introduced earlier.  Now, there's no
	question about which element we're using in each
	function.</para>

      <para id="x_KL">In a pattern, a wild card acts similarly to a
	variable, but it doesn't bind a new variable.  As the examples
	above indicate, we can use more than one wild card in a single
	pattern.</para>

      <para id="x_LL">Another advantage of wild cards is that a
	Haskell compiler can warn us if we introduce a variable name
	in a pattern, but do not use it in a function's body. Defining
	a variable, but forgetting to use it, can often indicate the
	presence of a bug, so this is a helpful feature. If we use a
	wild card instead of a variable that we do not intend to use,
	the compiler won't complain.</para>
    </sect2>

    <sect2 id="deftypes.patterns.nonexhaustive">
      <title>Exhaustive patterns and wild cards</title>

      <para id="x_Ag">When writing a series of patterns, it's important to cover
	all of a type's constructors.  For example, if we're
	inspecting a list, we should have one equation that matches
	the non-empty constructor <function>(:)</function>, and one
	that matches the empty-list constructor
	<function>[]</function>.</para>

      <para id="x_Bg">Let's see what happens if we fail to cover all
	the cases. Here, we deliberately omit a check for the
	<function>[]</function> constructor.</para>

      &BadPattern.hs:badExample;

      <para id="x_Cg">If we apply this to a value that it cannot match, we'll
	get an error at runtime: our software has a bug!</para>

      &badpattern.ghci:error;

      <para id="x_Dg">In this example, no equation in the function's
	definition matches the value <code>[]</code>.</para>

      <tip>
	<title>Warning about incomplete patterns</title>

	<para id="x_Eg">&GHC; provides a helpful compilation option,
	  <option>-fwarn-incomplete-patterns</option>, that will cause
	  it to print a warning during compilation if a sequence of
	  patterns don't match all of a type's value constructors.</para>
      </tip>

      <para id="x_Fg">If we need to provide a default behavior in cases where
	we don't care about specific constructors, we can use a wild
	card pattern.</para>

      &BadPattern.hs:goodExample;

      <para id="x_Gg">The wild card above will match the <code>[]</code>
	constructor, so applying this function does not lead to a
	crash.</para>

      &badpattern.ghci:ok;

    </sect2>
  </sect1>

  <sect1 id="deftypes.record">
    <title>Record syntax</title>

    <para id="x_Hg">Writing accessor functions for each of a data type's
      components can be repetitive and tedious.</para>

    &BookStore.hs:niceAccessors.noid;

    <para id="x_Ig">We call this kind of code <emphasis>boilerplate</emphasis>:
      necessary, but bulky and irksome.  Haskell programmers don't
      like boilerplate.  Fortunately, the language addresses this
      particular boilerplate problem: we can define a data type, and
      accessors for each of its components, simultaneously.  (The
      positions of the commas here is a matter of preference.  If you
      like, put them at the end of a line instead of the beginning.)</para>

    &BookStore.hs:Customer;

    <para id="x_Jg">This is almost exactly identical in meaning to the
      following, more familiar form.</para>

    &AltCustomer.hs:Customer;
    
    <para id="x_Kg">For each of the fields that we name in our type definition,
      Haskell creates an accessor function of that name.</para>

    &bookstore.ghci:accessor.type;

    <para id="x_Lg">We can still use the usual application syntax to create a
      value of this type.</para>

    &BookStore.hs:customer1;

    <para id="x_Mg">Record syntax adds a more verbose notation for creating a
      value.  This can sometimes make code more readable.</para>

    &BookStore.hs:customer2;

    <para id="x_AC1">If we use this form, we can vary the order in which we list
      fields.  Here, we have moved the name and address fields
      from their positions in the declaration of the type.</para>

    <para id="x_Ng">When we define a type using record syntax, it also
      changes the way the type's values are printed.</para>

    &bookstore.ghci:customer1;

    <para id="x_Og">For comparison, let's look at a
      <type>BookInfo</type> value; we defined this type without record
      syntax.</para>

    &bookstore.ghci:cities;

    <para id="x_Pg">The accessor functions that we get <quote>for free</quote>
      when we use record syntax really are normal Haskell
      functions.</para>

    &bookstore.ghci:accessor;

    <para id="x_Bn">
      The standard <literal>System.Time</literal> module makes good
      use of record syntax.  Here's a type defined in that module:
    </para>
    <programlisting>
data CalendarTime = CalendarTime {
  ctYear                      :: Int,
  ctMonth                     :: Month,
  ctDay, ctHour, ctMin, ctSec :: Int,
  ctPicosec                   :: Integer,
  ctWDay                      :: Day,
  ctYDay                      :: Int,
  ctTZName                    :: String,
  ctTZ                        :: Int,
  ctIsDST                     :: Bool
}
    </programlisting>
    <para id="x_Cn">
      In the absence of record syntax, it would be painful
      to extract specific fields from a type like this.  The notation
      makes it easier to work with large structures.
    </para>
  </sect1>

  <sect1 id="deftypes.paramtypes">
    <title>Parameterised types</title>

    <para id="x_Z4">We've repeatedly mentioned that the list type is
      polymorphic: the elements of a list can be of any type.  We can
      also add polymorphism to our own types. To do this, we introduce
      type variables into a type declaration.  The Prelude defines a
      type named <type>Maybe</type>: we can use this to represent a
      value that could be either present or missing, e.g. a field in a
      database row that could be null.</para>

    &Nullable.hs:Nullable;

    <para id="x_a4">Here, the variable <varname
	role="type">a</varname> is not a regular variable: it's a type
      variable.  It indicates that the <type>Maybe</type> type takes
      another type as its parameter.  This lets us use
      <type>Maybe</type> on values of any type.</para>

    &Nullable.hs:wrappedTypes;

    <para id="x_b4">As usual, we can experiment with this type in
      &ghci;.</para>

    &nullable.ghci:experiment;

    <para id="x_c4"><type>Maybe</type> is a polymorphic, or generic,
      type.  We give the <type>Maybe</type> type constructor a
      parameter to create a specific type, such as <type>Maybe
	Int</type> or <type>Maybe [Bool]</type>.  As we might expect,
      these types are distinct.</para>

    <para id="x_e4">We can nest uses of parameterised types inside
      each other, but when we do, we may need to use parentheses to
      tell the Haskell compiler how to parse our expression.</para>

    &Nullable.hs:parens;

    <para id="x_d4">To once again extend an analogy to more familiar
      languages, parameterised types bear some resemblance to
      templates in C++, and to generics in Java. Just be aware that
      this is a shallow analogy.  Templates and generics were added to
      their respective languages long after the languages were
      initially defined, and have an awkward feel. Haskell's
      parameterised types are simpler and easier to use, as the
      language was designed with them from the beginning.</para>
  </sect1>

  <sect1 id="deftypes.recursive">
    <title>Recursive types</title>

    <para id="x_Rg">The familiar list type is <emphasis>recursive</emphasis>:
      it's defined in terms of itself.  To understand this,
      let's create our own list-like type.  We'll use
      <code>Cons</code> in place of the <function>(:)</function>
      constructor, and <code>Nil</code> in place of
      <code>[]</code>.</para>

    &ListADT.hs:List;

    <para id="x_Sg">Because <type>List a</type> appears on both the
      left and the right of the <code>=</code> sign, the type's
      definition refers to itself.  If we want to use the
      <code>Cons</code> constructor to create a new value, we must
      supply one value of type <varname role="type">a</varname>, and
      another of type <varname role="type">List a</varname>. Let's see
      where this leads us in practice.</para>

    <para id="x_Tg">The simplest value of type <type>List a</type>
      that we can create is <code>Nil</code>.  Save the type
      definition in a file, then load it into &ghci;.</para>

    &listadt.ghci:empty;

    <para id="x_Ug">Because <code>Nil</code> has a <type>List</type>
      type, we can use it as a parameter to <code>Cons</code>.</para>

    &listadt.ghci:tiny;

    <para id="x_Vg">And because <code>Cons 0 Nil</code> has the type <type>List
	a</type>, we can use this as a parameter to
      <code>Cons</code>.</para>

    &listadt.ghci:two;

    <para id="x_Wg">We could continue in this fashion indefinitely,
      creating ever longer <code>Cons</code> chains, each with a
      single <code>Nil</code> at the end.</para>
    
    <tip>
      <title>Is List an acceptable list?</title>

      <para id="x_Xg">We can easily prove to ourselves that our <type>List
	  a</type> type has the same shape as the built-in list type
	<type>[a]</type>.  To do this, we write a function that
	takes any value of type <type>[a]</type>, and produces a
	value of type <type>List a</type>.</para>

      &ListADT.hs:fromList;

      <para id="x_Yg">By inspection, this clearly substitutes a
	<code>Cons</code> for every <function>(:)</function>, and a
	<code>Nil</code> for each <code>[]</code>.  This covers both
	of the built-in list type's constructors.  The two types are
	<emphasis>isomorphic</emphasis>; they have the same
	shape.</para>

      &listadt.ghci:fromList;
    </tip>

    <para id="x_K5">For a third example of what a recursive type
      is, here is a definition of a binary tree type.</para>

    &Tree.hs:Tree;

    <para id="x_BC1">A binary tree is either a node with two children, which are
      themselves binary trees, or an empty value.</para>

    <para id="x_Zg">This time, let's search for insight by comparing our
      definition with one from a more familiar language.  Here's a
      similar class definition in Java.</para>

    &Tree.java:Tree;

    <para id="x_ag">The one significant difference is that Java lets us use the
      special value <code>null</code> anywhere to indicate
      <quote>nothing</quote>, so we can use <code>null</code> to
      indicate that a node is missing a left or right child.  Here's a
      small function that constructs a tree with two leaves (a leaf,
      by convention, has no children).</para>

    &Tree.java:Example;

    <para id="x_bg">In Haskell, we don't have an equivalent of
      <code>null</code>. We could use the <type>Maybe</type> type to
      provide a similar effect, but that bloats the pattern matching.
      Instead, we've decided to use a no-argument <code>Empty</code>
      constructor.  Where the Java example provides <code>null</code>
      to the <type>Tree</type> constructor, we supply
      <code>Empty</code> in Haskell.</para>

    &Tree.hs:simpleTree;

    <sect2>
      <title>Exercises</title>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_cg">Write the converse of <function>fromList</function>
	      for the <type>List</type> type: a function that takes a
	      <type>List a</type> and generates a
	      <type>[a]</type>.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para id="x_dg">Define a tree type that has only one constructor,
	      like our Java example.  Instead of the
	      <code>Empty</code> constructor, use the
	      <type>Maybe</type> type to refer to a node's
	      children.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="deftypes.error">
    <title>Reporting errors</title>

    <para id="x_w3">Haskell provides a standard function,
      <function>error :: String -&gt; a</function>, that we can call
      when something has gone terribly wrong in our code.  We give it
      a string parameter, which is the error message to display. Its
      type signature looks peculiar: how can it produce a value of any
      type <varname role="type">a</varname> given only a string?</para>

    <para id="x_x3">It has a result type of <varname
	role="type">a</varname> so that we can call it anywhere and it
      will always have the right type.   However, it does not return a
      value like a normal function: instead, it <emphasis>immediately
	aborts evaluation</emphasis>, and prints the error message we
      give it.</para>

    <para id="x_eg">The <function>mySecond</function> function returns
      the second element of its input list, but fails if its input
      list isn't long enough.</para>

    &MySecond.hs:mySecond;

    <para id="x_y3">As usual, we can see how this works in practice in
      &ghci;.</para>

    &error.ghci:mySecond;

    <para id="x_z3">Notice the third case above, where we
      try to use the result of the call to
      <function>mySecond</function> as the argument to another
      function.  Evaluation still terminates and drops us back to the
      &ghci; prompt.  This is the major weakness of using
      <function>error</function>: it doesn't let our caller
      distinguish between a recoverable error and a problem so severe
      that it really should terminate our program.</para>

    <para id="x_CC1">As we have already seen, a pattern matching failure causes a
      similar unrecoverable error.</para>

    &error.ghci:myError;

    <sect2 id="deftypes.morecontrolled">
      <title>A more controlled approach</title>

      <para id="x_fg">We can use the <type>Maybe</type> type
	to represent the possibility of an error.</para>

      <para id="x_gg">If we want to indicate that an operation has
	failed, we can use the <function>Nothing</function>
	constructor.  Otherwise, we wrap our value with the
	<function>Just</function> constructor.</para>

      <para id="x_hg">Let's see how our <function>mySecond</function> function
	changes if we return a <type>Maybe</type> value instead of
	calling <function>error</function>.</para>

      &MySecond.hs:safeSecond;

      <para id="x_ig">If the list we're passed is too short, we return
	<code>Nothing</code> to our caller. This lets them decide what
	to do, where a call to <function>error</function> would force
	a crash.</para>

      &error.ghci:safeSecond;

      <para id="x_jg">To return to an earlier topic, we can further
	improve the readability of this function with pattern
	matching.</para>

      &MySecond.hs:tidySecond;

      <para id="x_kg">The first pattern only matches if the list is at least two
	elements long (it contains two list constructors), and it
	binds the variable <varname>x</varname> to the list's second
	element. The second pattern is matched if the first
	fails.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.locals">
    <title>Introducing local variables</title>

    <para id="x_f4">Within the body of a function, we can introduce
      new local variables whenever we need them, using a &let;
      expression.  Here is a simple function that determines whether
      we should lend some money to a customer.  We meet a money
      reserve of at least 100, we return our new balance after
      subtracting the amount we have loaned.</para>

    &Lending.hs:lend;

    <para id="x_g4">The keywords to look out for here are &let;, which
      starts a block of variable declarations, and <code>in</code>,
      which ends it.  Each line introduces a new variable.  The name
      is on the left of the <literal>=</literal>, and the expression
      to which it is bound is on the right.</para>

    <note>
      <title>Special notes</title>

      <para id="x_ng">Let us re-emphasise our wording: a name in a
	&let; block is bound to an <emphasis>expression</emphasis>,
	not to a <emphasis>value</emphasis>.  Because Haskell is a
	lazy language, the expression associated with a name won't
	actually be evaluated until it's needed.  In the above example,
	we will not compute the value of <varname>newBalance</varname>
	if we do not meet our reserve.</para>

      <para id="x_og">When we define a variable in a &let; block, we
	refer to it as a <emphasis>&let;-bound</emphasis> variable.
	This simply means what it says: we have bound the variable in
	a &let; block.</para>

      <para id="x_pg">Also, our use of white space here is important.
	We'll talk in more detail about the layout rules in <xref
	  linkend="deftypes.offside"/>.</para>
    </note>

    <para id="x_qg">We can use the names of a variable in a &let;
      block both within the block of declarations and in the
      expression that follows the <code>in</code> keyword.</para>

    <para id="x_rg">In general, we'll refer to the places within our
      code where we can use a name as the name's
      <emphasis>scope</emphasis>.  If we can use a name, it's
      <emphasis>in scope</emphasis>, otherwise it's <emphasis>out of
	scope</emphasis>.  If a name is visible throughout a source
      file, we say it's at the <emphasis>top level</emphasis>.</para>

    <sect2>
      <title>Shadowing</title>

      <para id="x_i4">We can <quote>nest</quote> multiple &let; blocks
	inside each other in an expression.</para>

      &NestedLets.hs:foo;

      <para id="x_yg">It's perfectly legal, but not exactly wise, to
	repeat a variable name in a nested &let; expression.</para>

      &NestedLets.hs:bar;

      <para id="x_zg">Here, the inner <varname>x</varname> is hiding,
	or <emphasis>shadowing</emphasis>, the outer
	<varname>x</varname>.  It has the same name, but a different
	type and value.</para>

      &nestedlets.ghci:bar;

      <para id="x_Ah">We can also shadow a function's parameters,
	leading to even stranger results.  What is the type of this
	function?</para>

      &NestedLets.hs:quux;

      <para id="x_Bh">Because the function's argument
	<varname>a</varname> is never used in the body of the
	function, due to being shadowed by the &let;-bound
	<varname>a</varname>, the argument can have any type at
	all.</para>

      &nestedlets.ghci:quux;

      <tip>
	<title>Compiler warnings are your friends</title>

	<para id="x_Ch">Shadowing can obviously lead to confusion and
	  nasty bugs, so &GHC; has a helpful
	  <option>-fwarn-name-shadowing</option> option.  When
	  enabled, &GHC; will print a warning message any time we
	  shadow a name.</para>
      </tip>
    </sect2>

    <sect2>
      <title>The where clause</title>

      <para id="x_Dh">We can use another mechanism to
	introduce local variables: the &where; clause. The
	definitions in a &where; clause apply to the code that
	<emphasis>precedes</emphasis> it.  Here's a similar function
	to <function>lend</function>, using &where; instead of &let;.</para>

      &Lending.hs:lend2;

      <para id="x_Fh">While a &where; clause may initially seem weird,
	it offers a wonderful aid to readability.  It lets us direct
	our reader's focus to the important details of an expression,
	with the supporting definitions following afterwards.  After a
	while, you may find yourself missing &where; clauses in
	languages that lack them.</para>

      <para id="x_l4">As with &let; expressions, white space is
	significant in &where; clauses.  We will talk more about
	the layout rules shortly, in <xref
	  linkend="deftypes.offside"/>.</para>
    </sect2>

    <sect2 id="deftypes.locals.functions">
      <title>Local functions, global variables</title>

      <para id="x_FL">You'll have noticed that Haskell's syntax for
	defining a variable looks very similar to its syntax for
	defining a function.  This symmetry is preserved in &let; and
	&where; blocks: we can define local
	<emphasis>functions</emphasis> just as easily as local
	<emphasis>variables</emphasis>.</para>

      &LocalFunction.hs:pluralise;

      <para id="x_GL">We have defined a local function,
	<function>plural</function>, that consists of several
	equations. Local functions can freely use variables from the
	scopes that enclose them: here, we use <varname>word</varname>
	from the definition of the outer function
	<function>pluralise</function>.  In the definition of
	<function>pluralise</function>, the <function>map</function>
	function (which we'll be revisiting in the next chapter)
	applies the local function <function>plural</function> to
	every element of the <varname>counts</varname> list.</para>

      <para id="x_Gh">We can also define variables, as well as
	functions, at the top level of a source file.</para>

      &GlobalVariable.hs:itemName;
    </sect2>
  </sect1>

  <sect1 id="deftypes.offside">
    <title>The offside rule and white space in an expression</title>

    <para id="x_u4">In our definitions of <function>lend</function>
      and <function>lend2</function>, the left margin of our text
      wandered around quite a bit.  This was not an accident: in
      Haskell, white space has meaning.</para>

    <para id="x_v4">Haskell uses indentation as a cue to parse
      sections of code. This use of layout to convey structure is
      sometimes called the <emphasis>offside rule</emphasis>. At the
      beginning of a source file, the first top level declaration or definition
      can start in any column, and the Haskell compiler or interpreter
      remembers that indentation level.  Every subsequent top level
      declaration must have the same indentation.</para>

    <para id="x_w4">Here's an illustration of the top level
      indentation rule. Our first file,
      <filename>GoodIndent.hs</filename>, is well behaved.</para>

    &GoodIndent.hs:good;

    <para id="x_x4">Our second, <filename>BadIndent.hs</filename>, doesn't play
      by the rules.</para>

    &BadIndent.hs:bad;

    <para id="x_y4">Here's what happens when we try to load the two files into
      &ghci;.</para>

    &indent.ghci:load;

    <para id="x_z4">An empty following line is treated as a
      continuation of the current item, as is a following line
      indented further to the right.</para>

    <para id="x_A5">The rules for &let; expressions and &where;
      clauses are similar.  After a &let; or &where; keyword, the
      Haskell compiler or interpreter remembers the indentation of the
      next token it sees. If the line that follows is empty, or its
      indentation is further to the right, it is considered to
      continue the previous line. If the indentation is the same as
      the start of the preceding item, this is treated as beginning a
      new item in the same block.</para>

    &Indentation.hs:foo;

    <para id="x_B5">Here are nested uses of &let; and
      &where;.</para>

    &letwhere.hs:let;

    <para id="x_C5">The name <varname>a</varname> is only visible
      within the inner &let; expression.  It's not visible
      in the outer &let;.  If we try to use the name
      <varname>a</varname> there, we'll get a compilation
      error.  The indentation gives both us and the compiler a visual
      cue as to what is currently in scope.</para>

    &letwhere.hs:where;

    <para id="x_D5">Similarly, the scope of the first &where; clause
      is the definition of <varname>foo</varname>, but the scope of
      the second is just the first &where; clause.</para>

    <para id="x_E5">The indentation we use for the &let; and
      &where; clauses makes our intentions easy to figure
      out.</para>

    <sect2 id="deftypes.tabs">
      <title>A note about tabs versus spaces</title>

      <para id="x_F5">If you use a Haskell-aware text editor (e.g. Emacs),
	it is probably already configured to use space characters for
	all white space when you edit Haskell source files.  If your editor is
	<emphasis>not</emphasis> Haskell-aware, you should configure
	it to only use space characters.</para>

      <para id="x_G5">The reason for this is portability.  In an editor
	that uses a fixed-width font, tab stops are by convention placed
	at different intervals on Unix-like systems (every eight
	characters) than on Windows (every four characters). This
	means that no matter what your personal beliefs are about
	where tabs belong, you can't rely on someone else's editor
	honouring your preferences.  Any indentation that uses tabs is
	going to look broken under <emphasis>someone's</emphasis>
	configuration.  In fact, this could lead to compilation
	problems, as the Haskell language standard requires
	implementations to use the Unix tab width convention.
	Using space characters avoids this problem
	entirely.</para>
    </sect2>

    <sect2 id="deftypes.block">
      <title>The offside rule is not mandatory</title>

      <para id="x_H5">We can use explicit structuring instead of layout to
	indicate what we mean.  To do so, we start a block of
	equations with an opening curly brace; separate each item with
	a semicolon; and finish the block with a closing curly brace.
	The following two uses of &let; have the same
	meanings.</para>

      &Braces.hs:braces;

      <para id="x_I5">When we use explicit structuring, the normal layout rules
	don't apply, which is why we can get away with unusual
	indentation in the second &let; expression.</para>

      <para id="x_J5">We can use explicit structuring anywhere that we'd
	normally use layout.  It's valid for &where;
	clauses, and even top-level declarations.  Just remember that
	although the facility exists, explicit structuring is hardly
	ever actually <emphasis>used</emphasis> in Haskell
	programs.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.case">
    <title>The case expression</title>

    <para id="x_q5">Function definitions are not the only place where
      we can use pattern matching.  The &case; construct lets us match
      patterns within an expression.  Here's what it looks like.  This
      function (defined for us in <code>Data.Maybe</code>) unwraps a
      <type>Maybe</type> value, using a default if the value is
      <code>Nothing</code>.</para>

    &Guard.hs:fromMaybe;

    <para id="x_r5">The <code>case</code> keyword is followed by an
      arbitrary expression: the pattern match is performed against the
      result of this expression. The <code>of</code> keyword signifies
      the end of the expression and the beginning of the block of
      patterns and expressions.</para>

    <para id="x_s5">Each item in the block consists of a pattern,
      followed by an arrow <code>-&gt;</code>, followed by an
      expression to evaluate if that pattern matches.  These
      expressions must all have the same type.  The result of the
      <code>case</code> expression is the result of the expression
      associated with the first pattern to match.  Matches are
      attempted from top to bottom.</para>

    <para id="x_t5">To express <quote>here's the expression to
	evaluate if none of the other patterns match</quote>, we just
      use the wild card pattern <code>_</code> as the last in our list
      of patterns.  If a pattern match fails, we will get the same
      kind of runtime error as we saw earlier.</para>
  </sect1>
  
  <sect1 id="deftypes.pattern.limits">
    <title>Common beginner mistakes with patterns</title>

    <para id="x_NL">There are a few ways in which new Haskell
      programmers can misunderstand or misuse patterns.  Here are some
      attempts at pattern matching gone awry.  Depending on what you
      expect one of these examples to do, it might contain a
      surprise.</para>

    <sect2>
      <title>Incorrectly matching against a variable</title>

      &BogusPattern.hs:whichFruit;

      <para id="x_w5">A naive glance suggests that this code is trying
	to check the value <function>f</function> to see whether it
	matches the value <varname>apple</varname> or
	<varname>orange</varname>.</para>

      <para id="x_DC1">It is easier to spot the mistake if we rewrite
	the code in an equational style.</para>

      &BogusPattern.hs:equational;

      <para id="x_EC1">Now can you see the problem?  Here, it is more obvious
	<varname>apple</varname> does not refer to the top level value
	named <varname>apple</varname>: it is a local pattern
	variable.</para>
      <note>
	<title>Irrefutable patterns</title>

	<para id="x_y5">We refer to a pattern that always succeeds as
	  <emphasis>irrefutable</emphasis>.  Plain variable names and
	  the wild card <code>_</code> are examples of irrefutable
	  patterns.</para>
      </note>

      <para id="x_Ih">Here's a corrected version of this function.</para>

      &BogusPattern.hs:betterFruit;

      <para id="x_Jh">We fixed the problem by matching against the
	literal values <code>"apple"</code> and
	<code>"orange"</code>.</para>
    </sect2>

    <sect2>
      <title>Incorrectly trying to compare for equality</title>

      <para id="x_Kh">What if we want to compare the values stored in
	two nodes of type <type>Tree</type>, and return one of them if
	they're equal?  Here's an attempt.</para>

      &BadTree.hs:bad_nodesAreSame;
    
      <para id="x_A6">A name can only appear once in a set of pattern
	bindings. We cannot place a variable in multiple positions to
	express the notion <quote>this value and that should be
	  identical</quote>.  Instead, we'll solve this problem using
	<emphasis>guards</emphasis>, another invaluable Haskell
	feature.</para>
    </sect2>
  </sect1>

  <sect1 id="deftypes.guard">
    <title>Conditional evaluation with guards</title>

    <para id="x_C6">Pattern matching limites us to performing fixed
      tests of a value's shape.  Although this is useful, we will
      often want to make a more expressive check before evaluating a
      function's body.  Haskell provides a feature,
      <emphasis>guards</emphasis>, that give us this ability.  We'll
      introduce the idea with a modification of the function we wrote
      to compare two nodes of a tree.</para>

    &BadTree.hs:nodesAreSame;

    <para id="x_FC1">In this example, we use pattern matching to ensure that we
      are looking at values of the right shape, and a guard to compare
      pieces of them.</para>

    <para id="x_Lh">A pattern can be followed by zero or more guards,
      each an expression of type <type>Bool</type>.  A guard is
      introduced by a <code>|</code> symbol.  This is followed by the
      guard expression, then an <code>=</code> symbol (or
      <code>-&gt;</code> if we're in a &case; expression), then the
      body to use if the guard expression evaluates to
      <code>True</code>. If a pattern matches, each guard associated
      with that pattern is evaluated, in the order in which they are
      written.  If a guard succeeds, the body affiliated with it is
      used as the result of the function.  If no guard succeeds,
      pattern matching moves on to the next pattern.</para>

    <para id="x_Mh">When a guard expression is evaluated, all of the
      variables mentioned in the pattern with which it is associated
      are bound and can be used.</para>

    <para id="x_GC1">Here is a reworked version of our <function>lend</function>
      function that uses guards.</para>

    &Lending.hs:lend3;

    <para id="x_HC1">The special-looking guard expression
      <varname>otherwise</varname> is simply a variable bound to the
      value <code>True</code>, to aid readability.</para>

    <para id="x_F6">We can use guards anywhere that we can use
      patterns.  Writing a function as a series of equations using
      pattern matching and guards can make it much clearer. Remember
      the <function>myDrop</function> function we defined in
      <xref linkend="funcstypes.if"/>?</para>

    &myDrop.hs:myDrop1;

    <para id="x_H6">Here is a reformulation that uses patterns and
      guards.</para>

    &myDrop.hs:niceDrop;

    <para id="x_Oh">This change in style lets us enumerate <emphasis>up
	front</emphasis> the cases in which we expect a function to
      behave differently. If we bury the decisions inside a function
      as &if; expressions, the code becomes harder to read.</para>
  </sect1>

  <sect1>
    <title>Exercises</title>

    <qandaset defaultlabel="number">
      <qandaentry>
	<question>
	  <para id="x_IC1">Write a function that computes the number of elements
	    in a list.  To test it, ensure that it gives the same
	    answers as the standard <function>length</function>
	    function.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_JC1">Add a type signature for your function to your source
	    file.  To test it, load the source file into &ghci;
	    again.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_KC1">Write a function that computes the mean of a list,
	    i.e. the sum of all elements in the list divided by its
	    length.  (You may need to use the
	    <function>fromIntegral</function> function to convert the
	    length of the list from an integer into a floating point
	    number.)</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_LC1">Turn a list into a palindrome, i.e. it should read the
	    same both backwards and forwards.  For example, given the
	    list <code>[1,2,3]</code>, your function should return
	    <code>[1,2,3,3,2,1]</code>.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_MC1">Write a function that determines whether its input
	    list is a palindrome.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_NC1">Create a function that sorts a list of lists based on
	    the length of each sublist.  (You may want to look at the
	    <function>sortBy</function> function from the
	    <code>Data.List</code> module.)</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_OC1">Define a function that joins a list of lists together
	    using a separator value.</para>

	  &Intersperse.hs:intersperse;

	  <para id="x_PC1">The separator should appear between elements of the
	    list, but should not follow the last element.  Your
	    function should behave as follows.</para>

	  &intersperse.ghci:intersperse;

	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_QC1">Using the binary tree type that we defined earlier in
	    this chapter, write a function that will determine the
	    height of the tree.  The height is the largest number of
	    hops from the root to an <code>Empty</code>. For example,
	    the tree <code>Empty</code> has height zero; <code>Node
	      "x" Empty Empty</code> has height one; <code>Node "x"
	      Empty (Node "y" Empty Empty)</code> has height two; and
	    so on.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_RC1">Consider three two-dimensional points
	    <emphasis>a</emphasis>, <emphasis>b</emphasis>, and
	    <emphasis>c</emphasis>.  If we look at the angle formed by
	    the line segment from <emphasis>a</emphasis> to
	    <emphasis>b</emphasis> and the line segment from
	    <emphasis>b</emphasis> to <emphasis>c</emphasis>, it
	    either turns left, turns right, or forms a straight line.
	    Define a <type>Direction</type> data type that lets you
	    represent these possibilities.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_SC1">Write a function that calculates the turn made by
	    three 2D points and returns a <type>Direction</type>.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_TC1">Define a function that takes a list of 2D points and
	    computes the direction of each successive triple.  Given
	    a list of points <code>[a,b,c,d,e]</code>, it should begin
	    by computing the turn made by <code>[a,b,c]</code>, then
	    the turn made by <code>[b,c,d]</code>, then
	    <code>[c,d,e]</code>.  Your function should return a list
	    of <type>Direction</type>.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_UC1">Using the code from the preceding three exercises,
	    implement Graham's scan algorithm for the convex hull of a
	    set of 2D points. You can find good description of what a
	    <ulink
	      url="http://en.wikipedia.org/wiki/Convex_hull">convex
	      hull</ulink>. is, and how the <ulink
	      url="http://en.wikipedia.org/wiki/Graham_scan">Graham
	      scan algorithm</ulink> should work, on <ulink
	      url="http://en.wikipedia.org/">Wikipedia</ulink>.</para>
	</question>
      </qandaentry>
    </qandaset>
  </sect1>
</chapter>
<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
