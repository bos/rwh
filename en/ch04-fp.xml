<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.fp">
  <title>Functional programming</title>

  <sect1>
    <title>How to think about loops</title>

    <para>Unlike traditional languages, Haskell has neither a
      <code>for</code> loop nor a <code>while</code> loop.  If we've
      got a lot of data to process, what do we use instead?  There are
      several possible answers to this question, so let's build up a
      toolbox of answers.</para>

    <sect2>
      <title>Transforming every piece of input</title>

      <para>Consider the C function <function>square</function>, which
	squares every element in an array.</para>

      &map.c:square;

      <para>This contains a straightforward and common kind of loop,
	one that does exactly the same thing to every element of its
	input array.  How might we write this loop in Haskell?</para>

      &Map.hs:square;

      <para>Our <function>square</function> function consists of two
	pattern matching equations.  The first
	<quote>deconstructs</quote> the beginning of a non-empty list,
	to get its head and tail.  It squares the first element, then
	puts that on the front of a new list, which is constructed by
	calling <function>square</function> on the remainder of the
	empty list.   The second equations ensures that
	<function>square</function> halts when it reaches the end of
	the input list.</para>

      <para>The effect of <function>square</function> is to construct
	a new list that's the same length as its input list, with
	every element in the input list substituted with its square in
	the output list.</para>

      <para>Here's another such C loop, one that ensures that every
	letter in a string is converted to uppercase.</para>

      &map.c:uppercase;

      <para>Let's look at a Haskell equivalent.</para>

      &Map.hs:upperCase;

      <para>Here, we're importing the <function>toUpper</function>
	function from the standard <code>Data.Char</code> module,
	which contains lots of useful functions for working with
	<type>Char</type> data.</para>

      <para>Our <function>upperCase</function> function follows a
	similar pattern to our earlier <function>square</function>
	function.  It terminates with an empty list when the input
	list is empty; and when the input isn't empty, it calls
	<function>toUpper</function> on the first element, then
	constructs a new list cell from that and the result of calling
	itself on the rest of the input list.</para>

      <para>These examples follow a common pattern for writing
	recursive functions over lists in Haskell.  The <emphasis>base
	  case</emphasis> handles the situation where our input list
	is empty.  The <emphasis>recursive case</emphasis> deals with
	a non-empty list; it does something with the head of the list,
	and calls itself recursively on the tail.</para>
    </sect2>

    <sect2>
      <title>Mapping over a list</title>

      <para>The <function>square</function> and
	<function>upperCase</function> functions that we just defined
	produce new lists that are the same lengths as their input
	lists, and do only one piece of work per element.  This is
	such a common pattern that Haskell's prelude defines a
	function, <function>map</function>, to make it easier.
	<function>map</function> takes a function, and applies it to
	every element of a list, returning a new list constructed from
	the results of these applications.</para>

      <para>Here are our <function>square</function> and
	<function>upperCase</function> functions rewritten to use
	<function>map</function>.</para>

      &Map.hs:map2;

      <para>This is our first time seeing a function that takes
	another function as its argument.  We can learn a lot about
	what <function>map</function> does by simply inspecting its
	type.</para>

      &ch04.map.ghci:type;

      <para>The signature tells us that <function>map</function> takes
	two arguments.  The first is a function that takes a value of
	one type, <varname role="type">a</varname>, and returns a
	value of another type, <varname role="type">b</varname>.  This
	is the only unfamiliar piece of notation in the type; notice
	the parentheses that surround the signature of the function
	argument so we (and Haskell) won't misread it.</para>

      <para>Since <function>map</function> takes a function as
	argument, we refer to it as a
	<emphasis>higher-order</emphasis> function.  (In spite of the
	name, there's nothing mysterious about higher-order
	functions; it's just a term for functions that take other
	functions as arguments, or return functions.)</para>

      <para>Since <function>map</function> abstracts out the pattern
	common to our <function>square</function> and
	<function>upperCase</function> functions so that we can reuse
	it with less boilerplate, we can look at what those functions
	have in common and figure out how to implement it
	ourselves.</para>

      &Map.hs:myMap;

      <para>We try out our <function>myMap</function> function to give
      outselves some assurance that it behaves similarly to the
	standard <function>map</function>.</para>

      &ch04.map.ghci:inuse;

      <para>This business of seeing that we're repeating an idiom,
	then abstracting it so we can reuse (and write less!) code, is
	a common aspect of Haskell programming.</para>
    </sect2>

    <sect2 id="hs.fp.filter">
      <title>Selecting pieces of input</title>

      <para>Another common operation on a sequence of data is to comb
	through it for elements that satisfy some criterion.  Here's
	an example in C++ of a function that walks a linked list of
	numbers and returns those that are odd.</para>

      &filter.cpp:oddList;

      <para>Our Haskell equivalent has a recursive case that's a bit
	more complex than our earlier functions: it only puts a number
	in the list it returns if the number is odd.  Using a guard
	expresses this nicely.</para>

      &Filter.hs:oddList;

      <para>Let's see that in action.</para>

      &ch04.filter.ghci:oddList;

      <para>Once again, this idiom is so common that Haskell's prelude
	defines a function, <function>filter</function>, which removes
	the need for boilerplate code to recurse over the list.</para>

      &ch04.filter.ghci:filter;

      <para>The <function>filter</function> function takes a predicate
	(a function that tests an argument and returns a
	<type>Bool</type>) and applies it to every element in its
	input list, returning a list of only those for which the
	predicate evaluates to <code>True</code>.</para>

      <para>We'll be discussing <function>filter</function> again
	soon, in <xref linkend="hs.fp.foldr.filter"/>.</para>
    </sect2>

    <sect2>
      <title>Computing one answer over a collection</title>

      <para>Another common thing to do with a loop is to <quote>fold
	  it up</quote>.  A simple example of this is summing the
	values of a list.</para>

      &Sum.hs:mySum;

      <para>Our <function>helper</function> function is tail
	recursive, and uses an <emphasis>accumulator</emphasis>
	parameter, <varname>acc</varname>, to hold the current partial
	sum of the list.  This is a <quote>natural</quote> way to
	represent a loop in a pure functional language.</para>

      <para>For something a little more complicated, let's take a look
	at the Adler-32 checksum. Here's a Java implementation.</para>

      &Adler32.java:Adler32;

      <para>Although Adler-32 is a simple checksum, this code isn't
	particularly easy to read on account of the bit-twiddling
	involved.  Can we do any better with a Haskell
	implementation?</para>

      &Adler32.hs:adler32;

      <para>This isn't exactly easier to follow than the Java code,
	but let's look at what's going on.  Once again,
	<function>helper</function> function is tail recursive.  We've
	turned the two variables we updated on every loop iteration in
	Java into accumulator parameters.  When our recursion
	terminates on the end of the input list, we compute our
	checksum and return it.</para>

      <para>If we take a step back, we can restructure our Haskell
	<function>adler32</function> to more closely resemble our
	earlier <function>mySum</function> function.  Instead of two
	accumulator parameters, we can use a single accumulator that's
	a two-tuple.</para>

      &Adler32.hs:adler32_try2;

      <para>Why would we want to make this seemingly meaningless
	structural change?  Because as we've already seen with
	<function>map</function> and <function>filter</function>, we
	can extract the common behaviour shared by
	<function>mySum</function> and
	<function>adler32_try2</function> into a higher-order
	function.  We can describe this behaviour as <quote>do
	  something to every element of a list, updating an
	  accumulator as we go, and returning the accumulator when
	  we're done</quote>.</para>

      <para>This kind of function is called a
	<emphasis>fold</emphasis>, because it <quote>folds up</quote>
	a list, and it has two variants, <function>foldl</function>
	and <function>foldr</function>.</para>
    </sect2>

    <sect2>
      <title>The left fold</title>

      &Fold.hs:foldl;

      <para>The <function>foldl</function> function takes a
	<quote>stepper</quote> function, an initial value for its
	accumulator, and a list.  The <quote>stepper</quote> takes an
	accumulator and an element from the list, and returns a new
	accumulator value. All <function>foldl</function> does is call
	the <quote>stepper</quote> on the current accumulator and an
	element of the list, and passes the new accumulator value to
	itself recursively to consume the rest of the list.</para>

      <para>We refer to <function>foldl</function> as a <quote>left
	  fold</quote> because it consumes the list from left (the
	head) to right.</para>

      <para>Here's a rewrite of <function>mySum</function> using
	<function>foldl</function>.</para>

      &Sum.hs:foldlSum;

      <para>Notice how much simpler this code is?  We're no longer
	using explicit recursion, because <function>foldl</function>
	takes care of that for us.  We've simplified our problem down
	to two things: what the initial value of the accumulator
	should be (the second parameter to
	<function>foldl</function>), and how to update the accumulator
	(the <function>step</function> function).  As an added bonus,
	our code is now shorter, too, which makes it easier to
	understand.</para>

      <para>We can rewrite <function>adler32_try2</function> in a
	similar way, using <function>foldl</function> to let us focus
	on the details that are important.</para>

      &Adler32.hs:adler32_foldl;

      <para>Here, our accumulator is a two-tuple, so the result of
	<function>foldl</function> will be, too. We pull the final
	accumulator apart when <function>foldl</function> returns, and
	bit-twiddle it into a <quote>proper</quote> checksum.</para>
    </sect2>

    <sect2>
      <title>Why use folds, maps, and filters?</title>

      <para>A quick glance reveals that
	<function>adler32_foldl</function> isn't really any shorter
	than <function>adler32_try2</function>.  Why should we use a
	fold in this case?  The advantage here lies in the fact that
	folds are extremely common in Haskell, and they have regular,
	predictable behaviour.</para>

      <para>This means that a reader with a little experience will
	have an easier time understanding a function that uses a fold
	than one that uses explicit recursion.  Where a fold isn't
	going to produce any surprises, the behaviour of a function
	that recurses explicitly isn't immediately obvious.  Explicit
	recursion requires us to read closely to understand exactly
	what's going on.</para>

      <para>This line of reasoning applies to other higher-order
	library functions, including those we've already seen,
	<function>map</function> and <function>filter</function>.
	Because they're library functions with well-defined behaviour,
	we only need to learn what they do once, and we'll have an
	advantage when we need to understand any code that uses
	them.</para>
    </sect2>

    <sect2>
      <title>Avoiding multiple traversals of a list</title>

      <para>From looking at <function>adler32_foldl</function>, we
	know that we can accumulate more than one value at a time when
	we fold over a list.  Here's another use for a fold:
	optimising code by avoiding multiple traversals of a
	list.</para>

      <para>Let's consider the problem of finding the root mean square
	of a list of numbers: compute the sum of the squares of every
	element in the list, divide by its length, then coompute the
	square root of that number.  In an imperative language like C,
	we wouldn't even think twice about writing code like
	this.</para>

      &rms.c:rootMeanSquare;

      <para>Clearly, we're looping over the list just once, updating
	the accumulator values <varname>mean_square</varname> and
	<varname>length</varname> as we go.</para>

      <para>Meanwhile, over in functional programming land, the
	temptation is strong to turn our verbal description of the
	root mean square into code.</para>

      &rms.hs:rootMeanSquare;

      <para>This is a lovely, compact translation of the verbal
	description.  It even uses our new friend, the
	<function>map</function> function, to make the code clearer by
	avoiding explicit recursion, but it's not necessarily good
	code.  The calls to <function>map</function> and
	<function>length</function> are each going to traverse the
	input list once.</para>

      <para>On a small list, the cost of traversing it twice obviously
	won't matter, but on a big list, we're likely to notice. We
	can use a fold to avoid this need to traverse the list
	twice.</para>

      &rms.hs:rootMeanSquare_foldl;

      <para>Clearly, this code isn't as readable as the earlier
	version that used <function>map</function> and
	<function>length</function>.  Which version should we prefer?
	It's often best to start out by writing the most readable
	code, since we can make that correct most quickly, and put off
	worrying about transforming it into something faster until
	much later, when we have profiling data for our program.  Only
	if those numbers indicate a performance problem should we
	worry about stepping back in and transforming our code.  We'll
	have much more to say about profiling, performance, and
	optimisation later, in chapter XXX.</para>
    </sect2>

    <sect2 id="hs.fp.foldr.filter">
      <title>Folding from the right and primitive recursion</title>

      <para>The counterpart to <function>foldl</function> is
	<function>foldr</function>, which folds from the right of a
	list.</para>

      &Fold.hs:foldr;

      <para>At first glance, <function>foldr</function> might seem
	less useful than <function>foldl</function>: what use is a
	function that folds from the right?  But consider the
	Prelude's <function>filter</function> function, which we last
	encountered in <xref linkend="hs.fp.filter"/>.  If we write
	<function>filter</function> using explicit recursion, it will
	look something like this.</para>

      &Fold.hs:filter;

      <para>Perhaps surpsisingly, though, we can write
	<function>filter</function> as a fold, using
	<function>foldr</function>.</para>

      &Fold.hs:myFilter;

      <para>This is the sort of definition that could cause us a
	headache, so let's examine it a little depth.  Like
	<function>foldl</function>, <function>foldr</function> takes a
	function and a base case (what to do when the input list is
	empty) as arguments.  From reading the type of
	<function>filter</function>, we know that our
	<function>myFilter</function> function must return a list of
	the same type as it consumes, so the base case should be a
	list of this type, and the <function>step</function> helper
	function must return a list.</para>

      <para>Since we know that <function>foldr </function> calls
	<function>step</function> on one element of the input list at
	a time, with the accumulator as its second argument, what
	<function>step</function> does must be quite simple.  If the
	predicate returns <function>True</function>, it pushes that
	element onto the accumulated list; otherwise, it leaves the
	list untouched.</para>

      <para>The class of functions that we can express using
	<function>foldr</function> is called <emphasis>primitive
	  recursive</emphasis>.  A surprisingly large number of list
	manipulation functions are primitive recursive.  For example,
	here's <function>map</function> written in terms of
	<function>foldr</function>.</para>

      &Fold.hs:myMap;

      <para>In fact, we can even write <function>foldl</function>
	using <function>foldr</function>!</para>

      &Fold.hs:myFoldl;

      <note>
	<para>If you want to understand the definition of
	  <function>foldl</function> using <function>foldr</function>,
	  it's best to have the following tools at hand: some headache
	  pills, a glass of water, &ghci; (so you can find out what
	  the <function>id</function> function does), and a pencil and
	  paper.</para>
      </note>

      <para>While we can write <function>foldl</function> in terms of
	<function>foldr</function>, we can't do the converse:
	<function>foldr</function> is <quote>more basic than</quote>
	<function>foldl</function>.  This should make it clearer why
	we call functions written with <function>foldr</function>
	primitive recursive.</para>

      <para>(By the way, don't feel like you have to go to special
	lengths to remember the term <quote>primitive
	  recursive</quote>.  It's just useful to remember that you
	read about it somewhere, and that it has something to do with
	<function>foldr</function>.)</para>
    </sect2>

    <sect2>
      <title>A final note about foldl</title>

      <para>To keep our initial discussion simple, we've used
	<function>foldl</function> throughout this section.  However,
	any time you want to fold from the left in practice, use
	<function>foldl'</function> from the <code>Data.List</code>
	module instead, because it's more efficient.  You should take
	this on faith for now; we'll explain why you should avoid
	plain <function>foldl</function> in normal use in section
	XXX.</para>
    </sect2>

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>The Prelude function <function>concat</function>
	      concatenates a list of lists into a single list, and has
	      the following type.</para>

	    &ch04.exercises.hs:concat;

	    <para>Write your own definition of
	      <function>concat</function> using
	      <function>foldr</function>.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>The Prelude function <function>takeWhile</function>
	      has the following type.</para>

	    &ch04.exercises.hs:takeWhile;

	    <para>Use &ghci; to figure out what
	      <function>takeWhile</function> does.  Write your own
	      definitions, first using explicit recursion, then
	      <function>foldr</function>.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>The <code>Data.List</code> module defines a function,
	      <function>groupBy</function>, which has the following
	      type.</para>

	    &ch04.exercises.hs:groupBy;

	    <para>Use &ghci; to load the <code>Data.List</code> module
	      and figure out what <function>groupBy</function> does,
	      then write your own implementation using a fold.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>

    <sect2>
      <title>Further reading</title>

      <para>The article <citation><biblioref
	    linkend="bib.hutton99"/></citation> is an excellent and
	deep tutorial covering folds. It includes many examples of how
	to use simple, systematic calculation techniques to turn
	functions that use explicit recursion into folds.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.fp.rle">
    <title>Example: Run-Length Encoding</title>
    <remark>FIXME:   Example: run-length encoding.  Use to show how
      looping can be done via tail recursion.
    </remark>
  </sect1>

  <sect1 id="hs.fp.inference">
    <title>Type Inference</title>
    <remark>FIXME: Discuss type inference: what it is and how it can
      save a lot of work.
    </remark>
  </sect1>

  <sect1 id="hs.fp.anonymous">
    <title>Anonymous (Lambda) Functions</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.fp.partialapp">
    <title>Curried functions and partial application</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.fp.typeclasses">
    <title>Typeclasses</title>
    <remark>FIXME: Introduce type classes.  Show how ghci infers types
      with constraints. Define some functions that use type class
      constraints. Talk about when it's appropriate to write explicit
      signatures. 
    </remark>
    <para>See also <xref linkend="hs.typeclasses"/>.</para>
  </sect1>

  <sect1 id="hs.fp.mapapi">
    <title>Example: Data.Map API</title>
    <remark>FIXME: Small example would be a finite map data structure
      API, with a list and tree implementation (different complexity,
      same api). Ties together basic types, small functions, top level
      functions. class Map m where new     :: m k v insert  :: k -> v
      -> m k v -> m k v lookup  :: k -> m k v -> v -- simple, O(n)
      data Map1 k v = [(k,v)] -- less simple, O(log n) data Map2 k v =
      Node k v (Map2 k v) (Map2 k v) | Empty

    </remark>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
