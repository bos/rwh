<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.wc" revision="unpublished">
  <title>Extended Example: Web Client Programming</title>
  <para>
    By this point, you've seen how to interact with a database, parse
    things, and handle errors.  Let's now take this a step farther and
    introduce a web client library to the mix.
  </para>
  <para>
    We'll develop a real application in this chapter: a podcast
    downloader, or "podcatcher".  The idea of a podcatcher is simple.
    It is given a list of URLs to process.  Each URL provides an XML
    file in the RSS format.  Inside this XML file, we'll find
    references to URLs for audio files to download.
  </para>
  <para>
    Podcatchers usually let the user subscribe to podcasts by adding
    RSS URLs to their configuration.  Then, the user can periodically
    run an update operation.  The podcatcher will download the RSS
    documents, examine them for audio file references, and download
    any audio files that haven't already been downloaded on behalf of
    this user.
  </para>
  <tip>
    <para>Users often call the RSS document a podcast or the
    podcast feed, and each individual audio file an episode.
    </para>
  </tip>
  <para>
    To make this happen, we need to have several things:
  </para>
  <itemizedlist>
    <listitem><para>An HTTP client library to download files</para>
    </listitem>
    <listitem><para>An XML parser</para>
    </listitem>
    <listitem><para>A way to specify and persistently store 
        which podcasts we're interested in</para>
    </listitem>
    <listitem><para>A way to persistently store which podcast episodes
    we've already downloaded
      </para>
    </listitem>
  </itemizedlist>

  <para>
    The last two items can be accomodated via a database we'll set up
    using HDBC.  The first two can be accomodated via other library
    modules we'll introduce in this chapter.
  </para>

  <tip>
    <para>The code in this chapter was written specifically for this
    book, but is based off code written for hpodder, an existing
    podcatcher written in Haskell.  hpodder has many more features
    than the examples presented here, which make it too long and
    complex for coverage in this book.  If you are interested in
    studying hpodder, its source code is freely available at <ulink
    url="http://software.complete.org/hpodder"/>.
    </para>
  </tip>

  <para>
    We'll write the code for this chapter in pieces.  Each piece will
    be its own Haskell module.  You'll be able to play with each piece
    by itself in &ghci;.  At the end, we'll write the final code that
    ties everything together into a finished application.  We'll start
    with the basic types we'll need to use.
  </para>

  <sect1 id="hs.wc.types">
    <title>Basic Types</title>
    <para>
      The first thing to do is have some idea of the basic information
      that will be important to the application.  This will generally
      be information about the podcasts the user is interested in,
      plus information about episodes that we have seen and
      processed.  It's easy enough to change this later if needed, but
      since we'll be importing it just about everywhere, we'll define
      it first.
    </para>
    &PodTypes.hs:all;
    <para>
      We'll be storing this information in a database.  Having a
      unique identifier for both a podcast and an episode makes it
      easy to find which episodes belong to a particular podcast, load
      information for a particular podcast or episode, or handle
      future cases such as changing URLs for podcasts.
    </para>
  </sect1>
  
  <sect1 id="hs.wc.db">
    <title>The Database</title>
    <para>
      Next, we'll write the code to make possible persistent storage
      in a database.  We'll primarily be interested in moving data
      between the Haskell structures we defined in
      <literal>PodTypes.hs</literal> and the database on disk.  Also,
      the first time the user runs the program, we'll need to create
      the database tables that we'll use to store our data.
    </para>
  </sect1>
    
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
