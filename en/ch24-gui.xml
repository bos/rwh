<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="gui" revision="unpublished">
  <title>GUI Programming with gtk2hs</title>
  <para>
    Thoughout this book, we have been developing simple text-based
    tools.  While these are often ideal interfaces, sometimes a
    graphical user interface (GUI) is required.  There are several GUI
    toolkits available for Haskell.  In this chapter, we will look at
    the most popular of them, gtk2hs.
  </para>
  
  <sect1 id="gui.install">
    <title>Installing gtk2hs</title>
    <para>
      Before we dive in to working with gtk2hs, you'll need to get it
      installed.  On most Linux, BSD, or other POSIX platforms, you
      will find ready-made gtk2hs packages.  You will generally need
      to install the GTK+ devlopment environment, glade, and gtk2hs.
      The specifics of doing so vary by distribution.
    </para>
    <para>
      Windows and Mac developers should consult the gtk2hs downloads
      site at <ulink
      url="http://www.haskell.org/gtk2hs/download/"></ulink>.  Begin
      by downloading gtk2hs from there.  Then you will also need glade
      version 3.  Mac developers can find this at <ulink
      url="http://www.macports.org/"></ulink>, while Windows
      developers should consult <ulink
      url="http://sourceforge.net/projects/gladewin32"></ulink>.
    </para>
  </sect1>

  <sect1 id="gui.overview">
    <title>Overview of the GTK+ Stack</title>
    <para>
      Before diving in to the code, let's pause a brief moment and
      consider the architecture of the system we are going to use.
      First off, we have GTK+.  GTK+ is a cross-platform GUI-building
      toolkit, implemented in C.  It runs on Windows, Mac, Linux,
      BSDs, and more.  It is also the toolkit beneath the Gnome
      desktop environment.
    </para>
    <para>
      Next, we have Glade.  Glade is a user interface designer, which
      lets you graphically lay out your application's windows and
      dialogs.  Glade saves the interface in XML files, which your
      application will load at runtime.
    </para>
    <para>
      The last piece of this puzzle is gtk2hs.  This is the Haskell
      binding for GTK+, Glade, and several related libraries.  It is
      one of many language bindings available for GTK+.
    </para>
  </sect1>

  <sect1 id="gui.glade">
    <title>User Interface Design with Glade</title>
    <para>
      In this chapter, we are going to develop a GUI for the podcast
      downloader we first developed in <xref linkend="wc"/>.  Our
      first task is to design the user interface in Glade.  Once we
      have accomplished that, we will write the Haskell code to
      integrate it with the application.
    </para>
    <para>
      Because this is a Haskell book, rather than a GUI design book,
      we will move fast through some of these early parts.  For more
      information on interface design with Glade, you may wish to
      refer to one of these resources:
    </para>
    <itemizedlist>
      <listitem><para>The Glade homepage, which contains documentation
      for Glade.  <ulink url="http://glade.gnome.org/"></ulink>
        </para>
      </listitem>
      <listitem><para>The GTK+ homepage contains information about the
      different widgets.  Refer to the documentation section, then the
      stable GTK documentation area.  <ulink
      url="http://www.gtk.org/"></ulink>
        </para>
      </listitem>
      <listitem><para>
          The gtk2hs homepage also has a useful documentation section,
          which contains an API reference to gtk2hs as well as a glade
          tutorial.  <ulink
          url="http://www.haskell.org/gtk2hs/"></ulink>
        </para>
      </listitem>
    </itemizedlist>
    <sect2 id="gui.glade.concepts">
      <title>Glade Concepts</title>
      <para>
        Glade is a user interface design tool.  It lets us use a
        graphical interface to design our graphical interface.  We
        could build up the window components using a bunch of calls to
        GTK+ functions, but it is usually easier to do this with
        Glade.
      </para>
      <para>
        The fundamental "thing" we work with in GTK+ is the
        <emphasis>widget</emphasis>.  A widget represents any part of
        the GUI, and may contain other widgets.  Some examples of
        widgets include a window, dialog box, button, and text within the
        button.
      </para>
      <para>
        Glade, then, is a widget layout tool.  We set up a whole tree
        of widgets, with top-level windows at the top of the tree.
        Glade saves this description into an XML file.  Our program
        loads this XML file at runtime.  We load the widgets by asking
        the Glade runtime library to load a widget with a specific
        name.
      </para>
      <para>
        Here's a screenshot of an example working with Glade to design
        our application's main screen:
      </para>
      <informalfigure>
        <graphic fileref="figs/gui-glade-3.png"/>
      </informalfigure>
      <para>
        In the downloadable material available for this book, you can
        find the full Glade XML file as
        <literal>podresources.glade</literal>.  You can load this file
        in Glade and edit it if you wish.
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="gui.event">
    <title>Event-Driven Programming</title>
    <para>
      GTK+, like many GUI toolkits, is an
      <emphasis>event-driven</emphasis> toolkit.  That means that
      instead of, say, displaying a dialog box and waiting for the
      user to click on a button, we instead tell gtk2hs what function
      to call if a certain button is clicked, but don't sit there
      waiting for a click in the dialog box.
    </para>
    <para>
      This is different from the model traditionally used for console
      programs.  When you think about it, though, it almost has to
      be.  A GUI program could have multiple windows open, and writing
      code to sit there waiting for input in the particular
      combination of open windows could be a complicated proposition.
    </para>
    <para>
      Event-driven programming compliments Haskell nicely.  As we've
      discussed over and over in this book, functional languages
      thrive on passing around functions.  So we'll be passing
      functions to gtk2hs that get called when certain events occur.
      These are known as <emphasis>callback functions</emphasis>.
    </para>
    <para>
      At the core of a GTK+ program is the <emphasis>main
      loop</emphasis>.  This is the part of the program that waits for
      actions from the user or commands from the program and carries
      them out.  The GTK+ main loop is handled entirely by GTK+.  To
      us, it looks like an I/O action that we execute, that doesn't
      return until the GUI has been disposed of.
    </para>
    <para>
      Since the main loop is responsible for doing everything from
      handling clicks of a mouse to redrawing a window when it has
      been uncovered, it must always be available.  We can't just run
      a long-running task -- such as downloading a podcast episode --
      from within the main loop.  This would make the GUI
      unresponsive, and actions such as clicking a Cancel button
      wouldn't be processed in a timely manner.
    </para>
    <para>
      Therefore, we will be using multithreading to handle these
      long-running tasks.  More information on multithreading can be
      found in <xref linkend="concurrent"/>.  For now, just know that
      we will use <literal>forkIO</literal> to create new threads for
      long-running tasks such as downloading podcast feeds and
      episodes.  For very quick tasks, such as adding a new podcast to
      the database, we will not bother with a separate thread since it
      will be executed so fast the user will never notice.
    </para>
  </sect1>

  <sect1 id="gui.init">
    <title>Initializing the GUI</title>
    <para>
      Our first steps are going to involve initializing the GUI for
      our program.  For reasons that we'll explain later,
      <remark>FIXME: add link</remark> we're going to have a small
      file called <literal>PodLocalMain.hs</literal> that loads
      <literal>PodMain</literal> and passes to it the path to
      <literal>podresources.glade</literal>, the XML file saved by
      Glade that gives the information about our GUI widgets.
    </para>
    &PodLocalMain.hs:all;
    <para>
      Now, let's consider <literal>PodMain.hs</literal>.  This file is
      the only Haskell source file that we had to modify from the
      example in <xref linkend="wc"/> to make it work as a GUI.  Let's
      start by looking at the start of our new
      <literal>PodMain.hs</literal> file.
    </para>
    &PodMain.hs:imports;
    <para>
      This first part of <literal>PodMain.hs</literal> is similar to
      our non-GUI version.  We import three additional components,
      however.  First, we have <literal>Graphics.UI.Gtk</literal>,
      which provides most of the GTK+ functions we will be using.
      Both this module and <literal>Database.HDBC</literal> provide a
      function named <literal>disconnect</literal>.  Since we'll be
      using the HDBC version, but not the GTK+ version, we don't
      import that function from <literal>Graphics.UI.Gtk</literal>.
      <literal>Graphics.UI.Gtk.Glade</literal> contains functions
      needed for loading and working with our Glade file.
    </para>
    <para>
      We also import <literal>Control.Concurrent</literal>, which has
      the basics needed for multi-threaded programming.  We'll use a
      few functions from here as described above once we get into the
      guts of the program.  Next, let's define a type to store
      information about our GUI.
    </para>
    &PodMain.hs:type;
    <para>
      Our new <literal>GUI</literal> type stores all the widgets we
      will care about in the entire program.  Large programs may not
      wish to have a monolothinc type like this.  For this small
      example, it makes sense because it can be easily around to
      different functions, and we'll know that we always have the
      information we need available.
    </para>
    <para>
      Within this record, we have fields for a <literal>Window</literal> (a
      top-level window), <literal>Dialog</literal> (dialog window),
      <literal>Button</literal> (clicable
      button), <literal>Label</literal> (piece of text), and
      <literal>Entry</literal> (place for the user to enter text).
      Let's now look at our <literal>main</literal> funciton:
    </para>
    &PodMain.hs:main;
    <para>
      Remember that the type of this <literal>main</literal> function
      is a little different than usual because it is being called by
      <literal>main</literal> in <literal>PodLocalMain.hs</literal>.
      We start by calling <literal>initGUI</literal>, which
      initializes the GTK+ system.  Next, we have a call to
      <literal>timeoutAddFull</literal>.  This call is only needed for
      multithreaded GTK+ programs.  It tells the GTK+ main loop to
      pause to give other threads a chance to run every so often.
    </para>
    <para>
      After that, we call our <literal>loadGlade</literal> function
      (see below) to load the widgets from our Glade XML file.  After
      that, we connect to our database, call our
      <literal>connectGui</literal> function to set up our callback
      functions.  Then, we fire up the GTK+ main loop.  We expect it
      could be minutes, hours, or even days before
      <literal>mainGUI</literal> returns.  When it does, it means the
      user has closed the main window or clicked the Exit button.
      After that, we disconnect from the database and close the
      program.  Now, let's look at our <literal>loadGlade</literal>
      function.
    </para>

    &PodMain.hs:loadGlade;

    <para>
      This function starts by calling <literal>xmlNew</literal>, which 
      loads the Glade XML file.  It returns <literal>Nothing</literal>
      on error.  Here we are using pattern matching to extract the
      result value on success.  If it fails, there will be a console
      (not graphical) exception displayed; one of the excercises at
      the end of this chapter addresses this.
    </para>
    <para>
      Now that we have Glade's XML file loaded, you will see a bunch
      of calls to <literal>xmlGetWidget</literal>.  This Glade
      function is used to load the XML definition of a widget, and
      return a GTK+ widget type for that widget.  We have to pass
      along to that function a value indicating what GTK+ type we
      expect -- we'll get a runtime error if these don't match.
    </para>
    <para>
      We start by creating a widget for the main window.  It is loaded
      from the XML widget defined with name
      <literal>"mainWindow"</literal> and stored in the
      <literal>mw</literal> variable.  We then use pattern matching
      and <literal>mapM</literal> to load up all the buttons.
      Then, we have two dialogs, a label, and an entry to load.
      Finally, we use all of these to build up the GUI type and return
      it.  Next, we need to set our callback functions up as event handlers.
    </para>
    &PodMain.hs:connectGui;
    <para>
      We start out the <literal>connectGui</literal> function by
      calling <literal>onDestroy</literal>.  This means that when
      somebody clicks on the operating system's close button
      (typically an X in
      the titlebar on Windows or Linux, or a red circle on Mac OS X),
      on the main window, we call the <literal>mainQuit</literal>
      function.  <literal>mainQuit</literal> closes all GUI windows
      and terminates the GTK main loop.
    </para>
    <para>
      Next, we call <literal>onClicked</literal> to register event
      handlers for clicking on our five different buttons.  For
      buttons, these handlers are also called if the user selects the
      button via the keyboard.  Clicking on these buttons will call
      our functions such as <literal>guiAdd</literal>, passing along
      the GUI record as well as a database handle.
    </para>
    <para>
      At this point, we have completely defined the main window for
      the GUI podcatcher.  It looks like this:
    </para>

    <informalfigure>
      <graphic fileref="figs/gui-pod-mainwin.png"/>
    </informalfigure>
  </sect1>

  <sect1 id="gui.add">
    <title>The Add Podcast Window</title>
    <para>
      Now that we've covered the main window, let's talk about the
      other windows that our application presents, starting with the
      Add Podcast window.  When the user clicks the button to add a
      new podcast, we need to pop up a dialog box to prompt for the
      URL of the podcast.  We have defined this dialog box in Glade,
      so all we need to do is set it up.
    </para>
    <para>
      We start by calling <literal>entrySetText</literal> to set the
      contents of the entry box (the place where the user types in the
      URL) to the empty string.  That's because the same widget gets
      reused over the lifetime of the program, and we don't want the
      last URL the user entered to remain there.  Next, we set up
      actions for the two buttons in the dialog.  If the users clicks
      on the cancel button, we simply remove the dialog box from the
      screen by calling <literal>widgetHide</literal> on it.  If the
      user clicks the OK button, we call <literal>procOK</literal>.
    </para>
    <para>
      <literal>procOK</literal> starts by retrieving the supplied URL
      from the entry widget.  Next, it uses
      <literal>widgetHide</literal> to get rid of the dialog box.
      Finally, it calls <literal>add</literal> to add the URL to the
      database.  This <literal>add</literal> is exactly the same
      function as we had in the non-GUI version of the program.
    </para>
    <para>
      Note that the <literal>guiAdd</literal> function returns almost
      immediately.  It just sets up the widgets and causes the box to
      be displayed; at no point does it block waiting for input.
      Here's what the dialog box looks like:
    </para>
    <informalfigure>
      <graphic fileref="figs/gui-pod-addwin.png"/>
    </informalfigure>
  </sect1>
    
  <sect1 id="gui.exercises">
    <title>Exercises</title>

    <orderedlist>
      <listitem><para>
          Present a helpful GUI error message if the call to
          <literal>xmlNew</literal> returns
          <literal>Nothing</literal>.
        </para>
      </listitem>
      <listitem><para>Modify the podcatcher to be able to run with
      either the GUI or the command-line interface from a single code
      base.  Hint: move common code out of
      <literal>PodMain.hs</literal>, then have two different
      <literal>Main</literal> modules, one for the GUI, and one for
      the command line.
        </para>
      </listitem>
    </orderedlist>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
