<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.funcstypes">
  <title>Types and Functions</title>

  <para>Topics: built-in types.  Writing functions.  Creating new
    types.</para>

  <sect1>
    <title>Haskell's type system</title>
    
    <para><quote>Haskell has a strong, static type system with
	inference.</quote> For a short sentence, this one gives us a
      lot for us to pore over.  Because Haskell is quite different
      from mainstream programming languages in how it treats types,
      let's not assume too much shared understanding as we talk about
      types.</para>

    <para>Every value and expression in Haskell has a
      <emphasis>type</emphasis>.  The type of a value indicates that
      it shares certain properties with other values that have the
      same type.  (You'll see us refer to a value <quote>having the
	type <code>X</code></quote>, or <quote>being of type
	<code>X</code></quote>.  The two phrases mean the same thing.)
      All values that have the type <type>Integer</type> have the
      ability to be added to other values of type
      <type>Integer</type>, and so on.</para>

    <para>Haskell has a <quote>strong</quote> type system, in which
      every expression and value has exactly one type.  Another aspect
      of Haskell's view of strong typing is that it will not
      automatically convert values from one type to another, a feature
      present in some other languages.</para>

    <note>
      <para>Conversations about type systems can lead to many a
	misunderstanding among programmers.  Some people say that C
	has a strong type system; others claim that Python does.
	Haskell programmers think strong typing is still something
	else.</para>

      <para>Since there's no universally agreed upon meaning for the
	phrase <quote>strong type</quote>,  it's best not to assume
	that someone else shares the same notion of it as you do.  (We
	also suggest that putting forth one definition as better than
	another doesn't often lead to enlightened discussion.)</para>
    </note>

    <para>Having a <quote>static</quote> type system means that the
      compiler knows the type of every value and expression at compile
      time, before any code is ever executed.  A Haskell compiler or
      interpreter will detect when we try to use types inconsistently
      in our code, and reject the code with an error message.</para>

    &ch03.basics.ghci:error;

    <para>Haskell's combination of strong and static typing also makes
      it impossible for type errors to occur at runtime.</para>

    <para>Finally, <quote>type inference</quote> means what it says:
      the compiler can automatically figure out the types of most
      values for us, so that we don't have to explicitly label
      them.</para>

    <para>We've already briefly seen Haskell's notation for types in
      <xref linkend="hs.starting.types"/>.  We write <code>expression
	:: <type>MyType</type></code> to say that
      <code>expression</code> has the type <type>MyType</type>.</para>
  </sect1>

  <sect1>
    <title>Some common basic types</title>
    
    <para>We've already encountered a few types in <xref
	linkend="hs.starting.types"/>.  Haskell has a number of
      built-in types that we'll use over and over.  Here are some of
      the language's basic types, types that aren't composed of other
      types</para>

    <itemizedlist>
      <listitem>
	<para>The <type>Char</type> type represents a character. The
	  values of <type>Char</type> are drawn from the Unicode
	  character set, which covers most of the world's written
	  languages.</para>
      </listitem>
      <listitem>
	<para>The <type>Bool</type> type represents a value in Boolean
	  logic.  The possible values of <type>Bool</type> are
	  <code>True</code> and <code>False</code>.</para>
      </listitem>
      <listitem>
	<para>The <type>Int</type> type represents a signed,
	  fixed-width integer.  The exact range of values represented
	  by <type>Int</type> depends on the system's longest
	  <quote>native</quote> integer: on a 32-bit machine, an
	  <type>Int</type> is usually 32 bits wide, while on a 64-bit
	  machine, it is usually 64 bits wide.</para>
      </listitem>
      <listitem>
	<para>The <type>Integer</type> type represents a signed
	  integer of arbitrary size.  <type>Integer</type>s are not
	  used as often as <type>Int</type>s, because they're a lot
	  more expensive to work with.</para>
      </listitem>
      <listitem>
	<para>The <type>Double</type> type is the type usually used to
	  represent floating point numbers.  It is typically 64 bits
	  wide, and uses the machine's native floating point
	  representation.  (A narrower type, <type>Float</type>, also
	  exists, but its use is discouraged; Haskell compiler writers
	  concentrate more on making <type>Double</type>
	  efficient.)</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>Useful composite data types: lists and tuples</title>

    <para>The most common composite data types in Haskell are the list
      and tuple.</para>

    <para>We've already seen the list type mentioned in <xref
	linkend="hs.starting.string"/>, where we found that Haskell
      represents a text string as a list of <type>Char</type> values,
      and that the type <quote>list of <type>Char</type></quote> is
      written <type>[Char]</type>.</para>

    <para>More generally, we can write the type <quote>list of
	<varname role="type">a</varname></quote> for any type <varname
	role="type">a</varname> by enclosing <varname
	role="type">a</varname> in square brackets, <type>[a]</type>.
      Lists are strongly typed: a list of one type has an identity of
      its own, distinct from a list of another type. The type
      <type>[Int]</type> is a list that can only contain values of
      type <type>Int</type>, for example.  We also call the list type
      <emphasis>polymorphic</emphasis>, because it can contain any
      type of value.</para>

    <para>Lists are the <quote>bread and butter</quote> of Haskell
      collections.  Whereas in an imperative language, we might repeat
      a task over many items by iterating through a loop, this is
      something that we tend to do in Haskell by recursing over a
      list.  We'll be spending a lot more time discussing lists in
      <xref linkend="hs.fp"/>.</para>

    <para>A tuple is a fixed-size collection of values, each of which
      can be of any type.  Unlike a list (the elements of which must
      all have the same type), there's no need for the elements of a
      tuple to have related types.  We write a tuple by enclosing its
      elements in parentheses and separating them with commas.  We use
      the same notation for writing its type.</para>

    &tuple.ghci:tuple;

    <para>We can construct a tuple with any number of elements
      (although in practice, a tuple with more than a handful becomes
      unwieldy).  A tuple's type encodes the number and types of its
      elements in its own type.  This means that tuples containing
      different numbers or types of elements have distinct types of
      their own.</para>

    &tuple.ghci:type;

    <para>A two-tuple of an <type>Int</type> and a <type>String</type>
      has a different type than a two-tuple of a <type>Bool</type> and
      a <type>Bool</type>, for example, and a three-tuple has a
      different type than a four-tuple.</para>

    <para>Probably the most common use of tuples is to let us return
      multiple values from a function.  We can also use them in other
      places where we want a fixed-size collection of values, for
      which the kind of container we're using isn't of much
      importance.  An example of this might be to represent a row in
      the result of a a database query.</para>
  </sect1>

  <sect1>
    <title>Calling functions</title>

    <para>Now that we've had our fill of data types for a while, let's
      turn our attention to <emphasis>working</emphasis> with some of
      the types we've seen.  We've already seen how to perform
      arithmetic in <xref linkend="hs.starting.arithmetic"/>, and it
      looks quite as it does in other languages.</para>

    <para>However, our discussion of lists and tuples mentioned how we
      can construct them, but not how we do anything with them
      afterwards.  Haskell defines a large library of functions for
      working with lists and (to a lesser extent) tuples, so let's
      find out how to use a few of those functions.</para>

    <para>To call a function in Haskell, we provide the name of the
      function followed by its arguments, all separated by white space.
      As an example, let's call the <function>head</function>
      function, which returns the first element of a list.</para>

    &func.ghci:head;

    <para>Its counterpart, <function>tail</function>, returns all
      <emphasis>but</emphasis> the head of a list.</para>

    &func.ghci:tail;

    <para>A related pair of functions, <function>take</function> and
      <function>drop</function>, take two arguments: given a number
      and a list, they return either the first, or all but the first,
      number of elements of the list.  (Here, remember that a
      <type>String</type> is a list of <type>Char</type>.)</para>

    &func.ghci:takeDrop;

    <para>If you're used to function call syntax in other languages,
      this notation can take a little getting used to, but it's
      undeniably simple and uniform.  Here's what we mean by
      uniform.</para>

    &func.ghci:snd;

    <para>In some other languages, the call to
      <function>snd</function> above might mean <quote>call
	<function>snd</function> with two arguments,
	<literal>1</literal> and <literal>2</literal></quote>, but in
      Haskell, it's a single-argument call, passing the tuple
      <literal>(1,2)</literal>.</para>

    <para>By the way, <function>snd</function> has a companion
      function, <function>fst</function>, which returns the first
      element of a tuple.</para>

    &func.ghci:fst;

    <sect2>
      <title>Passing an expression to a function</title>

      <para>Haskell evaluates an expression from left to right.  If we
	want to use the result of one expression as an argument to
	another, we have to keep this in mind and use parentheses to
	tell the parser what we really mean.  Here's an
	example.</para>

      &func.ghci:headDrop;

      <para>We can read this as <quote>pass the result of the
	  expression <code>drop 4 "azerty"</code> as the argument to
	  <function>head</function></quote>.  If we were to leave out
	the parentheses, Haskell would instead interpret the
	expression as <quote>pass <function>drop</function> as the
	  argument to <function>head</function></quote>.  Compilation
	would fail with a type error, as <function>drop</function> is
	a function, not a list.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Understanding a function's type signature</title>

    <para>A consequence of Haskell's strong typing is that
      <function>fst</function> and <function>snd</function> only
      accept two-tuples as arguments.  Let's see what &ghci; tells us
      about their types.</para>

    &func.ghci:fst.type;

    <para>We can read the <literal>-&gt;</literal> above as
      <quote>returns</quote>.  The entire signature thus tells us that
      <function>fst</function> takes any two-tuple whose elements are
      of types <varname role="type">a</varname> and <varname
	role="type">b</varname> (each of which can be of any type),
      and returns a value with type <varname role="type">a</varname>.
      Sure enough, if we try calling <function>fst</function> with a
      three-tuple, things don't go so well.</para>

    &func.ghci:fst.bad;

    <para>Notice that the type signatures above give us a strong hint
      as to what these functions might actually
      <emphasis>do</emphasis>. This is an incredibly valuable property
      of types in a functional language.  Since there aren't usually
      any side effects for us to worry about, figuring what a function
      does can often be a matter of reading its name and understanding
      its type signature, with no <quote>regular documentation</quote>
      required.</para>

    <para>Just as we called the list type polymorphic because it can
      contain values of any type, when a function has type variables
      in its signature, indicating that some of its arguments can be
      of any type, we call the function polymorphic, too.</para>

    <para>So far, we haven't seen a signature for a function that
      takes <emphasis>more</emphasis> than one argument.  We've
      already encountered a few such functions; let's look at
      <function>take</function>.</para>

    &func.ghci:take.type;

    <para>It's pretty clear that there's something going on with an
      <type>Int</type> and some lists, but why are there two
      <literal>-&gt;</literal> symbols in the signature?  Haskell
      parses this chain of arrows from right to left.  If we introduce
      parentheses, it makes it clearer how Haskell is interpreting
      this type signature.</para>

    &Take.hs:type;

    <para>From this, it looks like we ought to read the type signature
      as a function that takes one argument, an <type>Int</type>, and
      returns another function.  That other function also takes one
      argument, a list, and returns a list of the same type as its
      argument.</para>

    <para>This is an intriguing idea, but it's not easy to see just
      yet what its consequences might be.  We'll return to this topic
      in <xref linkend="hs.fp.partialapp"/>, once we've spent a bit of
      time writing functions.</para>

  </sect1>

  <sect1>
    <title>Haskell source files, and writing simple functions</title>

    <para>Now that we know how to call functions, it's time we turned
      our attention to writing them.  While we can write functions in
      &ghci;, it's not a good environment for doing so, because it
      limits any expression or definition to one line in length.  So
      instead, we'll finally break down and create a source
      file.</para>

    <para>Haskell source files are usually identified with a suffix of
      <filename>.hs</filename>.  Here's a simple function definition:
      open up a file named <filename>add.hs</filename>, and add these
      contents to it.</para>

    &add.hs:add;

    <para>On the left hand side of the <literal>=</literal> is the
      name of the function, followed by the arguments to the function.
      On the right hand side is the body of the function.  With our
      source file saved, we can load it into &ghci;, and use our new
      <function>add</function> function straight away.</para>

    &add.ghci:add;

    <para>When we call <function>add</function>, the variables
      <varname>a</varname> and <varname>b</varname> on the left hand
      side of our definition are given (or <quote>bound to</quote>)
      the values <literal>1</literal> and <literal>2</literal>, then
      the right hand side is evaluated, and the result
      returned.</para>

    <para>Haskell doesn't need a <command>return</command> statement;
      the result of a function is the result of evaluating whatever
      expression is in the function's body.</para>

    <sect2 id="hs.funcstypes.if">
      <title>Conditional evaluation</title>

      <para>Like other languages, Haskell has an <code>if</code>
	expression.  Let's see it in action, then we'll explain what's
	going on.  As an example, we'll write our own version of the
	standard <function>take</function> function. Before we begin,
	let's probe a little bit of how <function>take</function>
	behaves, so we can replicate its behaviour.</para>

      &myTake.ghci:take;

      <para>From the above, it seems that <function>take</function>
	returns an empty list if the number to remove is greater than
	the number of elements, and that it treats negative numbers as
	zero.  Here's a <function>myTake</function> function that has
	the same behaviour, and uses Haskell's <code>if</code>
	expression to decide what to do.</para>

      &myTake.hs:myTake;

      <para>Let's save it in a file named
	<filename>myTake.hs</filename>, then load it into
	&ghci;.</para>

      &myTake.ghci:myTake;

      <para>Now that we've seen <function>myTake</function> in action,
	let's return to the source code and look at a few of the
	novelties we've introduced.</para>

      <para>First is the <code>if</code> keyword itself.  It takes an
	expression of type <type>Bool</type>.  If that evaluates to
	<function>True</function>, it evaluates the expression on the
	<code>then</code> branch.  Otherwise, it evaluates the
	expression on the <code>else</code> branch.</para>

      <para>The combination of <code>if</code>, <code>then</code>,
	<code>else</code> and the expression after each keyword
	combine to make up a single expression, as far as Haskell is
	concerned.  Whichever branch is evaluated is the result of the
	<code>if</code>.  Because an expression can only have one
	type, the expressions in the <code>then</code> and
	<code>else</code> branches must have the same type.  If they
	don't, an <code>if</code> expression won't typecheck.</para>

      <para>Whereas it can make sense in an imperative language to
	omit the <code>else</code> branch from an <code>if</code>,
	this would be nonsensical in Haskell.  An <code>if</code>
	expression that was missing an <code>else</code> couldn't
	typecheck, since it would sometimes have a value and sometimes
	not.</para>

      <para>The second novelty is almost trivial: the
	<function>null</function> function, which we use in the
	Boolean portion of the <code>if</code>, indicates whether a
	list is empty.</para>

      &myTake.ghci:null;

      <para>Third is that our function calls itself recursively.  This
	is an early example of how, in Haskell, we use recursion where
	in an imperative language we'd probably use a loop.</para>

      <para>Finally, our <code>if</code> expression spans several
	lines.  We line the <code>then</code> and <code>else</code>
	branches up under the <code>if</code> for neatness, but this
	is not mandatory.  We could put all of them on a single line,
	for example, but we'd end up with less readable code.</para>

      &myTake.hs:myTake2;

      <remark>XXX Make a forward reference to discussion of the layout
	rule.</remark>

    </sect2>
  </sect1>

  <sect1>
    <title>Defining a new data type</title>
      
    <para>Although lists and tuples are useful, we'll still often want
      to construct new data types of our own.  We define a new data
      type using the <code>data</code> keyword.</para>

    &MyType.hs:MyType;

    <para>The <type>MyType</type> after the <code>data</code> keyword
      is the name of our new type.  (As we've already mentioned, a
      type name must start with a capital letter.)  The string
      <code>MyConstructor</code> is the name of the
      <emphasis>constructor</emphasis> we'll call to create a value of
      this type.  (As with a type name, a constructor name must start
      with a capital letter.)  Finally, the <type>Int</type> and
      <type>String</type> are the <emphasis>components</emphasis> of
      the type.  A component serves the same purpose in Haskell as a
      field in a structure or class would in another language.</para>

    <note>
      <para>We'll explain the full meaning of <code>deriving
	  (Show)</code> later, in
	<xref linkend="hs.typeclasses.wellknown.show"/>.  For now,
	it's enough to know that we need to tack this onto a type
	declaration so that &ghci; will automatically know how to
	print a value of this type.</para>
    </note>

    <para>We can create a new value of type <type>MyType</type> by
      treating <function>MyConstructor</function> as a function, and
      calling it with arguments of types <type>Int</type> and
      <type>String</type>.</para>

    &MyType.hs:myValue;

    <para>Once we've defined a type, we can experiment with it in
      &ghci;, starting by using the <command>:load</command> command
      to load our source file.</para>

    &mytype.ghci:load;

    <para>Remember the <code>myValue</code> variable we defined?  Here
      it is.</para>

    &mytype.ghci:myValue;

    <para>We can construct new values interactively in &ghci;,
      too.</para>

    &mytype.ghci:newValue;

    <para>To find out more about a type, we can use some of &ghci;'s
      browsing capabilities.  The <command>:info</command> command
      gets &ghci; to tell us us everything it knows about a
      type.</para>
    
    &mytype.ghci:info;

    <para>We can also find out why we use
      <function>MyConstructor</function> to construct a new value of
      type <type>MyType</type>.</para>

    &mytype.ghci:type;

    <para>From Haskell's perspective, then, a constructor is just
      another function, one that happens to return a value of the type
      we want to construct.</para>
  </sect1>

  <sect1>
    <title>Algebraic data types</title>

    <para>The <type>Bool</type> type that we introduced earlier is the
      simplest example of a sort of type called an <emphasis>algebraic
	data type</emphasis>. An algebraic data type has a fixed set
      of possible values, each of which is identified by a distinct
      constructor.</para>

    <para>In the case of <type>Bool</type>, the type has two
      constructors, <code>True</code> and <code>False</code>.  Each
      constructor is separated by a <literal>|</literal> character,
      which we can read as <quote>or</quote>.  These are usually
      referred to as alternatives or cases.</para>

      &Bool.hs:Bool;

    <para>Each constructor can take zero or more arguments; the
      numbers and types of the arguments accepted by each constructor
      are independent.  For example, here's one way we might represent
      versions of the Windows operating system, where old releases
      were monolithic, and newer releases have <quote>service pack
	levels</quote> denoting major updates after their initial
      releases.</para>

      &OsVersion.hs:WindowsVersion;

    <para>The alternatives that represent older releases don't need
      arguments, but those for the newer releases need an
      <type>Int</type> to represent the patch level.</para>

    <sect2>
      <title>Analogues to algebraic data types in other
	languages</title>

      <para>Algebraic data types provide a single structuring
	mechanism in instances where other languages have several
	different building blocks.  Here are some analogues from C and
	C++, which might make it clearer what we can do with algebraic
	data types.</para>

      <para>With just one constructor, an algebraic data type groups
	related values into one, and gives that value an identity
	distinct from other types.  It corresponds to a
	<code>struct</code> in C or C++, and its components to the
	fields of a struct.</para>

      <para>If an algebraic data type has multiple alternatives, we
	can think of it as similar to a <code>union</code> in C or
	C++.  A big difference between the two is that a union doesn't
	tell us which alternative is actually present; we have to
	record which alternative we're using ourselves, usually in
	another field of a struct.  This means that unions can
	sometimes be sources of bugs, where our notion of which
	alternative we should be using is incorrect.</para>

      <para>With an algebraic data type, Haskell stores the
	constructor that we use in the value that we create, so we
	don't need to manually sock it away somewhere else.</para>

      <para>Algebraic data types also serve where we'd use an
	<code>enum</code> in C or C++, to represent a range of
	discrete symbolic values.</para>

      &Enum.hs:Roygbiv;

    </sect2>

    <sect2>
      <title>A few final notes</title>

      <para>From reading the preceding sections, it should be clear
	that <emphasis>all</emphasis> of the data types that we define
	with the <code>data</code> keyword are algebraic data types.
	Some may have just one alternative; others have several; but
	they're all using the same organising machinery.</para>

      <para>Another useful thing to know is that it's perfectly okay
	for the name of an algebraic type to have the same name as one
	of its constructors to be the same.  It's always obvious from
	context whether we're using a name to refer to a type or a
	constructor, so this doesn't introduce any ambiguity.</para>

      <para>Giving a type and its constructor the same name is in fact
	something that we do frequently when the type has just one
	constructor.</para>

      &TypeName.hs:PerfectlyNormal;

      <para>When a type has multiple constructors, it's still legal to
	give one of the constructors the  same name as the type, but
	this is much less common.</para>

      &TypeName.hs:LegalButWeird;

    </sect2>
  </sect1>

  <sect1>
    <title>Parameterised types</title>

    <para>In our discussion of lists, we mentioned that we can create
      a list of values of any type.  We can define our own types that
      allow this, too.  To do this, we introduce variables into a type
      declaration.</para>

      &Wrapper.hs:Wrapper;

    <para>Here, the variable <varname role="type">a</varname> is not a
      regular variable; it's called a <emphasis>type
	variable</emphasis>, because it indicates that our
      <type>Wrapper</type> type takes another type as its parameter
      (hence calling it a parameterised type). What this lets us do is
      use <type>Wrapper</type> on values of any type.</para>

      &Wrapper.hs:wrappedTypes;

    <para>As usual, we can load our source file into &ghci; and
      experiment with it.</para>

      &wrapper.ghci:experiment;

    <para><type>Wrapper</type> is a <quote>generic</quote> container
      type (albeit a fairly useless one); we can construct a
      <type>Wrapper</type> from a value of any type.  It is also
      strongly typed; the type of whatever it contains is encoded in
      its own type.</para>

    <para>To once again extend an analogy to more familiar languages,
      this gives us a facility that bears some resemblance to
      templates in C++, and to generics in Java.  (In fact, Java's
      generics facility was inspired by several aspects of Haskell's
      type system.)</para>

    <para>We can nest uses of parameterised types inside each other,
      but when we do, we may need to use parentheses to tell the
      Haskell compiler what we mean.</para>

      &Wrapper.hs:parens;
  </sect1>

  <sect1>
    <title>Back to writing functions: local variables</title>

    <para>Let's take a break from writing about types for a few
      moments.  Within the body of a function, we can introduce new
      local variables whenever we need them, using a <code>let</code>
      expression.  As an example, let's write a function that
      calculates the real-valued roots of the quadratic equation
      <literal>a * (x ** 2) + b * x + c == 0</literal>.</para>

    &Roots.hs:realRoots;

    <para>The keywords to look out for here are <code>let</code>,
      which starts a block of variable declarations, and
      <code>in</code>, which ends it.  Each line introduces a new
      variable.  The name is on the left of the <literal>=</literal>,
      and its value on the right.  We can use these variables both
      within our block of variable declarations and in the expression
      that follows the <code>in</code> keyword.</para>

    <para>There's no problem with a variable earlier in a
      <code>let</code> block referring to a later one, or even with
      them referring to each other.  (In some functional languages,
      this sort of flexible <code>let</code> is named
      <code>letrec</code>.)</para>

    <para>We can have multiple <code>let</code> blocks within an
      expression.  There's also another mechanism we can use to
      introduce local variables, called a <code>where</code> block.
      The definitions in a <code>where</code> block apply to the code
      that <emphasis>precedes</emphasis> it.  Let's illustrate what we
      mean with another example.</para>

    &Roots.hs:roots;

    <para>Here, the <function>roots</function> function returns the
      real roots when they're defined, and the complex roots
      otherwise. (We left out the divide-by-zero case for simplicity.)
      While a <quote>where</quote> clause initially looks very weird
      to non-Haskell programmers, it's a great way to put the
      <quote>important</quote> code early, followed by the auxiliary
      definitions that support it.  After a while, you'll find
      yourself missing <code>where</code> clauses in languages that
      lack them!</para>

    <para>The main difference between <code>let</code> and
      <code>where</code> is one of scope.  The scope of a
      <code>let</code> only extends to the expression after the
      <code>in</code> keyword, while the variables introduced by a
      <code>where</code> clause are visible upwards to the beginning
      of the block that it <quote>belongs</quote> to. Also,
      <code>let</code> is always paired with an expression, but
      <code>where</code> is paired with a block of equations.</para>

    <para>We'll be talking more about how to write <code>let</code>
      expressions and <code>where</code> clauses in <xref
	linkend="hs.funcstypes.offside"/>.</para>

    <note>
      <para>It's probably obvious from context above, but
	<function>(:+)</function> is the constructor for a complex
	number, taking the real part on the left and the imaginary
	part on the right.</para>

      <para>Also, <type>Complex</type> is parameterised over the type
	of complex number it should represent.  In practice, it only
	makes much sense to use <type>Complex Double</type>, since
	&GHC; implements <type>Double</type> more efficiently than
	<type>Float</type>.</para>
    </note>
  </sect1>

  <sect1>
    <title>How to represent a complicated result</title>

    <para>We sneaked two previously unseen standard types,
      <type>Maybe</type> and <type>Either</type>, into our
      root-finding examples.  We use <type>Maybe</type> when it might
      not make sense to return a normal result, for example because a
      function's result is undefined for some inputs.  We use
      <function>Just</function> to say <quote>we have a
	result</quote>, and the argument to <function>Just</function>
      is that result.  When we can't give a result, we use
      <function>Nothing</function>, which takes no arguments.</para>

    &realRoots.ghci:maybe;
    
    <para>Why do we need <type>Maybe</type> here?  The real-valued
      roots of a quadratic equation are infinity when
      <varname>a</varname>, the coefficient of <literal>x **
	2</literal>, is zero.</para>

    &realRoots.ghci:a0;

    <para>They're also not defined when <literal>b ** 2 - 4 * a *
	c</literal> is negative, because we would need to use complex
      numbers to represent a negative square root.</para>

    &realRoots.ghci:complex;

    <para>Otherwise, we can return a normal result, wrapped in
      <function>Just</function>.</para>

    &realRoots.ghci:just;

    <para>The <type>Either a b</type> type gives us more flexibility,
      as it's got two type parameters.  We can wrap a value of any
      type <varname role="type">a</varname> with <type>Left</type>, or
      a value of an unrelated type <varname role="type">b</varname>
      with <type>Right</type>.  Our <function>roots</function>
      function uses this to return a <type>Double</type> when the real
      roots are defined, and a <type>Complex Double</type> when
      they're not.</para>
  </sect1>

  <sect1 id="hs.funcstypes.offside">
    <title>The offside rule, and white space in a function
      body</title>

    <para>In our definition of <function>realRoots</function>, the
      left margin of our text wandered around quite a bit.  This was
      not an accident: in Haskell, white space has meaning.</para>

    <para>Haskell uses indentation as a cue to parse sections of code.
      This use of layout to convey structure is sometimes called the
      offside rule. At the top level, the first declaration or
      definition can start in any column, and the Haskell compiler or
      interpreter remembers that indentation level.  Every subsequent
      top-level declaration must have the same indentation.</para>

    <para>Here's an illustration of the top-level indentation rule.
      Our first file, <filename>GoodIndent.hs</filename>, is well
      behaved.</para>

    &GoodIndent.hs:good;

    <para>Our second, <filename>BadIndent.hs</filename>, doesn't play
      by the rules.</para>

    &BadIndent.hs:bad;

    <para>Here's what happens when we try to load the two files into
      &ghci;.</para>

    &indent.ghci:load;

    <para>An empty line is treated as a continuation of the current
      item, as is a line indented to the right of the current current
      item.</para>

    <para>The rules for <code>let</code> expressions and
      <code>where</code> clauses are similar.  After a
      <code>let</code> or <code>where</code> keyword, the Haskell
      compiler or interpreter remembers the indentation of the next
      token it sees. If the next line is empty, or its indentation is
      further to the right than the previous line, this counts as
      continuing the previous line. On the other hand, if the
      indentation is the same as the previous line, this is treated as
      beginning a new item in the same block.</para>

    <para>Here are nested uses of <code>let</code> and
      <code>where</code>.</para>

    &letwhere.hs:let;

    <para>In the body of <varname>bar</varname>, the variable
      <varname>a</varname> is only visible within the <code>let</code>
      expression that defines it.  It's not visible to the
      <code>let</code> expression that defines <varname>b</varname>;
      only the <emphasis>result</emphasis> of the inner
      <code>let</code> expression is visible.</para>

    &letwhere.hs:where;

    <para>Similarly, the scope of the first <code>where</code> clause
      is the definition of <varname>foo</varname>, but the scope of
      the second is just the first <code>where</code> clause.</para>

    <para>The indentation we use for the <code>let</code> and
      <code>where</code> clauses makes our intentions easy to figure
      out.</para>

    <sect2>
      <title>A note about tabs versus spaces</title>

      <para>If you are using a Haskell-aware text editor (e.g. Emacs),
	it is probably already configured to use space characters for
	all white space within a line.  If your editor is
	<emphasis>not</emphasis> Haskell-aware, you should configure
	it to only use space characters.</para>

      <para>The reason for this is simple portability.  In an editor
	that uses a fixed-width font, tab stops are by default placed
	at different intervals on Unix-like systems (every eight
	characters) than on Windows  (every four characters). This
	means that no matter what your personal beliefs are about
	where tabs belong, you can't rely on someone else's editor
	honouring your preferences.  Any indentation that uses tabs is
	going to look broken under <emphasis>someone's</emphasis>
	configuration; this could lead to compilation problems, too.
	Using space characters instead avoids this problem
	entirely.</para>
    </sect2>

    <sect2>
      <title>The offside rule is not mandatory</title>

      <para>We can use explicit structuring instead of layout to
	indicate what we mean.  To do so, we start a block of
	equations with an opening curly brace; separate each item with
	a semicolon; and finish the block with a closing curly brace.
	The following two uses of <code>let</code> have the same
	meanings.</para>

      &Braces.hs:braces;

      <para>When we use explicit structuring, the normal layout rules
	don't apply, which is why we can get away with unusual
	indentation in the second <code>let</code> expression.</para>

      <para>We can use explicit structuring anywhere that we'd
	normally use layout.  It's valid for <code>where</code>
	clauses, and even top-level declarations.  Just remember that
	although the facility exists, explicit structuring is hardly
	ever actually <emphasis>used</emphasis> in Haskell
	programs.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Recursive types</title>

    <para>Here's a definition of a binary tree type.</para>

      &Tree.hs:Tree;

    <para>We call this a <emphasis>recursive</emphasis> type because
      <type>Tree</type>, the type we're defining, appears both on the
      left hand side and the right hand side of the definition: we
      define the type in terms of itself.</para>
  </sect1>

  <sect1>
    <title>A little more about lists</title>

    <para>Now that we're getting familiar with some of the jargon
      around types, we can revisit lists.  Haskell's list type is a
      parameterised type, because we can make lists of any other type.
      It is also an algebraic data type, with two constructors.  One
      is the empty list, written <code>[]</code> (sometimes pronounced
      <quote>nil</quote>, which is borrowed from Lisp).</para>

    &list.ghci:empty;

    <para>The other is the <function>(:)</function> operator, often
      pronounced <quote>cons</quote> (this is short for
      <quote>construct</quote>, and also borrowed from Lisp).  The
      <function>(:)</function> operator takes an element and a list,
      and constructs a new list.</para>

    &list.ghci:cons;

    <para>We can use <function>(:)</function> repeatedly to add new
      elements to the front of a list.</para>

    &list.ghci:cons2;

    <para>The right hand side of <function>(:)</function> must be a
      list, and of the correct type.  If it's not, we'll get an
      error.</para>

    &list.ghci:cons.bad;

    <para>Because <function>(:)</function> constructs a list from
      another list, the list type is recursive.  So here we have a
      built-in type that's parameterised, recursive, and
      algebraic.</para>

    <para>One consequence of lists being generic is that lists of
      lists, for example, aren't special in any way.</para>

    &list.ghci:listlist;

    <para>This has type <type>[[String]]</type>, a list of lists of
      strings.  But since <type>String</type> is just a synonym for
      <type>[Char]</type>, it's <emphasis>really</emphasis> a list of
      lists of lists of <type>Char</type>.  Whew!</para>
  </sect1>

  <sect1>
    <title>Unit, the zero-element tuple</title>

    <para>Haskell has a special tuple type with no elements, written
      <type>()</type>, and pronounced <quote>unit</quote>.</para>

    &unit.ghci:unit;

    <para>This type is only really used with parameterised data types,
      to indicate that one of the type parameters isn't being used.
      Since it doesn't encode any information, it's a rough equivalent
      to <code>void</code> in C.</para>

    <para>Here's an example of <type>()</type> in use.  We can
      generalise our earlier <type>Tree</type> type a little, so that
      internal nodes contain values of type <varname
	role="type">a</varname>, while leaves contain values of type
      <varname role="type">b</varname>.</para>

    &Tree.hs:ComplexTree;

    <para>If we wanted to create a <type>ComplexTree</type> where we
      wanted to store <type>Int</type>s on the leaves, but don't care
      about the internal nodes.  We would write its type as
      <type>ComplexTree () Int</type>.</para>
  </sect1>

  <sect1>
    <title>Pattern matching</title>

    <para>Although we introduced a handful of functions earlier that
      can operate on lists, we've yet to see how we might generally
      get values out of a constructed algebraic data type.  Haskell
      has a simple pattern matching facility that we can use to this
      end.</para>

    <para>A pattern lets us peer inside a compound value and bind
      variables to the values it contains.  In fact, when we define a
      function, the parameters to that function are really patterns
      that bind our variables to an entire value.</para>

    <para>Here's an example of pattern matching in action on a list;
      we're going to add all elements of the list together.</para>

    &add.hs:sumList;

    <para>See that <code>(x:xs)</code> on the left of the first line?
      The <code>:</code> means <quote>match the head of a
	list</quote>; that's the familiar list constructor,
      <function>(:)</function>, in action in a new way.  The variables
      <varname>x</varname> and <varname>xs</varname> are given the
      values of (<quote>bound to</quote>) the head and tail of the
      list, respectively.  The whole pattern is wrapped in parentheses
      so Haskell won't parse it as three separate arguments.</para>

    <para>What effect does pattern matching have? Haskell will only
      evaluate the right hand side of an equation if it can match all
      of the patterns on the left hand side.  In the definition of
      <function>sumList</function> above, the right hand side of the
      first equation won't be evaluated if the input list is empty.
      Instead, Haskell will <quote>fall through</quote> to the
      equation on the following line, which <emphasis>does</emphasis>
      have a pattern for the empty list, and it will evaluate
      that.</para>

    <para>It might initially look like we have two functions named
      <function>sumList</function> here, but Haskell lets us define a
      function as a series of equations, so in fact these two clauses
      are defining the behaviour of one function, for different
      inputs.  (By the way, there's a standard function,
      <function>sum</function>, that does </para>

    <para>The syntax for pattern matching on a tuple is similar to the
      syntax for constructing a tuple.  Here's a function that returns
      the third element from a three-tuple.</para>

    &Tuple.hs:third;

    <para>There's no limit on how <quote>deep</quote> within a value a
      pattern can look.  Here's a definition that looks both inside a
      tuple and inside a list within that tuple.</para>

    &Tuple.hs:complicated;

    <para>We can try this out interactively.</para>

    &tuple.ghci:complicated;

    <para>Wherever a literal value is present in a pattern, that value
      must match exactly for the pattern match to succeed.  If every
      pattern within a series of equations fails to match, we get a
      runtime error.</para>

    &tuple.ghci:nomatch;

    <para>We can pattern match on algebraic data types using their
      constructors.  Remember the <type>Wrapper</type> type we defined
      earlier?  Here's how we can extract a wrapped value from a
      <type>Wrapper</type>.</para>

    &Wrapper.hs:unwrap;

    <para>Let's see it in action.</para>

    &wrapper.ghci:unwrap;

    <para>Notice that Haskell infers the type of the
      <function>unwrap</function> function based on the constructor
      we're using in our pattern.  If we're trying to match a value
      whose constructor is <function>Wrapper</function>, then the type
      of that parameter must be <type>Wrapper a</type>.</para>
    
    <note>
      <para>Haskell tests patterns for matches in the order in which
	we list them in our code.  It goes from top to bottom and
	stops at the first match; it <emphasis>does not</emphasis>
	check every pattern and use the best match.</para>

      <para>If you're familiar with pattern matching from a logic
	programming language like Prolog, Haskell's facility is
	simpler and less powerful.  It doesn't provide backtracking or
	unification.</para>
    </note>

    <sect2>
      <title>The don't-care, or wild card, pattern</title>

      <para>When we're writing a pattern, we can specify that we don't
	care what value a particular value within a structure has,
	without actually binding that value to a name.  The notation
	for this is <code>_</code> (called a wild card or <quote>don't
	  care</quote>), and we use it as follows.  This function
	tells us whether the result of the <function>roots</function>
	function we defined earlier is real-valued or not.</para>

      &Roots.hs:isRealValued;

      <para>Here, we don't care about the value of the result, just
	about which constructor was used to create it.  If it was
	<function>Left</function>, the result must be a complex
	number, otherwise it must be real.  We can use a wild card for
	the entire second pattern; there's no need to see if the
	constructor is <function>Right</function>, because it
	<emphasis>must</emphasis> be; <type>Either</type> only has two
	constructors.</para>
    </sect2>

    <sect2>
      <title>The case expression</title>

      <para>We're not limited to using patterns in function
	definitions.  The <code>case</code> expression lets us match
	patterns at any time.  Here's what it looks like.</para>

      &Roots.hs:hasRealRoots;

      <para>The <code>case</code> keyword is followed by an arbitrary
	expression; the result of this expression is what we're
	pattern matching on.  The <code>of</code> keyword signifies
	the end of the expression and the beginning of the block of
	patterns and expressions.</para>

      <para>Each item in the block consists of a pattern, followed by
	an arrow <code>-&gt;</code>, followed by an expression to
	evaluate if that pattern matches.  The result of the
	<code>case</code> expression is the result of the expression
	associated with the first pattern to match, taken from top to
	bottom.</para>

      <para>To express <quote>here's the expression to evaluate if
	  none of the other patterns match</quote>, we would just use
	the wild card pattern <code>_</code> as the last in our list
	of patterns.</para>
    </sect2>

    <sect2>
      <title>A flying visit back to the where clause</title>

      <para>Now that we've seen that we can define a function as a
	series of equations, the usefulness of the <code>where</code>
	clause should be a bit more clear.  Variables that we define
	inside a <code>where</code> clause are visible across all of
	the equations that precede it in a single block.</para>
    </sect2>
    
  </sect1>

  <sect1>
    <title>Conditional evaluation with guards</title>

    <para>We can further extend our expressive arsenal using
      <emphasis>guards</emphasis>.  A guard is an expression of type
      <type>Bool</type>; if it evaluates to <function>True</function>,
      the equation that follows it is evaluated.  Otherwise, the next
      guard in the series is evaluated, and so on.  Here's an example
      of guards in action.</para>

    &Roots.hs:guardedRoots;

    <para>Each guard is introduced by a <code>|</code> symbol,
      followed by the guard expression, then an <code>=</code> symbol
      (or <code>-&gt;</code> if within a <code>case</code>
      expression), then the expression to evaluate if the guard
      succeeds.</para>

    <para>We can use guards anywhere that we can use patterns.  The
      combination of writing a function as a series of equations,
      pattern matching, and guards lets us write code that's
      clear and easy to understand.</para>

    <para>Remember the <function>myTake</function> function we defined
      in <xref linkend="hs.funcstypes.if"/>?</para>

    &myTake.hs:myTake.noid;

    <para>Here's a reformulation of that function using patterns and
      guards.  Instead of reasoning about what an <code>if</code>
      expression is doing and which branch will be evaluated, the code
      uses a series of equations with simple patterns and guards. This
      makes it easy to understand its behaviour under different
      circumstances.</para>

    &myTake.hs:niceTake;

  </sect1>

  <sect1>
    <title>Infix functions</title>

    <para>Usually, when we define or call a function in Haskell, we
      write the name of the function, followed by its arguments; this
      is called prefix notation, because the name of the function
      comes before its arguments.  For a function that takes two
      arguments, we have the option of using it in
      <emphasis>infix</emphasis> form, between its first and second
      arguments.  This allows us to write expressions using functions
      as if they were infix operators.</para>

    <para>The syntax for defining or calling a function in infix form
      is to enclose the name of the function in backtick characters
      (sometimes known as backquotes).  Here's a simple infix
      definition.</para>

    &Plus.hs:plus;

    <para>Defining a function in infix form doesn't change anything
      about the behaviour of the function.  We can call the function
      using infix or prefix notation, as we prefer.</para>

    &infix.ghci:plus;

    <para>Infix notation is useful for more than just our own
      functions.  For example, Haskell's standard
      <code>Data.List</code> module defines a function,
      <function>isPrefixOf</function>, that indicates whether all
      elements of its first argument are equal to the first elements
      of its second argument.</para>

    &infix.ghci:type;

    <para>Let's define a few variables in &ghci;.</para>

    &infix.ghci:vars;

    <para>If we call <function>isPrefixOf</function> using prefix
      notation, we can have a hard time remembering which argument
      we're checking for as a prefix of the other.</para>

    &infix.ghci:prefix;

    <para>But if we use infix notation, the code <quote>reads</quote>
      more naturally; it's now obvious that we're checking the
      variable on the left to see if it's a prefix of the variable on
      the right.</para>

    &infix.ghci:infix;

    <para>There's no hard-and-fast rule that dictates when you ought
      to use infix versus prefix notation, although prefix notation is
      far more common.  It's best to choose whichever makes your code
      more readable in a specific situation.</para>

    <note>
      <para>The backtick notation is not a general mechanism: it's a
	piece of special syntax that applies only to names.  For
	example, we can't put backticks around an expression that
	returns a function, and then treat that as an infix
	function.</para>
    </note>
  </sect1>

</chapter>
<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
