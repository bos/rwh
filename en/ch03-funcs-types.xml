<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="funcstypes" revision="alpha;beta">
  <title>Types and Functions</title>

  <para id="x_n2">Topics: built-in types.  Writing functions.</para>

  <sect1>
    <title>Why care about types?</title>

    <para id="x_p2">Every expression and function in Haskell has a
      <emphasis>type</emphasis>.  For example, the value
      <literal>True</literal>  has the type <type>Bool</type>, while
      the value <literal>"foo"</literal> has the type
      <type>String</type>.  The type of a value indicates that it
      shares certain properties with other values of the same type.
      For example, we can add numbers, and we can concatenate lists;
      these are properties of those types. We say an expression
      <quote>has type <code>X</code></quote>, or <quote>is of type
	<code>X</code></quote>.</para>
    
    <para id="x_ol">Before we launch into a deeper discussion of Haskell's type
      system, let's talk about why we should care about types at all:
      what are they even <emphasis>for</emphasis>?  At the lowest
      level, a computer is concerned with bytes, with barely any
      additional structure.  What a type system gives us is
      <emphasis>abstraction</emphasis>. A type adds meaning to plain
      bytes: it lets us say <quote>these bytes are text</quote>,
      <quote>those bytes are an airline reservation</quote>, and so
      on.  Usually, a type system goes beyond this to prevent us from
      accidentally mixing types up: for example, a type system usually
      won't let us treat a hotel reservation as a car rental
      receipt.</para>

    <para id="x_pl">The benefit of introducing abstraction is that it lets us
      forget or ignore low-level details.  If I know that a value in
      my program is a string, I don't have to know the intimate
      details of how strings are implemented: I can just assume that
      my string is going to behave like all the other strings I've
      worked with.</para>

    <para id="x_ql">What makes type systems interesting is that they're not all
      equal.  In fact, different type systems are often not even
      concerned with the same kinds of problems.  A programming
      language's type system deeply colours the way we think, and
      write code, in that language.</para>

    <para id="x_rl">Haskell's type system allows us to think at a very
      abstract level: it permits us to write concise, powerful
      programs.</para>
  </sect1>

  <sect1 id="funcstypes.types">
    <title>Haskell's type system</title>

    <para id="x_o2">There are three interesting aspects to types in
      Haskell: they are <emphasis>strong</emphasis>, they are
      <emphasis>static</emphasis>, and they can be automatically
      <emphasis>inferred</emphasis>.  Let's talk in more detail about
      each of these ideas.  When possible, we'll present similarities
      between concepts from Haskell's type system and related ideas in
      other languages.  We'll also touch on the respective strengths
      and weaknesses of each of these properties.</para>

    <sect2>
      <title>Strong types</title>

      <para id="x_q2">When we say that Haskell has a
	<emphasis>strong</emphasis> type system, we mean that the type
	system guarantees that a program cannot contain certain kinds
	of errors.  These errors come from trying to write expressions
	that don't make sense, such as using an integer as a function.
	For instance, if a function expects to work with integers, and we
	pass it a string, a Haskell compiler will reject this.</para>

      <para id="x_Yd">We call an expression that obeys a language's type
	rules <emphasis>well typed</emphasis>.  An expression that
	disobeys the type rules is <emphasis>ill typed</emphasis>, and
	will cause a <emphasis>type error</emphasis>.</para>

      <para id="x_BN">Another aspect of Haskell's view of strong
	typing is that it will not automatically coerce values from
	one type to another.  (Coercion is also known as casting or
	conversion.) For example, a C compiler will automatically and
	silently coerce a value of type <type>int</type> into a
	<type>float</type> on our behalf if a function expects a
	parameter of type <type>float</type>, but a Haskell compiler
	will raise a compilation error in a similar situation.  We
	must explicitly coerce types by applying coercion
	functions.</para>

      <para id="x_sl">Strong typing does occasionally make it more difficult to
	write certain kinds of code.  For example, a classic way to
	write low-level code in the C language is to be given a byte
	array, and cast it to treat the bytes as if they're really a
	complicated data structure.  This is very efficient, since it
	doesn't require us to copy the bytes around.  Haskell's type
	system does not allow this sort of coercion.  In order to get
	the same structured view of the data, we would need to do some
	copying, which would cost a little in performance.</para>

      <para id="x_tl">The huge benefit of strong typing is that it catches real
	bugs in our code before they can cause problems.  For example,
	in a strongly typed language, we can't accidentally use a
	string where an integer is expected.</para>

      <note>
	<title>Weaker and stronger types</title>

	<para id="x_r2">It is useful to be aware that many language
	  communities have their own definitions of a <quote>strong
	    type</quote>.  Nevertheless, we will speak briefly and in
	  broad terms about the notion of strength in type
	  systems.</para>

	<para id="x_ul">In academic computer science, the meanings of
	  <quote>strong</quote> and <quote>weak</quote> have a
	  narrowly technical meaning: strength refers to <emphasis>how
	    permissive</emphasis> a type system is. A weaker type
	  system treats more expressions as valid than a stronger type
	  system.</para>

	<para id="x_vl">For example, in Perl, the expression <code>"foo" +
	    2</code> evaluates to the number 2, but the expression
	  <code>"13foo" + 2</code> evaluates to the number 15. Haskell
	  rejects both expressions as invalid, because the
	  <function>(+)</function> operator requires both of its
	  operands to be numeric. Because Perl's type system is more
	  permissive than Haskell's, we say that it is weaker under
	  this narrow technical interpretation.</para>
	
	<para id="x_wl">The fireworks around type systems have their roots in
	  ordinary English, where people attach notions of
	  <emphasis>value</emphasis> to the words <quote>weak</quote>
	  and <quote>strong</quote>: we usually think of strength as
	  better than weakness. Many more programmers speak plain
	  English than academic jargon, and quite often academics
	  <emphasis>really are</emphasis> throwing brickbats at
	  whatever type system doesn't suit their fancy. The result is
	  often that popular Internet pastime, a flame war.</para>
      </note>
    </sect2>

    <sect2>
      <title>Static types</title>

      <para id="x_t2">Having a <emphasis>static</emphasis> type system
	means that the compiler knows the type of every value and
	expression at compile time, before any code is executed.  A
	Haskell compiler or interpreter will detect when we try to use
	expressions whose types don't match, and reject our code with
	an error message before we run it.</para>

      &ch03.basics.ghci:error;

      <para id="x_CN">This error message is of a kind we've seen
	before. The compiler has inferred that the type of the
	expression <literal>"false"</literal> is <type>[Char]</type>.
	The <function>(&amp;&amp;)</function> operator requires each
	of its operands to be of type <type>Bool</type>, and its left
	operand indeed has this type. Since the actual type of
	<literal>"false"</literal> does not match the required type,
	the compiler rejects this expression as ill typed.</para>
      
      <para id="x_xl">Static typing can occasionally make it difficult
	to write some useful kinds of code.  In languages like Python,
	<quote>duck typing</quote> is common, where an object acts
	enough like another to be used as a substitute for
	it<footnote>
	  <para><quote>If it walks like a duck, and quacks like a
	      duck, then let's call it a duck.</quote></para>
	</footnote>.  Fortunately, Haskell's system of
	<emphasis>typeclasses</emphasis>, which we will cover in <xref
	linkend="typeclasses"/>, provides almost all of the benefits
	of dynamic typing, in a safe and convenient form. For Haskell
	has some support for programming with truly dynamic types,
	though it is not quite as easy as in a language that
	wholeheartedly embraces the notion.</para>

      <para id="x_u2">Haskell's combination of strong and static
	typing makes it impossible for type errors to occur at
	runtime. While this means that we need to do a little more
	thinking <quote>up front</quote>, it also eliminates many
	simple errors that can otherwise be devilishly hard to find.
	It's a truism within the Haskell community that once code
	compiles, it's more likely to work correctly than in other
	languages. (Perhaps a more realistic way of putting this is
	that Haskell code often has fewer trivial bugs.)</para>

      <para id="x_yl">Programs written in dynamically typed languages require
	large suites of tests to give some assurance that simple type
	errors cannot occur.  Test suites cannot offer complete
	coverage: some common tasks, such as refactoring a program to
	make it more modular, can introduce new type errors that a
	test suite may not expose.</para>

      <para id="x_zl">In Haskell, the compiler proves the absence of type errors
	for us: a Haskell program that compiles will not suffer from
	type errors when it runs. Refactoring is usually a matter of
	moving code around, then recompiling and tidying up a few
	times until the compiler gives us the <quote>all
	  clear</quote>.</para>

      <para>A helpful analogy to understand the value of static typing
	is to look at it as putting pieces into a jigsaw puzzle. In
	Haskell, if a piece has the wrong shape, it simply won't fit.
	In a dynamically typed language, all the pieces are 1x1
	squares and always fit, so you have to constantly examine the
	resulting picture and check (through testing) whether it's
	correct.</para>
    </sect2>

    <sect2>
      <title>Type inference</title>

      <para id="x_v2">Finally, a Haskell compiler can automatically
	deduce the types of almost<footnote>
	  <para id="x_Am">Occasionally, we need to give the compiler a little
	    information to help it to make a choice in understanding
	    our code.</para>
	</footnote> all expressions in a program. This process is
	known as <emphasis>type inference</emphasis>. Haskell allows
	us to explicitly declare the type of any value, but the
	presence of type inference means that this is almost always
	optional, not something we are required to do.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>What to expect from the type system</title>

    <para id="x_Bm">Our exploration of the major capabilities and benefits of
      Haskell's type system will span a number of chapters.  Early on,
      you may find Haskell's types to be a chore to deal with.</para>

    <para id="x_Cm">For example, instead of simply writing some code
      and running it to see if it works as you might expect in Python
      or Ruby, you'll first need to make sure that your program passes
      the scrutiny of the type checker.  Why stick with the learning
      curve?</para>

    <para id="x_DN">While strong, static typing makes Haskell safe,
      type inference makes it concise.  The result is potent: we end
      up with a language that's both safer than popular statically
      typed languages, and often more expressive than dynamically
      typed languages.  This is a strong claim to make, and we will
      back it up with evidence throughout the book.</para>

    <para id="x_Dm">Fixing type errors may initially feel like more work than if
      you were using a dynamic language.  It might help to look at
      this as moving much of your debugging <emphasis>up
	front</emphasis>.  The compiler shows you many of the logical
      flaws in your code, instead of leaving you to stumble across
      problems at runtime.</para>

    <para id="x_Em">Furthermore, because Haskell can infer the types of your
      expressions and functions, you gain the benefits of static
      typing <emphasis>without</emphasis> the added burden of
      <quote>finger typing</quote> imposed by less powerful statically
      typed languages.  In other languages, the type system serves the
      needs of the compiler.  In Haskell, it serves
      <emphasis>you</emphasis>.  The tradeoff is that you have to
      learn to work within the framework it provides.</para>

    <para id="x_Fm">We will introduce new uses of Haskell's types throughout
      this book, to help us to write and test practical code.  As a
      result, the complete picture of why the type system is
      worthwhile will emerge gradually.  While each step should
      justify itself, the whole will end up greater than the sum of
      its parts.</para>
  </sect1>

  <sect1 id="funcstypes.basic">
    <title>Some common basic types</title>
    
    <para id="x_x2">In <xref
	linkend="starting.types"/>, we introduced a few types. Here
      are several more of the most common base types.</para>

    <itemizedlist>
      <listitem>
	<para id="x_y2">A <type>Char</type> value represents a Unicode
	  character.</para>
      </listitem>
      <listitem>
	<para id="x_z2">A <type>Bool</type> value represents a value
	  in Boolean logic.  The possible values of type
	  <type>Bool</type> are <code>True</code> and
	  <code>False</code>.</para>
      </listitem>
      <listitem>
	<para id="x_A3">The <type>Int</type> type is used for signed,
	  fixed-width integer values.  The exact range of values
	  representable as <type>Int</type> depends on the system's
	  longest <quote>native</quote> integer: on a 32-bit machine,
	  an <type>Int</type> is usually 32 bits wide, while on a
	  64-bit machine, it is usually 64 bits wide.  The Haskell
	  standard only guarantees that an <type>Int</type> is wider
	  than 28 bits.  (There exist numeric types that are exactly
	  8, 16, and so on bits wide, in signed and unsigned flavours;
	  we'll get to those later.)</para>
      </listitem>
      <listitem>
	<para id="x_B3">An <type>Integer</type> value is a signed
	  integer of unbounded size.  <type>Integer</type>s are not
	  used as often as <type>Int</type>s, because they are more
	  expensive both in performance and space consumption.  On the
	  other hand, <type>Integer</type> computations do not
	  silently overflow, so they give more reliably correct
	  answers.</para>
      </listitem>
      <listitem>
	<para id="x_C3">Values of type <type>Double</type> are used
	  for floating point numbers.  A <type>Double</type> value is
	  typically 64 bits wide, and uses the system's native
	  floating point representation.  (A narrower type,
	  <type>Float</type>, also exists, but its use is discouraged;
	  Haskell compiler writers concentrate more on making
	  <type>Double</type> efficient, so <type>Float</type> is much
	  slower.)</para>
      </listitem>
    </itemizedlist>

    <para id="x_w2">We have already briefly seen Haskell's notation
      for types in <xref linkend="starting.types"/>.  When we write a
      type explicitly, we use the notation <code>expression ::
	<type>MyType</type></code> to say that <code>expression</code>
      has the type <type>MyType</type>.  If we omit the
      <code>::</code> and the type that follows, a Haskell compiler
      will infer the type of the expression.</para>

    &ch03.basics.ghci:types;

    <para>The combination of <code>::</code> and the type after it is
      called a <emphasis>type signature</emphasis>.</para>
  </sect1>

  <sect1 id="funcstypes.calling">
    <title>Function application</title>

    <para id="x_Gm">Now that we've had our fill of data types for a while, let's
      turn our attention to <emphasis>working</emphasis> with some of
      the types we've seen, using functions.</para>

    <para id="x_R3">To apply a function in Haskell, we write the name
      of the function followed by its arguments.</para>

    &func.ghci:odd;

    <para id="x_kd">We don't use parentheses or commas to group or
      separate the arguments to a function; merely writing the name of
      the function, followed by each argument in turn, is enough. As
      an example, let's apply the <function>compare</function>
      function, which takes two arguments.</para>
    
    &func.ghci:compare;

    <para id="x_U3">If you're used to function call syntax in other
      languages, this notation can take a little getting used to, but
      it's simple and uniform.</para>

    <para id="x_Hm">Function application has higher precedence than using
      operators, so the following two expressions have the same
      meaning.</para>

    &func.ghci:precedence;

    <para id="x_Im">The above parentheses don't do any harm, but they
      add some visual noise.  Sometimes, however, we
      <emphasis>must</emphasis> use parentheses to indicate how we
      want a complicated expression to be parsed.</para>

    &func.ghci:precedence2;

    <para id="x_Jm">This applies <function>compare</function> to the
      results of applying <code>sqrt 3</code> and <code>sqrt 6</code>,
      respectively.  If we omit the parentheses, it looks like we are
      trying to pass four arguments to <function>compare</function>,
      instead of the two it accepts.</para>
  </sect1>

  <sect1 id="funcstypes.composite">
    <title>Useful composite data types: lists and tuples</title>

    <para id="x_D3">A composite data type is constructed from other
      types.  The most common composite data types in Haskell are
      lists and tuples.</para>

    <para id="x_E3">We've already seen the list type mentioned in
      <xref
	linkend="starting.string"/>, where we found that Haskell
      represents a text string as a list of <type>Char</type> values,
      and that the type <quote>list of <type>Char</type></quote> is
      written <type>[Char]</type>.</para>

    <para id="x_Km">The <function>head</function> function returns the
      first element of a list.</para>

    &func.ghci:head;

    <para id="x_S3">Its counterpart, <function>tail</function>,
      returns all <emphasis>but</emphasis> the head of a list.</para>

    &func.ghci:tail;

    <para id="x_F3">As you can see, we can apply
      <function>head</function> and <function>tail</function> to lists
      of different types.  Applying <function>head</function> to a
      <type>[Char]</type> value returns a <type>Char</type> value,
      while applying it to a <type>[Bool]</type> value returns a
      <type>Bool</type> value.  The <function>head</function> function
      doesn't care what type of list it deals with.</para>

    <para id="x_Lm">Because the values in a list can have any type, we
      call the list type <emphasis>polymorphic</emphasis><footnote>
	<para id="x_Mm">We'll talk more about polymorphism in <xref
	    linkend="funcstypes.polymorphism"/>.</para>
      </footnote>.  When we want to write a polymorphic type, we use a
      <emphasis>type variable</emphasis>, which must begin with a
      lowercase letter.  A type variable is a placeholder, where
      eventually we'll substitute a real type.</para>

    <para id="x_Nm">We can write the type <quote>list of <varname
	  role="type">a</varname></quote> by enclosing the type
      variable in square brackets: <type>[a]</type>.  This amounts to
      saying <quote>I don't care what type I have; I can make a list
	with it</quote>.</para>

    <note>
      <title>Distinguishing type names and type variables</title>

      <para id="x_Om">We can now see why a type name must start with
	an uppercase letter: this makes it distinct from a type
	variable, which must start with a lowercase letter.</para>
    </note>

    <para id="x_bd">When we talk about a list with values of a
      specific type, we substitute that type for our type variable.
      So, for example, the type <type>[Int]</type> is a list of values
      of type <type>Int</type>, because we substituted
      <type>Int</type> for <varname role="type">a</varname>.
      Similarly, the type <type>[MyPersonalType]</type> is a list of
      values of type <type>MyPersonalType</type>.  We can perform this
      substitution recursively, too: <type>[[Int]]</type> is a list of
      values of type <type>[Int]</type>, i.e. a list of lists of
      <type>Int</type>.</para>

    &usingtypes.ghci:listlist;

    <para>The type of this expression is a list of lists of
      <type>Bool</type>.</para>

    <note>
      <title>Lists are special</title>

      <para id="x_G3">Lists are the <quote>bread and butter</quote> of
	Haskell collections. In an imperative language, we might
	perform a task many items by iterating through a loop.  This
	is something that we often do in Haskell by traversing a list,
	either by recursing or using a function that recurses for us.
	Lists are the easiest stepping stone into the idea that we can
	use data to structure our program and its control flow. We'll
	be spending a lot more time discussing lists in
	<xref linkend="fp"/>.</para>
    </note>

    <para id="x_H3">A tuple is a fixed-size collection of values,
      where each value can have a different type.  This distinguishes
      them from a list, which can have any length, but whose elements
      must all have the same type.</para>

    <para id="x_Pm">To help to understand the difference, let's say we
      want to track two pieces of information about a book.  It has a
      year of publication, which is a number, and a title, which is a
      string. We can't keep both of these pieces of information in a
      list, because they have different types.  Instead, we use a
      tuple.</para>

    &tuple.ghci:book;

    <para id="x_dd">We write a tuple by enclosing its elements in
      parentheses and separating them with commas.  We use the same
      notation for writing its type.</para>

    &tuple.ghci:tuple;

    <para id="x_ed">There's a special type, <type>()</type>, that acts
      as a tuple of zero elements.  This type has only one value, also
      written <code>()</code>.  Both the type and the value are
      usually pronounced <quote>unit</quote>.  If you are familiar
      with C, <type>()</type> is somewhat similar to
      <type>void</type>.</para>
    
    <para id="x_fd">Haskell doesn't have a notion of a one-element
      tuple. Tuples are often referred to using the number of elements
      as a prefix. A 2-tuple has two elements, and is usually called a
      <emphasis>pair</emphasis>.  A <quote>3-tuple</quote> (sometimes
      called a <emphasis>triple</emphasis>) has three elements; a
      5-tuple has five; and so on. In practice, working with tuples
      that contain more than a handful of elements makes code
      unwieldy, so tuples of more than a few elements are rarely
      used.</para>

    <para id="x_gd">A tuple's type represents the number, positions,
      and types of its elements.  This means that tuples containing
      different numbers or types of elements have distinct types, as
      do tuples whose types appear in different orders.</para>

    &tuple.ghci:type1;

    <para id="x_hd">In this example, the expression <code>(False,
	'a')</code> has the type <type>(Bool, Char)</type>, which is
      distinct from the type of <code>('a', False)</code>. Even though
      the number of elements and their types are the same, these two
      types are distinct because the positions of the element types
      are different.</para>

    &tuple.ghci:type2;

    <para id="x_id">This type, <type>(Bool, Char, Char)</type>, is
      distinct from <type>(Bool, Char)</type> because it contains
      three elements, not two.</para>

    <para id="x_K3">We often use tuples to return multiple values from
      a function.  We can also use them any time we need a fixed-size
      collection of values, if the circumstances don't require a
      custom container type.</para>

    <sect2 id="funcstypes.composite.exercises">
      <title>Exercises</title>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_L3">What are the types of the following
	      expressions?</para>
	    <itemizedlist>
	      <listitem>
		<para id="x_M3"><code>False</code></para>
	      </listitem>
	      <listitem>
		<para id="x_N3"><code>(["foo", "bar"],
		    'a')</code></para>
	      </listitem>
	      <listitem>
		<para id="x_O3"><code>[(True, []), (False,
		    [['a']])]</code></para>
	      </listitem>
	    </itemizedlist>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>Functions over lists and tuples</title>

    <para id="x_Q3">Our discussion of lists and tuples mentioned how
      we can construct them, but little about how we do anything with
      them afterwards.  We have only been introduced to two list
      functions so far,
      <function>head</function> and <function>tail</function>.</para>

    <para id="x_T3">A related pair of list functions,
      <function>take</function> and <function>drop</function>, take
      two arguments.  Given a number <varname>n</varname> and a list,
      <function>take</function> returns the first <varname>n</varname>
      elements of the list, while <function>drop</function> returns
      all <emphasis>but</emphasis> the first <varname>n</varname>
      elements of the list.  (As these functions take two arguments,
      notice that we separate each function and its arguments
      using white space.)</para>

    &func.ghci:takeDrop;

    <para id="x_ld">For tuples, the <function>fst</function> and
      <function>snd</function> functions return the first and second
      element of a pair, respectively.</para>

    &tuple.ghci:fst;

    <para id="x_Qm">If your background is in any of a number of other languages,
      each of these may look like an application of a function to two
      arguments. Under Haskell's convention for function application,
      each one is an application of a function to a single pair.</para>

    <note>
      <title>Haskell tuples aren't immutable lists</title>

      <para id="x_md">If you are coming from the Python world, you'll
	probably be used to lists and tuples being almost
	interchangeable. Although the elements of a Python tuple are
	immutable, it can be indexed and iterated over using the same
	methods as a list. This isn't the case in Haskell, so don't
	try to carry that idea with you into unfamiliar linguistic
	territory.</para>

      <para id="x_nd">As an illustration, take a look at the type
	signatures of <function>fst</function> and
	<function>snd</function>: they're defined
	<emphasis>only</emphasis> for pairs, and can't be used with
	tuples of other sizes.  Haskell's type system makes it tricky
	to write a generalised <quote>get the second element from any
	  tuple, no matter how wide</quote> function.</para>
    </note>

    <sect2 id="funcstypes.calling.expr">
      <title>Passing an expression to a function</title>

      <para id="x_X3">In Haskell, function application is left
	associative.  This is best illustrated by example: the
	expression <code>a b c d</code> is equivalent to <code>(((a b)
	  c) d)</code>. If we want to use one expression as an
	argument to another, we have to use explicit parentheses to
	tell the parser what we really mean.  Here's an
	example.</para>

      &func.ghci:headDrop;

      <para id="x_Y3">We can read this as <quote>pass the expression
	  <code>drop 4 "azerty"</code> as the argument to
	  <function>head</function></quote>.  If we were to leave out
	the parentheses, the offending expression would be similar to
	passing three arguments to <function>head</function>.
	Compilation would fail with a type error, as
	<function>head</function> requires a single argument, a
	list.</para>
    </sect2>
  </sect1>

  <sect1 id="funcstypes.sigs">
    <title>Function types and purity</title>

    <para id="x_Z3">Let's take a look at a function's type.</para>

    &func.ghci:lines.type;

    <para id="x_a3">We can read the <literal>-&gt;</literal> above as
      <quote>to</quote>, which loosely translates to
      <quote>returns</quote>.  The signature as a whole thus reads as
      <quote><function>lines</function> has the type
	<type>String</type> to list-of-<type>String</type></quote>.
      Let's try applying the function.</para>

    &func.ghci:lines;

    <para id="x_b3">The <function>lines</function> function splits a
      string on line boundaries. Notice that its type signature gave
      us a hint as to what the function might actually do: it takes
      one <type>String</type>, and returns many.  This is an
      incredibly valuable property of types in a functional
      language.</para>

    <para id="x_ce">A <emphasis>side effect</emphasis> introduces a
      dependency between the global state of the system and the
      behaviour of a function.  For example, let's step away from
      Haskell for a moment and think about an imperative programming
      language.  Consider a function that reads and returns the value
      of a global variable.  If some other code can modify that global
      variable, then the result of a particular application of our
      function depends on the current value of the global variable.
      The function has a side effect, even though it never modifies
      the variable itself.</para>

    <para id="x_Rm">Side effects are essentially invisible inputs to, or outputs
      from, functions.  In Haskell, the default is for functions to
      <emphasis>not</emphasis> have side effects: the result of a
      function depends only on the inputs that we explicitly provide.
      We call these functions <emphasis>pure</emphasis>; functions
      with side effects are <emphasis>impure</emphasis>.</para>

    <para id="x_Sm">If a function has side effects, we can tell by reading its
      type signature: the type of the function's result will begin
      with <type>IO</type>.</para>

    &ch03.basics.ghci:readFile;

    <para id="x_Tm">Haskell's type system prevents us from accidentally mixing
      pure and impure code.</para>
  </sect1>

  <sect1 id="funcstypes.srcfile">
    <title>Haskell source files, and writing simple functions</title>

    <para id="x_h3">Now that we know how to apply functions, it's time
      we turned our attention to writing them.  While we can write
      functions in &ghci;, it's not a good environment for this.  It
      only accepts a highly restricted subset of Haskell: most
      importantly, the syntax it uses for defining functions is not
      the same as we use in a Haskell source file<footnote>
	<para>The environment in which &ghci; operates is called the
	  &IO; monad.  In <xref
	  linkend="io"/>, we will cover the &IO; monad in depth, and
	  the seemingly arbitrary restrictions that &ghci; places on
	  us will make more sense.</para>
      </footnote>. Instead, we'll finally break down and create a
      source file.</para>

    <para id="x_i3">Haskell source files are usually identified with a suffix of
      <filename>.hs</filename>.  Here's a simple function definition:
      open up a file named <filename>add.hs</filename>, and add these
      contents to it.</para>

    &add.hs:add;

    <para id="x_j3">On the left hand side of the <literal>=</literal> is the
      name of the function, followed by the arguments to the function.
      On the right hand side is the body of the function.  With our
      source file saved, we can load it into &ghci;, and use our new
      <function>add</function> function straight away.  (The prompt
      that &ghci; displays will change after you load your file.)</para>

    &add.ghci:add;

    <note>
      <title>What if ghci cannot find your source file?</title>

      <para id="x_od">When you run &ghci; it may not be able to find your source
	file.  It will search for source files in whatever directory
	it was run.  If this is not the directory that your source
	file is actually in, you can use &ghci;'s <code>:cd</code>
	command to change its working directory.</para>

      &cd.ghci:cd;

      <para id="x_pd">Alternatively, you can provide the path to your Haskell
	source file as the argument to <code>:load</code>.   This path
	can be either absolute or relative to &ghci;'s current
	directory.</para>
    </note>

    <para id="x_k3">When we apply <function>add</function> to the
      values <literal>1</literal> and <literal>2</literal>, the
      variables <varname>a</varname> and <varname>b</varname> on the
      left hand side of our definition are given (or <quote>bound
	to</quote>) the values <literal>1</literal> and
      <literal>2</literal>, so the result is the expression <code>1 +
	2</code>.</para>

    <para id="x_l3">Haskell doesn't have a <command>return</command>
      keyword, as a function is a single expression, not a sequence of
      statements.  The value of the expression is the result of the
      function.  (Haskell does have a function called
      <function>return</function>, but we won't discuss it for a
      while; it has a different meaning than in imperative
      languages.)</para>

    <para id="x_qd">When you see an <literal>=</literal> symbol in Haskell code,
      it represents <quote>meaning</quote>: the name on the left
      is defined to be the expression on the right.</para>

    <sect2 id="funcstypes.variable">
      <title>Just what is a variable, anyway?</title>

      <para id="x_sK">In Haskell, a variable provides a way to
	give a name to an expression.  Once a variable is
	<emphasis>bound to</emphasis> (i.e. associated with) a
	particular expression, its value does not change: we can
	always use the name of the variable instead of writing out the
	expression, and get the same result either way.</para>

      <para id="x_rK">If you're used to imperative programming
	languages, you're likely to think of a variable as a way of
	identifying a <emphasis>memory location</emphasis> (or some
	equivalent) that can hold different values at different times.
	In an imperative language we can change a variable's value at
	any time, so that examining the memory location repeatedly can
	potentially give different results each time.</para>

      <para id="x_rd">The critical difference between these two notions of a
	variable is that in Haskell, once we've bound a variable to an
	expression, we know that we can always substitute it for that
	expression, because it will not change.  In an imperative
	language, this notion of substitutability does not
	hold.</para>

      <para id="x_Um">For example, if we run the following tiny Python script,
	it will print the number 11.</para>

      &assign.py:assign;

      <para id="x_Vm">In contrast, trying the equivalent in Haskell results in
	an error.</para>

      &Assign.hs:assign;

      <para id="x_Wm">We cannot assign a value to <varname>x</varname>
	twice.</para>

      &assign.ghci:load;
    </sect2>

    <sect2 id="funcstypes.if">
      <title>Conditional evaluation</title>

      <para id="x_m3">Like many other languages, Haskell has an
	<code>if</code> expression.  Let's see it in action, then
	we'll explain what's going on.  As an example, we'll write our
	own version of the standard <function>drop</function>
	function. Before we begin, let's probe a little into how
	<function>drop</function> behaves, so we can replicate its
	behaviour.</para>

      &myDrop.ghci:drop;

      <para id="x_n3">From the above, it seems that
	<function>drop</function> returns the original list if the
	number to remove is less than or equal to zero.  Otherwise, it
	removes elements until either it runs out or reaches the given
	number. Here's a <function>myDrop</function> function that has
	the same behaviour, and uses Haskell's <code>if</code>
	expression to decide what to do.  The
	<function>null</function> function below checks whether a list
	is empty.</para>

      &myDrop.hs:myDrop;

      <para id="x_Ym">In Haskell, indentation is important: it
	<emphasis>continues</emphasis> an existing definition, instead
	of starting a new one.  Don't omit the indentation!</para>

      <para>You might wonder where the variable name
	<varname>xs</varname> comes from in the Haskell function. This
	is a common naming pattern for lists: you can read the
	<code>s</code> as a suffix, so the name is essentially
	<quote>plural of <varname>x</varname></quote>.</para>

      <para id="x_o3">Let's save our Haskell function in a file named
	<filename>myDrop.hs</filename>, then load it into
	&ghci;.</para>

      &myDrop.ghci:myDrop;

      <para id="x_p3">Now that we've seen <function>myDrop</function>
	in action, let's return to the source code and look at all the
	novelties we've introduced.</para>

      <para id="x_wd">First of all, we have introduced
	<code>--</code>, the beginning of a single-line comment.  This
	comment extends to the end of the line.</para>

      <para id="x_q3">Next is the <code>if</code> keyword itself.  It
	introduces an expression that has three components.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_xd">An expression of type <type>Bool</type>,
	    immediately following the &if;.  We refer to this as a
	    <emphasis>predicate</emphasis>.</para>
	</listitem>
	<listitem>
	  <para id="x_yd">A <code>then</code> keyword, followed by
	    another expression.  This expression will be used as the
	    value of the &if; expression if the predicate evaluates to
	    <code>True</code>.</para>
	</listitem>
	<listitem>
	  <para id="x_zd">An <code>else</code> keyword, followed by
	    another expression.  This expression will be used as the
	    value of the &if; expression if the predicate evaluates to
	    <code>False</code>.</para>
	</listitem>
      </itemizedlist>

      <para id="x_Ae">We'll refer to the expressions after the
	<code>then</code> and <code>else</code> keywords as
	<quote>branches</quote>. The branches must have the same
	types; the &if; expression will also have this type.  An
	expression such as <code>if True then 1 else "foo"</code> has
	different types for its branches, so it is ill typed and will
	be rejected by a compiler or interpreter.</para>

      <para id="x_Zm"></para>

      <para id="x_s3">Recall that Haskell is an expression-oriented
	language.  In an imperative language, it can make sense to
	omit the <code>else</code> branch from an <code>if</code>,
	because we're working with <emphasis>statements</emphasis>,
	not expressions.  However, when we're working with
	expressions, an <code>if</code> that was missing an
	<code>else</code> wouldn't have a result or type if the
	predicate evaluated to <function>False</function>, so it would
	be nonsensical.</para>

      <para id="x_t3">Our predicate contains a few more novelties. The
	<function>null</function> function indicates whether a list is
	empty, while the <function>(||)</function> operator performs a
	logical <quote>or</quote> of its <type>Bool</type>-typed
	arguments.</para>

      &myDrop.ghci:null;

      <tip>
	<title>Operators are not special</title>

	<para id="x_Be">Notice that we were able to find the type of
	  <function>(||)</function> by wrapping it in parentheses. The
	  <function>(||)</function> operator isn't <quote>built
	    into</quote> the language: it's an ordinary
	  function.</para>

	<para id="x_am">The <function>(||)</function> operator
	  <quote>short circuits</quote>: if its left operand evaluates
	  to <code>True</code>, it doesn't evaluate its right operand.
	  In most languages, short-circuit evaluation requires special
	  support, but not in Haskell.  We'll see why shortly.</para>
      </tip>

      <para id="x_u3">Next, our function applies itself recursively.
	This is our first example of recursion, which we'll talk about
	in some detail shortly.</para>

      <para id="x_v3">Finally, our <code>if</code> expression spans
	several lines.  We align the <code>then</code> and
	<code>else</code> branches under the <code>if</code> for
	neatness.  So long as we use some indentation, the exact
	amount is not important.  If we wish, we can write the
	entire expression on a single line.</para>

      &myDrop.hs:myDrop2;

      <para>The length of this version makes it more difficult to
	read.  We will usually break an &if; expression across several
	lines to keep the predicate and each of the branches easier to
	follow.</para>

      <para>For comparison, here is a Python equivalent of the Haskell
	<function>myDrop</function>.  The two are structured
	similarly: each decrements a counter while removing an element
	from the head of the list.</para>

      &myDrop.py:myDrop;

    </sect2>
  </sect1>

  <sect1>
    <title>Understanding evaluation by example</title>

    <para id="x_Ce">In our description of <function>myDrop</function>,
      we have so far focused on surface features.  We need to go
      deeper, and develop a useful mental model of how function
      application works. To do this, we'll first work through a few
      simple examples, until we can walk through the evaluation of the
      expression <code>myDrop 2 "abcd"</code>.</para>

    <para id="x_De">We've talked several times about substituting an
      expression for a variable, and we'll make use of this capability
      here. Our procedure will involve rewriting expressions over and
      over, substituting expressions for variables until we reach a
      final result. This would be a good time to fetch a pencil and
      paper, so that you can follow our descriptions by trying them
      yourself.</para>

    <sect2>
      <title>Lazy evaluation</title>

      <para id="x_bm">We will begin by looking at the definition of a simple,
	nonrecursive function.</para>

      &RoundToEven.hs:odd;

      <para id="x_cm">Here, <function>mod</function> is the standard modulo
	function.  The first big step to understanding how evaluation
	works in Haskell is figuring out what the result of evaluating
	the expression <code>isOdd (1 + 2)</code> is.</para>

      <para id="x_dm">Before we explain how evaluation proceeds in
	Haskell, let us recap the sort of evaluation strategy used by
	more familiar languages.  First, evaluate the subexpression
	<code>1 + 2</code>, to give <code>3</code>.  Then apply the
	<function>odd</function> function with <varname>n</varname>
	bound to <code>3</code>.  Finally, evaluate <code>mod 3
	  2</code> to give <code>1</code>, and <code>1 == 1</code> to
	give <code>True</code>.</para>

      <para id="x_em">In a language that uses
	<emphasis>strict</emphasis> evaluation, the arguments to a
	function are evaluated before the function is applied.
	Haskell chooses another path: <emphasis>non-strict</emphasis>
	evaluation.</para>

      <para id="x_fm">In Haskell, the subexpression <code>1 + 2</code>
	is <emphasis>not</emphasis> reduced to the value
	<code>3</code>. Instead, we create a <quote>promise</quote>
	that when the value of the expression <code>isOdd (1 + 2)</code>
	is needed, we'll be able to compute it.  The record that we
	use to track an unevaluated expression is referred to as a
	<emphasis>thunk</emphasis>.  This is <emphasis>all</emphasis>
	that happens: we create a thunk, and defer the actual
	evaluation until it's really needed. If the result of this
	expression is never subsequently used, we will not compute its
	value at all.</para>

      <para id="x_gm">Non-strict evaluation is often referred to as
	<emphasis>lazy evaluation</emphasis><footnote>
	  <para>The terms <quote>non-strict</quote> and
	    <quote>lazy</quote> have slightly different technical
	    meanings, but we won't go into the details of the
	    distinction here.</para>
	</footnote>.</para>
    </sect2>

    <sect2>
      <title>A more involved example</title>

      <para id="x_om">Let us now look at the evaluation of the
	expression <code>myDrop 2 "abcd"</code>, where we use
	<function>print</function> to ensure that it will be
	evaluated.</para>

      &myDrop.ghci:print;

      <para id="x_pm">Our first step is to attempt to apply
	<function>print</function>, which needs its argument to be
	evaluated.  To do that, we apply the function
	<function>myDrop</function> to the values <code>2</code> and
	<code>"abcd"</code>.  We bind the variable
	<varname>n</varname> to the value <code>2</code>, and
	<varname>xs</varname> to <code>"abcd"</code>. If we substitute
	these values into <function>myDrop</function>'s predicate, we
	get the following expression.</para>

      &myDrop.ghci:myDrop1;

      <para id="x_Fe">We then evaluate enough of the predicate to find
	out what its value is.  This requires that we evaluate the
	<function>(||)</function> expression.  To determine its value,
	the <function>(||)</function> operator needs to examine the
	value of its left operand first.</para>

      &myDrop.ghci:myDrop2;

      <para id="x_Ge">Substituting that value into the
	<function>(||)</function> expression leads to the following
	expression.</para>

      &myDrop.ghci:myDrop2a;

      <para id="x_He">If the left operand had evaluated to
	<literal>True</literal>, <function>(||)</function> would not
	need to evaluate its right operand, since it could not affect
	the result of the expression. Since it evaluates to
	<literal>False</literal>, <function>(||)</function> must
	evaluate the right operand.</para>

      &myDrop.ghci:myDrop3;

      <para id="x_Ie">We now substitute this value back into the
	<function>(||)</function> expression.  Since both operands
	evaluate to <literal>False</literal>, the
	<function>(||)</function> expression does too, and thus the
	predicate evaluates to <literal>False</literal>.</para>

      &myDrop.ghci:myDrop4;

      <para id="x_Je">This causes the &if; expression's
	<code>else</code> branch to be evaluated. This branch contains
	a recursive application of <function>myDrop</function>.</para>

      <note>
	<title>Short circuiting for free</title>

	<para id="x_qm">Many languages need to treat the logical-or
	  operator specially so that it short circuits if its left
	  operand evaluates to <code>True</code>.  In Haskell,
	  <function>(||)</function> is an ordinary function:
	  non-strict evaluation builds this capability into the
	  language.</para>

	<para>In Haskell, we can easily define a new function that
	  short circuits.</para>

	&shortCircuit.hs:newOr;

	<para>If we write an expression like <code>newOr True (length
	    [1..] &gt; 0)</code>, it will not evaluate its second
	  argument.  (This is just as well: that expression tries to
	  compute the length of an infinite list.  If it were
	  evaluated, it would hang &ghci;, looping infinitely until we
	  killed it.)</para>

	<para>Were we to write a comparable function in, say, Python,
	  strict evaluation would bite us: both arguments would be
	  evaluated before being passed to <function>newOr</function>,
	  and we would not be able to avoid the infinite loop on the
	  second argument.</para>
      </note>
    </sect2>

    <sect2>
      <title>Recursion</title>

      <para id="x_Ke">When we apply <function>myDrop</function>
	recursively, <varname>n</varname> is bound to the thunk
	<code>2 - 1</code>, and <varname>xs</varname> to <code>tail
	  "abcd"</code>.</para>

      <para id="x_Le">We're now evaluating <function>myDrop</function> from the
	beginning again.  We substitute the new values of
	<varname>n</varname> and <varname>xs</varname> into the
	predicate.</para>

      &myDrop.ghci:myDrop5;

      <para id="x_Me">Here's a condensed version of the evaluation of the left
	operand.</para>

      &myDrop.ghci:myDrop6;

      <para id="x_Ne">As we should now expect, we didn't evaluate the
	expression <code>2 - 1</code> until we needed its value.  We
	also evaluate the right operand lazily, deferring <code>tail
	  "abcd"</code> until we need its value.</para>

      &myDrop.ghci:myDrop7;
    
      <para id="x_Oe">The predicate again evaluates to <literal>False</literal>,
	causing the <code>else</code> branch to be evaluated once
	more.</para>

      <para id="x_Pe">Because we've had to evaluate the expressions for
	<varname>n</varname> and <varname>xs</varname> to evaluate the
	predicate, we now know that in this application of
	<function>myDrop</function>, <varname>n</varname> has the
	value <code>1</code> and <varname>xs</varname> has the value
	<code>"bcd"</code>.</para>
    </sect2>

    <sect2>
      <title>Ending the recursion</title>

      <para id="x_Qe">In the next recursive application of
	<function>myDrop</function>, we bind <varname>n</varname> to
	<code>1 - 1</code> and <varname>xs</varname> to <function>tail
	  "bcd"</function>.</para>

      &myDrop.ghci:myDrop9;

      <para id="x_Re">Once again, <function>(||)</function> needs to evaluate
	its left operand first.</para>

      &myDrop.ghci:myDrop10;

      <para id="x_Se">Finally, this expression has evaluated to
	<literal>True</literal>!</para>

      &myDrop.ghci:myDrop11;

      <para id="x_Te">Because the right operand cannot affect the result of
	<function>(||)</function>, it is not evaluated, and the result
	of the predicate is <literal>True</literal>.  This causes us
	to evaluate the <code>then</code> branch.</para>

      &myDrop.ghci:myDrop12;

    </sect2>

    <sect2>
      <title>Returning from the recursion</title>

      <para id="x_Ue">Remember, we're now inside our second recursive
	application of <function>myDrop</function>.  This application
	evaluates to <code>tail "bcd"</code>.  We return from the
	application of the function, substituting this expression for
	<code>myDrop (1 - 1) (tail "bcd")</code>, to become the result
	of this application.</para>

      &myDrop.ghci:myDrop13;

      <para id="x_Ve">We then return from the first recursive application,
	substituting the result of the second recursive application for
	<code>myDrop (2 - 1) (tail "abcd")</code>, to become the
	result of this application.</para>

      &myDrop.ghci:myDrop14;

      <para id="x_We">Finally, we return from our original
	application, substituting the result of the first recursive
	application.</para>

      &myDrop.ghci:myDrop15;

      <para id="x_Xe">Notice that as we return from each successive recursive
	application, none of them needs to evaluate the expression <code>tail
	  "bcd"</code>: the final result of evaluating the original expression is
	a <emphasis>thunk</emphasis>.  The thunk is only
	finally evaluated when &ghci; needs to print it.</para>

      &myDrop.ghci:myDrop16;
    </sect2>

    <sect2>
      <title>What have we learned?</title>

      <para id="x_Ye">We have established several important points here.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_Ze">It makes sense to use substitution and rewriting to
	    understand the evaluation of a Haskell expression.</para>
	</listitem>

	<listitem>
	  <para id="x_ae">Laziness leads us to defer evaluation until we need a
	    value, and to evaluate just enough of an expression to
	    establish its value.</para>
	</listitem>

	<listitem>
	  <para id="x_be">The result of applying a function may be a
	    thunk (a deferred expression).</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="funcstypes.polymorphism">
    <title>Polymorphism in Haskell</title>

    <para id="x_he">When we introduced lists, we mentioned that the
      list type is polymorphic.  We'll talk about Haskell's
      polymorphism in more detail here.</para>

    <para id="x_ie">If we want to fetch the last element of a list, we
      use the <function>last</function> function.  The value that it
      returns must have the same type as the elements of the list, but
      <function>last</function> operates in the same way no matter
      what type those elements actually are.</para>

    &func.ghci:last;

    <para id="x_je">To capture this idea, its type signature contains
      a <emphasis>type variable</emphasis>.</para>

    &func.ghci:last.type;

    <para id="x_ke">Here, <varname role="type">a</varname> is the type variable.
      We can read the signature as <quote>takes a list, all of whose
	elements have some type <varname role="type">a</varname>, and
	returns a value of the same type <varname
	  role="type">a</varname></quote>.</para>

    <tip>
      <title>Identifying a type variable</title>

      <para id="x_le">Type variables always start with a lowercase letter.  You
	can always tell a type variable from a normal variable by
	context, because the languages of types and functions are
	separate: type variables live in type signatures, and regular
	variables live in normal expressions.</para>

      <para id="x_me">It's common Haskell practice to keep the names of type
	variables very short.  One letter is overwhelmingly common;
	longer names show up infrequently.
	Type signatures are usually brief; we gain more in
	readability by keeping names short than we would by making
	them descriptive.</para>
    </tip>

    <para id="x_c3">When a function has type variables in its
      signature, indicating that some of its arguments can be of any
      type, we call the function polymorphic.</para>

    <para id="x_ne">When we want to apply <function>last</function>
      to, say, a list of <type>Char</type>, the compiler substitutes
      <type>Char</type> for each <varname role="type">a</varname>
      throughout the type signature, which gives us the type of
      <function>last</function> with an input of <type>[Char]</type>
      as <type>[Char] -&gt; Char</type>.</para>

    <para id="x_oe">This kind of polymorphism is called
      <emphasis>parametric</emphasis> polymorphism.  The choice of
      naming is easy to understand by analogy: just as a function can
      have parameters that we can later bind to real values, a Haskell
      type can have parameters that we can later bind to other
      types.</para>

    <tip>
      <title>A little nomenclature</title>

      <para id="x_pe">If a type contains type parameters, we say that
	it is a parameterised type, or a polymorphic type.  If a
	function or value's type contains type parameters, we call it
	polymorphic.</para>
    </tip>

    <para id="x_qe">When we see a parameterised type, we've
      already noted that the code doesn't care what the actual type is.
      However, we can make a stronger statement: <emphasis>it has no
	way to find out what the real type is</emphasis>, or to
      manipulate a value of that type.  It can't create a value;
      neither can it inspect one.  All it can do is treat it as a
      fully abstract <quote>black box</quote>.  We'll cover one reason
      that this is important soon.</para>

    <para id="x_re">Parametric polymorphism is the most visible kind
      of polymorphism that Haskell supports. Haskell's parametric
      polymorphism directly influenced the design of the generic
      facilities of the Java and C# languages.  A parameterised type
      in Haskell is similar to a type variable in Java
      generics.  C++ templates also bear a resemblance to parametric
      polymorphism.</para>

    <para id="x_rm">To make it clearer how Haskell's polymorphism differs from
      other languages, here are a few forms of polymorphism that are
      common in other languages, but not present in Haskell.</para>

    <para id="x_se">In mainstream object oriented languages,
      <emphasis>subtype</emphasis> polymorphism is more widespread
      than parametric polymorphism.  The subclassing mechanisms of C++
      and Java give them subtype polymorphism.  A base class defines a
      set of behaviours that its subclasses can modify and
      extend.  Since Haskell isn't an object oriented language, it
      doesn't provide subtype polymorphism.</para>

    <para id="x_te">Also common is <emphasis>coercion</emphasis>
      polymorphism, which allows a value of one type to be implicitly
      converted into a value of another type.  Many languages provide
      some form of coercion polymorphism: one example is automatic
      conversion between integers and floating point numbers.  Haskell
      deliberately avoids even this kind of simple automatic
      coercion.</para>

    <para id="x_ue">This is not the whole story of polymorphism in Haskell:
      we'll return to the subject in <xref
	linkend="typeclasses"/>.</para>

    <sect2>
      <title>Reasoning about polymorphic functions</title>

      <para id="x_ve">In <xref linkend="funcstypes.sigs"/>, we talked about
	figuring out the behaviour of a function based on its type
	signature.  We can apply the same kind of reasoning to
	polymorphic functions.  Let's look again at
	<function>fst</function>.</para>

      &func.ghci:fst.type;

      <para id="x_we">First of all, notice that its argument contains two type
	variables, <varname role="type">a</varname> and <varname
	  role="type">b</varname>, signifying that the elements of the
	tuple can be of different types.</para>

      <para id="x_xe">The result type of <function>fst</function> is <varname
	  role="type">a</varname>.  We've already mentioned that
	parametric polymorphism makes the real type inaccessible:
	<function>fst</function> doesn't have enough information to
	construct a value of type <varname role="type">a</varname>,
	nor can it turn an <varname role="type">a</varname> into a
	<varname role="type">b</varname>.  So the
	<emphasis>only</emphasis> possible valid behaviour (omitting
	infinite loops or crashes) it can have is to
	return the first element of the pair.</para>

      <sect3>
	<title>Further reading</title>
      
	<para id="x_ye">There is a deep mathematical sense in which
	  any non-pathological function of type <type>(a,b) -&gt;
	    a</type> must do exactly what <function>fst</function>
	  does. Moreover, this line of reasoning extends to more
	  complicated polymorphic functions. The paper
	  <citation><biblioref linkend="bib.wadler89"/></citation>
	  covers this procedure in depth.</para>

	<remark>It's been suggested that we should create a
	  <quote>theory box</quote> for discussions of the deep stuff,
	  and references to academic papers.</remark>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>The type of a function of more than one argument</title>

    <para id="x_d3">So far, we haven't looked much at signatures for
      functions that take more than one argument.  We've already used
      a few such functions; let's look at the signature of one,
      <function>take</function>.</para>

    &func.ghci:take.type;

    <para id="x_e3">It's pretty clear that there's something going on
      with an <type>Int</type> and some lists, but why are there two
      <literal>-&gt;</literal> symbols in the signature?  Haskell
      groups this chain of arrows from right to left; that is,
      <literal>-&gt;</literal> is right-associative.  If we introduce
      parentheses, we can make it clearer how this type signature is
      interpreted.</para>

    &Take.hs:type;

    <para id="x_f3">From this, it looks like we ought to read the type
      signature as a function that takes one argument, an
      <type>Int</type>, and returns another function.  That other
      function also takes one argument, a list, and returns a list of
      the same type as its result.</para>

    <para id="x_g3">This is correct, but it's not easy to see what its
      consequences might be.  We'll return to this topic in <xref
	linkend="fp.partialapp"/>, once we've spent
      a bit of time writing functions.  For now, we can treat the type
      following the last <code>-&gt;</code> as being the function's
      return type, and the preceding types to be those of the
      function's arguments.</para>

    <para id="x_ze">We can now write a type signature for the
      <function>myDrop</function> function that we defined
      earlier.</para>

    &myDrop.hs:myDrop.type;

  </sect1>

  <sect1 id="funcstypes.sigs.exercises">
    <title>Exercises</title>

    <qandaset defaultlabel="number">
      <qandaentry>
	<question>
	  <para id="x_A4">Haskell provides a standard function,
	    <code>last :: [a] -&gt; a</code>, that returns the last
	    element of a list.  From reading the type alone, what are
	    the possible valid behaviours (omitting crashes and
	    infinite loops) that this function could have?  What are a
	    few things that this function clearly cannot do?</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_sm">Write a function <function>lastButOne</function>, that
	    returns the element <emphasis>before</emphasis> the
	    last.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_B4">Load your <function>lastButOne</function>
	    function into &ghci;, and try it out on lists of different
	    lengths.  What happens when you pass it a list that's too
	    short?</para>
	</question>
      </qandaentry>
    </qandaset>
  </sect1>

  <sect1>
    <title>Why the fuss over purity?</title>

    <para id="x_tm">Few programming languages go as far as Haskell in insisting
      that purity should be the default.  This choice has profound and
      valuable consequences.</para>

    <para id="x_um">Because the result of applying a pure function can only
      depend on its arguments, we can often get a strong hint of what
      a pure function does by simply reading its name and
      understanding its type signature.  As an example, let's look at
      <function>not</function>.</para>

      &func.ghci:not.type;

    <para id="x_de">Even if we didn't know the name of this function,
      its signature alone limits the possible valid behaviours it
      could have.</para>

    <itemizedlist>
      <listitem>
	<para id="x_ee">Ignore its argument, and always return either
	  <code>True</code> or <code>False</code>.</para>
      </listitem>
      <listitem>
	<para id="x_fe">Return its argument unmodified.</para>
      </listitem>
      <listitem>
	<para id="x_ge">Negate its argument.</para>
      </listitem>
    </itemizedlist>

    <para id="x_vm">We also know that this function can <emphasis>not</emphasis>
      do some things: it cannot access files; it cannot talk to the
      network; it cannot tell what time it is.</para>

    <para id="x_wm">Purity makes the job of understanding code easier.  The
      behaviour of a pure function does not depend on the value of a
      global variable, or the contents of a database, or the state of
      a network connection.  Pure code is inherently modular: every
      function is self-contained, and has a well-defined
      interface.</para>

    <para id="x_xm">A non-obvious consequence of purity being the default is
      that working with <emphasis>impure</emphasis> code becomes
      easier.  Haskell encourages a style of programming in which we
      separate code that <emphasis>must</emphasis> have side effects
      from code that doesn't need them.  In this style, impure code
      tends to be simple, with the <quote>heavy lifting</quote>
      performed in pure code.</para>

    <para id="x_ym">Much of the risk in software lies in talking to the outside
      world, be it coping with bad or missing data, or handling
      malicious attacks. Because Haskell's type system tells us
      exactly which parts of our code have side effects, we can be
      appropriately on our guard.  Because our favoured coding style
      keeps impure code isolated and simple, our <quote>attack
	surface</quote> is small.</para>
  </sect1>

  <sect1 id="funcstypes.end">
    <title>Conclusion</title>

    <para id="x_T6">In this chapter, we've had a whirlwind overview of
      Haskell's type system and much of its syntax.  We've read about
      the most common types, and discovered how to write simple
      functions.  We've been introduced to polymorphism, conditional
      expressions, purity, and about lazy evaluation.</para>

    <para id="x_U6">This all amounts to a lot of information to
      absorb.  In <xref linkend="deftypes"/>, we'll build on this
      basic knowledge to further enhance our understanding of
      Haskell.</para>

  </sect1>

</chapter>
<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
