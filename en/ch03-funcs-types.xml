<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.funcstypes" revision="alpha">
  <title>Types and Functions</title>

  <para id="x_n2">Topics: built-in types.  Writing functions.  Creating new
    types.</para>

  <sect1 id="hs.funcstypes.types">
    <title>Haskell's type system</title>
    
    <para id="x_o2">There are three interesting aspects to types in
      Haskell: they are <emphasis>strong</emphasis>, they are
      <emphasis>static</emphasis>, and they can usually be
      automatically <emphasis>inferred</emphasis> by an
      implementation.  Let's talk in more detail about each of these
      ideas.  Because Haskell is quite different from mainstream
      programming languages in how it treats types, let's not assume
      too much shared understanding as we discuss each idea.</para>

    <para id="x_p2">Every value and expression in Haskell has a
      <emphasis>type</emphasis>, such as <type>Integer</type> or
      <type>[Char]</type>.  The type of a value indicates that it
      shares certain properties with other values of the same type.
      For example, we can add numbers, and we can concatenate lists;
      these are properties of those types. We say a value or
      expression <quote>has type <code>X</code></quote>, or <quote>is
	of type <code>X</code></quote>; the two phrases mean the same
      thing.  Functions, being values, have types too.</para>

    <para id="x_AN">Here are a few examples of values, expressions,
      and their types: the value <literal>'a'</literal> has type
      <type>Char</type>; the expression <literal>"a" ++ "b"</literal>
      has type <type>String</type> (the <function>++</function> is the
      concatenation operator).  We call an expression that obeys the
      language's type rules <emphasis>well typed</emphasis>.  An
      expression that disobeys the type rules, such as <code>10 +
	"hello"</code>, is <emphasis>ill typed</emphasis>, and will be
      rejected by a Haskell implementation.  (Our example <code>10 +
	"hello"</code> is ill typed because the
      <function>(+)</function> operator works with numbers.)</para>

    <para id="x_q2">When we say that Haskell has a
      <quote>strong</quote> type system, we mean that every expression
      and value has exactly one <emphasis>most general
	type</emphasis>, which is a notion we can explain by example.
      The expression <literal>x - 1</literal> doesn't represent a
      specific type of number: it will work equally well if
      <varname>x</varname> is an <type>Integer</type> or a
      <type>Double</type> (a floating point number). As a result, the
      most general type for which the expression is valid is any
      numeric type.  The expression <type>1 &lt; 2</type> is defined
      to return a <type>Bool</type>, so its most general type is
      <type>Bool</type>.</para>

    <para id="x_BN">Strong typing means that any attempt to apply a
      function to a value of a different type causes an error. Another
      aspect of Haskell's view of strong typing is that it will not
      automatically coerce values from one type to another.  (Coercion
      is also known as casting or conversion.)  For example, a C
      compiler will automatically and silently coerce a value of type
      <type>int</type> into a <type>float</type> on our behalf if a
      function expects a parameter of type <type>float</type>, but a
      Haskell compiler will raise a compilation error in a similar
      situation.  We must explicitly coerce types ourselves.</para>

    <note>
      <title>So what's a strong type?</title>

      <para id="x_r2">It's useful to be aware that many language
	communities define a <quote>strong type</quote> differently.
	Broadly speaking, an implementation of a weak type system will
	not report an error when presented with an expression like
	<code>10 + "foo"</code>.  A stronger type system is less
	permissive in how it allows values of different types to be
	mixed, and will report some an error for such an expression.
	Haskell is less permissive than C, so it has a stronger type
	system.</para>
    </note>

    <para id="x_t2">Having a <quote>static</quote> type system means
      that the compiler knows the type of every value and expression
      at compile time, before any code is executed.  A Haskell
      compiler or interpreter will detect when we try to use
      expressions whose types don't match, and reject our code with an
      error message.</para>

    &ch03.basics.ghci:error;

    <para id="x_CN">This error message is of a kind we've seen before.  It's
      telling us that the value <literal>"false"</literal> cannot be treated
      as a <type>Bool</type>.</para>

    <para id="x_u2">Haskell's combination of strong and static typing
      makes it impossible for type errors to occur at runtime.  While
      this forces us to do more thinking <quote>up front</quote>, it
      also eliminates large numbers of simple errors that can
      otherwise be devilishly hard to find.  It's a truism within the
      Haskell community that once code compiles, it's more likely to
      work correctly than in other languages.  (Perhaps a more
      realistic way of putting this is that Haskell code often has
      fewer trivial bugs.)</para>

    <para id="x_v2">Finally, the compiler can automatically deduce the
      types of almost all values in a program. This process is known
      as type inference. Haskell allows us to explicitly declare the
      type of any value, but the presence of type inference means that
      this is almost always optional, not something we must do.</para>

    <para id="x_DN">While strong, static typing makes Haskell safe, type
      inference makes it concise.  The result is potent: we end up
      with a language that's both safer than popular statically typed
      languages, and often more expressive than dynamic
      languages.</para>

    <para id="x_w2">We've already briefly seen Haskell's notation for types in
      <xref linkend="hs.starting.types"/>.  We write <code>expression
	:: <type>MyType</type></code> to say that
      <code>expression</code> has the type <type>MyType</type>.</para>
  </sect1>

  <sect1 id="hs.funcstypes.basic">
    <title>Some common basic types</title>
    
    <para id="x_x2">In <xref
	linkend="hs.starting.types"/>, we introduced a few types. Here
      are more of the most ubiquitous base types, i.e. those that
      aren't composed of other types.</para>

    <itemizedlist>
      <listitem>
	<para id="x_y2">A <type>Char</type> value represents a
	  character. The values of <type>Char</type> are drawn from
	  the Unicode character set, which covers most of the world's
	  written languages.</para>
      </listitem>
      <listitem>
	<para id="x_z2">A <type>Bool</type> value represents a value
	  in Boolean logic.  The possible values of type
	  <type>Bool</type> are <code>True</code> and
	  <code>False</code>.</para>
      </listitem>
      <listitem>
	<para id="x_A3">The <type>Int</type> type is used for signed,
	  fixed-width integer values.  The exact range of values
	  representable as <type>Int</type> depends on the system's
	  longest <quote>native</quote> integer: on a 32-bit machine,
	  an <type>Int</type> is usually 32 bits wide, while on a
	  64-bit machine, it is usually 64 bits wide.  (There are also
	  numeric types that are exactly 8, 16, and so on bits wide;
	  we'll get to those later.)</para>
      </listitem>
      <listitem>
	<para id="x_B3">An <type>Integer</type> value is a signed
	  integer of arbitrary size.  <type>Integer</type>s are not
	  used as often as <type>Int</type>s, because they're more
	  expensive in terms of both performance and space
	  consumption.</para>
      </listitem>
      <listitem>
	<para id="x_C3">Values of type <type>Double</type> are used
	  for floating point numbers.  A <type>Double</type> value is
	  typically 64 bits wide, and uses the system's native
	  floating point representation.  (A narrower type,
	  <type>Float</type>, also exists, but its use is discouraged;
	  Haskell compiler writers concentrate more on making
	  <type>Double</type> efficient, so <type>Float</type> is much
	  slower.)</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="hs.funcstypes.composite">
    <title>Useful composite data types: lists and tuples</title>

    <para id="x_D3">The most common composite data types in Haskell
      are lists and tuples.</para>

    <para id="x_xK">A handy rule of thumb for remembering which is
      which is that a list has varying size and uniform type, while a
      tuple has a uniform size and varying type.  We'll see what this
      means below.</para>

    <para id="x_E3">We've already seen the list type mentioned in <xref
	linkend="hs.starting.string"/>, where we found that Haskell
      represents a text string as a list of <type>Char</type> values,
      and that the type <quote>list of <type>Char</type></quote> is
      written <type>[Char]</type>.  (The type <type>String</type> is
      simply an alias for <type>[Char]</type>.  You can use the two
      interchangeably.)</para>

    <para id="x_F3">We call the list type
      <emphasis>polymorphic</emphasis> because it can contain any type
      of value (see <xref linkend="hs.funcstypes.polymorphism"/> for
      more details).  We can write the type <quote>list of <varname
	  role="type">a</varname></quote> for any type <varname
	role="type">a</varname> by enclosing the type in square
      brackets: <type>[a]</type>.  The lowercase <varname
	role="type">a</varname> is called a <emphasis>type
	variable</emphasis>; it's a placeholder for some other type
      whose details do not matter.</para>

    <para>So, for example, the type <type>[Int]</type> is a list of
      values of type <type>Int</type> (and <emphasis>only</emphasis>
      of type <type>Int</type>!), the type
      <type>[MyPersonalType]</type> is a list of values of type
      <type>MyPersonalType</type>, and <type>[[Int]]</type> is a list
      of values of type <type>[Int]</type>, i.e. a list of
      lists of <type>Int</type>.</para>

    <para id="x_G3">Lists are the <quote>bread and butter</quote> of Haskell
      collections.  However, their utility goes beyond merely
      gathering values together.</para>

    <para>In an imperative language, we might repeat a task over many
      items by iterating through a loop.  This is something that we
      often do in Haskell with operations over a list, either by
      recursing or using a function that recurses for us.  Lists are
      the easiest stepping stone into the idea that we can use data to
      structure our program and its control flow. We'll be spending a
      lot more time discussing lists in <xref linkend="hs.fp"/>.</para>

    <para id="x_H3">A tuple is a fixed-size collection of values, each
      of which can be of any type.  Unlike a list (the elements of
      which must all have the same type), there's no need for the
      elements of a tuple to have related types.  In fact, tuples are
      important precisely because they're the easiest way to group
      multiple values that can have different types.  We write a tuple
      by enclosing its elements in parentheses and separating them
      with commas.  We use the same notation for writing its
      type.</para>

    &tuple.ghci:tuple;

    <para>There's a special type, <type>()</type>, that acts as a
      tuple of zero elements.  This type has only one value, also
      written <code>()</code>.  Both the type and the value are
      usually pronounced <quote>unit</quote>.</para>
    
    <para>Haskell doesn't have a notion of a one-element tuple. Larger
      tuples are often spoken of the number of elements as a prefix,
      hence <quote>3-tuple</quote> (for a tuple of three elements),
      <quote>5-tuple</quote>, and so on.</para>

    <para id="x_I3">We can construct tuples with fairly large numbers
      of elements.  In practice, working with more than a handful of
      elements quickly leads to unwieldy code, so tuples of more than
      half a dozen elements are uncommon.</para>

    <para>A tuple's type represents both the number and types of its
      elements.  This means that tuples containing different numbers
      or types of elements have distinct types of their own.</para>

    &tuple.ghci:type;

    <para id="x_J3">A 2-tuple of <type>Int</type> and
      <type>String</type> has a different type than a 2-tuple of
      <type>Bool</type> and <type>Bool</type>, for example, and a
      3-tuple has a different type than a 4-tuple.  2-tuples are often
      referred to as pairs, and 3-tuples less frequently as
      triples.</para>

    <para id="x_K3">A common use of tuples is to let us return
      multiple values from a function.  We can also use them in other
      places where we want a fixed-size collection of values, but
      don't need a custom container type.</para>

    <sect2 id="hs.funcstypes.composite.exercises">
      <title>Exercises</title>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_L3">What are the types of the following
	      expressions?</para>
	    <itemizedlist>
	      <listitem>
		<para id="x_M3"><code>False</code></para>
	      </listitem>
	      <listitem>
		<para id="x_N3"><code>(["foo", "bar"], 'a')</code></para>
	      </listitem>
	      <listitem>
		<para id="x_O3"><code>[(True, []), (False, [['a']])]</code></para>
	      </listitem>
	    </itemizedlist>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="hs.funcstypes.calling">
    <title>Function application</title>

    <para id="x_P3">Now that we've had our fill of data types for a while, let's
      turn our attention to <emphasis>working</emphasis> with some of
      the types we've seen.  We've already seen how to perform
      arithmetic in <xref linkend="hs.starting.calc.arithmetic"/>, and it
      looks quite as it does in other languages.</para>

    <para id="x_Q3">Our discussion of lists and tuples mentioned how we
      can construct them, but not how we do anything with them
      afterwards.  Haskell defines a large library of functions for
      working with lists and (to a lesser extent) tuples, so let's
      find out how to use a few of those functions.</para>

    <para id="x_R3">To call a function in Haskell, we write the name
      of the function followed by its arguments.  We don't use
      parentheses or commas to group or separate arguments; mere
      juxtaposition is enough. As an example, let's call the
      <function>head</function> function, which returns the first
      element of a list.</para>

    &func.ghci:head;

    <para id="x_S3">Its counterpart, <function>tail</function>, returns all
      <emphasis>but</emphasis> the head of a list.</para>

    &func.ghci:tail;

    <para id="x_T3">A related pair of functions,
      <function>take</function> and <function>drop</function>, take
      two arguments.  Given a number <varname>n</varname> and a list,
      <function>take</function> returns the first <varname>n</varname>
      elements of the list, while <function>drop</function> returns
      all <emphasis>but</emphasis> the first <varname>n</varname>
      elements of the list.  These functions take two arguments;
      notice that we simply separate the each function and its
      arguments using white space.</para>

    &func.ghci:takeDrop;

    <para id="x_U3">If you're used to function call syntax in other
      languages, this notation can take a little getting used to, but
      it's  simple and uniform.  Here's what we mean by uniform: the
      following expression calls <function>snd</function> with one
      argument, a pair.</para>

    &func.ghci:snd;

    <para id="x_V3">In some other languages, the call to
      <function>snd</function> above might mean <quote>call
	<function>snd</function> with two arguments,
	<literal>1</literal> and <literal>2</literal></quote>.</para>

    <para id="x_W3">By the way, <function>snd</function> has a
      companion function, <function>fst</function>, which returns the
      first element of a pair.</para>

    &func.ghci:fst;
    <note>
      <title>Haskell tuples aren't just immutable lists</title>

      <para>If your background is in Python, you'll probably be used
	to lists and tuples being almost interchangeable.  This isn't
	the case in Haskell, so don't try to carry that idea with
	you into unfamiliar language territory.</para>

      <para>As an illustration, take a look at the type signatures of
	<function>fst</function> and <function>snd</function>: they're
	defined <emphasis>only</emphasis> for pairs, and can't be used
	with tuples of other sizes.  It's tricky to write a
	generalised <quote>get the second element from any tuple, no
	  matter how wide</quote> function in Haskell, but people do
	fine without it.</para>
    </note>

    <sect2 id="hs.funcstypes.calling.expr">
      <title>Passing an expression to a function</title>

      <para id="x_X3">Haskell parses an expression from left to right.  If we
	want to use the result of one expression as an argument to
	another, we have to keep this in mind and use parentheses to
	tell the parser what we really mean.  Here's an
	example.</para>

      &func.ghci:headDrop;

      <para id="x_Y3">We can read this as <quote>pass the result of
	  the expression <code>drop 4 "azerty"</code> as the argument
	  to <function>head</function></quote>.  If we were to leave
	out the parentheses, Haskell would instead interpret the
	expression as <quote>pass <function>drop</function> as the
	  argument to <function>head</function></quote> .  Compilation
	would fail with a type error, as <function>head</function>
	requires its argument to be a list, and
	<function>drop</function> is a function.  (The offending
	expression would actually be parsed as <code>(((head drop) 4)
	  "azerty")</code>, where we've introduced lots of extra
	  parentheses to eliminate any ambiguity.)</para>
    </sect2>
  </sect1>

  <sect1 id="hs.funcstypes.sigs">
    <title>Understanding a function's type signature</title>

    <para id="x_Z3">Let's take a look at a function's type.</para>

    &func.ghci:lines.type;

    <para id="x_a3">We can read the <literal>-&gt;</literal> above as
      <quote>returns</quote>.  The entire signature thus tells us that
      <function>lines</function> takes a value of type
      <type>String</type> and returns a value with type
      <type>[String]</type>: it takes one string, and returns a list
      of strings.</para>

    &func.ghci:lines;

    <para id="x_b3">The <code>\n</code> in the input string is an
      escaped newline character: <function>lines</function> splits a
      string on line boundaries.  Notice that its type signature gave
      us a strong hint as to what the functions might actually
      <emphasis>do</emphasis>.</para>

    <para>This is an incredibly valuable property of types in a
      functional language.  If a function has the possibility of
      causing side effects, this will be represented in its type (as we'll
      see in <xref linkend="hs.io"/>).  If a function's type does not
      say that it can cause side effects, we refer to it as
      <emphasis>pure</emphasis>: its output can only depend on its
      inputs.  Understanding what a pure function does can often be a
      matter of reading its name and understanding its type signature.
      As an example, let's look at <function>not</function>.</para>

    &func.ghci:not.type;

    <para>Even if we didn't know the name of this function, its
      signature alone limits the possible behaviours it could have.
      (Let's omit crashing.)</para>

    <itemizedlist>
      <listitem>
	<para>Ignore its argument, and always return either
	  <code>True</code> or <code>False</code>.</para>
      </listitem>
      <listitem>
	<para>Return its argument unmodified.</para>
      </listitem>
      <listitem>
	<para>Negate its argument.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="hs.funcstypes.polymorphism">
    <title>Polymorphism in Haskell</title>

    <para>When we introduced lists, we mentioned that the list type is
      polymorphic.  We'll talk about polymorphism in more detail here,
      because it's a generic term that might cause confusion if we
      don't nail it down.</para>

    <para>If we want to fetch the last element of a list, we can call
      the <function>last</function> function.  The value that it
      returns must have the same type as the values in the list, but
      <function>last</function> operates in the same way no matter
      what that type actually <emphasis>is</emphasis>.</para>

    &func.ghci:last;

    <para>To capture the idea that <function>last</function> needs its
      argument and result types to be the same, but doesn't need to
      know their details, its type signature contains a <emphasis>type
	variable</emphasis>.</para>

    &func.ghci:last.type;

    <para>Here, <varname role="type">a</varname> is the type
      variable.</para>

    <tip>
      <title>Identifying a type variable</title>

      <para>Type variables always start with a lowercase letter.  You
	can always tell a type variable from a normal variable by
	context, because the languages of types and functions are
	separate: type variables live in type signatures, and regular
	variables live in normal expressions.</para>

      <para>It's common Haskell practice to keep the names of type
	variables very short.  One letter is overwhelmingly common;
	two is rare; and I don't think I've ever seen a type variable
	that was three or more characters long.  Type signatures are
	usually brief, so we gain more in readability by keeping names
	short than we would by making them descriptive.</para>
    </tip>

    <para id="x_c3">When a function has type variables in its
      signature, indicating that some of its arguments can be of any
      type, we call the function polymorphic.</para>

    <para>When we want to call <function>last</function> on, say, a
      list of <type>Char</type>, we can substitute <type>Char</type>
      for <varname role="type">a</varname> throughout the type
      signature, which gives us the type of
      <function>last</function>-over-<type>[Char]</type> as being
      <type>[Char] -&gt; Char</type>.</para>

    <para>This kind of polymorphism is called
      <emphasis>parametric</emphasis> polymorphism.  The choice of
      naming is easy to understand by analogy: just as a function can
      have parameters that we can later bind to real values, a Haskell
      type can have parameters that we can later bind to other
      types.</para>

    <tip>
      <title>A little nomenclature</title>

      <para>If the type of a function contains type parameters, we
	could call it a polymorphic function, or say that it has a
	parameterised type.  This is also the case for types.</para>
    </tip>

    <para>When a function or type has a parameterised type, we've
      already said that it doesn't care what the real type is.
      However, we can make a stronger statement: <emphasis>it has no
	way to find out what the real type is</emphasis>, or to
      manipulate a value of that type.  It can't create a value; it
      can't inspect it.  All it can do is treat it as a fully abstract
      <quote>black box</quote>.  We'll cover one reason that this is
      important soon.</para>

    <para>Parametric polymorphism is the most visible kind of
      polymorphism that Haskell supports.  Here are a few popular
      forms of polymorphism that are not present in Haskell.</para>

    <para>In mainstream object oriented languages,
      <emphasis>subtype</emphasis> polymorphism is more widespread
      than parametric polymorphism.  The subclassing mechanisms of C++
      and Java give them subtype polymorphism.  A base class defines a
      set of behaviours that its subclasses can modify and
      extend.  Since Haskell isn't an object oriented language, it
      doesn't provide subtype polymorphism.</para>

    <para>Also common is <emphasis>coercion</emphasis> polymorphism,
      which allows a value of one type to be implicitly converted into
      a value of another type.  Many languages provide some form of
      coercion polymorphism: one example is automatic conversion
      between integers and floating point numbers.  Haskell avoids
      even this kind of simple automatic coercion.</para>

    <para>This is not the whole story: we'll refine our understanding
      of Haskell's support for polymorphism in <xref
	linkend="hs.typeclasses"/>.</para>

    <sect2>
      <title>Reasoning about polymorphic functions</title>

      <para>In <xref linkend="hs.funcstypes.sigs"/>, we talked about
	figuring out the behaviour of a function based on its type
	signature.  We can apply the same kind of reasoning to
	polymorphic functions.  Let's look again at
	<function>fst</function>.</para>

      &func.ghci:fst.type;

      <para>First of all, notice that its argument contains two type
	variables, <varname role="type">a</varname> and <varname
	  role="type">b</varname>, signifying that the elements of the
	tuple can be of different types.</para>

      <para>The result type of <function>fst</function> is <varname
	  role="type">a</varname>.  We've already mentioned that
	parametric polymorphism makes the real type inaccessible:
	<function>fst</function> doesn't have enough information to
	construct a value of type <varname role="type">a</varname>,
	nor can it turn an <varname role="type">a</varname> into a
	<varname role="type">b</varname>.  So the
	<emphasis>only</emphasis> possible behaviour it can have is to
	return the first element of the pair.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>The type of a function of more than one argument</title>

    <para id="x_d3">So far, we haven't seen a signature for a function
      that takes <emphasis>more</emphasis> than one argument.  We've
      already used a few such functions; let's look at the signature
      of one, <function>take</function>.</para>

    &func.ghci:take.type;

    <para id="x_e3">It's pretty clear that there's something going on
      with an <type>Int</type> and some lists, but why are there two
      <literal>-&gt;</literal> symbols in the signature?  Haskell
      parses this chain of arrows from right to left; that is, it's
      right-associative.  If we introduce parentheses, we can make it
      clearer how this type signature is interpreted.</para>

    &Take.hs:type;

    <para id="x_f3">From this, it looks like we ought to read the type
      signature as a function that takes one argument, an
      <type>Int</type>, and returns another function.  That other
      function also takes one argument, a list, and returns a list of
      the same type as its argument.</para>

    <para id="x_g3">This is an intriguing idea, but it's not yet easy
      to see just yet what its consequences might be.  We'll return to
      this topic in <xref linkend="hs.fp.partialapp"/>, once we've
      spent a bit of time writing functions.</para>
  </sect1>

  <sect1 id="hs.funcstypes.srcfile">
    <title>Haskell source files, and writing simple functions</title>

    <para id="x_h3">Now that we know how to call functions, it's time
      we turned our attention to writing them.  While we can write
      functions in &ghci;, it's not a good environment for this.  It
      only accepts a highly restricted subset of Haskell: most
      importantly, the syntax it uses for defining functions is not
      the same as we use in a Haskell source file. Instead, we'll
      finally break down and create a source file.</para>

    <para id="x_i3">Haskell source files are usually identified with a suffix of
      <filename>.hs</filename>.  Here's a simple function definition:
      open up a file named <filename>add.hs</filename>, and add these
      contents to it.</para>

    &add.hs:add;

    <para id="x_j3">On the left hand side of the <literal>=</literal> is the
      name of the function, followed by the arguments to the function.
      On the right hand side is the body of the function.  With our
      source file saved, we can load it into &ghci;, and use our new
      <function>add</function> function straight away.  (The prompt
      that &ghci; displays will change after you load your file.)</para>

    &add.ghci:add;

    <note>
      <title>What if ghci cannot find your source file?</title>

      <para>When you run &ghci; it may not be able to find your source
	file.  It will search for source files in whatever directory
	it was run.  If this is not the directory that your source
	file is actually in, you can use &ghci;'s <code>:cd</code>
	command to change its working directory.</para>

      &cd.ghci:cd;

      <para>Alternatively, you can provide the path to your Haskell
	source file as the argument to <code>:load</code>.   This path
	can be either absolute or relative to &ghci;'s current
	directory.</para>
    </note>

    <para id="x_k3">When we apply <function>add</function> to the
      values <literal>1</literal> and <literal>2</literal>, the
      variables <varname>a</varname> and <varname>b</varname> on the
      left hand side of our definition are given (or <quote>bound
	to</quote>) the values <literal>1</literal> and
      <literal>2</literal>, so the result is the expression <code>1 +
	2</code>.</para>

    <para id="x_l3">Haskell doesn't have a <command>return</command>
      statement, as a function is a single expression, not a sequence
      of statements.</para>

    <para>When you see an <literal>=</literal> symbol in Haskell code,
      it represents <quote>equivalence</quote>: the name on the left
      is equivalent to the expression on the right. It does
      <emphasis>not</emphasis> represent <quote>assignment</quote> of
      a value to a memory location.  This distinction is very
      important.</para>

    <sect2 id="hs.funcstypes.variable">
      <title>Just what is a variable, anyway?</title>

      <para id="x_sK">In Haskell, a variable is a way of giving a name
	to an expression.  Once a variable is <emphasis>bound
	  to</emphasis> (i.e. associated with) a particular
	expression, its value does not change: we can always use the
	name of the variable instead of writing out the expression,
	and get the same result either way.</para>

      <para id="x_rK">If you're used to imperative programming
	languages, you're likely to think of a variable as a way of
	identifying a <emphasis>memory location</emphasis> (or some
	equivalent) that can hold different values at different times.
	In an imperative language can change a variable's value at any
	time, so that examoining the memory location repeatedly can
	potentially give different results each time.</para>

      <para>The critical difference between these two notions of a
	variable is that in Haskell, once we've bound a variable to an
	expression, we know that we can always substitute it for that
	expression, because it will not change.  In an imperative
	language, this notion of substitutability does not
	hold.</para>

      <sect3>
	<title>Shadowing</title>

	<para>Sit with &ghci; for a few moments and enter the
	  following series of expressions.</para>

	&shadowing.ghci:shadow;

	<para>It looks like we're giving <varname>x</varname> two
	  different values.  This seems to directly contradict our
	  earlier statement that we can't change a variable's
	  value!</para>

	<para>However, what we've done with the second &let; is
	  introduce a new variable, <emphasis>also</emphasis> named
	  <varname>x</varname>.  The older <varname>x</varname> is
	  still present, and still has the value <literal>1</literal>.
	  The new <varname>x</varname> hides the older
	  <varname>x</varname>: we say that it
	  <emphasis>shadows</emphasis> the other variable.</para>

	<para>While there's really nothing untoward going on here, we
	  won't be fully describing the rules for this particular case
	  until <xref linkend="hs.monads.do"/>.  We'll see another
	  case of shadowing later in this chapter.</para>
      </sect3>
    </sect2>

    <sect2 id="hs.funcstypes.if">
      <title>Conditional evaluation</title>

      <para id="x_m3">Like other languages, Haskell has an
	<code>if</code> expression.  Let's see it in action, then
	we'll explain what's going on.  As an example, we'll write our
	own version of the standard <function>take</function>
	function. Before we begin, let's probe a little into how
	<function>drop</function> behaves, so we can replicate its
	behaviour.</para>

      &myDrop.ghci:drop;

      <para id="x_n3">From the above, it seems that
	<function>drop</function> returns the original list if the
	number to remove is less than or equal to zero.  Otherwise, it
	removes elements until either it runs out or reaches the given
	number. Here's a <function>myDrop</function> function that has
	the same behaviour, and uses Haskell's <code>if</code>
	expression to decide what to do.</para>

      &myDrop.hs:myDrop;

      <para id="x_o3">Let's save it in a file named
	<filename>myDrop.hs</filename>, then load it into
	&ghci;.</para>

      &myDrop.ghci:myDrop;

      <para id="x_p3">Now that we've seen <function>myDrop</function>
	in action, let's return to the source code and look at all the
	novelties we've introduced.</para>

      <para>First of all, we have introduced <code>--</code>, the
	beginning of a single-line comment.  A single-line comment
	stretches from this sequence until the end of the same
	line.</para>

      <para>Next, we've written a type signature for
	<function>myDrop</function>.  This is not required, as a
	Haskell implementation will infer the type of
	<function>myDrop</function> if we omit an explicit type, but
	it's a good habit to get into.</para>

      <para id="x_q3">Next is the <code>if</code> keyword itself.  It
	introduces an expression that has three components.</para>

      <itemizedlist>
	<listitem>
	  <para>An expression of type <type>Bool</type>, immediately
	    following the &if;.  We refer to this as a
	    <emphasis>predicate</emphasis>.</para>
	</listitem>
	<listitem>
	  <para>A <code>then</code> keyword, followed by another
	    expression.  This expression will be used as the value of
	    the &if; expression if the predicate evaluates to
	    <code>True</code>.</para>
	</listitem>
	<listitem>
	  <para>An <code>else</code> keyword, followed by another
	    expression.  This expression will be used as the value of
	    the &if; expression if the predicate evaluates to
	    <code>False</code>.</para>
	</listitem>
      </itemizedlist>

      <para>We'll refer to the expressions after the <code>then</code>
	and <code>else</code> keywords as <quote>branches</quote>. The
	branches must have the same types; the &if; expression will
	also have this type.  An expression such as <code>if True then
	  1 else "foo"</code> has different types for its branches, so
	it is ill typed and will be rejected by a compiler or
	interpreter.</para>

      <para id="x_s3">While it can make sense in an imperative
	language to omit the <code>else</code> branch from an
	<code>if</code>, this would be nonsensical in Haskell.  An
	<code>if</code> expression that was missing an
	<code>else</code> wouldn't have a type if the predicate
	evaluated to <function>False</function>, so it would be ill
	typed.</para>

      <para id="x_t3">The predicate contains a few more novelties. The
	<function>null</function> function indicates whether a list is
	empty, while the <function>(||)</function> operator performs a
	logical <quote>or</quote> of its <type>Bool</type>-typed
	arguments.</para>

      &myDrop.ghci:null;

      <tip>
	<title>Operators are not special</title>

	<para>Notice that we were able to find the type of
	  <function>(||)</function> by wrapping it in parentheses. The
	  <function>(||)</function> operator isn't <quote>built
	    into</quote> the language: it's a normal function!</para>
      </tip>

      <para id="x_u3">Next, our function calls itself recursively.
	This is our first example of recursion, which we'll talk about
	in some detail shortly.</para>

      <para id="x_v3">Finally, our <code>if</code> expression spans
	several lines.  We line the <code>then</code> and
	<code>else</code> branches up under the <code>if</code> for
	neatness, but this is not mandatory.  If we wanted, we could
	put all of them on a single line, but we'd end up with a long,
	unreadable line.</para>

      &myDrop.hs:myDrop2;

    </sect2>
  </sect1>

  <sect1>
    <title>Understanding evaluation by example</title>

    <para>In our description of <function>myDrop</function>, we have
      so far focused on surface features.  We need to go deeper, and
      develop a useful mental model of how function application works.
      To do this, we'll walk through the evaluation of the expression
      <code>myDrop 2 "abcd"</code>.</para>

    <para>We've talked several times about substituting an expression
      for a variable, and we'll make use of this capability here. Our
      procedure will involve rewriting expressions over and over,
      substituting expressions for variables until we reach a final
      result. It's a good idea to transcribe this description using a
      paper and pencil, to be sure that you can follow it.</para>

    <para>When we start, our first step is to apply the function
      <function>myTake</function>.  We do this by giving the variable
      <varname>n</varname> the value <literal>2</literal>, and
      <varname>xs</varname> the value <literal>"abcd"</literal>.  If
      we substitute these values into the predicate, we get the
      following expression.</para>

    &myDrop.ghci:myDrop1;

    <para>We then evaluate enough of the predicate to find out what
      its value is.  We start by evaluating the
      <function>(||)</function> expression.  To determine its value,
      the <function>(||)</function> operator needs to examine the
      value of its left operand first.</para>

    &myDrop.ghci:myDrop2;

    <para>Substituting that value into the <function>(||)</function>
      expression leads to the following expression.</para>

    &myDrop.ghci:myDrop2a;

    <para>If the left operand had evaluated to
      <literal>True</literal>, <function>(||)</function> would not
      need to evaluate its right operand, since it could not affect
      the result of the expression. Since it evaluates to
      <literal>False</literal>, <function>(||)</function> must
      evaluate the right operand.</para>

    &myDrop.ghci:myDrop3;

    <para>We now substitute this value back into the
      <function>(||)</function> expression.  Since both operands
      evaluate to <literal>False</literal>, the
      <function>(||)</function> expression does, too, thus the
      predicate evaluates to <literal>False</literal>.</para>

    &myDrop.ghci:myDrop4;

    <para>This causes the &if; expression's <code>else</code> branch
      to be evaluated. This branch contains a recursive application of
      <function>myDrop</function>.</para>

    <sect2>
      <title>Recursion</title>

      <para>When we apply <function>myDrop</function> recursively, we
	substitute the values in the caller of <varname>n</varname>
	and <varname>xs</varname> to get the expressions that we
	should now use: <varname>n</varname> is bound to the
	expression <code>2 - 1</code>, and <varname>xs</varname> to
	the expression <code>tail "abcd"</code>.</para>

      <para>We're now evaluating <function>myDrop</function> from the
	beginning again.  We substitute the new values of
	<varname>n</varname> and <varname>xs</varname> into the
	predicate.</para>

      &myDrop.ghci:myDrop5;

      <para>Here's a condensed version of the evaluation of the left
	operand.</para>

      &myDrop.ghci:myDrop6;

      <para>Notice that we didn't evaluate the expression <code>2 -
	  1</code> until we needed its value.  This is our first step
	towards understanding lazy evaluation!  We also evaluate the
	right operand lazily, deferring <code>tail "abcd"</code> until
	we need its value.</para>

      &myDrop.ghci:myDrop7;
    
      <para>The predicate again evaluates to <literal>False</literal>,
	causing the <code>else</code> branch to be evaluated once
	more.</para>

      <para>Because we've had to evaluate the expressions for
	<varname>n</varname> and <varname>xs</varname> to evaluate the
	predicate, we now know that in this application of
	<function>myDrop</function>, <varname>n</varname> has the
	value <code>1</code> and <varname>xs</varname> has the value
	<code>"bcd"</code>.</para>
    </sect2>

    <sect2>
      <title>More recursion</title>

      <para>In the next recursive application of
	<function>myDrop</function>, we bind <varname>n</varname> to
	<code>1 - 1</code> and <varname>xs</varname> to <function>tail
	  "bcd"</function>.</para>

      &myDrop.ghci:myDrop9;

      <para>Once again, <function>(||)</function> needs to evaluate
	its left operand first.</para>

      &myDrop.ghci:myDrop10;

      <para>Finally, this expression has evaluated to
	<literal>True</literal>!</para>

      &myDrop.ghci:myDrop11;

      <para>Because the right operand cannot affect the result of
	<function>(||)</function>, it is not evaluated, and the result
	of the predicate is <literal>True</literal>.  This causes us
	to evaluate the <code>then</code> branch.</para>

      &myDrop.ghci:myDrop12;

    </sect2>

    <sect2>
      <title>Returning from the recursion</title>

      <para>Remember, we're now inside our second recursive
	application of <function>myDrop</function>.  This application
	evaluates to <code>tail "bcd"</code>.  We return from the
	application, substituting this expression for <code>myDrop (1
	  - 1) (tail "bcd")</code>, to become the result of this
	application.</para>

      &myDrop.ghci:myDrop13;

      <para>We then return from the first recursive application,
	substituting the result of the second recursive call for
	<code>myDrop (2 - 1) (tail "abcd")</code>, to become the
	result of this application.</para>

      &myDrop.ghci:myDrop14;

      <para>Finally, we return from our original call, substituting
	the result of the first recursive call.</para>

      &myDrop.ghci:myDrop15;

      <para>Notice that as we return from each successive recursive
	call, none of them needs to evaluate the expression <code>tail
	  "bcd"</code>: the final result of applying this function is
	an <emphasis>expression</emphasis>.  The expression is only
	finally evaluated when &ghci; needs to print it.</para>

      &myDrop.ghci:myDrop16;
    </sect2>

    <sect2>
      <title>What have we learned?</title>

      <para>We have established several important points here.</para>

      <itemizedlist>
	<listitem>
	  <para>It makes sense to use substitution and rewriting to
	    understand the evaluation of a Haskell expression.</para>
	</listitem>

	<listitem>
	  <para>Laziness leads us to defer evaluation until we need a
	    value, and to evaluate just enough of an expression to
	    establish its value.</para>
	</listitem>

	<listitem>
	  <para>The result of applying a function may be an expression
	    whose evaluation has been deferred because it has not yet
	    been needed.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="hs.funcstypes.error">
    <title>Reporting errors</title>

    <para id="x_w3">Haskell provides a standard function,
      <function>error :: Char -&gt; a</function>, that we can call
      when something has gone terribly wrong in our code.  We give it
      a string parameter, which is the error message to display. Its
      type signature looks peculiar; how can it produce a value of any
      type <varname role="type">a</varname> given just a string? The
      answer is that it doesn't, because <function>error</function> is
      special.</para>

    <para id="x_x3">It has that type so that we can call it anywhere
      and it will always have the right type.   However, instead of
      returning a value like a normal function, it immediately
      terminates evaluation, and prints the error message we give it.
      Here's an example.  The <function>mySecond</function> function
      returns the second element of its input list, but fails if its
      input list isn't long enough.</para>

    &MySecond.hs:mySecond;

    <para id="x_y3">As usual, we can see how this works in practice in
      &ghci;.</para>

      &error.ghci:mySecond;

    <para id="x_z3">Notice that in the third case above, where we're
      trying to use the result of the call to
      <function>mySecond</function> as the argument to another
      function, evaluation still terminates and drops us back to the
      &ghci; prompt.  This is both the strength and weakness calling
      <function>error</function>: it doesn't let us distinguish
      between recoverable errors and problems so severe that they
      really should terminate a program.  We'll see one way around
      this problem in
      <xref linkend="hs.funcstypes.maybe"/>.</para>

    <remark>Would this be a good point at which to split this chapter
      into two?</remark>
  </sect1>

  <sect1 id="hs.funcstypes.sigs.exercises">
    <title>Exercises</title>

    <qandaset defaultlabel="number">
      <qandaentry>
	<question>
	  <para id="x_A4">Haskell provides a standard function,
	    <code>last :: [a] -&gt; a</code>, that returns the last
	    element of a list.  Write a function
	    <function>lastButOne</function>, that returns the element
	    <emphasis>before</emphasis> the last.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para id="x_B4">Load your <function>lastButOne</function>
	    function into &ghci;, and try it out on lists of different
	    lengths.  What happens when you pass it a list that's too
	    short?</para>
	</question>
      </qandaentry>
    </qandaset>

  </sect1>

  <sect1 id="hs.funcstypes.data">
    <title>Defining a new data type</title>
      
    <para id="x_C4">Although lists and tuples are useful, we'll still often want
      to construct new data types of our own.  We define a new data
      type using the <code>data</code> keyword.</para>

    &MyType.hs:MyType;

    <para id="x_D4">The <type>MyType</type> after the <code>data</code> keyword
      is the name of our new type.  (As we've already mentioned, a
      type name must start with a capital letter.)  The string
      <code>MyConstructor</code> is the name of the
      <emphasis>constructor</emphasis> we'll call to create a value of
      this type.  (As with a type name, a constructor name must start
      with a capital letter.)  Finally, the <type>Int</type> and
      <type>String</type> are the <emphasis>components</emphasis> of
      the type.  A component serves the same purpose in Haskell as a
      field in a structure or class would in another language.</para>

    <note>
      <title>Deriving what?</title>

      <para id="x_E4">We'll explain the full meaning of <code>deriving
	  (Show)</code> later, in
	<xref linkend="hs.typeclasses.wellknown.show"/>.  For now,
	it's enough to know that we need to tack this onto a type
	declaration so that &ghci; will automatically know how to
	print a value of this type.</para>
    </note>

    <para id="x_F4">We can create a new value of type <type>MyType</type> by
      treating <function>MyConstructor</function> as a function, and
      calling it with arguments of types <type>Int</type> and
      <type>String</type>.</para>

    &MyType.hs:myValue;

    <para id="x_G4">Once we've defined a type, we can experiment with it in
      &ghci;, starting by using the <command>:load</command> command
      to load our source file.</para>

    &mytype.ghci:load;


    <para id="x_H4">Remember the <code>myValue</code> variable we defined?  Here
      it is.</para>

    &mytype.ghci:myValue;

    <para id="x_zK">A constructor serves as both a function for creating a value
      and a <quote>tag</quote> identifying what type of value we have.
      The value that &ghci; prints is telling us that we have created
      a value with the tag <code>MyConstructor</code>, with the given
      values in each <quote>slot</quote>.  (By the way, this is why we
      had to add <code>deriving (Show)</code> to the definition of our
      type; without that, &ghci; would print an error message, telling
      us that it doesn't know how to print a value of this
      type.)</para>

    <para id="x_I4">We can construct new values interactively in &ghci;,
      too.</para>

    &mytype.ghci:newValue;

    <para id="x_AL">The &ghci; command <command>:type</command> lets us see what
      the type of that expression is.</para>

    &mytype.ghci:valueType;

    <para id="x_J4">To find out more about a type, we can use some of &ghci;'s
      browsing capabilities.  The <command>:info</command> command
      gets &ghci; to tell us everything it knows about a
      type.</para>
    
    &mytype.ghci:info;

    <para id="x_K4">We can also find out why we use
      <function>MyConstructor</function> to construct a new value of
      type <type>MyType</type>.</para>

    &mytype.ghci:type;

    <para id="x_L4">From Haskell's perspective, then, a constructor is just
      another function, one that happens to return a value of the type
      we want to construct.</para>
  </sect1>

  <sect1 id="hs.funcstypes.adt">
    <title>Algebraic data types</title>

    <para id="x_M4">The <type>Bool</type> type that we introduced earlier is the
      simplest example of a sort of type called an <emphasis>algebraic
	data type</emphasis>. An algebraic data type has a fixed set
      of possible values, each of which is identified by a distinct
      constructor.</para>

    <para id="x_BL">The use of the word <quote>algebraic</quote> simply
      indicates that the components of an algebraic data type are used
      together.</para>

    <para id="x_N4">In the case of <type>Bool</type>, the type has two
      constructors, <code>True</code> and <code>False</code>.  Each
      constructor is separated by a <literal>|</literal> character,
      which we can read as <quote>or</quote>.  These are usually
      referred to as alternatives or cases.</para>

      &Bool.hs:Bool;

    <para id="x_O4">Each constructor of an algebraic type can take
      zero or more arguments; the numbers and types of the arguments
      accepted by each constructor are independent.  For example,
      here's one way we might represent versions of the Windows
      operating system, where old releases were monolithic, and newer
      releases have <quote>service pack levels</quote> denoting major
      updates after their initial releases.</para>

      &OsVersion.hs:WindowsVersion;

    <para id="x_P4">The alternatives that represent older releases don't need
      arguments, but those for the newer releases need an
      <type>Int</type> to represent the patch level.</para>

    <sect2 id="hs.funcstypes.adt.comp">
      <title>Analogues to algebraic data types in other
	languages</title>

      <para id="x_Q4">Algebraic data types provide a single structuring
	mechanism in instances where other languages have several
	different building blocks.  Here are some analogues from C and
	C++, which might make it clearer what we can do with algebraic
	data types.</para>

      <para id="x_R4">With just one constructor, an algebraic data type groups
	related values into one, and gives that value an identity
	distinct from other types.  It corresponds to a
	<code>struct</code> in C or C++, and its components correspond to the
	fields of a struct.  Here's such a <code>struct</code>.</para>

      &types.c:coord;

      <para id="x_CL">And here's an equivalent type in Haskell.</para>

      &SimpleTypes.hs:Coord;

      <para id="x_DL">The only significant difference is that the fields in the
	Haskell type are anonymous and positional.  In <xref
	linkend="hs.funcstypes.pattern"/>, we'll see how to use names
	to access the fields of the <type>Coord</type> type.</para>

      <para id="x_S4">If an algebraic data type has multiple alternatives, we
	can think of it as similar to a <code>union</code> in C or
	C++.  A big difference between the two is that a union doesn't
	tell us which alternative is actually present; we have to
	record which alternative we're using ourselves, usually in
	another field of a struct.  This means that unions can
	sometimes be sources of bugs, where our notion of which
	alternative we should be using is incorrect.</para>

      <para id="x_T4">With an algebraic data type, Haskell stores the
	constructor that we use in the value that we create, so we
	don't need to manually sock it away somewhere else.</para>

      <para id="x_U4">Algebraic data types also serve where we'd use
	an <code>enum</code> in C or C++, to represent a range of
	discrete symbolic values. Such algebraic data types are
	sometimes referred to as enumeration types.  Here's an example
	from C.</para>

      &types.c:roygbiv;

      <para id="x_EL">And here's a Haskell equivalent.</para>

      &SimpleTypes.hs:Roygbiv;

    </sect2>

    <sect2 id="hs.funcstypes.adt.notes">
      <title>A few final notes</title>

      <para id="x_V4">From reading the preceding sections, it should be clear
	that <emphasis>all</emphasis> of the data types that we define
	with the <code>data</code> keyword are algebraic data types.
	Some may have just one alternative; others have several; but
	they're all using the same organising machinery.</para>

      <para id="x_W4">Another useful thing to know is that it's perfectly okay
	for the name of an algebraic type to have the same name as one
	of its constructors to be the same.  It's always obvious from
	context whether we're using a name to refer to a type or a
	constructor, so this doesn't introduce any ambiguity.</para>

      <para id="x_X4">Giving a type and its constructor the same name is in fact
	something that we do frequently when the type has just one
	constructor.</para>

      &TypeName.hs:PerfectlyNormal;

      <para id="x_Y4">When a type has multiple constructors, it's still legal to
	give one of the constructors the  same name as the type, but
	this is much less common.</para>

      &TypeName.hs:LegalButWeird;

    </sect2>
  </sect1>

  <sect1 id="hs.funcstypes.paramtypes">
    <title>Parameterised types</title>

    <para id="x_Z4">In our discussion of lists, we mentioned that we can create
      a list of values of any type.  We can define our own types that
      allow this, too.  To do this, we introduce variables into a type
      declaration.</para>

      &Wrapper.hs:Wrapper;

    <para id="x_a4">Here, the variable <varname role="type">a</varname> is not a
      regular variable; it's called a <emphasis>type
	variable</emphasis>, because it indicates that our
      <type>Wrapper</type> type takes another type as its parameter
      (hence calling it a parameterised type). What this lets us do is
      use <type>Wrapper</type> on values of any type.</para>

      &Wrapper.hs:wrappedTypes;

    <para id="x_b4">As usual, we can load our source file into &ghci; and
      experiment with it.</para>

      &wrapper.ghci:experiment;

    <para id="x_c4"><type>Wrapper</type> is a <quote>generic</quote> container
      type (albeit a fairly useless one); we can construct a
      <type>Wrapper</type> from a value of any type.  It is also
      strongly typed; the type of whatever it contains is represented in
      its own type.</para>

    <para id="x_d4">To once again extend an analogy to more familiar languages,
      this gives us a facility that bears some resemblance to
      templates in C++, and to generics in Java.  (In fact, Java's
      generics facility was inspired by several aspects of Haskell's
      type system.)</para>

    <para id="x_e4">We can nest uses of parameterised types inside each other,
      but when we do, we may need to use parentheses to tell the
      Haskell compiler what we mean.</para>

      &Wrapper.hs:parens;
  </sect1>

  <sect1 id="hs.funcstypes.locals">
    <title>Back to writing functions: local variables</title>

    <para id="x_f4">Let's take a break from writing about types for a few
      moments.  Within the body of a function, we can introduce new
      local variables whenever we need them, using a <code>let</code>
      expression.  As an example, let's write a function that
      calculates the real-valued roots of the quadratic equation
      <literal>a * (x ** 2) + b * x + c == 0</literal>.</para>

    &Roots.hs:realRoots;

    <para id="x_g4">The keywords to look out for here are <code>let</code>,
      which starts a block of variable declarations, and
      <code>in</code>, which ends it.  Each line introduces a new
      variable.  The name is on the left of the <literal>=</literal>,
      and its value on the right.  We can use these variables both
      within our block of variable declarations and in the expression
      that follows the <code>in</code> keyword.</para>

    <para id="x_h4">There's no problem with a variable earlier in a
      <code>let</code> block referring to a later one, or even with
      them referring to each other.  (In some functional languages,
      this sort of flexible <code>let</code> is named
      <code>letrec</code>.)</para>

    <para id="x_i4">We can have multiple <code>let</code> blocks within an
      expression.  There's also another mechanism we can use to
      introduce local variables, called a <code>where</code> block.
      The definitions in a <code>where</code> block apply to the code
      that <emphasis>precedes</emphasis> it.  Let's illustrate what we
      mean with another example.</para>

    &Roots.hs:roots;

    <para id="x_j4">Here, the <function>roots</function> function returns the
      real roots when they're defined, and the complex roots
      otherwise. (We left out the divide-by-zero case for simplicity.)
      While a <quote>where</quote> clause initially looks very weird
      to non-Haskell programmers, it's a great way to put the
      <quote>important</quote> code early, followed by the auxiliary
      definitions that support it.  After a while, you'll find
      yourself missing <code>where</code> clauses in languages that
      lack them!</para>

    <para id="x_k4">The main difference between <code>let</code> and
      <code>where</code> is one of scope.  The scope of a
      <code>let</code> only extends to the expression after the
      <code>in</code> keyword, while the variables introduced by a
      <code>where</code> clause are visible upwards to the beginning
      of the block that it <quote>belongs</quote> to. Also,
      <code>let</code> is always paired with an expression, but
      <code>where</code> is paired with a block of equations.</para>

    <para id="x_l4">We'll be talking more about how to write <code>let</code>
      expressions and <code>where</code> clauses in <xref
	linkend="hs.funcstypes.offside"/>.</para>

    <note>
      <title>A few observations about complex numbers</title>

      <para id="x_m4">It's probably obvious from context above, but
	<function>(:+)</function> is the constructor for a complex
	number, taking the real part on the left and the imaginary
	part on the right.</para>

      <para id="x_n4">Also, <type>Complex</type> is parameterised over the type
	of complex number it should represent.  In practice, it only
	makes much sense to use <type>Complex Double</type>, since
	&GHC; implements <type>Double</type> more efficiently than
	<type>Float</type>.</para>
    </note>

    <sect2 id="hs.funcstypes.locals.functions">
      <title>Local functions</title>

      <para id="x_FL">You'll have noticed that Haskell's syntax for defining a
	variable looks very similar to its syntax for defining a
	function.  This symmetry is preserved in <code>let</code> and
	<code>where</code> blocks; we can define local
	<emphasis>functions</emphasis> just as easily as local
	<emphasis>variables</emphasis>.  All of the same syntax
	applies as at the top level: we can use multiple equations,
	patterns, and guards.</para>

      &LocalFunction.hs:pluralise;

      <para id="x_GL">In this example, we define and use a local function
	<function>plural</function> using several equations.  Local
	functions can freely use variables from the scopes that
	enclose them; here, we use <varname>word</varname> from the
	definition of the outer function
	<function>pluralise</function>.  In the definition of
	<function>pluralise</function>, the <function>map</function>
	function (which we'll be revisiting in the next chapter)
	applies the local function <function>plural</function> to
	every element of the <varname>counts</varname> list.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.funcstypes.maybe">
    <title>How to represent a complicated result</title>

    <para id="x_o4">We sneaked two previously unseen standard types,
      <type>Maybe</type> and <type>Either</type>, into our
      root-finding examples.  We use <type>Maybe</type> when it might
      not make sense to return a normal result, for example because a
      function's result is undefined for some inputs.  We use
      <function>Just</function> to say <quote>we have a
	result</quote>, and the argument to <function>Just</function>
      is that result.  When we can't give a result, we use
      <function>Nothing</function>, which takes no arguments.</para>

    &realRoots.ghci:maybe;
    
    <para id="x_p4">Why do we need <type>Maybe</type> here?  The real-valued
      roots of a quadratic equation are infinity when
      <varname>a</varname>, the coefficient of <literal>x **
	2</literal>, is zero.</para>

    &realRoots.ghci:a0;

    <para id="x_q4">They're also not defined when <literal>b ** 2 - 4 * a *
	c</literal> is negative, because we would need to use complex
      numbers to represent a negative square root.</para>

    &realRoots.ghci:complex;

    <para id="x_r4">Otherwise, we can return a normal result, wrapped in
      <function>Just</function>.</para>

    &realRoots.ghci:just;

    <para id="x_s4">Compared to <function>error</function>, which we saw in
      <xref linkend="hs.funcstypes.error"/>, <type>Maybe</type> has
      the huge advantage that it's a normal value, which we return to
      our caller to deal with.  Calling <function>error</function>, by
      contrast, is more akin to pulling on the program's ejector seat
      handle as it disintegrates around us; something terrible has
      happened, and we need to give up right now.</para>

    <para id="x_t4">The <type>Either a b</type> type gives us even more
      flexibility than <type>Maybe</type>, as it's got two type
      parameters. We can wrap a value of any type <varname
	role="type">a</varname> with <type>Left</type>, or a value of
      an unrelated type <varname role="type">b</varname> with
      <type>Right</type>.  Our <function>roots</function> function
      uses this to return a <type>Double</type> when the real roots
      are defined, and a <type>Complex Double</type> when they're
      not.</para>
  </sect1>

  <sect1 id="hs.funcstypes.offside">
    <title>The offside rule, and white space in a function
      body</title>

    <para id="x_u4">In our definition of <function>realRoots</function>, the
      left margin of our text wandered around quite a bit.  This was
      not an accident: in Haskell, white space has meaning.</para>

    <para id="x_v4">Haskell uses indentation as a cue to parse sections of code.
      This use of layout to convey structure is sometimes called the
      offside rule. At the top level, the first declaration or
      definition can start in any column, and the Haskell compiler or
      interpreter remembers that indentation level.  Every subsequent
      top-level declaration must have the same indentation.</para>

    <para id="x_w4">Here's an illustration of the top-level indentation rule.
      Our first file, <filename>GoodIndent.hs</filename>, is well
      behaved.</para>

    &GoodIndent.hs:good;

    <para id="x_x4">Our second, <filename>BadIndent.hs</filename>, doesn't play
      by the rules.</para>

    &BadIndent.hs:bad;

    <para id="x_y4">Here's what happens when we try to load the two files into
      &ghci;.</para>

    &indent.ghci:load;

    <para id="x_z4">An empty line is treated as a continuation of the current
      item, as is a line indented to the right of the current current
      item.</para>

    <para id="x_A5">The rules for <code>let</code> expressions and
      <code>where</code> clauses are similar.  After a
      <code>let</code> or <code>where</code> keyword, the Haskell
      compiler or interpreter remembers the indentation of the next
      token it sees. If the next line is empty, or its indentation is
      further to the right than the previous line, this counts as
      continuing the previous line. On the other hand, if the
      indentation is the same as the previous line, this is treated as
      beginning a new item in the same block.</para>

    <para id="x_B5">Here are nested uses of <code>let</code> and
      <code>where</code>.</para>

    &letwhere.hs:let;

    <para id="x_C5">In the body of <varname>bar</varname>, the variable
      <varname>a</varname> is only visible within the <code>let</code>
      expression that defines it.  It's not visible to the
      <code>let</code> expression that defines <varname>b</varname>;
      only the <emphasis>result</emphasis> of the inner
      <code>let</code> expression is visible.</para>

    &letwhere.hs:where;

    <para id="x_D5">Similarly, the scope of the first <code>where</code> clause
      is the definition of <varname>foo</varname>, but the scope of
      the second is just the first <code>where</code> clause.</para>

    <para id="x_E5">The indentation we use for the <code>let</code> and
      <code>where</code> clauses makes our intentions easy to figure
      out.</para>

    <sect2 id="hs.funcstypes.tabs">
      <title>A note about tabs versus spaces</title>

      <para id="x_F5">If you are using a Haskell-aware text editor (e.g. Emacs),
	it is probably already configured to use space characters for
	all white space within a line.  If your editor is
	<emphasis>not</emphasis> Haskell-aware, you should configure
	it to only use space characters.</para>

      <para id="x_G5">The reason for this is simple portability.  In an editor
	that uses a fixed-width font, tab stops are by default placed
	at different intervals on Unix-like systems (every eight
	characters) than on Windows  (every four characters). This
	means that no matter what your personal beliefs are about
	where tabs belong, you can't rely on someone else's editor
	honouring your preferences.  Any indentation that uses tabs is
	going to look broken under <emphasis>someone's</emphasis>
	configuration.  In fact, this could lead to compilation
	problems, as the Haskell language standard requires
	implementations to use the Unix tab width convention.
	Using space characters avoids these problem
	entirely.</para>
    </sect2>

    <sect2 id="hs.funcstypes.block">
      <title>The offside rule is not mandatory</title>

      <para id="x_H5">We can use explicit structuring instead of layout to
	indicate what we mean.  To do so, we start a block of
	equations with an opening curly brace; separate each item with
	a semicolon; and finish the block with a closing curly brace.
	The following two uses of <code>let</code> have the same
	meanings.</para>

      &Braces.hs:braces;

      <para id="x_I5">When we use explicit structuring, the normal layout rules
	don't apply, which is why we can get away with unusual
	indentation in the second <code>let</code> expression.</para>

      <para id="x_J5">We can use explicit structuring anywhere that we'd
	normally use layout.  It's valid for <code>where</code>
	clauses, and even top-level declarations.  Just remember that
	although the facility exists, explicit structuring is hardly
	ever actually <emphasis>used</emphasis> in Haskell
	programs.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.funcstypes.recursive">
    <title>Recursive types</title>

    <para id="x_K5">Here's a definition of a binary tree type.</para>

      &Tree.hs:Tree;

    <para id="x_L5">We call this a <emphasis>recursive</emphasis> type because
      <type>Tree</type>, the type we're defining, appears both on the
      left hand side and the right hand side of the definition: we
      define the type in terms of itself.</para>
  </sect1>

  <sect1 id="hs.funcstypes.listadt">
    <title>A little more about lists</title>

    <para id="x_M5">Now that we're getting familiar with some of the jargon
      around types, we can revisit lists.  Haskell's list type is a
      parameterised type, because we can make lists of any other type.
      It is also an algebraic data type, with two constructors.  One
      is the empty list, written <code>[]</code> (sometimes pronounced
      <quote>nil</quote>, which is borrowed from Lisp).</para>

    &list.ghci:empty;

    <para id="x_N5">The other is the <function>(:)</function> operator, often
      pronounced <quote>cons</quote> (this is short for
      <quote>construct</quote>, and also borrowed from Lisp).  The
      <function>(:)</function> operator takes an element and a list,
      and constructs a new list.</para>

    &list.ghci:cons;

    <para id="x_O5">We can use <function>(:)</function> repeatedly to add new
      elements to the front of a list.</para>

    &list.ghci:cons2;

    <para id="x_P5">The right hand side of <function>(:)</function> must be a
      list, and of the correct type.  If it's not, we'll get an
      error.</para>

    &list.ghci:cons.bad;

    <para id="x_Q5">Because <function>(:)</function> constructs a list from
      another list, the list type is recursive.  So here we have a
      built-in type that's parameterised, recursive, and
      algebraic.</para>

    <para id="x_R5">One consequence of lists being generic is that lists of
      lists, for example, aren't special in any way.</para>

    &list.ghci:listlist;

    <para id="x_S5">This has type <type>[[String]]</type>, a list of lists of
      strings.  But since <type>String</type> is just a synonym for
      <type>[Char]</type>, it's <emphasis>really</emphasis> a list of
      lists of lists of <type>Char</type>.  Whew!</para>

    <para id="x_T5">We're not limited to building up lists one element at a
      time.  Haskell defines an inline function,
      <function>(++)</function>, that we can use to append one list
      onto the end of another.</para>

    &list.ghci:append;

    <para id="x_U5">The <function>concat</function> function takes a list of
      lists, and concatenates the whole lot into a single list.</para>

    &list.ghci:concat;

  </sect1>

  <sect1 id="hs.funcstypes.unit">
    <title>Unit, the zero-element tuple</title>

    <para id="x_V5">Haskell has a special tuple type with no elements, written
      <type>()</type>, and pronounced <quote>unit</quote>.</para>

    &unit.ghci:unit;

    <para id="x_W5">This type is only really used with parameterised data types,
      to indicate that one of the type parameters isn't being used.
      Since it doesn't encode any information, it's a rough equivalent
      to <code>void</code> in C.</para>

    <para id="x_X5">Here's an example of <type>()</type> in use.  We can
      generalise our earlier <type>Tree</type> type a little, so that
      internal nodes contain values of type <varname
	role="type">a</varname>, while leaves contain values of type
      <varname role="type">b</varname>.</para>

    &Tree.hs:ComplexTree;

    <para id="x_Y5">If we wanted to create a <type>ComplexTree</type> where we
      wanted to store <type>Int</type>s on the leaves, but don't care
      about the internal nodes.  We would write its type as
      <type>ComplexTree () Int</type>.</para>
  </sect1>

  <sect1 id="hs.funcstypes.pattern">
    <title>Pattern matching</title>

    <para id="x_Z5">Although we introduced a handful of functions earlier that
      can operate on lists, we've yet to see how we might generally
      get values out of a constructed algebraic data type.  Haskell
      has a simple pattern matching facility that we can use to this
      end.</para>

    <para id="x_a5">A pattern lets us peer inside a compound value and bind
      variables to the values it contains.  In fact, when we define a
      function, the parameters to that function are really patterns
      that bind our variables to an entire value.</para>

    <para id="x_b5">Here's an example of pattern matching in action on a list;
      we're going to add all elements of the list together.</para>

    &add.hs:sumList;

    <para id="x_c5">See that <code>(x:xs)</code> on the left of the first line?
      The <code>:</code> means <quote>match the head of a
	list</quote>; that's the familiar list constructor,
      <function>(:)</function>, in action in a new way.  The variables
      <varname>x</varname> and <varname>xs</varname> are given the
      values of (<quote>bound to</quote>) the head and tail of the
      list, respectively.  The whole pattern is wrapped in parentheses
      so Haskell won't parse it as three separate arguments.</para>

    <para id="x_d5">What effect does pattern matching have? Haskell will only
      evaluate the right hand side of an equation if it can match all
      of the patterns on the left hand side.  In the definition of
      <function>sumList</function> above, the right hand side of the
      first equation won't be evaluated if the input list is empty.
      Instead, Haskell will <quote>fall through</quote> to the
      equation on the following line, which <emphasis>does</emphasis>
      have a pattern for the empty list, and it will evaluate
      that.</para>

    <para id="x_e5">It might initially look like we have two functions
      named <function>sumList</function> here, but Haskell lets us
      define a function as a series of equations; so in fact these two
      clauses are defining the behaviour of one function, over
      different inputs.  (By the way, there's already a standard
      function, <function>sum</function>, that does this
      adding-of-a-list for us.  This <function>sumList</function> is
      purely for illustration.)</para>

    <para id="x_f5">The syntax for pattern matching on a tuple is similar to the
      syntax for constructing a tuple.  Here's a function that returns
      the third element from a three-tuple.</para>

    &Tuple.hs:third;

    <para id="x_g5">There's no limit on how <quote>deep</quote> within a value a
      pattern can look.  Here's a definition that looks both inside a
      tuple and inside a list within that tuple.</para>

    &Tuple.hs:complicated;

    <para id="x_h5">We can try this out interactively.</para>

    &tuple.ghci:complicated;

    <para id="x_i5">Wherever a literal value is present in a pattern
      (<literal>True</literal> and <literal>5</literal> in the tuple
      pattern above), that value must match exactly for the pattern
      match to succeed.  If every pattern within a series of equations
      fails to match, we get a runtime error.</para>

    &tuple.ghci:nomatch;

    <para id="x_j5">We can pattern match on algebraic data types using their
      constructors.  Remember the <type>Wrapper</type> type we defined
      earlier?  Here's how we can extract a wrapped value from a
      <type>Wrapper</type>.</para>

    &Wrapper.hs:unwrap;

    <para id="x_k5">Let's see it in action.</para>

    &wrapper.ghci:unwrap;

    <para id="x_l5">Notice that Haskell infers the type of the
      <function>unwrap</function> function based on the constructor
      we're using in our pattern.  If we're trying to match a value
      whose constructor is <function>Wrapper</function>, then the type
      of that parameter must be <type>Wrapper a</type>.</para>
    
    <para id="x_HL">And for good measure, here's how we can define functions to
      access the fields of the <type>Coord</type> type we defined in
      <xref linkend="hs.funcstypes.adt.comp"/>.</para>

    &SimpleTypes.hs:accessors;

    <note>
      <title>The ordering of patterns is important</title>

      <para id="x_m5">Haskell tests patterns for matches in the order in which
	we list them in our code.  It goes from top to bottom and
	stops at the first match; it <emphasis>does not</emphasis>
	check every pattern and use the best match.</para>

      <para id="x_n5">If you're familiar with pattern matching from a logic
	programming language like Prolog, Haskell's facility is
	simpler and less powerful.  It doesn't provide backtracking or
	unification.</para>
    </note>

    <para id="x_IL">Here are some rules of thumb to help with remembering how
      pattern matching works.  A constructor in a pattern
      checks that the matched value has the right <quote>shape</quote>.  A
      literal value ensures that that portion of the value has exactly
      the matching contents.  And a variable makes no assertions about
      either the shape or contents of the matched value; it matches anything,
      and gives the variable that value.</para>

    <para id="x_JL">So the pattern <code>(3:xs)</code> first of all is an
      assertion that a matching value is a non-empty list, by matching
      against the <function>(:)</function> constructor.  It also
      ensures that the head of the list is the literal value
      <literal>3</literal>.  And whatever the tail of the list is, it
      will be bound to the variable <varname>xs</varname>.</para>

    <sect2 id="hs.funcstypes.dontcare">
      <title>The don't-care, or wild card, pattern</title>

      <para id="x_o5">When we're writing a pattern, we can specify that we don't
	care what value a particular value within a structure has,
	without actually binding that value to a name.  The notation
	for this is <code>_</code> (called a wild card or <quote>don't
	  care</quote>), and we use it as follows.  This function
	tells us whether the result of the <function>roots</function>
	function we defined earlier is real-valued or not.</para>

      &Roots.hs:isRealValued;

      <para id="x_p5">Here, we don't care about the value of the result, just
	about which constructor was used to create it.  If it was
	<function>Left</function>, the result must be a complex
	number, otherwise it must be real.  We can use a wild card for
	the entire second pattern; there's no need to see if the
	constructor is <function>Right</function>, because it
	<emphasis>must</emphasis> be; <type>Either</type> only has two
	constructors.</para>

      <para id="x_KL">In a pattern, a wild card acts similarly
	to a variable, only it doesn't bind the value to a name.
	While we can't put the same variable name multiple times in a
	single pattern, we can use a wild card as many times as we
	need to.</para>

      <para id="x_LL">Another advantage of wild cards is that a Haskell compiler
	can warn us if we introduce a variable name in a pattern, but
	don't use it in a function's body; defining something but
	forgetting to use it can often indicate a bug.  Using a wild
	card instead of an unused variable makes it explicit that we
	really don't care what value is present, and will prevent such
	a warning.</para>

      <para id="x_ML">Wild cards also help readability, as they make it easier
	to tell which values we're really using.</para>

      &SimpleTypes.hs:niceAccessors;

    </sect2>

    <sect2 id="hs.funcstypes.case">
      <title>The case expression</title>

      <para id="x_q5">We're not limited to using patterns in function
	definitions.  The <code>case</code> expression lets us match
	patterns at any time.  Here's what it looks like.</para>

      &Roots.hs:hasRealRoots;

      <para id="x_r5">The <code>case</code> keyword is followed by an arbitrary
	expression; the result of this expression is what we're
	pattern matching on.  The <code>of</code> keyword signifies
	the end of the expression and the beginning of the block of
	patterns and expressions.</para>

      <para id="x_s5">Each item in the block consists of a pattern, followed by
	an arrow <code>-&gt;</code>, followed by an expression to
	evaluate if that pattern matches.  The result of the
	<code>case</code> expression is the result of the expression
	associated with the first pattern to match, taken from top to
	bottom.</para>

      <para id="x_t5">To express <quote>here's the expression to evaluate if
	  none of the other patterns match</quote>, we would just use
	the wild card pattern <code>_</code> as the last in our list
	of patterns.</para>
    </sect2>

    <sect2 id="hs.funcstypes.where">
      <title>A flying visit back to the where clause</title>

      <para id="x_u5">Now that we've seen that we can define a function as a
	series of equations, the usefulness of the <code>where</code>
	clause should be a bit more clear.  Variables that we define
	inside a <code>where</code> clause are visible across all of
	the equations that precede it in a single block.</para>
    </sect2>
    
    <sect2 id="hs.funcstypes.pattern.limits">
      <title>Early pattern matching pitfalls</title>

      <para id="x_NL">There are a few ways in which new Haskell programmers can
	misunderstand or misuse patterns.  Here are a few potential
	missteps that you can easily avoid.</para>

      <para id="x_v5">There's no way to write a pattern that compares
	a value with a variable.  Matching a pattern only lets us
	perform exact comparisons against combinations of constructors
	and simple values.</para>

      <para id="x_OL">Here's a well-intentioned example of pattern matching gone
	awry.  This code compiles cleanly, but depending on what you
	expect it to do, it might surprise you.</para>

      &BogusPattern.hs:isHead;

      <para id="x_w5">A naive glance suggests that this code is trying
	to check the value of <function>f</function> to see if it's
	actually the standard function <function>head</function>, but
	here's what it is <emphasis>really</emphasis> doing.</para>

      <para id="x_x5">Because the first pattern in the
	<code>case</code> expression is a variable, this branch of the
	<code>case</code> will <emphasis>always</emphasis> match, no
	matter what the value of <varname>f</varname> is.  The name
	<varname>head</varname> thus acts as a local variable whose
	value is the value of <varname>f</varname>, which hides the
	global definition of the well-known <function>head</function>
	function.  </para>

      <note>
	<title>Irrefutable patterns</title>

	<para id="x_y5">A pattern that consists only of a variable will always
	  match, because it's not being compared against any value that
	  could cause the match to fail.  We refer to patterns that
	  always match as <quote>irrefutable</quote>.</para>
      </note>

      <para id="x_z5">The first pattern always matches, because it's
	irrefutable.  But the second pattern <emphasis>also</emphasis>
	always matches, because it uses a wild card.  However, because
	Haskell attempts to match patterns in the order in which we
	write them, the first pattern will always succeed, and the
	second pattern will never actually be reached. Because the two
	patterns will match the same values, they are said to
	<emphasis>overlap</emphasis>.  If &GHC; ever complains to you
	about overlapping patterns, it's telling you that one of your
	patterns is the same as another, and so it will never actually
	be matched.</para>

      <para id="x_A6">Another thing to be aware of is that a variable
	can only appear once in a pattern.  For example, we can't put
	a variable in multiple places within a pattern to express the
	notion <quote>this value and that should be
	  identical</quote>.</para>

      <para id="x_B6">The way around these restrictions of Haskell's patterns is
	to use patterns in combination with a language facility called
	<emphasis>guards</emphasis>, which we'll talk about
	next.</para>

    </sect2>
  </sect1>

  <sect1 id="hs.funcstypes.guard">
    <title>Conditional evaluation with guards</title>

    <para id="x_C6">We can further extend our expressive arsenal using
      <emphasis>guards</emphasis>.  A guard is an expression of type
      <type>Bool</type>; if it evaluates to <function>True</function>,
      the equation that follows it is evaluated.  Otherwise, the next
      guard in the series is evaluated, and so on.  A series of guards
      is only checked if the patterns that they're associated with
      match.  Here's an example of guards in action.</para>

    &Roots.hs:guardedRoots;

    <para id="x_D6">Each guard is introduced by a <code>|</code> symbol,
      followed by the guard expression, then an <code>=</code> symbol
      (or <code>-&gt;</code> if within a <code>case</code>
      expression), then the expression to evaluate if the guard
      succeeds.  A guard expression can use any variables matched in
      the pattern that precedes it.</para>

    <para id="x_E6">The <varname>otherwise</varname> used in the second guard
      has an obvious meaning: it's the expression to evaluate if
      previous guards all evaluate to <function>False</function>. It's
      not a special piece of syntax, though; it's just a predefined variable
      whose value is <function>True</function>.</para>

    <para id="x_F6">We can use guards anywhere that we can use
      patterns.  The advantage of writing a function as a series of
      equations using pattern matching and guards is that it often
      makes code much clearer.  Remember the
      <function>myDrop</function> function we defined in <xref
	linkend="hs.funcstypes.if"/>?</para>

    &myDrop.hs:myDrop.noid;

    <para id="x_H6">Here's a reformulation of that function using
      patterns and guards.  Instead of reasoning about what an
      <code>if</code> expression is doing and which branch will be
      evaluated, the code uses a series of equations with simple
      patterns and guards. Hoisting the control decisions to the
      <quote>outside</quote> of the code, instead of burying it inside
      with <code>if</code> expressions, lets us enumerate up front
      the cases in which we expect the behaviour of the function to
      differ.</para>

    &myDrop.hs:niceDrop;

    <para id="x_I6">Let's return to one of the limitations of patterns that we
      mentioned in the previous section: the fact that we can't 
      check two variables within a pattern for equality.
      We can express this quite easily by following the pattern with a
      guard.</para>

    &Guard.hs:secondEqualsThird;

    <para id="x_J6">Here, for good measure, we've illustrated guard
      syntax in a <code>case</code> expression.  This guard expression
      compares the variables matched in the pattern for equality.</para>
  </sect1>

  <sect1 id="hs.funcstypes.infix">
    <title>Infix functions</title>

    <para id="x_K6">Usually, when we define or call a function in Haskell, we
      write the name of the function, followed by its arguments; this
      is called prefix notation, because the name of the function
      comes before its arguments.  For a function that takes two
      arguments, we have the option of using it in
      <emphasis>infix</emphasis> form, between its first and second
      arguments.  This allows us to write expressions using functions
      as if they were infix operators.</para>

    <para id="x_L6">The syntax for defining or calling a function in infix form
      is to enclose the name of the function in backtick characters
      (sometimes known as backquotes).  Here's a simple infix
      definition.</para>

    &Plus.hs:plus;

    <para id="x_M6">Defining a function in infix form doesn't change anything
      about the behaviour of the function.  We can call the function
      using infix or prefix notation, as we prefer.</para>

    &infix.ghci:plus;

    <para id="x_N6">Infix notation is useful for more than just our own
      functions.  For example, Haskell's standard
      <code>Data.List</code> module defines a function,
      <function>isPrefixOf</function>, that indicates whether all
      elements of its first argument are equal to the first elements
      of its second argument.</para>

    &infix.ghci:type;

    <para id="x_O6">Let's define a few variables in &ghci;.</para>

    &infix.ghci:vars;

    <para id="x_P6">If we call <function>isPrefixOf</function> using prefix
      notation, we can have a hard time remembering which argument
      we're checking for as a prefix of the other.</para>

    &infix.ghci:prefix;

    <para id="x_Q6">But if we use infix notation, the code <quote>reads</quote>
      more naturally; it's now obvious that we're checking the
      variable on the left to see if it's a prefix of the variable on
      the right.</para>

    &infix.ghci:infix;

    <para id="x_R6">There's no hard-and-fast rule that dictates when you ought
      to use infix versus prefix notation, although prefix notation is
      far more common.  It's best to choose whichever makes your code
      more readable in a specific situation.</para>

    <note>
      <para id="x_S6">The backtick notation is not a general mechanism: it's a
	piece of special syntax that applies only to names.  For
	example, we can't put backticks around an expression that
	returns a function, and then treat that as an infix
	function.</para>
    </note>
  </sect1>

  <sect1 id="hs.funcstypes.end">
    <title>Conclusion</title>

    <para id="x_T6">In this chapter, we've had a whirlwind overview of Haskell's
      type system and much of its syntax.  We've read about basic
      types, compound types, and how to write our own algebraic data
      types.  We've seen how to write functions, and how to declare
      local variables within them.  We've read about Haskell's offside
      rule for laying out functions, and how we can avoid it if we
      need to.  We've seen conditional evaluation, pattern matching
      and guards.  We've discussed error handling.</para>

    <para id="x_U6">This all amounts to a lot of information to absorb.  In
      <xref linkend="hs.fp"/>, we'll build on this basic knowledge to
      understand how we can write, and think about, code in
      Haskell.</para>

  </sect1>

</chapter>
<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
