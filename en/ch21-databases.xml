<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

  <chapter id="hs.databases" revision="unpublished">
    <title>Using Databases</title>

    <para>
      Many different applications have the need to store data in databases.
      Everything from web forums to podcatchers or even backup programs
      frequently use databases for persistent storage.  SQL-based databases are
      often quite convenient: they are fast, can scale from tiny to massive
      sizes, can operate over the network, often help handle locking and
      transactions, and can even provide failover and redundancy improvements
      for applications.  Databases come in many different shapes: the large
      commercial databases such as Oracle, Open Source engines such as
      PostgreSQL or MySQL, and even embeddable engines such as Sqlite.
    </para>
    <para>
      Because databases are so important, Haskell support for them is important
      as well.  In this chapter, we will introduce you to one of the Haskell
      frameworks for working with databases.  We will also use this framework
      to begin building a podcast downloader, which we will further develop in
      <remark>FIXME: insert link to ch22</remark>.
    </para>

    <sect1 id="hs.databases.hdbc">
      <title>Overview of HDBC</title>
      <para>
        At the bottom of the database stack is the database engine.  The
        database engine is responsible for actually storing data on disk.
        Well-known database engines include PostgreSQL, MySQL, and Oracle.
      </para>
      <para>
        Most modern database engines support SQL, the Structured Query
        Language, as a standard way of getting data into and out of relational
        databases.  This book will not provide a tutorial on SQL or relational
        database management; for background on that, please refer to
        <remark>FIXME: add reference to an appropriate O'Reilly title</remark>.
      </para>
      <para>
        Once you have a database engine that supports SQL, you need a way to
        communicate with it.  Each database has its own protocol.  Since SQL is
        reasonably constant across databases, it is possible to make a generic
        interface that uses drivers for each individual protocol.
      </para>
      <para>
        Haskell has several different database frameworks available, some
        providing high-level layers atop others.  For this chapter, we will
        concentrate on HDBC, the Haskell DataBase Connectivity system.  HDBC is
        a database abstraction library.  That is, you can write code that uses
        HDBC and can access data stored in almost any SQL database with little
        or no modification.<footnote><para>This assumes you restrict yourself to
            using standard SQL.</para></footnote>  Even if you may never need
        to switch underlying database engines, the HDBC system of drivers makes
        a large number of choices available to you with a single constant
        interface.
      </para>
    </sect1>

    <sect1 id="hs.databases.hdbc.install">
      <title>Installing HDBC and Drivers</title>
      <para>
        To connect to a given database with HDBC, you need at two packages:
        the generic interface, and a driver for your specific database.  You
        can obtain the generic HDBC package from <ulink
          url="http://software.complete.org/hdbc"/>.  <remark>FIXME: insert
          link to section on installing software</remark>.  For this chapter,
        we will use HDBC version 1.1.3 for examples.
      </para>
      <para>
        You'll also need a database backend and backend driver.  For
        this chapter, we'll use Sqlite version 3.  Sqlite is an embedded
        database, so it doesn't require a separate server and is easy to
        set up.  Many operating systems already ship with Sqlite verison
        3.  If yours doesn't, you can download it from <ulink
          url="http://www.sqlite.org/"/>.  The HDBC homepage has a link to
        known HDBC backend drivers.  The specific driver for Sqlite
        version 3 can be obtained from <ulink
          url="http://software.complete.org/hdbc-sqlite3"/>. 
      </para>
    </sect1>

    <sect1 id="hs.databases.connect">
      <title>Connecting to Databases</title>
      <para>
        To connect to a database, you will use a connection function
        from a database backend driver.  Each database has its own
        unique method of connecting.  The initial connection is
        generally the only time you will call anything from a backend
        driver module directly.
      </para>
      <para>
        The database connection function will return a database
        handle.  The precise type of this handle may vary from one
        driver to the next, but it will always be an instance of the
        &IConnection; typeclass.  All of the functions you will use to
        operate on databases will work with any type that is an
        instance of &IConnection;.  When you're done talking to the
        database, call the <literal>disconnect</literal> function.  It
        will disconnect you from the database.  Here's an example of
        connecting to a Sqlite database:
      </para>
      &connect.ghci:conn;
    </sect1>

    <sect1 id="hs.databases.transactions">
      <title>Transactions</title>
      <para>
        Most modern SQL databases have a notion of transactions.
        Transactions are useful for many things.  A transaction is
        designed to ensure that all components of a modification get
        applied, or that none of them do.  Furthermore, transactions
        help prevent other processes accessing the same database from
        seeing partial data from modifications that are in progress.
      </para>
      <para>
        Many databases require you to either explicitly commit all
        your changes before they appear on disk, or to run in an
        "autocommit" mode.  The "autocommit" mode runs an implicit
        commit after every statement.   This may make the adjustment
        to transactional databases easier for programmers not
        accustomed to them, but complicates the life of people that
        actually want transactions.
      </para>
      <para>
        HDBC intentionally does not support autocommit mode.  When you
        modify data in your databases, you must explicitly cause it to
        be committed to disk.  There are two ways to do that in HDBC:
        you can call &commit; when you're ready to write the data to
        disk, or you can use the &withTransaction; function to wrap
        around your modification code.   &withTransaction; will cause
        data to be committed upon successful completion of your
        function.
      </para>
      <para>
        Sometimes a problem will occur while you are working on
        writing data to the database.  Perhaps you get an error from
        the database or discover a problem with the data.  In these
        instances, you can "roll back" your changes.  This will cause
        all changes you were making since your last &commit; or roll
        back to be forgotten.  In HDBC, you can call the &rollback;
        function to do this.  If you are using &withTransaction;, any
        uncaught exception will cause a roll back to be issued.
      </para>
      <warning>
        <para>
          One popular database, MySQL, does not support transactions
          with its default table type.  In its default configuration,
          MySQL will silently ignore calls to &commit; or &rollback;
          and will commit all changes to disk immediately.  The HDBC
          ODBC driver has instructions for configuring MySQL to
          indicate to HDBC that it does not support transactions,
          which will cause &commit; and &rollback; to generate
          errors.  Alternatively, you can use InnoDB tables with
          MySQL, which do support transactions.  InnoDB tables are
          recommended for use with HDBC.
        </para>
      </warning>
    </sect1>

    <sect1 id="hs.databases.simplequeries">
      <title>Simple Queries</title>
      <para>
        Some of the simplest queries in SQL involve statements that
        don't return any data.  These queries can be used to create
        tables, insert data, delete data, and set database parameters.
      </para>
      <para>
        The most basic function for sending queries to a database is
        &run;.  This function takes an &IConnection;, a &String;
        representing the query itself, and a list of parameters.
        Let's use it to set up some things in our database.
      </para>
      &query.ghci:setup;
      <para>
        After connecting to the database, we first created a table
        called <literal>test</literal>.  Then we inserted one row of
        data into the table.  Finally, we committed the changes and
        disconnected from the database.  Note that if we hadn't called
        &commit;, no final change would have been written to the
        database at all.
      </para>
    </sect1>

    <sect1 id="hs.database.sqlvalue">
      <title>SqlValues</title>
      <para>
        Before proceeding any farther, we need to discuss a data type
        introduced in HDBC: &SqlValue;.  Since both Haskell and SQL
        are strongly-typed systems, HDBC tries to preserve type
        information as much as possible.  At the same time, Haskell
        and SQL types don't exactly mirror each other.  Furthermore,
        different databases have different ways of representing things
        such as dates or special characters in strings.
      </para>
      <para>
        &SqlValue; is a data type that has a number of constructors
        such as &SqlString;, &SqlBool;, &SqlNull;, &SqlInteger;, and
        more.  This lets you represent various types of data in
        argument lists to the database, and to see various types of
        data in the results coming back, and still store it all in a
        list.  There are convenience functions &toSql; and &fromSql;
        that you will normally use.  If you care about the precise
        representation of data, you can still manually construct
        &SqlValue; data if you need to.
      </para>
    </sect1>

    <sect1 id="hs.databases.args">
      <title>Query Parameters</title>
      <para>
        FIXME
      </para>
    </sect1>

    <sect1 id="hs.databases.readingresults">
      <title>Reading Results</title>
      <para>
        We can get data back out of the database fairly easily as
        well.  HDBC provides a number of functions for doing this.  To
        start with, we'll use &quickQueryp;.
      </para>
      <para><remark>FIXME</remark></para>
    </sect1>

    <sect1 id="hs.databases.metadata">
      <title>Database Metadata</title>
      <para><remark>FIXME</remark></para>
    </sect1>

    <sect1 id="hs.databases.errors">
      <title>Error Handling</title>
      <para><remark>FIXME</remark></para>
    </sect1>

    <sect1 id="hs.databases.threading">
      <title>Threading</title>
      <para><remark>FIXME</remark></para>
    </sect1>

    <sect1 id="hs.databases.typeable">
      <title>Data.Typeable</title>
      <para><remark>FIXME</remark></para>
    </sect1>
  </chapter>
  

  <!--
  local variables: 
  sgml-parent-document: ("00book.xml" "book")
  end:
  -->
