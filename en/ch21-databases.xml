<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

  <chapter id="hs.databases" revision="unpublished">
    <title>Using Databases</title>

    <para>
      Many different applications have the need to store data in databases.
      Everything from web forums to podcatchers or even backup programs
      frequently use databases for persistent storage.  SQL-based databases are
      often quite convenient: they are fast, can scale from tiny to massive
      sizes, can operate over the network, often help handle locking and
      transactions, and can even provide failover and redundancy improvements
      for applications.  Databases come in many different shapes: the large
      commercial databases such as Oracle, Open Source engines such as
      PostgreSQL or MySQL, and even embeddable engines such as Sqlite.
    </para>
    <para>
      Because databases are so important, Haskell support for them is important
      as well.  In this chapter, we will introduce you to one of the Haskell
      frameworks for working with databases.  We will also use this framework
      to begin building a podcast downloader, which we will further develop in
      <remark>FIXME: insert link to ch22</remark>.
    </para>

    <sect1 id="hs.databases.hdbc">
      <title>Overview of HDBC</title>
      <para>
        At the bottom of the database stack is the database engine.  The
        database engine is responsible for actually storing data on disk.
        Well-known database engines include PostgreSQL, MySQL, and Oracle.
      </para>
      <para>
        Most modern database engines support SQL, the Structured Query
        Language, as a standard way of getting data into and out of relational
        databases.  This book will not provide a tutorial on SQL or relational
        database management; for background on that, please refer to
        <remark>FIXME: add reference to an appropriate O'Reilly title</remark>.
      </para>
      <para>
        Once you have a database engine that supports SQL, you need a way to
        communicate with it.  Each database has its own protocol.  Since SQL is
        reasonably constant across databases, it is possible to make a generic
        interface that uses drivers for each individual protocol.
      </para>
      <para>
        Haskell has several different database frameworks available, some
        providing high-level layers atop others.  For this chapter, we will
        concentrate on HDBC, the Haskell DataBase Connectivity system.  HDBC is
        a database abstraction library.  That is, you can write code that uses
        HDBC and can access data stored in almost any SQL database with little
        or no modification.<footnote><para>This assumes you restrict yourself to
            using standard SQL.</para></footnote>  Even if you may never need
        to switch underlying database engines, the HDBC system of drivers makes
        a large number of choices available to you with a single constant
        interface.
      </para>
    </sect1>

    <sect1 id="hs.databases.hdbc.install">
      <title>Installing HDBC and Drivers</title>
      <para>
        To connect to a given database with HDBC, you need at two packages:
        the generic interface, and a driver for your specific database.  You
        can obtain the generic HDBC package from <ulink
          url="http://software.complete.org/hdbc"/>.  <remark>FIXME: insert
          link to section on installing software</remark>.  For this chapter,
        we will use HDBC version 1.1.3 for examples.
      </para>
      <para>
        You'll also need a database backend and backend driver.  For
        this chapter, we'll use Sqlite version 3.  Sqlite is an embedded
        database, so it doesn't require a separate server and is easy to
        set up.  Many operating systems already ship with Sqlite verison
        3.  If yours doesn't, you can download it from <ulink
          url="http://www.sqlite.org/"/>.  The HDBC homepage has a link to
        known HDBC backend drivers.  The specific driver for Sqlite
        version 3 can be obtained from <ulink
          url="http://software.complete.org/hdbc-sqlite3"/>. 
      </para>
    </sect1>

    <sect1 id="hs.databases.connect">
      <title>Connecting to Databases</title>
      <para>
        To connect to a database, you will use a connection function
        from a database backend driver.  Each database has its own
        unique method of connecting.  The initial connection is
        generally the only time you will call anything from a backend
        driver module directly.
      </para>
      <para>
        The database connection function will return a database
        handle.  The precise type of this handle may vary from one
        driver to the next, but it will always be an instance of the
        &IConnection; typeclass.  All of the functions you will use to
        operate on databases will work with any type that is an
        instance of &IConnection;.  When you're done talking to the
        database, call the <literal>disconnect</literal> function.  It
        will disconnect you from the database.  Here's an example of
        connecting to a Sqlite database:
      </para>
      &connect.ghci:conn;
    </sect1>

    <sect1 id="hs.databases.transactions">
      <title>Transactions</title>
      <para>
        Most modern SQL databases have a notion of transactions.
        Transactions are useful for many things.  A transaction is
        designed to ensure that all components of a modification get
        applied, or that none of them do.  Furthermore, transactions
        help prevent other processes accessing the same database from
        seeing partial data from modifications that are in progress.
      </para>
      <para>
        Many databases require you to either explicitly commit all
        your changes before they appear on disk, or to run in an
        "autocommit" mode.  The "autocommit" mode runs an implicit
        commit after every statement.   This may make the adjustment
        to transactional databases easier for programmers not
        accustomed to them, but complicates the life of people that
        actually want transactions.
      </para>
      <para>
        HDBC intentionally does not support autocommit mode.  When you
        modify data in your databases, you must explicitly cause it to
        be committed to disk.  There are two ways to do that in HDBC:
        you can call &commit; when you're ready to write the data to
        disk, or you can use the &withTransaction; function to wrap
        around your modification code.   &withTransaction; will cause
        data to be committed upon successful completion of your
        function.
      </para>
      <para>
        Sometimes a problem will occur while you are working on
        writing data to the database.  Perhaps you get an error from
        the database or discover a problem with the data.  In these
        instances, you can "roll back" your changes.  This will cause
        all changes you were making since your last &commit; or roll
        back to be forgotten.  In HDBC, you can call the &rollback;
        function to do this.  If you are using &withTransaction;, any
        uncaught exception will cause a roll back to be issued.
      </para>
      <warning>
        <para>
          One popular database, MySQL, does not support transactions
          with its default table type.  In its default configuration,
          MySQL will silently ignore calls to &commit; or &rollback;
          and will commit all changes to disk immediately.  The HDBC
          ODBC driver has instructions for configuring MySQL to
          indicate to HDBC that it does not support transactions,
          which will cause &commit; and &rollback; to generate
          errors.  Alternatively, you can use InnoDB tables with
          MySQL, which do support transactions.  InnoDB tables are
          recommended for use with HDBC.
        </para>
      </warning>
    </sect1>

    <sect1 id="hs.databases.simplequeries">
      <title>Simple Queries</title>
      <para>
        Some of the simplest queries in SQL involve statements that
        don't return any data.  These queries can be used to create
        tables, insert data, delete data, and set database parameters.
      </para>
      <para>
        The most basic function for sending queries to a database is
        &run;.  This function takes an &IConnection;, a &String;
        representing the query itself, and a list of parameters.
        Let's use it to set up some things in our database.
      </para>
      &query.ghci:setup;
      <para>
        After connecting to the database, we first created a table
        called <literal>test</literal>.  Then we inserted one row of
        data into the table.  Finally, we committed the changes and
        disconnected from the database.  Note that if we hadn't called
        &commit;, no final change would have been written to the
        database at all.
      </para>
      <para>
        The &run; function returns the number of rows each query
        modified.  For the first query, which created a table, no rows
        were modified.  The second query inserted a single row, so
        &run; returned <literal>1</literal>.
      </para>
    </sect1>

    <sect1 id="hs.database.sqlvalue">
      <title>SqlValues</title>
      <para>
        Before proceeding any farther, we need to discuss a data type
        introduced in HDBC: &SqlValue;.  Since both Haskell and SQL
        are strongly-typed systems, HDBC tries to preserve type
        information as much as possible.  At the same time, Haskell
        and SQL types don't exactly mirror each other.  Furthermore,
        different databases have different ways of representing things
        such as dates or special characters in strings.
      </para>
      <para>
        &SqlValue; is a data type that has a number of constructors
        such as &SqlString;, &SqlBool;, &SqlNull;, &SqlInteger;, and
        more.  This lets you represent various types of data in
        argument lists to the database, and to see various types of
        data in the results coming back, and still store it all in a
        list.  There are convenience functions &toSql; and &fromSql;
        that you will normally use.  If you care about the precise
        representation of data, you can still manually construct
        &SqlValue; data if you need to.
      </para>
    </sect1>

    <sect1 id="hs.databases.args">
      <title>Query Parameters</title>
      <para>
        HDBC, like most databases, supports a notion of replacable
        paramaters in queries.  There are two primary benefits of
        using replacable parameters: they improve performance when
        executing similar queries repeatedly, and they permit easy and
        portable insertion of data into queries.
      </para>
      <para>
        Let's say you wanted to add thousands of rows into our new
        table <literal>test</literal>.  You could issue thousands of
        queries looking like <literal>INSERT INTO test VALUES (0,
        'zero')</literal> and <literal>INSERT INTO test VALUES (1,
        'one')</literal>.  This forces the database server to parse
        each SQL statement individually.  If you could replace the two
        values with a placeholder, the server could parse the SQL
        query once, and just execute it multiple times with the
        different data.
      </para>
      <para>
        A second problem involves escaping.  What if you wanted to
        insert the string <literal>I don't like 1</literal>?  SQL uses
        the single quote character to show the end of the field.  Most
        SQL databases would require you to write this as <literal>I
        don''t like 1</literal>.  But rules for other special
        charcters such as backslashes differ between databases.
        Rather than trying to code this yourself, HDBC can handle it
        all for you.  Let's look at an example.
      </para>
      &query.ghci:runargs;
      <para>
        The question marks in the INSERT query in this example are the
        placeholders.  We then passed the parameters that are going to
        go there.  &run; takes a list of &SqlValue;, so we used
        &toSql; to convert each item into an &SqlValue;.  HDBC
        automatically handled conversion of the &String;
        <literal>"zero"</literal> into the appropriate representation
        for the database in use.
      </para>
      <para>
        This approach won't actually achieve any performance benefits
        when inserting large amounts of data.  For that, we need more
        control over the process of creating the SQL query.  We'll
        discuss that in the next section.
      </para>
      <note>
        <para>
          Replacable parameters only work for parts of the queries
          where the server is expecting a value, such as a WHERE
          clause in a SELECT statement or a value for an INSERT
          statement.  You cannot say <literal>run "SELECT * from ?"
          [toSql "tablename"]</literal> and expect it to work.  A
          table name is not a value, and most databases will not
          accept this syntax.  That's not a big problem in practice,
          because there is rarely a call for replacing things that
          aren't values in this way.
        </para>
      </note>
    </sect1>

    <sect1 id="hs.databases.statements">
      <title>Prepared Statements</title>
      <para>
        HDBC defines a function &prepare; that will prepare a SQL
        query, but it does not yet bind
        the parameters to the query.  &prepare; returns a
        &Statement; representing the compiled query.  
      </para>
      <para>
        Once you have a &Statement;, you can do a number of things
        with it.  You can call &execute; on it one or more times.
        After calling &execute; on a query that returns data, you can
        use one of the fetch functions to retrieve that data.
        Functions like &run; and &quickQueryp; use statements and
        &execute; internally; they are simply shortcuts to let you
        perform common tasks quickly.  When you need more control over
        what's happening, you can use a &Statement; instead of a
        function like &run;.
      </para>
      <para>
        Let's look at using statements to insert multiple values with
        a single query.  Here's an example:
      </para>
      &query.ghci:mult;
      <para>
        In this example, we created a prepared statement and called it
        <literal>stmt</literal>.  We then executed that statement four
        times, and passed different parameters each time.  These
        parameters are used, in order, to replace the question marks
        in the original query string.  Finally, we commit the changes
        and disconnect the database.
      </para>
      <para>
        HDBC also provides a function &executeMany; that can be useful
        in situations such as this.  &executeMany; simply takes a list
        rows of data to call the statement with.  Here's an example:
      </para>
      &query.ghci:executeMany;
      <note>
        <para>
          On the server, most databases will have an optimization that
          they can apply to <literal>executeMany</literal> so that they only have to compile
          this query string once, rather than twice.<footnote><para>HDBC
              emulates this behavior for databases that do not provide it,
              providing programmers a unified API for running queries
              repeatedly.</para> </footnote> This can lead to a dramatic
          performance gain when inserting large amounts of data at
          once.  Some databases can also apply this optimization to
          <literal>execute</literal>, but not all.
        </para>
      </note>
    </sect1>

    <sect1 id="hs.databases.readingresults">
      <title>Reading Results</title>
      <para>
        So far, we have discussed queries that insert or change data.
        Let's discuss getting data back out of the database.  The
        function &quickQueryp; looks very similar to &run;, but it
        returns a list of results instead of a count of changed rows.
        &quickQueryp; is normally used with SELECT statements.  Let's
        see an example:
      </para>
      &query.ghci:qqp;
      <para>
        &quickQueryp; returns a list of rows, where each row is itself
        represented as <literal>[SqlValue]</literal>.  The values in
        the row are listed in the order returned by the database.  You
        can use <literal>fromSql</literal> to convert them into
        regular Haskell types as needed.
      </para>
      <para>
        It's a bit hard to read that output.  Let's extend this
        example to format the results nicely.  Here's some code to do
        that:
      </para>
      &query.hs:all;
      <para>
        This program does mostly the same thing as our example with
        &ghci;, but with a new addition: the
        <literal>convRow</literal> function.  This function takes a
        row of data from the database and converts it to a &String;.
        This string can then be easily printed out.
      </para>
      <para>
        Notice how we took <literal>intid</literal> from
        <literal>fromSql</literal> directly, but processed
        <literal>fromSql sqlDesc</literal> as a <literal>Maybe
        String</literal> type.  If you recall, we declared that the
        first column in this table can never contain a NULL value, but
        that the second column could.  Therefore, we can safely ignore
        the potential for a NULL in the first column, but not in the
        second.  It is possible to use <literal>fromSql</literal> to
        convert the second column to a &String; directly, and it would
        even work -- until a row with a NULL in that position was
        encountered, which would cause a runtime exception.  So, we
        convert a SQL NULL value into the string
        <literal>"NULL"</literal>.  When printed, this will be
        indistinguishable from a SQL string <literal>'NULL'</literal>,
        but that's acceptable for this example.  Let's try calling
        this function in &ghci;:
      </para>
      &query.ghci:queryhs;

      <sect2 id="hs.databases.readingstatements">
        <title>Reading with Statements</title>
        <para>
          As we discussed in <xref
          linkend="hs.databases.statements"/>, you can use statements
          for reading.  There are a number of ways of reading data
          from statements that can be useful in certain situations.
          Like &run;, &quickQueryp; is a convenience function that in
          fact uses statements to accomplish its task.
        </para>
        <para>
          To create a statement for reading, you use &prepare; just as
          you would for a statement that will be used to write data.
          You also use &execute; to execute it on the database
          server.  Then, you can use various functions to read data
          from the &Statement;.  The &fetchAllRowsp; function returns
          <literal>[[SqlValue]]</literal>, just like &quickQueryp;.
          There is also a function called
          <literal>sFetchAllRows'</literal>, which converts every
          column's data to a <literal>Maybe String</literal> before
          returning it.  Finally, there is
          <literal>fetchAllRowsAL'</literal>, which returns
          <literal>(String, SqlValue)</literal> pairs for each
          column.  The &String; is the column name as returned by the
          database; see <xref linkend="hs.databases.metadata"/> for
          other ways to obtain column names.
        </para>
        <para>
          You can also read data one row at a time by calling
          <literal>fetchRow</literal>, which returns <literal>IO
          (Maybe [SqlValue])</literal>.  It will be &Nothing; if all
          the results have already been read, or one row otherwise.
        </para>
        <remark>FIXME: start here</remark>


      </sect2>

      <sect2 id="hs.databases.readinglazy">
        <title>Lazy Reading</title>
        <para><remark>FIXME</remark></para>
      </sect2>

    </sect1>
        
    <sect1 id="hs.databases.metadata">
      <title>Database Metadata</title>
      <para><remark>FIXME</remark></para>
    </sect1>

    <sect1 id="hs.databases.errors">
      <title>Error Handling</title>
      <para><remark>FIXME</remark></para>
    </sect1>

    <sect1 id="hs.databases.threading">
      <title>Threading</title>
      <para><remark>FIXME</remark></para>
    </sect1>

    <sect1 id="hs.databases.typeable">
      <title>Data.Typeable</title>
      <para><remark>FIXME</remark></para>
    </sect1>
  </chapter>
  

  <!--
  local variables: 
  sgml-parent-document: ("00book.xml" "book")
  end:
  -->
