<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="sockets" revision="unpublished">
  <title>Sockets and Syslog</title>

  <sect1 id="sockets.basics">
    <title>Basic Networking</title>
    <para id="x_Od">
      In several earlier chapters of this book <remark>FIXME: insert
      refs</remark>, we have discussed services that operate over a
      network.  Two examples are client/server databases and web
      services.  When the need arises to devise a new protocol, or to
      communicate with a protocol that doesn't have an existing helper
      library in Haskell, you'll need to use the lower-level
      networking tools in the Haskell library.
    </para>
    <para id="x_Pd">
      In this chapter, we will discuss these lower-level tools.
      Network communication is a broad topic with entire books devoted
      to it.  In this chapter, we will show you how to use Haskell to
      apply low-level network knowledge you already have.  If you need
      a background on network programming, we suggest <remark>FIXME:
      insert reference to an appropriate book</remark>.
    </para>
    <para id="x_Qd">
      Haskell's networking functions almost always correspond directly
      to familiar C function calls.  As most other languages also
      layer atop C, you should find this interface familiar.
    </para>
  </sect1>
  
  <sect1 id="sockets.udp">
    <title>Communicating with UDP</title>
    <para id="x_Rd">
      UDP breaks data down into packets.  It does not ensure that the
      data reaches its destination, or reaches it only once.  It does
      use checksumming to ensure that packets that arrive have not
      been corrupted.  UDP tends to be used in applications that are
      performance- or latency-sensitive, in which each individual
      packet of data is less important than the overall performance of
      the system.  It may also be used where the TCP behavior isn't
      the most efficient, such as ones that send short, discrete
      messages.  Examples of systems that tend to use UDP
      include audio and video conferencing, time synchronization,
      network-based filesystems, and logging systems.
    </para>

    <sect2 id="sockets.udp.client">
      <title>UDP Client Example: syslog</title>
      <para id="x_Sd">
        The traditional Unix syslog service allows programs to send
        log messages over a network to a central server that records
        them.  Some programs are quite performance-sensitive, and may
        generate a large volume of messages.   In these programs, it
        could be more important to have the logging impose a minimal
        performance overhead than to guarantee every message is
        logged.  Moreover, it may be desirable to continue program
        operation even if the logging server is unreachable.  For this
        reason, UDP is one of the protocols supported by syslog for
        the transmission of log messages.  The protocol is simple and
        we present a Haskell implementation of a client here.
      </para>
      &syslogclient.hs:all;
      <para>
        This also requires <literal>SyslogTypes.hs</literal>, shown
        here:
      </para>
      &SyslogTypes.hs:all;
      <para>
        With &ghci;, you can send a message to a local syslog server.
        You can use either the example syslog server presented in this
        chapter, or an existing syslog server like you would typically
        find on Linux or other POSIX systems.  Note that most of these
        disable the UDP port by default and you may need to enable UDP
        before your vendor-supplied syslog daemon will display
        received messages.
      </para>
      <para>
        If you were sending a message to a syslog server on the local
        system, you might use a command such as this:
      </para>
      &syslogclient.ghci:all;
      
    </sect2>

    <sect2 id="sockets.udp.server">
      <title>UDP Syslog Server</title>
      <para id="x_Td">
        UDP servers will bind to a specific port on the server
        machine.  They will accept packets directed to that port and
        process them.  Since UDP is a stateless, packet-oriented
        protocol, programmers normally use a call such as
        <literal>recvFrom</literal> to receive both the data and
        information about the machine that sent it, which is used for
        sending back a response.
      </para>
      &syslogserver.hs:all;
      <para>
        You can run this in &ghci;.  A call to <literal>serveLog
        "1514" plainHandler</literal> will set up a UDP server on port
        1514 that will use <literal>plainHandler</literal> to print
        out every incoming UDP packet on that port.  Ctrl-C will
        terminate the program.
      </para>
    </sect2>

  </sect1>

  <sect1 id="sockets.tcp">
    <title>Communicating with TCP</title>
    <para id="x_Ud">
      TCP is designed to make data transfer over the Internet as
      reliable as possible.  TCP traffic is a stream of data.  While
      this stream gets broken up into individual packets by the
      operating system, the packet boundaries are neither known nor
      relevant to applications.  TCP guarantees that, if traffic is
      delivered to the application at all, that it has arrived intact,
      unmodified, exactly once, and in order.  Obviously, things such
      as a broken wire can cause traffic to not be delivered, and no
      protocol can overcome those limitations.
    </para>
    <para id="x_Vd">
      This brings with it some tradeoffs compared with UDP.  First of
      all, there are a few packets that must be sent at the start of
      the TCP conversation to establish the link.  For very short
      conversations, then, UDP would have a performance advantage.
      Also, TCP tries very hard to get data through.  If one end of a
      conversation tries to send data to the remote, but doesn't
      receive an acknowledgment back, it will periodically re-transmit
      the data for some time before giving up.  This makes TCP robust
      in the face of dropped packets.  However, it also means that TCP
      is not the best choice for real-time protocols that involve
      things such as live audio or video.
    </para>
    <para id="x_Wd">
      
    </para>
    <para id="x_Xd">
      Multithreading to handle multiple connections
    </para>
  </sect1>


</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
