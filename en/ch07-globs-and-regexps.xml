<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.glob">
  <title>Case study: regular expressions and file name
    matching</title>

  <para>Working with text strings is a fundamental tool in the
    programmer's toolbox.  We've already been introduced to
    bytestrings and ropes as efficient ways to work with large text
    strings.  Throughout this book, we'll be returning to string
    manipulation over and again, to show off the breadth of different
    techniques and libraries you can use to tackle different problems
    that happen to involve working with strings.</para>

  <para>In this chapter, we'll develop a library that can match file
    names against succinct <quote>glob-style</quote> patterns.  This
    is a common feature of command shells on popular platforms.  To
    begin, we'll introduce the pattern language that we'll be working
    with.  The first version of our library will translate these
    patterns into regular expressions, so we'll need to understand how
    to use regular expressions in Haskell.  Next, we'll talk about how
    to use Haskell's standard directory listing functions with this
    library.  We'll then write an interpreter for the pattern language
    directly, so that we can avoid the regular expression library.
    Along the way, we'll talk a little about writing portable code in
    Haskell.</para>

  <sect1>
    <title>File name matching</title>

    <para>Many <quote>system-oriented</quote> programming languages
      provide library routines that let you match a file name against
      a pattern, or that will give a list of files that match the
      pattern.  (In other languages, this function is often named
      <function>fnmatch</function>.)  Although Haskell's standard
      library generally has good <quote>system programming</quote>
      facilities, it doesn't provide these kinds of pattern matching
      functions.  We'll take this as an opportunity to develop our
      own.</para>

    <para>The kinds of patterns we'll be dealing with are commonly
      referred to as <quote>glob patterns</quote> (the term we'll
      use), <quote>wildcard patterns</quote>, or <quote>shell-style
	patterns</quote>.  These patterns have just a few simple
      rules.</para>

    <itemizedlist>
      <listitem>
	<para>Matching a string against a pattern starts at the
	  beginning of a string, and finishes at the end.</para>
      </listitem>
      <listitem>
	<para>Most literal characters match themselves.  For example,
	  the text <literal>foo</literal> in a pattern will match
	  <literal>foo</literal>, and only <literal>foo</literal>, in
	  an input string.</para>
      </listitem>
      <listitem>
	<para>The <literal>*</literal> (asterisk) character means
	  <quote>match anything</quote>; it will match any text,
	  including the empty string.</para>
      </listitem>
      <listitem>
	<para>The <literal>?</literal> (question mark) character means
	  <quote>match any single character</quote>.</para>
      </listitem>
      <listitem>
	<para>A <literal>[</literal> (open square bracket) character
	  begins a <emphasis>character class</emphasis>, which is
	  ended by a <literal>]</literal>.  Its meaning is
	  <quote>match any character in this class</quote>.  A
	  character class can be <emphasis>negated</emphasis> by
	  following the opening <literal>[</literal> with a
	  <literal>!</literal>, so that it means <quote>match any
	    character <emphasis>not</emphasis> in this
	    class</quote>.</para>
	<para>As a shorthand, a character followed by a
	  <literal>-</literal> (dash), followed by another character,
	  denotes a <emphasis>range</emphasis>: <quote>match any
	    character within this set</quote>.</para>
	<para>Character classes have an added subtlety; they can't be
	  empty.  The first character after the opening
	  <literal>[</literal> or <literal>[!</literal> is part of the
	  class.</para>
      </listitem>
      <listitem>
	<para>Outside of a character class, there is an <quote>escape
	    character</quote> (<literal>\</literal> on Unix-like
	  systems), the character following it takes its normal
	  literal meaning (so <literal>\*</literal> matches an
	  asterisk, not any text).</para>
      </listitem>
    </itemizedlist>

    <para>While Haskell doesn't provide a glob matching function, it
      has excellent regular expression matching facilities.  Glob
      patterns are nothing more than restricted regular expressions
      with slightly different syntax.  It's easy to convert glob
      patterns into regular expressions, so we'll take that tack
      initially.  But in order to do so, we must first understand how
      to use regular expressions in Haskell.</para>
  </sect1>

  <sect1>
    <title>Regular expressions in Haskell</title>

    <para>In this section, I'll be assuming that you are already
      familiar with regular expressions (which I'll abbreviate as
      <emphasis>regexps</emphasis> from here on) by way of some other
      language, such as Python, Perl, or Java.  Rather than introduce
      them as something new, I'll be focusing on what's different
      about regexp handling in Haskell, compared to imperative
      languages.  Haskell's regular expression matching libraries are
      a lot more expressive than those of other languages, so there's
      plenty to talk about.</para>

    <para>To begin our use of the regexp libraries, the only module
      we'll need to work with is <classname
	role="module">Text.Regex.Posix</classname>.  As usual, the
      most convenient way to explore this module is by interacting
      with it via <command>ghci</command>.</para>

    &regexp.ghci:load;

    <para>The only function that we're likely to need for normal use
      is the regexp matching function, an infix operator named
      <function>=~</function> (borrowed from Perl.  The first hurdle
      to overcome is that Haskell's regexp libraries make heavy use of
      polymorphism.  As a result, the type signature of the
      <function>=~</function> operator is a bit difficult to
      understand.  Let's drop into <command>ghci</command> and see
      what it looks like.</para>

    &regexp.ghci:typetwiddle;

    <para>Ouch!  Rather than pick apart what this convoluted
      definition means, let's take a shortcut.  The
      <function>=~</function> operator uses typeclasses for both of
      its arguments, and also for its return type.  The first argument
      (on the left of the <function>=~</function>) is the text to
      match; the second (on the right) is the regular expression to
      match against.  We can pass either a <type>String</type> or a
      <type>Data.ByteString</type> as either argument.</para>

    <sect2>
      <title>The many types of result</title>

      <para>The <function>=~</function> operator is polymorphic in its
	return type, so the Haskell compiler needs some way to know
	what type of result we would like.  In real code, it may be
	able to infer the right type, due to the way we subsequently
	use the result.  But such cues are often lacking when we're
	exploring with <command>ghci</command>.  If we omit a specific
	type for the result, we'll get an intimidating-looking error
	message.  Here's what <command>ghci</command> tells us if we
	try to do a regexp match but omit the return type.</para>

      &regexp.ghci:noreturn;

      <para>That's quite an impenetrable error message, but what it
	means is that <command>ghci</command> can't infer what type of
	result to give back to us.  (This is the same kind of error
	that a compiler would print if it couldn't infer the correct
	type in a real program.)  Here's the key to dealing with this
	error.  When <command>ghci</command> can't infer the <varname
	  condition="tyvar">target</varname> type, we tell it what
	we'd like the type to be.  If we want an expression of type
	<type>Bool</type>, we'll get a pass/fail result.</para>

      &regexp.ghci:bool.passfail;

      <para>In the bowels of the base regexp library, there's a
	typeclass named <classname>RegexContext</classname> that
	describes how a <varname condition="tyvar">target</varname>
	type should behave; the base library defines many instances of
	this typeclass for us. The <type>Bool</type> type is an
	instance of this typeclass, so we get back a usable result.
	Another such instance is <type>Int</type>, which gives us a
	count of the number of times the regexp matches.</para>

      &regexp.ghci:int.count;

      <para>If we ask for a <type>String</type> result, we'll get the
	first substring that matches, or an empty string if nothing
	matches.</para>

      &regexp.ghci:string;

      <note>
	<para>Getting back an empty string for <quote>no match</quote>
	  poses an obvious difficulty if the empty string could be a
	  valid match for the regexp.</para>

	<remark>FIXME: Find some place to mention the monadic
	  <function>=~~</function> operator.</remark>
      </note>

      <para>Another valid type of result is <type>[String]</type>,
	which returns a list of <emphasis>all</emphasis> matching
	strings.</para>

      &regexp.ghci:list.string;
      
      <para>That's about it for <quote>simple</quote> result types,
	but we're not by any means finished.  Before we continue,
	let's use a single pattern for our remaining examples.</para>
      
      &regexp.ghci:let;

      <para>We can obtain quite a lot of information about the context
	in which a match occurs.  If we ask for a three-element tuple,
	we'll get back the text <emphasis>before</emphasis> the first
	match, the text <emphasis>of</emphasis> that match, and the
	text that <emphasis>follows</emphasis> it.</para>

      &regexp.ghci:3tuple.match;

      <para>If the match fails, the entire text is returned as the
	<quote>before</quote> element of the tuple, with the other two
	elements left empty.</para>

      &regexp.ghci:3tuple.nomatch;

      <para>Asking for a four-element tuple gives us a fourth element
	that's a list of all groups in the pattern that
	matched.</para>

      &regexp.ghci:4tuple;

      <para>We can get  numeric information about matches, too.  A
	pair of <type>Int</type>s gives us the starting offset of the
	first match, and its length.  If we ask for a list of these
	pairs, we'll get this information for all matches.</para>

      &regexp.ghci:2tuple.match;

      <para>A failed match is represented by the value
	<literal>-1</literal> as the first element of the tuple (the
	match offset), or an empty list of tuples.</para>

      &regexp.ghci:2tuple.nomatch;

      <para>Believe it or not, this is <emphasis>not</emphasis> a
	comprehensive list of built-in instances of the
	<classname>RegexContext</classname> typeclass.  For a complete
	list, see the documentation for the <classname
	  role="module">Text.Regex.Base.Context</classname>
	module.</para>

    </sect2>

    <sect2>
      <title>Mixing and matching string types</title>

      <para>As we noted earlier, the <function>=~</function> operator
	uses typeclasses for its argument types and its return type.
	Any combination of <type>String</type> and
	<type>ByteString</type> will work for the types of both the
	regular expression and the text to match against.</para>

      &regexp.ghci:mix.simple;
      
      <para>However, be aware that if you want a string value in the
	result of a match, the text you're matching against must be
	the same type of string.  Let's see what this means in
	practice.</para>

      &regexp.ghci:mix.match;

      <para>In the above example, we've used the
	<function>pack</function> to turn a <type>String</type> into a
	<type>ByteString</type>.  The typechecker accepts this because
	<type>ByteString</type> appears in the result type.  But if we
	try getting a <type>String</type> out, that
	<emphasis>won't</emphasis> work.</para>

      &regexp.ghci:mix.nomatch;

      <para>And ouch!  That's quite an error message.  Don't let its
	verbosity confound you; we can easily fix this problem by
	making the string types of the left hand side and the result
	match once again.</para>

      &regexp.ghci:mix.rematch;

      <para>This restriction does <emphasis>not</emphasis> apply to
	the type of the regexp to match against.  It can be either a
	<type>String</type> or <type>ByteString</type>, unconstrained
	by the other types in use.</para>
    </sect2>

    <sect2>
      <title>Other things you should know</title>

      <para>When you look through Haskell library documentation,
	you'll see several regexp-related modules.  The modules under
	<classname role="module">Text.Regex.Base</classname> define
	the common API adhered to by all of the other regexp modules.
	It's possible to have multiple implementations of the regexp
	API installed at one time.  At the time of writing,
	<application>GHC</application> is bundled with one
	implementation, <classname
	  role="module">Text.Regex.Posix</classname>.  As its name
	suggests, this package provides POSIX regexp semantics.</para>

      <note>
	<para>If you're coming to Haskell from a language like Perl,
	  Python, or Java, and you've used regular expressions in one
	  of those languages, you should be aware that the POSIX
	  regexps handled by the <classname
	    role="module">Text.Regex.Posix</classname> module are
	  different in some significant ways from Perl-style regexps.
	  Here are a few of the more notable differences.</para>

	<para>Perl regexp engines do left-biased matching when
	  matching alternatives, whereas POSIX engines choose the
	  greediest match.  What this means is that given a regexp of
	  <literal>(foo|fo*)</literal> and a text string of
	  <literal>foooooo</literal>, a Perl-style engine will give a
	  match of <literal>foo</literal> (the leftmost match), while
	  a POSIX engine will match the entire string (the greediest
	  match).</para>

	<para>POSIX regexps have less uniform syntax than Perl-style
	  regexps.  They also lack a number of capabilities provided
	  by Perl-style regexps, such as zero-width assertions and
	  control over greedy matching.</para>
      </note>

      <para>Other Haskell regexp packages are available for download
	on the Internet.  Some provide faster engines than the current
	POSIX engine; others provide Perl-style matching capabilities.
	All follow the standard API that we have covered in this
	section.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Translating a glob pattern into a regular
      expression</title>

    <para>Now that we've seen the myriad of ways to match text against
      regular expressions, let's turn our attention back to glob
      patterns.  We want to write a function that will take a glob
      pattern and return its representation as a regular expression.
      Both glob patterns and regexps are text strings, so the type
      that our function ought to have seems clear.</para>

    &GlobRegex.hs:type;

    <para>We start our definition of the
      <function>globToRegex</function> function by recalling that a
      text string must match a glob pattern.  Before we attempt to
      convert any part of the glob pattern, we need to have a
      <quote>rooted</quote> regular expression.</para>
    
    &GlobRegex.hs:rooted;

    <para>Recall that the <type>String</type> is just a synonym for
      <type>[Char]</type>, a list of <type>Char</type>s.  The
      <function>:</function> operator puts a value (the
      <literal>^</literal> character in this case) onto the front of a
      list, where the list is the value returned by the yet-to-be-seen
      <function>globToRegex'</function> function.</para>

    <para>That single-quote character in the name
      <function>globToRegex'</function>is not a typo, by the way;
      Haskell is unusual in allowing single quotes as parts of
      identifiers. They usually appear at the ends of names, and are
      then most often pronounced as <quote>prime</quote>.  But you
      could, if you wanted to, name a function
      <function>head'n'tail</function>.</para>

    <note>
      <para>It's perfectly normal for a Haskell function to refer to
	functions or values that follow, rather than precede, it in a
	source file.  The Haskell compiler doesn't care about ordering
	at this level.  This grants you the flexibility to structure
	your code in the manner that makes most logical sense to you,
	as opposed to a way that makes the compiler writer's life
	easiest.</para>
    </note>

    <para>With the regular expression rooted, the
      <function>globToRegex'</function> function will do the bulk of
      the translation work.  We'll use the convenience of Haskell's
      pattern matching to enumerate each of the cases we'll need to
      cover.</para>

    &GlobRegex.hs:asterisk;

    <para>We now have a very minimal glob translator.  Our first
      clause requires that if we hit the end of our glob pattern, we
      return <literal>$</literal>, the regular expression symbol for
      <quote>match end-of-line</quote>.  The second gets us to
      substitute the string <literal>.*</literal> every time we see a
      <literal>*</literal> in our input list.  And the third passes
      every other character through, unaltered.</para>

    <para>We can immediately save our new source file (let's call it
      <filename>GlobRegexTiny.hs</filename> and start playing with it
      in <command>ghci</command>.  This is a great way to do
      exploratory programming: write a little code, load it into the
      interpreter, and see what happens.</para>

    &glob-regexp.ghci:tiny;

    <para>These few lines of interaction might look trivial, but we
      have received immediate feedback on two fronts: our code passes
      the daunting scrutiny of Haskell's typechecker, and it produces
      sensible-looking results. Monkeying around with code in the
      interpreter early and often is consistently worthwhile.</para>

    <para>The remaining cases for a complete definition of
      <function>globToRegex'</function> are easy to enumerate.  First,
      we get <literal>?</literal> out of the way.</para>

    &GlobRegex.hs:question;

    <para>More interesting is how we handle character classes.</para>

    &GlobRegex.hs:class;

    <para>We take advantage of two behaviours of Haskell's pattern
      matcher here.  The first is that it will match patterns in the
      order in which we declare them, so we place the most specific
      patterns first, and the least specific last.  Secondly, there's
      no limit to the <quote>depth</quote> of a pattern: we can
      <quote>peek</quote> forwards into a list as far as we need
      to.</para>

    <para>Here, the first pattern matches on three consecutive items
      of its input to ensure that a <quote>negative</quote> character
      class cannot be empty.  The second pattern matches on only two
      items, so ensure that a <quote>positive</quote> character class
      cannot be empty.  The final clause can only match if it's given
      a syntactically invalid character class.</para>

    <para>Finally, all other characters can be passed through, but
      they may need to be escaped.</para>

    &GlobRegex.hs:last;

    <para>The <function>escape</function> function ensures that the
      regexp engine will not interpret certain characters as pieces of
      regular expression syntax.</para>

    &GlobRegex.hs:escape;

    <para>The <function>charClass</function> helper function does
      nothing more than ensure that a character class is correctly
      terminated.  It passes its input through unmolested until it
      hits a <literal>]</literal>, when it hands control back to
      <function>globToRegex'</function>.</para>

    &GlobRegex.hs:charClass;

    <para>Now that we've finished defining
      <function>globToRegex</function> and its helpers, let's load it
      into &ghci; and try it out.</para>

    &glob-regexp.ghci:real;

    <para>Sure enough, that looks like a reasonable regexp.  Can we
      use it to match against a string?</para>

    &glob-regexp.ghci:matches;

    <para>It works!  Now let's play around a little with &ghci;.  We
      can create a temporary definition for
      <function>fnmatch</function> and try it out.  (This is another
      example of how &ghci; is great for exploratory
      programming.)</para>

    &glob-regexp.ghci:fnmatch;

    <para>The name <quote><function>fnmatch</function></quote> doesn't
      really have the <quote>Haskell nature</quote>, though.  The
      typical Haskell style is for functions to have descriptive,
      camel cased names.  In our library, we'll give this function the
      name <function>matchesGlob</function>.</para>

    &GlobRegex.hs:matchesGlob;

    <sect2>
      <title>Exercises</title>

      <qandaset defaultlabel="number">

	<qandaentry>
	  <question>
	    <para>Use &ghci; to explore what happens if you pass a
	      malformed pattern, such as <literal>[</literal>, to
	      <function>globToRegex</function>.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>While filesystems on Unix are usually sensitive to
	      case (e.g. <quote>G</quote> vs. <quote>g</quote>) in
	      file names, Windows filesystems are not. Add a parameter
	      to the <function>globToRegex</function> and
	      <function>matchesGlob</function> functions that allows
	      control over case sensitive matching.</para>
	  </question>
	</qandaentry>

      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>An important aside: writing lazy functions</title>

    <para>In an imperative language, the
      <function>globToRegex'</function> function is one that we'd
      usually express as a loop. For example, Python's standard
      <package>fnmatch</package> module includes a function named
      <function>translate</function> that does exactly the same job as
      our <function>globToRegex</function> function.  It's written as
      a loop.</para>

    <para>If you've been exposed to functional programming through a
      language such as Scheme or ML, you've probably had drilled into
      your head the notion that <quote>the way to emulate a loop is
	via tail recursion</quote>.  A function
      usually needs a little local scratch storage when it executes.
      A tail recursive function must either return a plain value, or
      make a recursive call as the last thing it does (these kinds of
      call are called <quote>tail calls</quote>).  Since a function
      making a tail call can by definition never use any of its local
      scratch storage again, a language implementation can reuse that
      space when it makes the tail call. This means that a series of
      tail calls can execute in constant space, just as we take for
      granted with a loop.</para>

    <para>Looking at the <function>globToRegex'</function> function,
      we can see that it is <emphasis>not</emphasis> tail recursive.
      To see why, let's examine its final clause again (several of its
      other clauses are structured similarly).</para>

      &GlobRegex.hs:last.noid;

    <para>It calls itself recursively, but this
      <emphasis>isn't</emphasis> the last thing the function does.
      The result of the recursive call is a parameter to the
      <function>(++)</function> function.</para>

    <para>So what's going on here?  Why are we not writing a tail
      recursive definition for this function?  The answer lies with
      Haskell's non-strict evaluation strategy.  Before we start
      talking about that, let's quickly talk about why, in a
      traditional language, we'd be trying to avoid this kind of
      recursive definition.</para>

    <para>Returning to the clause above,
      <function>globToRegex'</function> computes a little bit of its
      result, then calls itself recursively, then returns the complete
      result.  In a traditional language, each recursive call is going
      to require the allocation of temporary scratch memory until it
      returns.</para>

    <remark>Image: stack allocation for a recursive call to
      <function>globToRegex'</function>.</remark>

    <para>Compound these scratch allocations over a large number of
      recursive calls, and the amount of space we use while processing
      grows linearly with the size of the list we must process.</para>

    <remark>Image: stack allocation for a pile of recursive
      calls.</remark>

    <para>For a problem like glob-to-regexp conversion, where we'll
      always be dealing with very small amounts of data, this overhead
      is insignificant.  But if we had a hundred million elements to
      process, and used plain recursion rather than tail recursion or
      a loop to process them, we'd have a severe problem.</para>

    <para>Haskell neatly defangs this problem by deferring the
      evaluation of an expression until its result is needed.  To
      understand how this deferred evaluation works, let's walk
      through what happens when the final clause of the
      <function>globToRegex'</function> is called.  (As you read, bear
      in mind that this is a simplified description.)</para>

    <para>In order to determine that this clause must be called, the
      pattern matcher must inspect a little bit of the list it was
      passed.  The pattern requires it to do nothing more than
      determine whether it has been given an empty list (in which case
      the clause will not be evaluated), or a non-empty list (the case
      we're interested in).  Once the pattern matcher has established
      that the list isn't empty, it goes no deeper.  It doesn't look
      inside <varname>c</varname>, the head of the list.  It doesn't
      follow <varname>cs</varname>, the tail.</para>

    <para>We have now decided to evaluate the right hand side of
      the clause.  The first expression we must evaluate is the call
      to the list append function, <function>(++)</function>.
      (Because we don't need the results of <code>escape c</code> or
      <code>globToRegex' cs</code> yet, we suspend the evaluation of
      those functions, to evaluate when we'll need them.)  So let's
      remind ourselves what <function>(++)</function> looks
      like:</para>

      &append.hs:append;

    <para>As the argument to <function>(++)</function> is not an
      empty list, the second clause matches, so we must evaluate
      <varname>x</varname>.  This requires that we evaluate
      <code>escape c</code>, which we had earlier deferred.  Let's
      look again at the definition of
      <function>escape</function>.</para>

    &GlobRegex.hs:escape.noid;

    <para>This will return a list whose first element is either the
      <literal>\</literal> character or the character it was passed.
      Once we've constructed the first element of this list, we'll
      defer constructing the rest of it until our caller needs it.  We
      suspend the evaluation of the rest of
      <function>escape</function> so that we can pass this datum back
      to our caller.  Haskell implementations do this by saving away
      enough information to resume the evaluation later; this saved
      package of information is called a <quote>thunk</quote>.</para>

    <para>Not only is the evaluation of <function>escape</function>
      suspended; so too are the evaluation of its callers,
      <function>(++)</function> and <function>globToRegex'</function>,
      and so on up the call chain until some expression needs to
      inspect the value.</para>

    <para>What would happen if the caller of
      <function>globToRegex'</function> was for some reason the
      function <function>null</function>?  <function>null</function>
      only cares whether its argument is an empty list: once it finds
      this out, it's never going to look at the remainder of the
      result of <function>globToRegex'</function>.  None of the work
      we deferred in order to get a partial result back to
      <function>null</function> will ever actually occur.</para>

    <para>Remarkably, given this kind of evaluation strategy, our
      recursive definition of <function>globToRegex'</function> will
      execute in constant space (more or less).  To see why, look at
      the definition of <function>(++)</function>; although it's
      simpler, it has a similar recursive structure.</para>

    <para>If we put on our implementor's hats and think about how we
      might suspend the evaluation of <function>(++)</function> in a
      thunk, all we need to store are the current heads of the left
      and right lists; the result of the next evaluation step depends
      on nothing more.  On each resumption of the thunk, we could
      simply peel off the head of the left list and update the thunk
      with the new head, repeating until we reach its end.  Therefore,
      we can execute in constant space.</para>
  </sect1>

  <sect1>
    <title>Making use of our pattern matcher</title>

    <para>It's all very well to have a function that can match glob
      patterns, but we'd like to be able to put this to practical use.
      On Unix-like systems, the <function>glob</function> function
      returns the names of all files and directories that match a
      given glob pattern.  Let's build a similar function in Haskell.
      Following the Haskell norm of descriptive naming, we'll call our
      function <function>namesMatching</function>.</para>

    &Glob.hs:module;

    <para>This function will obviously have to manipulate filesystem
      paths a lot, splicing and joining them as it goes.  We'll need
      to use a few previously unfamiliar modules along the way.</para>

    <para>The <classname role="module">System.Directory</classname>
      module provides standard functions for working with directories
      and their contents.</para>

    &Glob.hs:import.directory;

    <para>The <classname role="module">System.FilePath</classname>
      module abstracts the details of an operating system's path name
      conventions.  Using this together with the <classname
	role="module">System.Directory</classname> module, we can
      write a portable <function>namesMatching</function> function
      that will run on both Unix-like and Windows systems.</para>

    &Glob.hs:import.filepath;

    <para>Finally, we'll be emulating a <quote>for</quote> loop;
      getting our first taste of exception handline in Haskell; and of
      course using the <function>matchesGlob</function> function we
      just wrote.</para>

    &Glob.hs:import.rest;

    <para>Since directories and files live in the <quote>real
	world</quote> of activities that have effects, our globbing
      function will have to have <classname>IO</classname> in its
      result type.</para>

    &Glob.hs:type;

    <para>If the string we're passed doesn't contain any pattern
      characters, all we need to do is check that the given name
      exists in the filesystem.  (Notice that we use Haskell's
      function guard syntax here to write a nice tidy definition.  An
      <quote>if</quote> would do, but isn't as aestheticall
      pleasing.)</para>

    &Glob.hs:mundane;

    <para>(You might have noticed that the function
      <function>doesNameExist</function> that we use here isn't in the
      list of functions we imported from <classname
	role="module">System.Directory</classname>.  We'll define it
      shortly.)</para>

    <para>What if the string <emphasis>is</emphasis> a glob
      pattern?</para>

    &Glob.hs:otherwise;

    <para>We use <function>splitFileName</function> to split the
      string into a pair of <quote>everything but the final
	name</quote> and <quote>the final name</quote>.  If the first
      element is empty, we're looking for a pattern in the current
      directory.</para>

    &Glob.hs:curdir;

    <para>Otherwise, we must check the directory name and see if it
      contains patterns.  If it does not, we create a singleton list
      of theb directory name.  If it contains a pattern, we list all
      of the matching directories.</para>

    &Glob.hs:pats;

    <remark>Point out the use of <function>return</function> above.
      This will be one of the first times the reader will have
      encountered it.  Even if we've already discussed this topic
      earlier, we should repeat ourselves.</remark>

    <note>
      <para>Using the <classname
	  role="module">System.FilePath</classname> module can be a
	litle tricky.  Above is a case in point; let's use &ghci; to
	illustrate the problem.  The
	<function>splitFileName</function> function leaves a trailing
	slash on the end of the directory name that it returns.</para>

      &glob.ghci:split;

      <para>If we didn't remember (or know enough) to remove that
	slash, we'd recurse endlessly in that call to
	<function>namesMatching</function> above, because of the
	following behaviour of
	<function>splitFileName</function>.</para>

      &glob.ghci:tricksy;

      <para>You can guess why this note got to be written!</para>
    </note>

    <para>Finally, we collect all matches in every directory, giving
      us a list of lists, and concatenate them into a single list of
      names.</para>

    &Glob.hs:glue;

    <para>The unfamiliar <function>forM</function> function above acts
      a little like a <quote>for</quote> loop: it maps its second
      argument (an action) over its first (a list), and returns the
      resulting list.</para>

    <para>We have a few loose ends to clean up.  The first is the
      definition of the <function>doesNameExist</function> function,
      used above.  The <classname
	role="module">System.Directory</classname> doesn't let us
      check to see if a name exists in the filesystem.  It forces us
      to think about whether we want to check for the existence of a
      file or a directory, even if we don't care what kind of thing
      the name is.  We react by rolling the two into a single
      function, so that we can ignore this library peculiarity.  In
      the name of performance, we make the check for a file first,
      since files are far more common than directories.</para>

    &Glob.hs:doesNameExist;

    <para>We have two other functions to define, each of which returns
      a list of names in a directory.  The
      <function>listMatches</function> function returns a list of all
      files matching the given glob pattern in a directory, while the
      <function>listPlain</function> function returns either an empty
      or singleton list, depending on whether the single name it's
      passed exists.</para>

    &Glob.hs:listfuncs;

    <para>If you looked closely at the definition of
      <function>listMatches</function> above, you'll see a call to a
      function named <function>handle</function>.  Earlier on, we
      imported this from the <classname
	role="module">Control.Exception</classname> module; as that
      import implies, this gives us our first taste of exception
      handling in Haskell.  Let's drop into &ghci; and see what we can
      find out.</para>

    &handle.ghci:type.handle;

    <para>This is telling us that <function>handle</function> takes
      two arguments.  The first is a function that is passed an
      exception value, and can do I/O (we can see this because of the
      <type>IO</type> type in its return value); this is the handler
      to run if an exception is thrown.  The second argument is the
      code to run that might throw an exception.</para>

    <para>As for the exception handler, the type of the
      <function>handle</function> constrains it to return the same
      type of value as the body of code that threw the exception.  So
      its choices are to either throw an exception or, as in our case,
      return a list of <type>String</type>s.</para>

    <para>The <function>const</function> function takes two arguments;
      it always returns its first argument, no matter what its second
      argument is.</para>

    &handle.ghci:type.handle;

    <para>We won't have anything more to say about exception handling
      here.  There's plenty more to cover, though, so we'll be
      returning to the subject of exceptions in chapter
      <remark>FIXME</remark>.</para>

    <sect2>
      <title>Exercises</title>
      <qandaset>
	<qandaentry>
	  <question>
	    <para>Although we've gone to some lengths to write a
	      portable <function>namesMatching</function> function,
	      the function uses our case sensitive
	      <function>globToRegex</function> function.  Find a way
	      to modify <function>namesMatching</function> to be case
	      sensitive on Unix, and case insensitive on Windows,
	      without modifying its type signature.</para>
	  </question>
	  <answer>
	    <para><emphasis>Hint</emphasis>: consider reading the
	      documentation for <classname
		role="module">System.FilePath</classname> to look for
	      a variable that tells you whether you're running on a
	      Unix-like system, or on Windows.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>If you're on a Unix-like system, look through the
	      documentation for the <classname
		role="module">System.Posix.Files</classname> module,
	      and see if you can find a replacement for the
	      <function>doesNameExist</function> function.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>The <literal>*</literal> wildcard only matches names
	      within a single directory.  Many shells have an extended
	      wildcard syntax, <literal>**</literal>, that matches
	      names recursively in all directories.  For example,
	      <literal>**.c</literal> would mean <quote>match a name
		ending in <literal>.c</literal> in this directory or
		any subdirectory at any depth</quote>.  Implement
	      matching on <literal>**</literal> wildcards.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>Handling errors through API design</title>

    <para>It's not necessarily a disaster if our
      <function>globToRegex</function> is passed a malformed pattern.
      Perhaps a user mistyped a pattern, in which case we'd like to be
      able to report a meaningful error message.</para>

    <para>Calling the <function>error</function> function when this
      kind of problem happens can be a drastic response.  The
      <function>error</function> throws an exception.  Pure Haskell
      code cannot deal with exceptions, so control is going to rocket
      out of your pure code into the nearest caller that lives in
      <classname>IO</classname> and has an appropriate exception
      handler installed.  If no such handler is installed, the default
      action is to terminate your program (or print a nasty error
      message, in &ghci;).</para>

    <para>So calling <function>error</function> is a little like
      pulling the handle of a fighter plane's ejection seat.  You're
      bailing out of a catastrophic situation that you can't deal with
      more gracefully, and there's likely to be a lot of flaming
      wreckage involved.</para>

    <para>We've established that <function>error</function> is for
      disasters, but we're still using it in
      <function>globToRegex</function>, where malformed input should
      be rejected, but not turned into a big deal.  What would be a
      better way to handle this?</para>

    <para>Haskell's type system to the rescue!  We can encode the
      possibility of failure in the type signature of
      <function>globToRegex</function>, using the predefined
      <type>Either</type> type.</para>

    &GlobRegexEither.hs:type;

    <para>A value returned by <function>globToRegex</function> will
      now be either <literal>Left "an error message"</literal> or
      <literal>Right "a valid regexp"</literal>.  This return type
      forces our callers to deal with the possibility of error.</para>

    <sect2>
      <title>Exercises</title>
      <qandaset>
	<qandaentry>
	  <question>
	    <para>Write a version of <function>globToRegex</function>
	      that uses the type signature above.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Modify the type signature of
	      <function>namesMatching</function> so that it encodes
	      the possibility of a bad pattern, and make it call your
	      rewritten <function>globToRegex</function>
	      function.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>Putting our code to work</title>

    <para>The <function>namesMatching</function> function isn't very
      exciting by itself, but it's a useful building block.  Combine
      it with a few more functions, and we can start to do interesting
      things.</para>

    <para>Here's one such example.  Let's define a
      <function>renameWith</function> function that, instead of simply
      renaming a file, applies a function to the file's name, and
      renames the file to whatever that function returns.</para>

    &Useful.hs:renameWith;

    <para>Once again, we work around Haskell's ungainly file/directory
      split with a helper function:</para>

    &Useful.hs:rename;

    <para>The <classname role="module">System.FilePath</classname>
      module provides many useful functions for manipulating file
      names.  They mesh nicely with our
      <function>renameWith</function> and
      <function>namesMatching</function>functions, so that we can
      quickly create functions with complex behaviour.  This terse
      function changes the file name suffixing convention for C++
      source files.</para>

    &Useful.hs:cc2cpp;

    <para>The <function>cc2cpp</function> function uses a few
      functions we'll be seeing over and over.  The
      <function>mapM</function> function maps a function that can do
      I/O over a list.  The <function>flip</function> function takes
      another function as argument, and swaps the order of its
      arguments (inspect the type of
      <function>replaceExtension</function> in &ghci; to see why).
      The <function>=&lt;&lt;</function> function feeds the result of
      its right hand side as an argument to its left.</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
