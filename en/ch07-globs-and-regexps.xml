<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.glob">
  <title>Case study: regular expressions and file name
    matching</title>

  <para>Working with text strings is a fundamental tool in the
    programmer's toolbox.  We've already been introduced to
    bytestrings and ropes as efficient ways to work with large text
    strings.  Throughout this book, we'll be returning to string
    manipulation over and again, to show off the breadth of different
    techniques and libraries you can use to tackle different problems
    that happen to involve working with strings.</para>

  <para>In this chapter, we'll develop a library that can match file
    names against succinct <quote>glob-style</quote> patterns.  This
    is a common feature of command shells on popular platforms.  To
    begin, we'll introduce the pattern language that we'll be working
    with.  The first version of our library will translate these
    patterns into regular expressions, so we'll need to understand how
    to use regular expressions in Haskell.  Next, we'll talk about how
    to use Haskell's standard directory listing functions with this
    library.  We'll then write an interpreter for the pattern language
    directly, so that we can avoid the regular expression library.
    Along the way, we'll talk a little about writing portable code in
    Haskell.</para>

  <sect1>
    <title>File name matching</title>

    <para>Many <quote>system-oriented</quote> programming languages
      provide library routines that let you match a file name against
      a pattern, or that will give a list of files that match the
      pattern.  (In other languages, this function is often named
      <function>fnmatch</function>.)  Although Haskell's standard
      library generally has good <quote>system programming</quote>
      facilities, it doesn't provide these kinds of pattern matching
      functions.  We'll take this as an opportunity to develop our
      own.</para>

    <para>The kinds of patterns we'll be dealing with are commonly
      referred to as <quote>glob patterns</quote> (the term we'll
      use), <quote>wildcard patterns</quote>, or <quote>shell-style
	patterns</quote>.  These patterns have just a few simple
      rules.</para>

    <itemizedlist>
      <listitem>
	<para>Matching a string against a pattern starts at the
	  beginning of a string, and finishes at the end.</para>
      </listitem>
      <listitem>
	<para>Most literal characters match themselves.  For example,
	  the text <literal>foo</literal> in a pattern will match
	  <literal>foo</literal>, and only <literal>foo</literal>, in
	  an input string.</para>
      </listitem>
      <listitem>
	<para>The <literal>*</literal> (asterisk) character means
	  <quote>match anything</quote>; it will match any text,
	  including the empty string.</para>
      </listitem>
      <listitem>
	<para>The <literal>?</literal> (question mark) character means
	  <quote>match any single character</quote>.</para>
      </listitem>
      <listitem>
	<para>A <literal>[</literal> (open square bracket) character
	  begins a <emphasis>character class</emphasis>, which is
	  ended by a <literal>]</literal>.  Its meaning is
	  <quote>match any character in this class</quote>.  A
	  character class can be <emphasis>negated</emphasis> by
	  following the opening <literal>[</literal> with a
	  <literal>!</literal>, so that it means <quote>match any
	    character <emphasis>not</emphasis> in this
	    class</quote>.</para>
	<para>As a shorthand, a character followed by a
	  <literal>-</literal> (dash), followed by another character,
	  denotes a <emphasis>range</emphasis>: <quote>match any
	    character within this set</quote>.</para>
	<para>Character classes have an added subtlety; they can't be
	  empty.  The first character after the opening
	  <literal>[</literal> or <literal>[!</literal> is part of the
	  class.</para>
      </listitem>
      <listitem>
	<para>Outside of a character class, there is an <quote>escape
	    character</quote> (<literal>\</literal> on Unix-like
	  systems), the character following it takes its normal
	  literal meaning (so <literal>\*</literal> matches an
	  asterisk, not any text).</para>
      </listitem>
    </itemizedlist>

    <para>While Haskell doesn't provide a glob matching function, it
      has excellent regular expression matching facilities.  Glob
      patterns are nothing more than restricted regular expressions
      with slightly different syntax.  It's easy to convert glob
      patterns into regular expressions, so we'll take that tack
      initially.  But in order to do so, we must first understand how
      to use regular expressions in Haskell.</para>
  </sect1>

  <sect1>
    <title>Regular expressions in Haskell</title>

    <para>In this section, I'll be assuming that you are already
      familiar with regular expressions (which I'll abbreviate as
      <emphasis>regexps</emphasis> from here on) by way of some other
      language, such as Python, Perl, or Java.  Rather than introduce
      them as something new, I'll be focusing on what's different
      about regexp handling in Haskell, compared to imperative
      languages.  Haskell's regular expression matching libraries are
      a lot more expressive than those of other languages, so there's
      plenty to talk about.</para>

    <para>To begin our use of the regexp libraries, the only module
      we'll need to work with is <classname
	role="module">Text.Regex.Posix</classname>.  As usual, the
      most convenient way to explore this module is by interacting
      with it via <command>ghci</command>.</para>

    &regexp.ghci:load;

    <para>The only function that we're likely to need for normal use
      is the regexp matching function, an infix operator named
      <function>=~</function> (borrowed from Perl.  The first hurdle
      to overcome is that Haskell's regexp libraries make heavy use of
      polymorphism.  As a result, the type signature of the
      <function>=~</function> operator is a bit difficult to
      understand.  Let's drop into <command>ghci</command> and see
      what it looks like.</para>

    &regexp.ghci:typetwiddle;

    <para>Ouch!  Rather than pick apart what this convoluted
      definition means, let's take a shortcut.  The
      <function>=~</function> operator uses typeclasses for both of
      its arguments, and also for its return type.  The first argument
      (on the left of the <function>=~</function>) is the text to
      match; the second (on the right) is the regular expression to
      match against.  We can pass either a <type>String</type> or a
      <type>Data.ByteString</type> as either argument.</para>

    <sect2>
      <title>The many types of result</title>

      <para>The <function>=~</function> operator is polymorphic in its
	return type, so the Haskell compiler needs some way to know
	what type of result we would like.  In real code, it may be
	able to infer the right type, due to the way we subsequently
	use the result.  But such cues are often lacking when we're
	exploring with <command>ghci</command>.  If we omit a specific
	type for the result, we'll get an intimidating-looking error
	message.  Here's what <command>ghci</command> tells us if we
	try to do a regexp match but omit the return type.</para>

      &regexp.ghci:noreturn;

      <para>That's quite an impenetrable error message, but what it
	means is that <command>ghci</command> can't infer what type of
	result to give back to us.  (This is the same kind of error
	that a compiler would print if it couldn't infer the correct
	type in a real program.)  Here's the key to dealing with this
	error.  When <command>ghci</command> can't infer the <varname
	  condition="tyvar">target</varname> type, we tell it what
	we'd like the type to be.  If we want an expression of type
	<type>Bool</type>, we'll get a pass/fail result.</para>

      &regexp.ghci:bool.passfail;

      <para>In the bowels of the base regexp library, there's a
	typeclass named <classname>RegexContext</classname> that
	describes how a <varname condition="tyvar">target</varname>
	type should behave; the base library defines many instances of
	this typeclass for us. The <type>Bool</type> type is an
	instance of this typeclass, so we get back a usable result.
	Another such instance is <type>Int</type>, which gives us a
	count of the number of times the regexp matches.</para>

      &regexp.ghci:int.count;

      <para>If we ask for a <type>String</type> result, we'll get the
	first substring that matches, or an empty string if nothing
	matches.</para>

      &regexp.ghci:string;

      <note>
	<para>Getting back an empty string for <quote>no match</quote>
	  poses an obvious difficulty if the empty string could be a
	  valid match for the regexp.</para>

	<remark>FIXME: Find some place to mention the monadic
	  <function>=~~</function> operator.</remark>
      </note>

      <para>Another valid type of result is <type>[String]</type>,
	which returns a list of <emphasis>all</emphasis> matching
	strings.</para>

      &regexp.ghci:list.string;
      
      <para>That's about it for <quote>simple</quote> result types,
	but we're not by any means finished.  Before we continue,
	let's use a single pattern for our remaining examples.</para>
      
      &regexp.ghci:let;

      <para>We can obtain quite a lot of information about the context
	in which a match occurs.  If we ask for a three-element tuple,
	we'll get back the text <emphasis>before</emphasis> the first
	match, the text <emphasis>of</emphasis> that match, and the
	text that <emphasis>follows</emphasis> it.</para>

      &regexp.ghci:3tuple.match;

      <para>If the match fails, the entire text is returned as the
	<quote>before</quote> element of the tuple, with the other two
	elements left empty.</para>

      &regexp.ghci:3tuple.nomatch;

      <para>Asking for a four-element tuple gives us a fourth element
	that's a list of all groups in the pattern that
	matched.</para>

      &regexp.ghci:4tuple;

      <para>We can get  numeric information about matches, too.  A
	pair of <type>Int</type>s gives us the starting offset of the
	first match, and its length.  If we ask for a list of these
	pairs, we'll get this information for all matches.</para>

      &regexp.ghci:2tuple.match;

      <para>A failed match is represented by the value
	<literal>-1</literal> as the first element of the tuple (the
	match offset), or an empty list of tuples.</para>

      &regexp.ghci:2tuple.nomatch;

      <para>Believe it or not, this is <emphasis>not</emphasis> a
	comprehensive list of built-in instances of the
	<classname>RegexContext</classname> typeclass.  For a complete
	list, see the documentation for the <classname
	  role="module">Text.Regex.Base.Context</classname>
	module.</para>

    </sect2>

    <sect2>
      <title>Mixing and matching string types</title>

      <para>As we noted earlier, the <function>=~</function> operator
	uses typeclasses for its argument types and its return type.
	Any combination of <type>String</type> and
	<type>ByteString</type> will work for the types of both the
	regular expression and the text to match against.</para>

      &regexp.ghci:mix.simple;
      
      <para>However, be aware that if you want a string value in the
	result of a match, the text you're matching against must be
	the same type of string.  Let's see what this means in
	practice.</para>

      &regexp.ghci:mix.match;

      <para>In the above example, we've used the
	<function>pack</function> to turn a <type>String</type> into a
	<type>ByteString</type>.  The typechecker accepts this because
	<type>ByteString</type> appears in the result type.  But if we
	try getting a <type>String</type> out, that
	<emphasis>won't</emphasis> work.</para>

      &regexp.ghci:mix.nomatch;

      <para>And ouch!  That's quite an error message.  Don't let its
	verbosity confound you; we can easily fix this problem by
	making the string types of the left hand side and the result
	match once again.</para>

      &regexp.ghci:mix.rematch;

      <para>This restriction does <emphasis>not</emphasis> apply to
	the type of the regexp to match against.  It can be either a
	<type>String</type> or <type>ByteString</type>, unconstrained
	by the other types in use.</para>
    </sect2>

    <sect2>
      <title>Other things you should know</title>

      <para>When you look through Haskell library documentation,
	you'll see several regexp-related modules.  The modules under
	<classname role="module">Text.Regex.Base</classname> define
	the common API adhered to by all of the other regexp modules.
	It's possible to have multiple implementations of the regexp
	API installed at one time.  At the time of writing,
	<application>GHC</application> is bundled with one
	implementation, <classname
	  role="module">Text.Regex.Posix</classname>.  As its name
	suggests, this package provides POSIX regexp semantics.</para>

      <note>
	<para>If you're coming to Haskell from a language like Perl,
	  Python, or Java, and you've used regular expressions in one
	  of those languages, you should be aware that the POSIX
	  regexps handled by the <classname
	    role="module">Text.Regex.Posix</classname> module are
	  different in some significant ways from Perl-style regexps.
	  Here are a few of the more notable differences.</para>

	<para>Perl regexp engines do left-biased matching when
	  matching alternatives, whereas POSIX engines choose the
	  greediest match.  What this means is that given a regexp of
	  <literal>(foo|fo*)</literal> and a text string of
	  <literal>foooooo</literal>, a Perl-style engine will give a
	  match of <literal>foo</literal> (the leftmost match), while
	  a POSIX engine will match the entire string (the greediest
	  match).</para>

	<para>POSIX regexps have less uniform syntax than Perl-style
	  regexps.  They also lack a number of capabilities provided
	  by Perl-style regexps, such as zero-width assertions and
	  control over greedy matching.</para>
      </note>

      <para>Other Haskell regexp packages are available for download
	on the Internet.  Some provide faster engines than the current
	POSIX engine; others provide Perl-style matching capabilities.
	All follow the standard API that we have covered in this
	section.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Translating a glob pattern into a regular
      expression</title>

    <para>Now that we've seen the myriad of ways to match text against
      regular expressions, let's turn our attention back to glob
      patterns.  We want to write a function that will take a glob
      pattern and return its representation as a regular expression.
      Both glob patterns and regexps are text strings, so the type
      that our function ought to have seems clear.</para>

    &GlobRegex.hs:type;

    <para>We start our definition of the
      <function>globToRegex</function> function by recalling that a
      text string must match a glob pattern must match.  Thus before
      we attempt to convert any part of the glob pattern, we need to
      have a <quote>rooted</quote> regular expression.</para>
    
    &GlobRegex.hs:rooted;

    <para>Recall that the <type>String</type> is just a synonym for
      <type>[Char]</type>, a list of <type>Char</type>s.  The
      <function>:</function> operator puts a value (the
      <literal>^</literal> character in this case) onto the front of a
      list, where the list is the value returned by the yet-to-be-seen
      <function>globToRegex'</function> function.</para>

    <note>
      <para>It's perfectly normal for a Haskell function to refer to
	functions or values that follow, rather than precede, it in a
	source file.  The Haskell compiler doesn't care about ordering
	at this level.  This grants you the flexibility to structure
	your code in the manner that makes most logical sense to you,
	as opposed to a way that makes the compiler writer's life
	easiest.</para>
    </note>

    <para>With the regular expression rooted, the
      <function>globToRegex'</function> function will do the bulk of
      the translation work.  We'll use the convenience of Haskell's
      pattern matching to enumerate each of the cases we'll need to
      cover.</para>

    &GlobRegex.hs:asterisk;

    <para>We now have a very minimal glob translator.  Our first
      clause requires that if we hit the end of our glob pattern, we
      return <literal>$</literal>, the regular expression symbol for
      <quote>match end-of-line</quote>.  The second gets us to
      substitute the string <literal>.*</literal> every time we see a
      <literal>*</literal> in our input list.  And the third passes
      every other character through, unaltered.</para>

    <para>We can immediately save our new source file (let's call it
      <filename>GlobRegexTiny.hs</filename> and start playing with it
      in <command>ghci</command>.  This is a great way to do
      exploratory programming: write a little code, load it into the
      interpreter, and see what happens.</para>

    &glob-regexp.ghci:tiny;

    <para>These few lines of interaction might look trivial, but we
      have received immediate feedback on two fronts: our code passes
      the daunting scrutiny of Haskell's typechecker, and it produces
      sensible-looking results. Monkeying around with code in the
      interpreter early and often is consistently worthwhile.</para>

    <para>The remaining cases for a complete definition of
      <function>globToRegex'</function> are easy to enumerate.  First,
      we get <literal>?</literal> out of the way.</para>

    &GlobRegex.hs:question;

    <para>More interesting is how we handle character classes.</para>

    &GlobRegex.hs:class;

    <para>We take advantage of two behaviours of Haskell's pattern
      matcher here.  The first is that it will match patterns in the
      order in which we declare them, so we place the most specific
      patterns first, and the least specific last.  Secondly, there's
      no limit to the <quote>depth</quote> of a pattern: we can
      <quote>peek</quote> forwards into a list as far as we need
      to.</para>

    <para>Here, the first pattern matches on three consecutive items
      of its input to ensure that a <quote>negative</quote> character
      class cannot be empty.  The second pattern matches on only two
      items, so ensure that a <quote>positive</quote> character class
      cannot be empty.  The final clause can only match if it's given
      a syntactically invalid character class.</para>

    <para>Finally, all other characters can be passed through, but
      they may need to be escaped.</para>

    &GlobRegex.hs:last;

    <para>The <function>escape</function> function ensures that the
      regexp engine will not interpret certain characters as pieces of
      regular expression syntax.</para>

    &GlobRegex.hs:escape;

    <para>The <function>charClass</function> helper function does
      nothing more than ensure that a character class is correctly
      terminated.  It passes its input through unmolested until it
      hits a <literal>]</literal>, when it hands control back to
      <function>globToRegex'</function>.</para>

    &GlobRegex.hs:charClass;

    <para>Now that we've finished defining
      <function>globToRegex</function> and its helpers, let's load it
      into &ghci; and try it out.</para>

    &glob-regexp.ghci:real;

    <para>Sure enough, that looks like a reasonable regexp.  Can we
      use it to match against a string?</para>

    &glob-regexp.ghci:matches;

    <para>It works!  Now let's play around a little with &ghci;.  We
      can create a temporary definition for
      <function>fnmatch</function> and try it out.  (This is another
      example of how &ghci; is great for exploratory
      programming.)</para>

    &glob-regexp.ghci:fnmatch;

    <para>The name <quote><function>fnmatch</function></quote> doesn't
      really have the <quote>Haskell nature</quote>, though.  The
      typical Haskell style is for functions to have descriptive,
      camel cased names.  In our library, we'll give this function the
      name <function>matchesGlob</function>.</para>

    &GlobRegex.hs:matchesGlob;

  </sect1>

  <sect1>
    <title>An important aside: writing lazy functions</title>

    <para>In an imperative language, the
      <function>globToRegex'</function> function is one that we'd
      usually express as a loop. For example, Python's standard
      <package>fnmatch</package> module includes a function named
      <function>translate</function> that does exactly the same job as
      our <function>globToRegex</function> function.  It's written as
      a loop.</para>

    <para>If you've been exposed to functional programming through a
      language such as Scheme or ML, you've probably had drilled into
      your head the notion that <quote>the way to emulate a loop is
	via tail recursion</quote>.  A function
      usually needs a little local scratch storage when it executes.
      A tail recursive function must either return a plain value, or
      make a recursive call as the last thing it does (these kinds of
      call are called <quote>tail calls</quote>).  Since a function
      making a tail call can by definition never use any of its local
      scratch storage again, a language implementation can reuse that
      space when it makes the tail call. This means that a series of
      tail calls can execute in constant space, just as we take for
      granted with a loop.</para>

    <para>Looking at the <function>globToRegex'</function> function,
      we can see that it is <emphasis>not</emphasis> tail recursive.
      To see why, let's examine its final clause again (several of its
      other clauses are structured similarly).</para>

      &GlobRegex.hs:last.noid;

    <para>It calls itself recursively, but this
      <emphasis>isn't</emphasis> the last thing the function does.
      The result of the recursive call is a parameter to the
      <function>(++)</function> function.</para>

    <para>So what's going on here?  Why are we not writing a tail
      recursive definition for this function?  The answer lies with
      Haskell's non-strict evaluation strategy.  Before we start
      talking about that, let's quickly talk about why, in a
      traditional language, we'd be trying to avoid this kind of
      recursive definition.</para>

    <para>Returning to the clause above,
      <function>globToRegex'</function> computes a little bit of its
      result, then calls itself recursively, then returns the complete
      result.  In a traditional language, each recursive call is going
      to require the allocation of temporary scratch memory until it
      returns.</para>

    <remark>Image: stack allocation for a recursive call to
      <function>globToRegex'</function>.</remark>

    <para>Compound these scratch allocations over a large number of
      recursive calls, and the amount of space we use while processing
      grows linearly with the size of the list we must process.</para>

    <remark>Image: stack allocation for a pile of recursive
      calls.</remark>

    <para>For a problem like glob-to-regexp conversion, where we'll
      always be dealing with very small amounts of data, this overhead
      is insignificant.  But if we had a hundred million elements to
      process, and used plain recursion rather than tail recursion or
      a loop to process them, we'd have a severe problem.</para>

    <para>Haskell neatly defangs this problem by deferring the
      evaluation of an expression until its result is needed.  To
      understand how this deferred evaluation works, let's walk
      through what happens when the final clause of the
      <function>globToRegex'</function> is called.  (As you read, bear
      in mind that this is a simplified description.)</para>

    <para>In order to determine that this clause must be called, the
      pattern matcher must inspect a little bit of the list it was
      passed.  The pattern requires it to do nothing more than
      determine whether it has been given an empty list (in which case
      the clause will not be evaluated), or a non-empty list (the case
      we're interested in).  Once the pattern matcher has established
      that the list isn't empty, it goes no deeper.  It doesn't look
      inside <varname>c</varname>, the head of the list.  It doesn't
      follow <varname>cs</varname>, the tail.</para>

    <para>We have now decided to evaluate the right hand side of
      the clause.  The first expression we must evaluate is the call
      to the list append function, <function>(++)</function>.
      (Because we don't need the results of <code>escape c</code> or
      <code>globToRegex' cs</code> yet, we suspend the evaluation of
      those functions, to evaluate when we'll need them.)  So let's
      remind ourselves what <function>(++)</function> looks
      like:</para>

      &append.hs:append;

    <para>As the argument to <function>(++)</function> is not an
      empty list, the second clause matches, so we must evaluate
      <varname>x</varname>.  This requires that we evaluate
      <code>escape c</code>, which we had earlier deferred.  Let's
      look again at the definition of
      <function>escape</function>.</para>

    &GlobRegex.hs:escape.noid;

    <para>This will return a list whose first element is either the
      <literal>\</literal> character or the character it was passed.
      Once we've constructed the first element of this list, we'll
      defer constructing the rest of it until our caller needs it.  We
      suspend the evaluation of the rest of
      <function>escape</function> so that we can pass this datum back
      to our caller.  Haskell implementations do this by saving away
      enough information to resume the evaluation later; this saved
      package of information is called a <quote>thunk</quote>.</para>

    <para>Not only is the evaluation of <function>escape</function>
      suspended; so too are the evaluation of its callers,
      <function>(++)</function> and <function>globToRegex'</function>,
      and so on up the call chain until some expression needs to
      inspect the value.</para>

    <para>What would happen if the caller of
      <function>globToRegex'</function> was for some reason the
      function <function>null</function>?  <function>null</function>
      only cares whether its argument is an empty list: once it finds
      this out, it's never going to look at the remainder of the
      result of <function>globToRegex'</function>.  None of the work
      we deferred in order to get a partial result back to
      <function>null</function> will ever actually occur.</para>

    <para>Remarkably, given this kind of evaluation strategy, our
      recursive definition of <function>globToRegex'</function> will
      execute in constant space (more or less).  To see why, look at
      the definition of <function>(++)</function>; although it's
      simpler, it has a similar recursive structure.</para>

    <para>If we put on our implementor's hats and think about how we
      might suspend the evaluation of <function>(++)</function> in a
      thunk, all we need to store are the current heads of the left
      and right lists; the result of the next evaluation step depends
      on nothing more.  On each resumption of the thunk, we could
      simply peel off the head of the left list and update the thunk
      with the new head, repeating until we reach its end.  Therefore,
      we can execute in constant space.</para>
  </sect1>

  <sect1>
    <title>Making use of our pattern matcher</title>

    <para>It's all very well to have a function that can match
      glob patterns, but we'd like to be able to put this to practical
      use.  On Unix-like systems, the <function>glob</function>
      function returns the names of all files and directories that
      match a given glob pattern.</para>

    <para>Since directories and files live in the <quote>real
	world</quote>, our globbing function will have to have
      <classname>IO</classname> in its result type.  Following the
      Haskell norm of descriptive naming, we'll call our function
      <function>namesMatching</function>.</para>

    &Glob.hs:type;

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
