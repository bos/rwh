<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.glob">
  <title>Case study: regular expressions and file name matching</title>

  <para>Working with text strings is a fundamental tool in the
    programmer's toolbox.  We've already been introduced to
    bytestrings and ropes as efficient ways to work with large text
    strings.  Throughout this book, we'll be returning to string
    manipulation over and again, to show off the breadth of different
    techniques and libraries you can use to tackle different problems
    that happen to involve working with strings.</para>

  <para>In this chapter, we'll develop a library that can match file
    names against succinct <quote>glob-style</quote> patterns.  This
    is a common feature of command shells on popular platforms.  To
    begin, we'll introduce the pattern language that we'll be working
    with.  The first version of our library will translate these
    patterns into regular expressions, so we'll need to understand how
    to use regular expressions in Haskell.  We'll then write an
    interpreter for the pattern language directly, so that we can
    avoid the regular expression library.  Finally, we'll talk about
    how to use Haskell's standard directory listing functions with
    this library.  Along the way, we'll talk a little about writing
    portable code in Haskell.</para>

  <sect1>
    <title>File name matching</title>

    <para>Many <quote>system-oriented</quote> programming languages
      provide library routines that let you match a file name against
      a pattern, or that will give a list of files that match the
      pattern.  Although Haskell's standard library generally has good
      <quote>system programming</quote> facilities, it doesn't provide
      these kinds of pattern matching functions.  We'll take this as
      an opportunity to develop our own.</para>

    <para>The kinds of patterns we'll be dealing with are commonly
      referred to as <quote>glob patterns</quote> (the term we'll
      use), <quote>wildcard patterns</quote>, or <quote>shell-style
	patterns</quote>.  These patterns have just a few simple
      rules.</para>

    <itemizedlist>
      <listitem>
	<para>Matching a string against a pattern starts at the
	  beginning of a string, and finishes at the end.</para>
      </listitem>
      <listitem>
	<para>Most literal characters match themselves.  For example,
	the text <literal>foo</literal> in a pattern will match
	<literal>foo</literal>, and only <literal>foo</literal>, in an
	input string.</para>
      </listitem>
      <listitem>
	<para>The <literal>*</literal> (asterisk) character means
	  <quote>match anything</quote>; it will match any text,
	  including the empty string.</para>
      </listitem>
      <listitem>
	<para>The <literal>?</literal> (question mark) character means
	  <quote>match any single character</quote>.</para>
      </listitem>
      <listitem>
	<para>A <literal>[</literal> (open square bracket) character
	  begins a <emphasis>character class</emphasis>, which is
	  ended by a <literal>]</literal>.  Its meaning is
	  <quote>match any character in this class</quote>.  A
	  character class can be <emphasis>negated</emphasis> by
	  following the opening <literal>[</literal> with a
	  <literal>!</literal>, so that it means <quote>match any
	  character <emphasis>not</emphasis> in this
	  class</quote>.</para>
	<para>As a shorthand, a character followed by a
	  <literal>-</literal> (dash), followed by another character,
	  denotes a <emphasis>range</emphasis>: <quote>match any
	  character within this set</quote>.</para>
	<para>Character classes have an added subtlety; they can't be
	  empty.  The first character after the opening
	  <literal>[</literal> or <literal>[!</literal> is part of the
	  class.</para>
      </listitem>
      <listitem>
	<para>Outside of a character class, there is an <quote>escape
	  character</quote> (<literal>\</literal> on Unix-like
	  systems), the character following it takes its normal
	  literal meaning (so <literal>\*</literal> matches an
	  asterisk, not any text).</para>
      </listitem>
    </itemizedlist>

    <para>While Haskell doesn't provide a glob matching function, it
      has excellent regular expression matching facilities.  Glob
      patterns are nothing more than restricted regular expressions
      with slightly different syntax.  It's easy to convert glob
      patterns into regular expressions, so we'll take that tack
      initially.  But in order to do so, we must first understand how
      to use regular expressions in Haskell.</para>
  </sect1>

  <sect1>
    <title>Regular expressions in Haskell</title>

    <para>In this section, I'll be assuming that you are already
      familiar with regular expressions (which I'll abbreviate as
      <emphasis>regexps</emphasis> from here on) by way of some other
      language, such as Python, Perl, or Java.  Rather than introduce
      them as something new, I'll be focusing on what's different
      about regexp handling in Haskell, compared to imperative
      languages.</para>

    <para>The first hurdle to overcome is that Haskell's regexp
      library makes heavy use of polymorphism; as a result, many of
      its type signatures are difficult to understand.</para>
&regexp.ghci:typetwiddle;
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
