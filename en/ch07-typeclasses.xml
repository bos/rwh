<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="typeclasses" revision="alpha;beta">
  <title>Using Typeclasses</title>

  <para id="x_iA">
    Typeclasses are among the most powerful features in Haskell.
    They allow you to define generic interfaces that provide a common
    feature set over a wide variety of types.  Typeclasses 
    are at the heart of some basic language features such as equality
    testing and numeric operators.  Before we talk about what exactly
    typeclasses are, though, we'd like to explain the need for them.
  </para>

  <sect1 id="typeclasses.need">
    <title>The need for typeclasses</title>
    <para id="x_jA">
      Let's imagine that for some unfathomable reason, the designers of the
      Haskell language neglected to implement the equality test
      <literal>==</literal>.  Once you got over your shock at hearing this, 
      you resolved to implement your own equality tests.  Your application
      consisted of a simple <literal>Color</literal> type, and so your first
      equality test is for this type.  Your first attempt might look like
      this:
    </para>
    &naiveeq.hs:color;
    <para id="x_kA">
      You can test this with &ghci;:
    </para>
    &naiveeq.ghci:all;
    <para id="x_lA">
      Now, let's say that you want to add an equality test for
      &String;s.
      Since a Haskell &String; is a list of characters, we can
      write a simple function to perform that test.
        For simplicity, we
      cheat a bit and use the <literal>==</literal> operator here to
      illustrate.
    </para>
    &naiveeq.hs:string;
    <para id="x_mA">
      You should now be able to see a problem: we have to use a function
      with a different name for every different type that we want to be able to compare.
      That's inefficient and annoying.  It's much more convenient to be able
      to just use <literal>==</literal> to compare anything.  It may also
      be useful to write generic functions such as <literal>/=</literal>
      that could be implemented in terms of <literal>==</literal>, and
      valid for almost anything.  By having a generic function that
      can compare anything, we can also make our code generic: if a
      piece of code only needs to compare things, then it ought to be
      able to accept any data type that the compiler knows how to
      compare.  And, what's more, if new data types are added later,
      the existing code shouldn't have to be modified.
    </para>
    <para id="x_jp">
      Haskell's typeclasses are designed to address all of these things.
    </para>
  </sect1>
  <sect1 id="typeclasses.whatarethey">
    <title>What are typeclasses?</title>
    <para id="x_nA">
      Typeclasses define a set of functions that can have different
      implementations depending on the type of data they are given.
      Typeclasses may look like the objects of object-oriented
      programming, but they are truly quite different.
    </para>

    <para id="x_tA">
      Let's use typeclasses to solve our equality dilemma from earlier in the
      chapter.  To begin with, we must define the typeclass
      itself.  We want a function that takes two parameters, both the
      same type, and returns a <literal>Bool</literal> indicating whether or not
      they are equal.  We don't care what that type is, but we just want two
      items of that type.  Here's our first definition of a typeclass:
    </para>
    &eqclasses.hs:basiceq;
    <para id="x_uA">
      This says that we are declaring a typeclass named
      <literal>BasicEq</literal>, and we'll refer to instance types with the
      letter <literal>a</literal>.  An instance type of this typeeclass
      is any type that implements the functions defined in the typeclass.
      This typeclass defines one function.
      That function takes two parameters&emdash;both corresponding to instance
      types&emdash;and returns a <literal>Bool</literal>.
    </para>
    <note>
      <para>
        The keywoard to define a typeclass in Haskell is
        <literal>class</literal>.  Unfortunately, this may be
        confusing for those of you coming from an object-oriented
        background, as we are not really defining the same thing.
      </para>
    </note>
    <para id="x_wA">
      On the first line, the name of the parameter <literal>a</literal>
      was chosen arbitrarily.  We could have used any name.  The key is that,
      when you list the types of your functions, you must use that name to
      refer to instance types.
    </para>
    <para id="x_yA">
      Let's look at this in &ghci;.
      Recall that you
      can type <command>:t</command> in &ghci; to 
      have it show you the type of something.  Let's see what it says about
      <literal>isEqual</literal>:
    </para>
    <screen>
*Main&gt; <userinput>:t isEqual</userinput>
isEqual :: (BasicEq a) => a -> a -> Bool
    </screen>
    <para id="x_zA">
      You can read that this way: "For all types <literal>a</literal>, so
      long as <literal>a</literal> is an instance of
      <literal>BasicEq</literal>, <literal>isEqual</literal> takes two
      parameters of type <literal>a</literal> and returns a
      <literal>Bool</literal>".  Let's take a quick look at defining
      <literal>isEqual</literal> for a particular type.
    </para>
    &eqclasses.hs:basicinstance;
    <para id="x_EN">
      You can also use &ghci; to verify that we can now use
      <literal>isEqual</literal> on &Bool;s, but not on any other type:
    </para>
    &eqclasses.ghci:all;
    <para id="x_FN">
      Notice that when we tried to compare two strings, &ghci; noticed that
      we hadn't provided an instance of <literal>BasicEq</literal> for
      &String;.  It therefore didn't know how to compare a &String;, and
      suggested that we could fix the problem by defining an instance of
      <literal>BasicEq</literal> for <literal>[Char]</literal>, which is the
      same as &String;.
    </para>
    <para id="x_GN">
      We'll go into more detail on defining instances in <xref
        linkend="typeclasses.instances"/>.  First, though, let's continue
      to look at ways to define typeclasses.  In this example, a
      not-equal-to function might be useful.
      Here's what we might say to define a typeclass with two functions:
    </para>
    &eqclasses.hs:basiceq2;
    <para id="x_BB">
      Someone providing an instance of <literal>BasicEq2</literal> will
      be required to define two functions: <literal>isEqual2</literal> and
      <literal>isNotEqual2</literal>.
    </para>
    <para id="x_CB">
      While our definition of <literal>BasicEq2</literal> is fine, it seems
      that we're making extra work for ourselves.  
      Logically speaking, if we
      know what <literal>isEqual</literal> or
      <literal>isNotEqual</literal> would return, we know how to figure out
      what the other function would return, for all types.  Rather than
      making users of the typeclass define both functions for all types, we
      can provide default implementations for them.  Then, users will only
      have to implement one function.
      <footnote>
        <para id="x_DB">
          We provided a default implementation of both functions, which gives
          implementers of instances choice: they can pick which one they
          implement.  We could have provided a default for only one function,
          which would have forced users to implement the other every time.
          As it is, users can implement one or both, as they see fit.
        </para>
      </footnote>
      Here's an example that shows how to do
      this.
    </para>
    &eqclasses.hs:basiceq3;
    <para id="x_EB">
      People implementing this class must provide an implementation of
      at least one function.  They can implement both if they wish,
      but they will not be required to.  While we did provide defaults
      for both functions, each function depends on the presence of the
      other to calculate an answer.  If we don't specify at least one,
      the resulting code would be an endless loop.  Therefore, at
      least one function must always be implemented.
    </para>
    <para id="x_FB">
      With <literal>BasicEq3</literal>, we have provided a class that does
      very much the same thing as Haskell's built-in <literal>==</literal>
      and <literal>/=</literal> operators.  In fact, these operators are
      defined by a typeclass that looks almost identical to
      <literal>BasicEq3</literal>.  The Haskell 98 Report
      defines a typeclass that implements equality
      comparison.  Here is the code for the built-in
      <literal>Eq</literal> typeclass.
      Note how similar it is to our
        <literal>BasicEq3</literal> typeclass.
    </para>
    <programlisting>
class  Eq a  where
    (==), (/=) :: a -> a -> Bool

       -- Minimal complete definition:
       --     (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)
   </programlisting>

  </sect1>

  <sect1 id="typeclasses.instances">
    <title>Declaring typeclass instances</title>
    <para id="x_GB">
      Now that you know how to define typeclasses, it's time to learn how to
      define instances of typeclasses.  Recall that types are made
      instances of a particular typeclass by implementing the
      functions necessary for that typeclass.
    </para>
    <para id="x_HB">
      <remark>FIXME: rearrange? see comments</remark>
      Recall our attempt to create a test for equality over a
      <literal>Color</literal> type back in <xref
      linkend="typeclasses.need"/>.
      Now let's see how we could make that same <literal>Color</literal>
      type a member of the <literal>BasicEq3</literal> class.
    </para>
    &eqclasses.hs:basiceq3inst;
    <para id="x_IB">
      Notice that we provide essentially the same function as we used
      back in <xref linkend="typeclasses.need"/>.  In fact, the
      implementation is identical.  However, in this case, we can use
      <literal>isEqual3</literal> on <emphasis>any</emphasis> type that
      we declare is an instance of <literal>BasicEq3</literal>, not just
      this one color type.  We could define equality tests for anything
      from numbers to graphics using the same basic pattern.  In fact, as you
      will see in <xref linkend="typeclasses.wellknown.equality"/>, this
      is exactly how you can make Haskell's <literal>==</literal> operator
      work for your own custom types.
    </para>
    <para id="x_JB">
      Note also that the <literal>BasicEq3</literal> class defined both
      <literal>isEqual3</literal> and <literal>isNotEqual3</literal>, but we
      implemented only one of them in the <literal>Color</literal> instance.  
      That's because of the default implementation
      contained in <literal>BasicEq3</literal>.  Since we didn't explicitly
      define <literal>isNotEqual3</literal>, the compiler automatically uses
      the default implementation given in the <literal>BasicEq3</literal>
      declaration.
    </para>

  </sect1>

  <sect1 id="typeclasses.wellknown">
    <title>Important Built-In Typeclasses</title>

    <para id="x_KB">
      Now that we've discussed defining your own typeclasses and making
      your types instances of typeclasses, it's time to introduce you to
      typeclasses that are a standard part of the Haskell Prelude.  As we mentioned at
      the beginning of this chapter, typeclasses are at the core of some
      important aspects of the language.  We'll cover the most common ones
      here.  For more details, the Haskell library reference is a good
      resource.  It will give you a description of the typeclasses, and
      usually also will tell you which functions you must implement to have a
      complete definition.  <remark>FIXME: add link to lib ref</remark>
    </para>

    <sect2 id="typeclasses.wellknown.show">
      <title>Show</title>
      <para id="x_LB">
        The <literal>Show</literal> typeclass is used to convert values to
        &String;s.  It is perhaps most commonly used to
        convert numbers to &String;s, but it is defined for
        so many types that it can be used to convert quite a bit more.  
        If you have defined your own types, making them instances of
        <literal>Show</literal> will make it easy to display them in &ghci;
        or print them out in programs.
      </para>
      <para id="x_MB">
        The most important function of <literal>Show</literal> is
        <literal>show</literal>.  It takes one argument: the data to convert.
        It returns a &String; representing that data.
        &ghci; reports the type of <literal>show</literal> like this:
      </para>

      &show.ghci:showtype;

      <para id="x_NB">
        Let's look at some examples of converting values to strings:
      </para>
      &show.ghci:showex;
      <para id="x_OB">
        Remember that &ghci; displays results as they would
        be entered into a Haskell program.  So the expression <literal>show 1</literal>
        returns a single-character string containing the digit
        <literal>1</literal>.  That is, the quotes are not part of the string
        itself.  We can make that clear by using
        <literal>putStrLn</literal>:
      </para>
      &show.ghci:printshowex;
      <para id="x_PB">
        You can also use <literal>show</literal> on
        &String;s:
      </para>
      &show.ghci:showstr;
      <para id="x_QB">
        Running <literal>show</literal> on &String;s can be
        confusing.  Since <literal>show</literal> generates a result that
        is suitable for a Haskell literal, <literal>show</literal> adds
        quotes and escaping suitable for inclusion in a Haskell program.
        &ghci; also uses <literal>show</literal> to
        display results, so quotes and escaping get added twice.  Using
        <literal>putStrLn</literal> can help make this difference clear.
      </para>

      <para id="x_RB">
        You can define a <literal>Show</literal> instance for your own types
        easily.  Here's an example:
      </para>

      &eqclasses.hs:show;

      <para id="x_SB">
        This example defines an instance of <literal>Show</literal> for our
        type 
        <literal>Color</literal> (see <xref
          linkend="typeclasses.need"/>).  The implementation is
        simple: we define a function <literal>show</literal> and that's all
        that's needed.
      </para>
      <note>
        <para id="x_kp">&Show; is usually used to define a &String;
        representation for data that is useful for a machine to parse
        back with &Read;.  Haskell programmers generally write custom
        functions to format data in pretty ways for displaying to end
        users, if this representation would be different than expected
        via &Show;.
        </para>
      </note>

    </sect2>

    <sect2 id="typeclasses.wellknown.read">
      <title>Read</title>
      <para id="x_TB">
        The &Read; typeclass is essentially the opposite of &Show;: it
        defines functions that will
        take a &String;, parse it, and return data in a native Haskell type.
        The most useful function in &Read; is &read;.
        You can ask &ghci; for its type like this:
      </para>

      &read.ghci:readtype;

      <para id="x_UB">
        Here's an example illustrating the use of &read; and &show;:
      </para>

      &read.hs:read;

      <remark>FIXME: have we already explained main, do, and
        type annotations on expressions?</remark>

      <para id="x_VB">
        This is a simple example of &read; and &show; together.  Notice that
        we gave an explicit type of &Double; when processing the &read;.
        That's because &read; returns a value of type
        <literal>Read a => a</literal> and &show; expects a value of type
        <literal>Show a => a</literal>.  There are many types that have
        instances
        defined for both &Read; and &Show;.  Without knowing a specific type,
        the compiler must guess from these many types which one is
        needed.  In situations like this, it may often choose &Integer;.  If
        we wanted to accept floating-point input, this wouldn't work, so we
        provided an explicit type.
      </para>
      <tip>
        <para id="x_lp">In most cases, if the explicit &Double; type annotation
        were omitted, the compiler would refuse to guess a
        common type and simply give an error.  The fact that it could
        default to &Integer; here is a special case arising from the
        fact that the literal <literal>2</literal> is treated as an
        &Integer; unless a different type of expected for it.
        </para>
      </tip>
      <para id="x_WB">
        You can see the same effect at work if you try to use &read; on the
        &ghci; command line.  &ghci; internally uses &show; to display
        results, meaning that you can hit this ambiguous typing problem there
        as well.  You'll need to explicitly give types for
        your &read; results in
        &ghci; as shown here:
      </para>
      &read.ghci:readerrors;
      <para id="x_XB">
        Recall the type of &read;:
        <literal>(Read a) => String -&gt; a</literal>.  The
        <literal>a</literal> here is the type of each instance of &Read;.
        Which particular parsing function is called depends upon the type
        that is expected from the return value of &read;.  Let's see how that
        works:
      </para>
      &read.ghci:readtypes;
      <para id="x_YB">
        Notice the error when trying to parse <literal>5.0</literal> as an
        &Integer;.  The interpreter selected a different instance of &Read;
        when the return value was expected to be &Integer; than it did when a
        &Double; was expected.  The &Integer; parser doesn't accept decimal
        points, and caused an exception to be raised.
      </para>
      <para id="x_ZB">
        The &Read; class provides for some fairly complicated parsers.
        You can define a simple parser by providing an implementation for the
        <literal>readsPrec</literal> function.  Your implementation can
        return a list containing exactly one tuple on a successful parse, or
        an empty list on an unsuccessful parse.  Here's an example
        implementation:
      </para>
      &eqclasses.hs:read;
      <para id="x_aB">
        This example handles the known cases for the three colors.  It
        returns an empty list (resulting in a "no parse" message) for others.
        The function is supposed to return the part of the input that was not
        parsed, so that the system can integrate the parsing of different
        types together.  Here's an example of using this new instance of
        &Read;:
      </para>
      &read.ghci:readcolor;
      <para id="x_bB">
        Notice the error on the final attempt.  That's because our parser is
        not smart enough to handle leading spaces yet.  If we modified it to
        accept leading spaces, that attempt would work.  You could
        rectify this by modifying your &Read; instance to discard any
        leading spaces, which is common practice in Haskell programs.
      </para>
      <tip>
        <para id="x_mp">
          While it is possible to build sophisticated parsers using
          the &Read; typeclass, many people find it easier to do so using
          Parsec, and rely on &Read; only for simpler tasks.  Parsec
          is covered in detail in <xref linkend="parsec"/>.
        </para>
      </tip>
    </sect2>

    <sect2 id="typeclasses.wellknown.serialization">
      <title>Serialization with Read and Show</title>
      <para id="x_cB">
        You may often have a data structure in memory that you need to
        store on disk for later retrieval or to send across the network.  The
        process of converting data in memory to a flat series of bits for
        storage is called <emphasis>serialization</emphasis>.
      </para>
      <para id="x_dB">
        It turns out that &read; and &show; make excellent tools for
        serialization.  &show; produces output that is both human-readable and
        machine-readable.  Most &show; output is also syntactically-valid
        Haskell, though it is up to people that write &Show; instances to
        make it so.
      </para>
      <tip>
        <para id="x_np">
          String handling in Haskell is normally lazy, so &read; and
          &show; can be used on quite large data structures without
          incident.  The built-in &read; and &show; instances in
          Haskell are efficient and implemented in pure Haskell.  For
          information on how to handle parsing exceptions, refer to
          <xref linkend="errors"/>.
        </para>
      </tip>
      <para id="x_eB">
        Let's try it out in &ghci;:
      </para>
      &serialization.ghci:ex1;
      <para id="x_fB">
        First, we assign <literal>d1</literal> to be a list.  Next, we print
        out the result of <literal>show d1</literal> so we can see what it
        generates.  Then, we write the result of <literal>show d1</literal>
        to a file named <literal>/tmp/test</literal>.
      </para>
      <para id="x_gB">
        Let's try reading it back.
        <remark>FIXME: xref to explanation of variable binding in ghci</remark>
      </para>
      &serialization.ghci:ex2;
      <para id="x_hB">
        First, we ask Haskell to read the file back.<footnote><para id="x_iB">As you will see
          in <xref linkend="io.lazy"/>, Haskell doesn't actually
          read the entire file at this point.  But for the purposes of this
          example, we can ignore that distinction.</para></footnote>  Then,
        we try to assign the result of <literal>read input</literal> to
        <literal>d2</literal>.  That generates an error.  The reason is that
        the interpreter doesn't know what type <literal>d2</literal> is meant
        to be, so it doesn't know how to parse the input.  If we give it an
        explicit type, it works, and we can verify that the two sets of data
        are equal.
      </para>
      <para id="x_jB">
        Since so many different types are instances of &Read; and &Show; by
        default (and others can be made instances easily; see <xref
          linkend="typeclasses.auto.derivation"/>), you can use it for
        some really complex data structures.  Here are a few examples of
        slightly more complex data structures:
        <remark>FIXME: like to def of $, or explain it here</remark>
      </para>
      &serialization.ghci:ex3;
    </sect2>

    <sect2 id="typeclasses.wellknown.numeric">
      <title>Numeric Types</title>
      <remark>FIXME: some of these tables don't render well under sgml2x.
      Will need to verify that they look good under the O'Reilly
      renderer.</remark>
      <para id="x_kB">
        Haskell has a powerful set of numeric types.  You can use everything
        from fast 32-bit or 64-bit integers to arbitrary-precision rational
        numbers.   You probably know that operators such as
        <literal>+</literal> can work with just about all of these.  This
        feature is implemented using typeclasses.  As a side benefit, it
        allows you to define your own numeric types and make them first-class
        citizens in Haskell.
      </para>
      <para id="x_lB">
        Let's begin our discussion of the typeclasses surrounding numeric
        types with an examination of the types themselves.  <xref
          linkend="numerictypes.summary"/> describes the most
        commonly-used numeric types in Haskell.  Note that there are also
        many more numeric types available for specific purposes such as
        interfacing to C.
      </para>
      <table id="numerictypes.summary" tocentry="1">
        <title>Selected Numeric Types</title>
        <tgroup cols='2' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;</entry>
              <entry>Double-precision floating point.  A common choice
              for floating-point data.</entry>
            </row>
            <row>
              <entry>&Float;</entry>
              <entry>Single-precision floating point.  Often used when
              interfacing with C.</entry>
            </row>
            <row>
              <entry>&Int;</entry>
              <entry>Fixed-precision signed integer; minimum range
                [-2^29..2^29-1].  Commonly used.</entry>
            </row>
            <row>
              <entry>&Int8;</entry>
              <entry>8-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int16;</entry>
              <entry>16-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int32;</entry>
              <entry>32-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int64;</entry>
              <entry>64-bit signed integer</entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry>Arbitrary-precision signed integer; range limited only by
                machine resources.  Commonly used.</entry>
            </row>
            <row>
              <entry>&Rational;</entry>
              <entry>Arbitrary-precision rational numbers.  Stored as a
                ratio of two &Integer;s.</entry>
            </row>
            <row>
              <entry>&Word;</entry>
              <entry>Fixed-precision unsigned integer; storage size same as
                &Int;</entry>
            </row>
            <row>
              <entry>&Word8;</entry>
              <entry>8-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word16;</entry>
              <entry>16-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word32;</entry>
              <entry>32-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word64;</entry>
              <entry>64-bit unsigned integer</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="x_mB">
        These are quite a few different numeric types.  There are some
        operations, such as addition, that ought to work with all of them.
        There are others, such as <literal>asin</literal>, that only apply to
        floating-point types.  <xref linkend="numerictypes.funcs"/>
        summarizes the different functions that operate on numeric types,
        and
        <xref linkend="numerictypes.typeclasses"/> matches the types with
        their respective typeclasses.  As you read that table, keep in mind
        that Haskell operators are just functions: you can say either
        <literal>(+) 2 3</literal> or <literal>2 + 3</literal> with the same
        result.  By convention, when referring to an operator as a function,
        it is written in parenthesis as seen in this table.
      </para>

      <table id="numerictypes.funcs" tocentry="1">
        <title>Selected Numeric Functions and Constants</title>
        <tgroup cols='4' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <colspec colname='c3'/>
          <colspec colname='c4'/>
          <thead>
            <row>
              <entry>Item</entry>
              <entry>Type</entry>
              <entry>Module</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>(+)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Addition</entry>
            </row>
            <row>
              <entry><literal>(-)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Subtraction</entry>
            </row>
            <row>
              <entry><literal>(*)</literal></entry>
              <entry><literal>Num a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Multiplication</entry>
            </row>
            <row>
              <entry><literal>(/)</literal></entry>
              <entry><literal>Fractional a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Fractional division</entry>
            </row>
            <row>
              <entry><literal>(**)</literal></entry>
              <entry><literal>Floating a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Raise to the power of</entry>
            </row>
            <row>
              <entry><literal>(^)</literal></entry>
              <entry><literal>(Num a, Integral b) => a -> b -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Raise a number to a non-negative,
                  integral power</entry>
            </row>
            <row>
              <entry><literal>(^^)</literal></entry>
              <entry><literal>(Fractional a, Integral b) => a -> b ->
              a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Raise a fractional number to any integral
              power</entry>
            </row>
                
            <row>
              <entry><literal>(%)</literal></entry>
              <entry><literal>Integral a => a -> a -> Ratio a</literal></entry>
              <entry><literal>Data.Ratio</literal></entry>
              <entry>Ratio composition</entry>
            </row>

            <row>
              <entry><literal>(.&amp;.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Data.Bits</literal></entry>
              <entry>Bitwise and</entry>
            </row>
            <row>
              <entry><literal>(.|.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Data.Bits</literal></entry>
              <entry>Bitwise or</entry>
            </row>
            <row>
              <entry><literal>abs</literal></entry>
              <entry><literal>Num a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Absolute value</entry>
            </row>
            <row>
              <entry><literal>approxRational</literal></entry>
              <entry><literal>RealFrac a => a -> a ->
                  Rational</literal></entry>
              <entry><literal>Data.Ratio</literal></entry>
              <entry>Approximate rational composition based on fractional numerators and
                denominators</entry>
            </row>

            <row>
              <entry><literal>cos</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Cosine.  Also provided are <literal>acos</literal>,
                <literal>cosh</literal>, and <literal>acosh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>div</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Integer division always truncated down; see also
                <literal>quot</literal></entry>
            </row>
            <row>
              <entry><literal>fromInteger</literal></entry>
              <entry><literal>Num a => Integer -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Conversion from an &Integer; to any numeric type</entry>
            </row>
            <row>
              <entry><literal>fromIntegral</literal></entry>
              <entry><literal>(Integral a, Num b) => a -> b</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>More general conversion from any &Integral; to
              any numeric type</entry>
            </row>
            <row>
              <entry><literal>fromRational</literal></entry>
              <entry><literal>Fractional a => Rational -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Conversion from a &Rational;.  May be lossy.</entry>
            </row>
            <row>
              <entry><literal>log</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Natural logarithm</entry>
            </row>
            <row>
              <entry><literal>logBase</literal></entry>
              <entry><literal>Floating a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Log with explicit base</entry>
            </row>
            <row>
              <entry><literal>maxBound</literal></entry>
              <entry><literal>Bounded a => a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>The maximum value of a bounded
                  type</entry>
            </row>
            <row>
              <entry><literal>minBound</literal></entry>
              <entry><literal>Bounded a => a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>The minimum value of a bounded
                  type</entry>
            </row>
            <row>
              <entry><literal>mod</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Integer modulus</entry>
            </row>
            <row>
              <entry><literal>pi</literal></entry>
              <entry><literal>Floating a => a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Mathematical constant pi</entry>
            </row>
            <row>
              <entry><literal>quot</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Integer division; fractional part of quotient
                  truncated towards zero</entry>
            </row>
            <row>
              <entry><literal>recip</literal></entry>
              <entry><literal>Fractional a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Reciprocal</entry>
            </row>
            <row>
              <entry><literal>rem</literal></entry>
              <entry><literal>Integral a => a -> a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Remainder of integer division</entry>
            </row>
            <row>
              <entry><literal>round</literal></entry>
              <entry><literal>(RealFrac a, Integral b) => a -> b</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Rounds to nearest integer</entry>
            </row>
            <row>
              <entry><literal>shift</literal></entry>
              <entry><literal>Bits a => a -> Int -> a</literal></entry>
              <entry><literal>Bits</literal></entry>
              <entry>Shift left by the specified number of bits,
                  which may be negative for a right shift.</entry>
            </row>
            <row>
              <entry><literal>sin</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Sine.  Also provided are <literal>asin</literal>,
                <literal>sinh</literal>, and <literal>asinh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>sqrt</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Square root</entry>
            </row>

            <row>
              <entry><literal>tan</literal></entry>
              <entry><literal>Floating a => a -> a</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Tangent.  Also provided are <literal>atan</literal>,
                <literal>tanh</literal>, and <literal>atanh</literal>, with
                the same type.</entry>
            </row>
            <row>
              <entry><literal>toInteger</literal></entry>
              <entry><literal>Integral a => a -> Integer</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Convert any &Integral; to an &Integer;</entry>
            </row>
            <row>
              <entry><literal>toRational</literal></entry>
              <entry><literal>Real a => a -> Rational</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Convert losslessly to &Rational;</entry>
            </row>
            <row>
              <entry><literal>truncate</literal></entry>
              <entry><literal>(RealFrac a, Integral b) => a -> b</literal></entry>
              <entry><literal>Prelude</literal></entry>
              <entry>Truncates number towards zero</entry>
            </row>
            <row>
              <entry><literal>xor</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Data.Bits</literal></entry>
              <entry>Bitwise exclusive or</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table id="numerictypes.typeclasses" tocentry="1" pgwide="1">
        <title>Typeclass Instances for Numeric Types</title>
        <tgroup cols='9' align='left'>
          <colspec colname='ctype'/>
          <colspec colname='cbits'/>
          <colspec colname='cbounded'/>
          <colspec colname='cfloating'/>
          <colspec colname='cfractional'/>
          <colspec colname='cintegral'/>
          <colspec colname='cnum'/>
          <colspec colname='creal'/>
          <colspec colname='crealfrac'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry><literal>Bits</literal></entry>
              <entry><literal>Bounded</literal></entry>
              <entry><literal>Floating</literal></entry>
              <entry><literal>Fractional</literal></entry>
              <entry><literal>Integral</literal></entry>
              <entry><literal>Num</literal></entry>
              <entry><literal>Real</literal></entry>
              <entry><literal>RealFrac</literal></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;</entry>
              <entry colname="cfloating">X</entry>
              <entry colname="cfractional">X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Float;</entry>
              <entry colname="cfloating">X</entry>
              <entry colname="cfractional">X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Int;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int16;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int32;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Int64;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry colname='cbits'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Rational; or any &Ratio;</entry>
              <entry colname='cfractional'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
              <entry colname='crealfrac'>X</entry>
            </row>
            <row>
              <entry>&Word;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word16;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word32;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
            <row>
              <entry>&Word64;</entry>
              <entry colname="cbits">X</entry>
              <entry colname='cbounded'>X</entry>
              <entry colname='cintegral'>X</entry>
              <entry colname='cnum'>X</entry>
              <entry colname='creal'>X</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para id="x_nB">
        Converting between numeric types is another common need.
        <xref linkend="numerictypes.funcs"/> listed many
        functions that can be used for conversion.  However, it is not always
        obvious how to apply them to convert between two arbitrary types.  To
        help you out, <xref linkend="numerictypes.conversion"/> provides
        information on converting between different types.
      </para>
      <table id='numerictypes.conversion' tocentry='1'>
        <title>Conversion Between Numeric Types</title>
        <tgroup cols='5'>
          <colspec colname='source'/>
          <colspec colname='float'/>
          <colspec colname='int'/>
          <colspec colname='integer'/>
          <colspec colname='rational'/>

          <thead>
            <row>
              <entry morerows='1'>Source Type</entry>
              <entry align='center' namest='float' nameend='rational'>Destination
                Type</entry>
            </row>
            <row>
              <entry colname='float'>&Double;, &Float;</entry>
              <entry colname='int'>&Int;, &Word;</entry>
              <entry colname="integer">&Integer;</entry>
              <entry colname="rational">&Rational;</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;, &Float;</entry>
              <entry colname='float'><literal>fromRational . toRational</literal></entry>
              <entry colname='int'><literal>truncate</literal> *</entry>
              <entry colname='integer'><literal>truncate</literal> *</entry>
              <entry colname='rational'><literal>toRational</literal></entry>
            </row>
            <row>
              <entry>&Int;, &Word;</entry>
              <entry colname='float'><literal>fromIntegral</literal></entry>
              <entry colname='int'><literal>fromIntegral</literal></entry>
              <entry colname='integer'><literal>fromIntegral</literal></entry>
              <entry colname='rational'><literal>fromIntegral</literal></entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry colname='float'><literal>fromIntegral</literal></entry>
              <entry colname='int'><literal>fromIntegral</literal></entry>
              <entry colname='integer'>N/A</entry>
              <entry colname='rational'><literal>fromIntegral</literal></entry>
            </row>
            <row>
              <entry>&Rational;</entry>
              <entry colname='float'><literal>fromRational</literal></entry>
              <entry colname='int'><literal>truncate</literal> *</entry>
              <entry colname='integer'><literal>truncate</literal> *</entry>
              <entry colname='rational'>N/A</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="x_op">
        * Instead of <literal>truncate</literal>, you could also use
          <literal>round</literal>, <literal>ceiling</literal>, or
          <literal>floor</literal>.
      </para>


      <para id="x_oL">
        For an extended example demonstrating the use of these numeric
        typeclasses, see <xref linkend="data.num"/>.
      </para>


    </sect2>

    <sect2 id="typeclasses.wellknown.equality">
      <title>Equality, Ordering, and Comparisons</title>
      <para id="x_oB">
        We've already talked about the arithmetic operators such as
        <literal>+</literal> that can be used for all sorts of different
        numbers.  But there are some even more widely-applied operators in
        Haskell.  The most obvious, of course, are the equality tests:
        <literal>==</literal> and <literal>/=</literal>.  These operators are
        defined in the &Eq; class.
      </para>
      <para id="x_pB">
        There are also comparison operators such as <literal>>=</literal> and
        <literal>&lt;=</literal>.  These are declared by the &Ord; typeclass.
        These are in a separate typeclass because there are some types, such
        as &Handle;, where an equality test makes sense, but there is no way
        to express a particular ordering.  Anything that is an instance of
        &Ord; can be sorted by <literal>Data.List.sort</literal>.
      </para>
      <para id="x_qB">
        Almost all Haskell types are instances of &Eq;, and nearly as many
        are instances of &Ord;.
      </para>
      <tip>
        <para id="x_pp">Sometimes, the ordering in &Ord; is arbitrary.  For
        instance, for &Maybe;, &Nothing; sorts before <literal>Just
        x</literal>, but this was an arbitrary decision.
        </para>
      </tip>

    </sect2>
  </sect1>

  <sect1 id="typeclasses.auto.derivation">
    <title>Automatic Derivation</title>
    <para id="x_rB">
      For many simple data types, the Haskell compiler can automatically
      derive instances of &Read;, &Show;, &Bounded;, &Enum;, &Eq;, and &Ord;
      for you.<footnote><para id="x_HN">While these are defined as regular Haskell
          typeclasses without any special magic, automatic derivation is a special
          feature of the compiler only supported with these particular
          typeclasses.</para></footnote>
      This saves you the effort of having to manually write code to compare
      or display your own types.
    </para>
    &colorderived.hs:all;
    <para id="x_sB">
      Let's take a look at how these derived instances work for us:
    </para>
    &derived.ghci:all;
    <para id="x_IN">
      Notice that the sort order for <literal>Color</literal>
      was based on the order that
      the constructors were defined, not on an alphabetical ordering.
    </para>
    <para id="x_uB">
      Automatic derivation is not always possible.  For instance, if you
      defined a type <literal>data MyType = MyType (Int -> Bool)</literal>,
      the compiler will not be able to derive an instance of &Show; because
      it doesn't know how to render a function.  You will get a compilation
      error in such a situation.
    </para>
  </sect1>

  <sect1 id="typeclasses.conclusion">
    <title>Conclusion</title>
    <para id="x_JN">In this chapter, you learned about the need for typeclasses and how
      to use them.  We talked about defining our own typeclasses and then
      covered some of the important typeclasses that are defined in the
      Haskell library.  Finally, we showed how to have the Haskell compiler
      automatically derive instances of certain typeclasses for your types.
    </para>
  </sect1>

  <!-- FIXME: cover these? 
  <sect1 id="typeclasses.overlapping">
    <title>Overlapping Instances</title>
    <para id="x_vB">
      FIXME
    </para>
  </sect1>

  <sect1 id="typeclasses.undecidable">
    <title>Undecidable Instances</title>
    <para id="x_wB">
      FIXME
    </para>
  </sect1>
  -->

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
