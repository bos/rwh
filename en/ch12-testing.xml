<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.quickcheck" revision="unpublished">
  <title>Testing and Quality Assurance</title>

  <para>
Building real systems means caring about quality control, robustness and 
correctness. With the right quality assurance mechanisms in place, 
well-written code can feel like a precision machine, with all functions
performing their tasks precisely and exactly as specified. There is no
sloppiness around the edges, and the code at the end is self-explanatory,
obviously correct code -- the kind of code that inspires confidence.
  </para>

  <para>
In Haskell, we have several tools at our disposal for building such 
precise systems. The rich, expressive type-system allows for complicated
invariants to be enforced statically -- making it impossible to produce
code violating particular constraints, while purity and polymorphism 
ensure code is built to be easily decoupled, refactored, and tested. 
The kind of code that doesn't go wrong.
  </para>

  <para>
Testing plays a key role in keeping code on the straight-and-narrow path.
The main testing mechanisms in Haskell are traditional unit testing (via the HUnit 
library), and its more powerful sibling, type-based <quote>property</quote>
testing, using QuickCheck. QuickCheck, in particular, encourages a high level
approach to testing in the form of abstract invariants functions should
satisfy.  QuickCheck, in effect, writes specific tests for you, using the
type system to guide the generation of test data.
  </para>

  <para>
In this chapter we'll look at how to use QuickCheck to establish invariants
in code, and then re-examine the JSON pretty printer developed in chapter 6,
testing it with QuickCheck. We'll also see how to guide the testing process
with GHC's test coverage tool: HPC.
  </para>

  <sect1>
    <title>QuickCheck: type-based testing</title>

    <para>
To get an overview of how property-based testing works, we'll begin with a
simple scenario: you've written a specialised sort function and want to test
its behaviour against a reference implementation.
    </para>

    <para>
First, we import the QuickCheck library, and the list library:
    </para>

    &QC-basics.hs:module;

    <para>
And the function we want to test -- a custom sort routine:
    </para>

    &QC-basics.hs:mysort;

    <para>
What a lovely sort function! Now, we'd like to check this function obeys some
basic properties first. One invariant that comes up in a lot of purely
functional code is <emphasis>idempotency</emphasis> -- applying a function twice
has the same result as applying it only once. For our sort routine, we can
state this invariant simply as:
  </para>

    &QC-basics.hs:idempotent;

    <para>
We follow the QuickCheck convention of prefixing properties with
<code>prop_</code>.  So, as a Haskell function, we've stated an invariant
that should hold for any list that we pass to our sort routine. To actually
test this invariant, we use the <code>quickCheck</code> function to generate
test data, applying the property code to that data, checking the result
holds each time:
  </para>

    &qc-basics.ghci:basics;

  <para>
To see the actual data generated for each test, and the result, we can
use <code>verboseCheck</code> in place of <code>quickCheck</code>.
  </para>

  </sect1>

<!--
  <sect1>
    <title>Generating arbitrary documents</title>

  <sect1>
    <title>Running tests</title>

  <sect1>
    <title>Code coverage information</title>

  <sect1>
    <title>The awkward testing squad: IO functions and error cases</title>
  -->

</chapter>

<!--

* Motivate testing 
    - purity, types good (make some tests meaningless),
    - but still have runtime invariants that must hold
    - but we can use types to make testing easier.

* HUnit
    - familiar comfortable
    - simple example
    - not very powerful

* QuickCheck
    - simple properties
    - predicates
    - writing Arbitrary instances
    - advice on properties to look for
        - identity
        - idempotence
        - locality

* Cautions:
    - getting arbitraries right ( '\n' example)
    - can't do IO easily
    - ensuring coverage: hpc

* Summary:
    - testing is straightforward
    - can leverage types for powerful property-based testing

  -->

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
