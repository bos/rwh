<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="quickcheck" revision="unpublished">
  <title>Testing and Quality Assurance</title>

  <para id="x_up">
Building real systems means caring about quality control, robustness and 
correctness. With the right quality assurance mechanisms in place, 
well-written code can feel like a precision machine, with all functions
performing their tasks precisely and exactly as specified. There is no
sloppiness around the edges, and the final result can be code that is
self-explanatory, obviously correct -- the kind of code that inspires
confidence.  </para>

  <para id="x_vp">
In Haskell, we have several tools at our disposal for building such 
precise systems. The expressive type-system allows for complicated invariants
to be enforced statically -- making it impossible to write code violating
chosen constraints. Meanwhile, purity and polymorphism encourage code that
is modular, refactorable, and testable. This is the kind of code that just
doesn't go wrong.
  </para>

  <para id="x_wp">
Testing plays a key role in keeping code on the straight-and-narrow path.
The main testing mechanisms in Haskell are traditional unit testing (via the HUnit 
library), and its more powerful descendant: type-based <quote>property</quote>
testing, with QuickCheck. Property-based testing encourages a high level
approach to testing in the form of abstract invariants functions should
satisfy universally, with the actual test data generated for the programmer
by the testing library. In this way code can be hammered with thousands of
tests that would be infeasible to write by hand, often uncovering subtle
corner cases that wouldn't be found otherwise.
  </para>

  <para id="x_xp">
In this chapter we'll look at how to use QuickCheck to establish invariants
in code and then re-examine the JSON pretty printer developed in chapter 6,
testing it with QuickCheck. We'll also see how to guide the testing process
with GHC's code coverage tool: HPC.
  </para>

  <sect1>
    <title>QuickCheck: type-based testing</title>

    <para id="x_yp">
To get an overview of how property-based testing works, we'll begin with a
simple scenario: you've written a specialised sort function and want to test
its behaviour against a reference implementation.
    </para>

    <para id="x_zp">
First, we import the QuickCheck library, and any other modules we need:
    </para>

    &QC-basics.hs:module;

    <para id="x_Aq">
And the function we want to test -- a custom sort routine:
    </para>

    &QC-basics.hs:mysort;

    <para id="x_Bq">
This is the classic Haskell sort implementation: a study in functional
programming elegance, if not efficiency. Now, we'd like to check that this
function obeys the basic rules a good sort should follow. One useful
invariant to start with, and one that comes up in a lot of purely functional
code, is <emphasis>idempotency</emphasis> -- applying a function twice has
the same result as applying it only once. For our sort routine, this should
certainly be true, or things have gone horribly wrong! As a test property,
this invariant can be stated simply:
  </para>

    &QC-basics.hs:idempotent;

    <para id="x_Cq">
We follow the QuickCheck convention of prefixing test properties with
<code>prop_</code> to separate them from normal code. This idempotency
property is encoded simply as a Haskell function stating an equality
that must hold for any data that is sorted. We can check this makes 
sense for a few simple cases by hand:
  </para>

    &qc-byhand.ghci:unit;

    <para id="x_oy">
Looking good. But writing out the input data by hand is silly, and violates
the oath of the lazy functional programmer: let the machine do the work!
Thanks to the Haskell type system, QuickCheck, our testing library,
comes with a set of random data generators for all the basic Haskell data
types, and uses type classes to dispatch to the appropriate data generator 
based on the type of the property under testing. We can generate 
sample random data by hand to see what's going on under the hood,
using the <code>Arbitrary</code> class. Here, a random list of booleans:
  </para>

    &qc-arbitrary.ghci:arbitrary;

    <para id="x_py">
Wrapping up all the generator details is the <code>quickCheck</code>
function, which takes care of calling the appropriate data producer, and
passing that test data to our property, checking the result condition holds.
As our idempotency test is polymorphic in the list element type, we need to 
pick a particular type to generate test data for, which we write as a type
constraint on the property:
  </para>

    &qc-basics.ghci:basics;

  <para id="x_Dq">
For the 100 different lists generated, our property held -- great!
As an aside, when developing tests, it is often useful to see the actual data
generated for each test, and the result, we can replace
<code>quickCheck</code> with <code>verboseCheck</code>, to see
(verbose) output for each test. We'll now look at more sophisticated
properties that our function might be tested for.
  </para>

    <para id="x_Eq">
Good libraries consist of a set of orthogonal primitives having sensible
relationships to each other. We can use QuickCheck to specify the
relationships between functions in our code, helping guide the process of
finding a suitable API, by developing functions that are interrelated by
useful invariants. Think of QuickCheck as an API "lint" tool.
    </para>

    <para id="x_Fq">
Our sort function should certainly have a number of interesting properties
tying it to the basic list operations. For example: the first element in a
sorted list should be the smallest element in the input list, which we 
might be tempted to write, using the <code>List</code> library's
<code>minimum</code> function, as:
    </para>

    &QC-basics.hs:relatives_wrong;

    <para id="x_qy">
Testing this, though, reveals an error:
    </para>

    &qc-wrong1.ghci:relatives_wrong1;

    <para id="x_ry">
The property failed when sorting an empty list, for which
<code>minimum</code> doesn't make any sense. So in fact, this property only
holds for non-empty lists. QuickCheck, thankfully, comes with a full property
writing embedded language, so we can specify more precisely our invariants. 
For the empty list case, we really want to say: <emphasis>if</emphasis> the
list is non-empty, <emphasis>then</emphasis> the first element of the sorted
result is the minimum:
    </para>

    &QC-basics.hs:relatives_right;

    <para id="x_sy">
By separating out the empty list case, we can now confirm the test:
    </para>

    &qc-right1.ghci:relatives_right1;

<para id="x_ty">
Note that the type of the property has changed from being a simple
<code>Bool</code> result, to the more general <code>Property</code> type
(its now a function that filters non-empty lists, before testing them).
</para>

<para id="x_uy">
We can now complete out property set for the basic sort function, with
some other invariants that it should satisfy: the last sorted element should
be the largest; and if we find the smallest element of two different lists,
that should be the first element if we append and sort those lists.  These
properties can be stated as:
    </para>

    &QC-basics.hs:relatives;

<para id="x_vy">
Finally, we can tie our implementation of list sort to the reference sort
function in the basic List library. That is, we'll use the
<code>Prelude</code> sort as a model against which to test our
implementation. They should sort the same thing:
    </para>

    &QC-basics.hs:model;

<para id="x_wy">
This kind of model-based testing is extremely powerful. Often developers will
have a reference implementation or prototype that, while inefficient, is
correct. This can then be used to ensure optimised or more complicated
production code follows the reference. By building a large suite of these
model based tests, and running them regularly (on every commit, for example),
we can cheaply ensure code stays under control. Many large Haskell projects
come bundled with property suites that rival the size of the project
itself, with thousands of tests running on every change, keeping the code
tied to the specification, and ensuring it behaves as advertised.
</para>

  </sect1>

<!--
  <sect1>
    <title>Generating arbitrary documents</title>

  <sect1>
    <title>Running tests</title>

  <sect1>
    <title>Code coverage information</title>

  <sect1>
    <title>The awkward testing squad: IO functions and error cases</title>
  -->

</chapter>

<!--

* Motivate testing 
    - purity, types good (make some tests meaningless),
    - but still have runtime invariants that must hold
    - but we can use types to make testing easier.

* HUnit
    - familiar comfortable
    - simple example
    - not very powerful

* QuickCheck
    - simple properties
    - predicates
    - writing Arbitrary instances
    - advice on properties to look for
        - identity
        - idempotence
        - locality

* Cautions:
    - getting arbitraries right ( '\n' example)
    - can't do IO easily
    - ensuring coverage: hpc

* Summary:
    - testing is straightforward
    - can leverage types for powerful property-based testing

  -->

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
