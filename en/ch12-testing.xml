<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="quickcheck" revision="unpublished">
  <title>Testing and Quality Assurance</title>

  <para id="x_up">
Building real systems means caring about quality control, robustness and 
correctness. With the right quality assurance mechanisms in place, 
well-written code can feel like a precision machine, with all functions
performing their tasks precisely and exactly as specified. There is no
sloppiness around the edges, and the final result can be code that is
self-explanatory, obviously correct -- the kind of code that inspires
confidence.  </para>

  <para id="x_vp">
In Haskell, we have several tools at our disposal for building such 
precise systems. The most obvious tool, and one built into the language
itself, is the expressive type-system, which allows for complicated
invariants to be enforced statically &emdash; making it impossible to write
code violating chosen constraints. Meanwhile, purity and polymorphism
encourage code that is modular, refactorable, and testable. This is the kind
of code that just doesn't go wrong.
  </para>

  <para id="x_wp">
Testing plays a key role in keeping code on the straight-and-narrow path.
The main testing mechanisms in Haskell are traditional unit testing (via the HUnit 
library), and its more powerful descendant: type-based <quote>property</quote>
testing, with QuickCheck. Property-based testing encourages a high level
approach to testing in the form of abstract invariants functions should
satisfy universally, with the actual test data generated for the programmer
by the testing library. In this way code can be hammered with thousands of
tests that would be infeasible to write by hand, often uncovering subtle
corner cases that wouldn't be found otherwise.
  </para>

  <para id="x_xp">
In this chapter we'll look at how to use QuickCheck to establish invariants
in code and then re-examine the JSON pretty printer developed in chapter 6,
testing it with QuickCheck. We'll also see how to guide the testing process
with GHC's code coverage tool: HPC.
  </para>

  <sect1>
    <title>QuickCheck: type-based testing</title>

    <para id="x_yp">
To get an overview of how property-based testing works, we'll begin with a
simple scenario: you've written a specialised sort function and want to test
its behaviour against a reference implementation.
    </para>

    <para id="x_zp">
First, we import the QuickCheck library, and any other modules we need:
    </para>

    &QC-basics.hs:module;

    <para id="x_Aq">
And the function we want to test &emdash; a custom sort routine:
    </para>

    &QC-basics.hs:mysort;

    <para id="x_Bq">
This is the classic Haskell sort implementation: a study in functional
programming elegance, if not efficiency. Now, we'd like to check that this
function obeys the basic rules a good sort should follow. One useful
invariant to start with, and one that comes up in a lot of purely functional
code, is <emphasis>idempotency</emphasis> &emdash; applying a function twice has
the same result as applying it only once. For our sort routine, this should
certainly be true, or things have gone horribly wrong! This invariant can be
encoded as a property simply:
</para>

    &QC-basics.hs:idempotent;

    <para id="x_Cq">
We follow the QuickCheck convention of prefixing test properties with
<code>prop_</code> to distinguish them from normal code. This idempotency
property is written simply as a Haskell function stating an equality
that must hold for any data that is sorted. We can check this makes 
sense for a few simple cases by hand:
  </para>

    &qc-byhand.ghci:unit;

    <para id="x_oy">
Looking good. But writing out the input data by hand is tedious, and violates
the oath of the lazy functional programmer: let the machine do the work!
Thanks to the Haskell type system, QuickCheck, our testing library,
comes with a set of data generators for all the basic Haskell data
types. QuickCheck uses the <code>Arbitrary</code> type class to present a
uniform interface to random data generation, with types used to resolve 
which generator to use. QuickCheck normally hides the data generation
plumbing, but we can run the generators by hand to see what the random
data looks like. For example, a random list of booleans:
  </para>

    &qc-arbitrary.ghci:arbitrary;

    <para id="x_py">
This test data is automatically generated, and passed to the property of our
choosing, via the <code>quickCheck</code> function. The type of the property
is used to select the appropriate test generator.  <code>quickCheck</code>
then checks that for all the test data produced, the property is satisifed.
Now, since our idempotency test is polymorphic in the list element type, we
need to pick a particular type to generate test data for, which we write as a
type constraint on the property, as follows:
  </para>

    &qc-basics.ghci:basics;

  <para id="x_Dq">
For the 100 different lists generated, our property held &emdash; great!
When developing tests, it is often useful to see the actual data
generated for each test, and the result, we can replace
<code>quickCheck</code> with <code>verboseCheck</code>, to see
(verbose) output for each test.  Let's now look at more sophisticated
properties that our function might satisfy.
  </para>

    <para id="x_Eq">
Good libraries consist of a set of orthogonal primitives having sensible
relationships to each other. We can use QuickCheck to specify the
relationships between functions in our code, helping guide the process of
finding a suitable API by developing functions that are interrelated by
useful invariants. Think of QuickCheck as an API "lint" tool.
    </para>

    <para id="x_Fq">
Our sort function should certainly have a number of interesting properties
tying it to the basic list operations. For example: the first element in a
sorted list should be the smallest element in the input list. We 
might be tempted to specify this in Haskell, using the <code>List</code> library's
<code>minimum</code> function, as:
    </para>

    &QC-basics.hs:relatives_wrong;

    <para id="x_qy">
Testing this, though, reveals an error:
    </para>

    &qc-wrong1.ghci:relatives_wrong1;

    <para id="x_ry">
The property failed when sorting an empty list &emdash; where
<code>minimum</code> doesn't make any sense. So, in fact, this property only
holds for non-empty lists. QuickCheck, thankfully, comes with a full property
writing embedded language, so we can specify more precisely our invariants,
filtering out values we don't want to consider. 
For the empty list case, we really want to say: <emphasis>if</emphasis> the
list is non-empty, <emphasis>then</emphasis> the first element of the sorted
result is the minimum:
    </para>

    &QC-basics.hs:relatives_right;

    <para id="x_sy">
Quite clean! By separating out the empty list case, we can now confirm the
property holds:
    </para>

    &qc-right1.ghci:relatives_right1;

<para id="x_ty">
Note that we changed the type of the property from being a simple
<code>Bool</code> result, to the more general <code>Property</code> type
(it is now a function that filters non-empty lists, before testing them,
rather than a simple <code>Bool</code> constant).
</para>

<para id="x_uy">
We can now complete out basic property set for a sort function with
some other invariants that it should satisfy: the last sorted element should
be the largest; and if we find the smallest element of two different lists,
that should be the first element if we append and sort those lists.  These
properties can be stated as:
    </para>

    &QC-basics.hs:relatives;

<para id="x_vy">
Another cheap technique for gaining confidence in some code is to test it
against a model implementation. We can tie our implementation of list
sort to the reference sort function in the basic List library. That is, we'll
use the <code>Prelude</code> sort as a model against which to test our
implementation. They should sort the same thing:
    </para>

    &QC-basics.hs:model;

<para id="x_wy">
This kind of model-based testing is extremely powerful. Often developers will
have a reference implementation or prototype that, while inefficient, is
correct. This can then be kept around, and used to ensure optimised or more
complicated production code still conforms to the reference specification. By
building a large suite of these model based tests, and running them regularly
(on every commit, for example), we can cheaply ensure code stays under
control. Many large Haskell projects come bundled with property suites that
rival the size of the project itself, with thousands of tests running on
every change, keeping the code tied to the specification, and ensuring it
behaves as advertised.
</para>

  </sect1>

  <sect1 id="quickcheck.indepth">
    <title>Testing case study: specifying JSON printing</title>

  </sect1>

<!--
  <sect1>
    <title>Generating arbitrary documents</title>

  <sect1>
    <title>Running tests</title>

  <sect1>
    <title>Code coverage information</title>

  <sect1>
    <title>The awkward testing squad: IO functions and error cases</title>
  -->

</chapter>

<!--

* Motivate testing 
    - purity, types good (make some tests meaningless),
    - but still have runtime invariants that must hold
    - but we can use types to make testing easier.

* HUnit
    - familiar comfortable
    - simple example
    - not very powerful

* QuickCheck
    - simple properties
    - predicates
    - writing Arbitrary instances
    - advice on properties to look for
        - identity
        - idempotence
        - locality

* Cautions:
    - getting arbitraries right ( '\n' example)
    - can't do IO easily
    - ensuring coverage: hpc
    - testing error conditions

* Summary:
    - testing is straightforward
    - can leverage types for powerful property-based testing

  -->

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
