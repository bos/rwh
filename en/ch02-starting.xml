<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.starting" revision="alpha">
  <title>Getting Started</title>

  <sect1 id="hs.starting.ghc">
    <title>Your Haskell environment</title>

    <para id="x_g">There's a number of Haskell implementations available, of
      which two are in wide use.  Hugs 98 is an interpreter that is
      primarily used for teaching.  For real applications, the Glasgow
      Haskell Compiler, or &GHC; as it's usually known, is much more
      popular.  This is the Haskell implementation we'll be using
      throughout this book.</para>

    <para id="x_h">&GHC; has three complementary components: &ghc;, a
      compiler that generates native code; &ghci;, an interpreter that
      we can run interactively; and &runghc;, an interpreter that we
      can run in <quote>batch</quote> mode.</para>

    <note>
      <title>Which part of GHC do we mean?</title>

      <para id="x_i">When we discuss the package as a whole, we'll refer to it
	as &GHC;.  If we're talking about one or another command,
	we'll mention either &ghc; or &ghci;.  (We'll rarely make
	reference to &runghc;.)</para>
    </note>

    <para id="x_j">In this book, we assume that you're using at least version
      6.6.1 of &GHC;.  To obtain a copy of &GHC; for your platform,
      visit <ulink url="http://www.haskell.org/ghc/download.html">the
	&GHC; download page</ulink>, and look for the list of binary
      packages.  If you're using Windows or Mac OS X, these binary
      packages are the best ones to use.</para>

    <remark>With 6.8.1 due out long before the book, should we make
      that the <quote>baseline</quote> version?</remark>

    <para id="x_k">Many Linux distributions, and BSD and other Unix variants,
      make pre-packaged versions of &GHC; available.  Because they are
      built specifically for each environment, these packages are less
      hassle to use than the generic binary packages. You can find a
      list of such packages at the &GHC; <ulink
	url="http://www.haskell.org/ghc/distribution_packages.html">distribution 
	packages</ulink> page.</para>

    <para id="x_nL">For more detailed information about how to install &GHC; on
      a variety of popular platforms, see <xref
	linkend="hs.install"/>.</para>
  </sect1>


  <sect1 id="hs.starting.ghci">
    <title>Getting started with ghci, the interpreter</title>

    <para id="x_L1">The interactive interpreter for &GHC; is a program named
      &ghci;.  It lets you enter and evaluate Haskell expressions, and
      explore modules and type information.</para>

    <para id="x_M1">When we run &ghci;, it displays a startup banner, followed
      by a <prompt>Prelude&gt;</prompt> prompt.</para>

    <screen>
<prompt>$</prompt> <userinput>ghci</userinput>
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.6.1, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.

Loading package base ... linking ... done.
<prompt>Prelude&gt;</prompt>
</screen>

    <para id="x_uK">The word <code>Prelude</code> in the prompt indicates that
      the <quote>standard prelude</quote>, a fairly large standard
      library of useful functions, is loaded and ready for us to use.
      When we load other modules or source files, they'll show up in
      the prompt, too.</para>

    <note>
      <title>The ephemeral ghci prompt</title>

      <para id="x_N1">The prompt displayed by &ghci; changes
	frequently depending on what modules we have loaded.  It can
	often grow long enough to leave little visual room on a single
	line for our input.  For brevity, we have replaced &ghci;'s
	default prompts throughout this book with the prompt string
	<prompt>ghci&gt;</prompt>.</para>
    </note>

    <sect2 id="hs.starting.ghci.edit">
      <title>Command line editing</title>

      <para id="x_O1">On most systems, &ghci; has some amount of command line
	editing ability.  On Unix-like systems, it uses the GNU
	readline library, which is powerful and customisable.  On
	Windows, &ghci;'s command line editing capabilities are
	provided by the <command>doskey</command> command.</para>

      <para id="x_P1">If you haven't used command line editing before, it's a
	huge time saver.  The basics are common to both Unix-like and
	Windows systems.  Pressing the <keycap
	  function="up">up</keycap> arrow key on your keyboard recalls
	the last line of input you entered; pressing <keycap
	  function="up">up</keycap> repeatedly cycles through earlier
	lines of input. You can use the <keycap
	  function="left">left</keycap> and <keycap
	  function="right">right</keycap> arrow keys to move around
	inside a line of input.</para>

      <para id="x_Q1">Just knowing this much will save you a lot of repeated
	typing.  If you want to learn more about command line editing
	on your system, consult the readline or
	<command>doskey</command> documentation.</para>
    </sect2>

  </sect1>

  <sect1 id="hs.starting.calc">
    <title>Basic interaction: using ghci as a calculator</title>

    <para id="x_R1">Where some people might run a calculator program, I often
      drop into &ghci; to perform simple calculations.  Using it this
      way serves as a good way to become familiar with &ghci; itself,
      and with the basics of Haskell expressions.</para>

    <sect2 id="hs.starting.calc.arithmetic">
      <title>Simple arithmetic</title>

      <para id="x_S1">We can immediately start typing expressions, to see what
	&ghci; will do with them.  Basic arithmetic works as we might
	expect.</para>
    
      &basics.ghci:arithmetic;

      <para id="x_T1">As the expressions above imply, Haskell has a notion of
	integers and floating point numbers.  In fact, it allows us to
	use arbitrarily large integers.  Here, the
	<function>(^)</function> is the exponentiation
	operator.</para>

      &basics.ghci:bignum;

      <para id="x_U1">Like other languages that use infix notation to write
	mathematical expressions, Haskell has a notion of operator
	precedence.  This allows us to get rid of a few parentheses.
	For example, the multiplication operator has a higher
	precedence than the addition operator, so Haskell treats the
	two following expressions as equivalent.</para>

      &basics.ghci:parens;

      <tip>
	<title>Don't be too aggressive with parenthesis removal</title>

	<para id="x_V1">As in other languages, it's often better to leave at
	  least some parentheses in place, even when Haskell allows us
	  to omit them.  Their presence can help future readers
	  (including ourselves) to understand what we intended.</para>

	<para id="x_W1">Even more importantly, complex expressions
	  that rely completely on operator precedence are notorious
	  sources of bugs.  A compiler and a human can easily end up
	  with different notions of what a long, parenthesis-free
	  expression is supposed to do.</para>
      </tip>
    </sect2>

    <sect2 id="hs.starting.calc.neg">
      <title>An arithmetic quirk: writing negative numbers</title>

      <para id="x_X1">Haskell presents us with one peculiarity in how we must
	write numbers: it's often necessary to enclose a negative
	number in parentheses.  This affects us as soon as we move
	past writing the simplest of expressions.</para>

      &basics.ghci:neg;

      <para id="x_Y1">Later on, we'll be seeing how Haskell lets us devise
	entirely new infix operators.  Now that we've been forewarned,
	the following may not prove too surprising.</para>

      <para id="x_Z1"><emphasis>Most</emphasis> of the time, we can omit
	white space from expressions, and Haskell will parse them as we
	intended.  But not always.  Here's an expression that
	works:</para>

      &basics.ghci:whitespace.ok;

      <para id="x_a1">And here's one that similar to the problematic negative
	number example above, but results in a different error
	message.</para>

      &basics.ghci:whitespace.eek;

      <para id="x_b1">What's happening here is that the Haskell parser is
	reading <literal>+-</literal> as a single token, and trying to
	use it as an operator.  Once again, a few parentheses get us
	and &ghci; looking at the expression in the same way.</para>

      &basics.ghci:whitespace.whew;

      <para id="x_c1">Compared to other languages, this unusual treatment of
	negative numbers is an annoyance, for sure, but it at least
	represents a reasoned trade-off.  As we mentioned, Haskell lets
	us define new operators at any time, and choose the precedence
	and associativity of those operators.  The language designers
	chose to accept a slightly cumbersome syntax for negative
	numbers in exchange for this expressive power.</para>
    </sect2>

    <sect2 id="hs.starting.calc.undef">
      <title>Undefined values, and introducing variables</title>

      <para id="x_d1">&ghci; defines at least one well-known mathematical
	constant for us.</para>

      &basics.ghci:pi;

      <para id="x_e1">But its coverage of mathematical constants is not great,
	as we can quickly see.  Let's see if Euler's number,
	<varname>e</varname>, is available.</para>

      &basics.ghci:e;

      <para id="x_f1">Oh well.</para>

      <note>
	<title>Don't worry about the error message</title>

	<para id="x_g1">If the above <quote>not in scope</quote> error message
	  seems a little daunting, don't worry.  All it means is that
	  there is no variable defined with the name
	  <varname>e</varname>.</para>
      </note>

      <para id="x_h1">We can define <varname>e</varname> ourselves; the &let;
	construct allows us to introduce a new variable.</para>

      &basics.ghci:let;

      <para id="x_i1">We can then use our definition of <varname>e</varname> in
	arithmetic expressions.</para>

      &basics.ghci:epipi;

    </sect2>

    <sect2 id="hs.starting.calc.comparison">
      <title>Comparison and Boolean operators</title>

      <para id="x_j1">Haskell gives us the usual operators for working with
	Boolean values.</para>

      &basics.ghci:boolean;

      <para id="x_k1">Unlike some other languages, Haskell does
	<emphasis>not</emphasis> treat the
	number zero as synonymous with <literal>False</literal>, nor
	does it accept non-zero as <literal>True</literal>.</para>

      &basics.ghci:boolean.bad;

      <para id="x_l1">Comparison operators are mostly going to be
	familiar from other languages that have taken some syntactic
	cues from C.</para>

      &basics.ghci:comparison;

      <para id="x_m1">There's one exception: the <quote>is not
	  equal</quote> operator is <function>(/=)</function>
	(somewhat visually similar to the mathematical &notEqual;
	operator), not the <function>(!=)</function> you might expect
	from a language that borrows many other operators from
	C.</para>

      &basics.ghci:neq;

    </sect2>

    <sect2 id="hs.starting.calc.rational">
      <title>Rational numbers, the Haskell prelude, and modules</title>

      <para id="x_n1">In addition to integers and floating point numbers,
	Haskell supports rational numbers.  Haskell coders collect
	self-contained hunks of code into
	<emphasis>modules</emphasis>.  The integer and floating point
	numbers, and the operators we've seen so far, are packaged in
	a module named <classname
	  role="module">Prelude</classname>, whose name we've already
	seen in &ghci;'s prompt.</para>

      <para id="x_o1">(The <classname role="module">Prelude</classname> module
	is often referred to as <quote>the standard prelude</quote>,
	because its contents are defined by the Haskell 98 standard.
	Sometimes, it's simply shortened to <quote>the
	  prelude</quote>.)</para>

      <para id="x_p1">The prelude is always implicitly available; we don't need
	to take any actions to use the types, values, or functions it
	defines.  But to use definitions from other modules, we must
	<emphasis>import</emphasis> them.  To use rational numbers,
	the module we need to import is named <classname
	  role="module">Data.Ratio</classname>.  We can use a &ghci;
	command named <command>:module</command> to import
	it.</para>

      &basics.ghci:module;

      <para id="x_q1">The notation for writing a rational number is as
	follows.</para>

      &basics.ghci:ratio;

      <para id="x_r1">The <function>(%)</function> operator above takes two
	integers and constructs a rational number from them.</para>

      <para id="x_s1">Arithmetic on rational numbers works in the same way as on
	other types of number, even allowing the same
	operators.</para>
      
      &basics.ghci:ratarith;
      
      <para id="x_t1">Haskell represents a rational number with the lowest
	denominator it can.  For example, the result of the following
	expression is simplified from <literal>254%7</literal> to
	something easier to read.</para>

      &basics.ghci:denom;

    </sect2>

    <sect2 id="hs.starting.calc.exp">
      <title>Aside: the faces of exponentiation</title>

      <remark>Is it too early to introduce this?  Does it disrupt the
	flow?</remark>

      <para id="x_u1">We've already seen an exponentiation operator in Haskell:
	<function>(^)</function> raises a number to an integer power.
	The word <emphasis>integer</emphasis> is significant here: if
	we try to raise a number to the power of a floating point
	number using the <function>(^)</function> operator, exciting
	things will happen.</para>

      &basics.ghci:intpower;

      <para id="x_v1">Notice from the second example that it doesn't matter
	whether or not the base is an integer, only that the exponent
	must be.</para>

      <para id="x_w1">There's a further constraint on the exponent that is not
	immediately obvious: it must be not just an integer, but a
	<emphasis>non-negative</emphasis> integer.</para>

      &basics.ghci:exponent.bad;

      <para id="x_x1">If you think about the simplest definition of
	exponentiation, which is a number repeatedly multiplied by
	itself a given number of times, this restriction makes
	sense.</para>

      <para id="x_y1">Haskell's exponentiation operator follows the convention
	that a number raised to the zeroth power is one.  This is why
	the restriction on the exponent is that it must be
	non-negative, and not that it must be positive.</para>

      &basics.ghci:exponent.zero;

      <para id="x_z1">Haskell also provides a generalised integer exponentiation
	operator, <function>(^^)</function>.  This accepts both
	positive and negative exponents, following the rule that a
	number raised to a negative exponent is the reciprocal of the
	number raised to the positive exponent.  Let's try this with
	both integer and rational bases.</para>

      &basics.ghci:exponent.neg;
      
      <para id="x_A2">Finally, Haskell also gives us a floating point
	exponentiation operator, <function>(**)</function>.</para>

      &basics.ghci:exponent.float;

    </sect2>
  </sect1>

  <sect1 id="hs.starting.errmsg">
    <title>Don't sweat those error messages</title>

    <para id="x_B2">Remember the point we made earlier about explicit
      parentheses often being good?  Here's an example of that idea in
      action, except here the parentheses are
      <emphasis>necessary</emphasis>, not merely a good idea.</para>

    &basics.ghci:denom.bad;

    <para id="x_C2">Look at that error message; it's detailed, and mentions a
      lot of concepts we haven't covered yet.  We're new to Haskell!
      How are we supposed to interpret all of that?  The first thing
      we must do is take a deep breath and not worry about the
      details.</para>

    <para id="x_D2">If we step back and gloss over the error message, we can see
      that &ghci; is displaying for us the expression that it had
      trouble with.  And it has helpfully added parentheses back into
      the expression, only look!  <emphasis>They're in the wrong
	places.</emphasis></para>

    <para id="x_E2">This isn't the fault of &ghci;.  It just happens that the
      <function>(%)</function> and <function>(*)</function> operators
      have the same precedences, so &ghci; parses the expression from
      left to right.  As a result, it tries to construct a rational
      from another rational and an integer, instead of from a pair of
      integers.  (If <function>(%)</function> had a higher precedence
      than <function>(*)</function>, the expression would be parsed
      the way we might have hoped.)</para>

    <para id="x_F2">All we have to do to correct this problem is add some
      explicit parentheses to say what we really mean.</para>

    &basics.ghci:denom.good;

    <note>
      <title>Remain dauntless in the face of error messages</title>

      <para id="x_G2">The important lesson here is one that we'll be repeating
	over and over throughout the early sections of this book. If
	you run into problems, <emphasis>don't panic</emphasis>. You
	do not need to understand every little detail of what's going
	on.  Early on, all you have to do is figure out enough to make
	progress through a problem.  You don't need instantaneous
	complete understanding, so don't worry if you don't have
	it.</para>
    </note>

  </sect1>

  <sect1 id="hs.starting.string">
    <title>Text, strings and lists</title>

    <para id="x_H2">If you are familiar with a language like Python, you'll find
      Haskell's notations for strings and lists
      familiar.</para>

    <para id="x_I2">A text string is surrounded by double quotes.</para>

    &basics.ghci:string;

    <para id="x_J2">As in many languages, we can represent hard-to-print
      characters by <quote>escaping</quote> them.  Haskell's escape
      characters and escaping rules expand on the conventions
      established by the C language (for details, see
      <xref linkend="hs.escapes"/>).</para>

    &basics.ghci:newline;
    
    <para id="x_K2">A list is surrounded by square brackets, with elements
      separated by commas.</para>

    &basics.ghci:list;

    <para id="x_L2">A list can be of any length.</para>

    &basics.ghci:list.shortlong;

    <para id="x_M2">All elements of a list must have the same type.</para>

    &basics.ghci:list.bad;
    
    <para id="x_N2">Once again, &ghci;'s error message is verbose, but it's
      simply telling us that it can't figure out how to turn the
      string into a number, so the list expression isn't properly
      typed. (It chose to try to turn the string into a number because
      the list starts with a number.)</para>
    
    <para id="x_O2">We can write a series of elements using range
      notation, and Haskell will fill in the contents of the list for
      us.</para>
    
    &basics.ghci:range;

    <para id="x_vK">Notice that range notation gives us a <emphasis>closed
	interval</emphasis>; the list contains both endpoints.</para>

    <para id="x_P2">When we write a range, we can optionally specify
      the size of the step to use by giving the first two elements,
      followed by the value at which to stop generating the
      range.</para>

    &basics.ghci:range.step;

    <para id="x_wK">In the latter case above, the list is quite sensibly missing
      the end point of the range, because it isn't an element of the
      series we defined.</para>

    <para id="x_Q2">Haskell makes a distinction between single characters and
      text strings.  A single character is enclosed in single
      quotes.</para>

    &basics.ghci:char;

    <para id="x_R2">In fact, a text string is simply a list of individual
      characters.  Here's a painful way to write a short string, which
      &ghci; gives back to us in a more familiar form.</para>

    &basics.ghci:work;

  </sect1>

  <sect1 id="hs.starting.types">
    <title>First steps with types</title>

    <para id="x_S2">Despite all our talk of types, our interactions with &ghci;
      have so far been free of much type-related thinking.  We haven't
      told &ghci; what types we've been using, and it's mostly been
      willing to accept our input.</para>

    <para id="x_T2">The first thing we can do to start explicitly exploring the
      world of types is to get &ghci; to tell us more about what it's
      doing.  &ghci; has a command, <command>:set</command>, that lets
      us change a few of its default behaviours.  We can tell it to
      print more type information as follows.</para>

    &types.ghci:set_t_on;

    <para id="x_U2">What the <code>+t</code> does is tell &ghci; to print the
      type of an expression after  the expression.  That cryptic
      <varname>it</varname> in the output can be very useful: it's
      actually the name of a special variable, in which &ghci; stores
      the result of the last expression we evaluated.  Let's break
      down the meaning of the last line of &ghci; output, then.</para>
      
    <itemizedlist>
      <listitem>
	<para id="x_V2">It's telling us about the variable
	  <varname>it</varname>.</para>
      </listitem>
      <listitem>
	<para id="x_W2">We can read the text <code>::</code> as meaning
	  <quote>the value on the left has the type on the
	    right</quote>.</para>
      </listitem>
      <listitem>
	<para id="x_X2">And the value on the right is the type in question,
	  namely <type>[Char]</type>.</para>
      </listitem>
    </itemizedlist>

    <note id="hs.starting.it">
      <title>The joy of <quote>it</quote></title>

      <para id="x_Y2">That <varname>it</varname> variable is wonderfully handy
	when we want to use the result of a prior expression in a new
	expression.</para>

      &types.ghci:it;

      <para id="x_Z2">When evaluating an expression, &ghci; won't change the
	value of <varname>it</varname> until after it's finished.  An
	error in the evaluation will leave <varname>it</varname>
	untouched, so we can type possibly bogus expressions with a
	bit of a safety net.</para>

      &types.ghci:it.bad;

      <para id="x_a2">Coupling <varname>it</varname> with liberal use of the
	arrow keys to recall and edit the last expression we typed,
	and we have a fairly decent environment for interactive
	experiments, where the cost of mistakes is very low.  Take
	advantage of the opportunity to make cheap, plentiful mistakes
	when you're exploring the language!</para>
    </note>

    <para id="x_b2">Here are a few more of Haskell's names for types, from
      expressions of the sort we've already seen.</para>

      &types.ghci:integer;

    <para id="x_c2">Haskell's arbitrary-precision
      integer type is named <type>Integer</type> .</para>

    <note>
      <title>Type names start with an uppercase letter</title>

      <para id="x_d2">Both of the type names we've seen so far,
	<type>Char</type> and <type>Integer</type>, have started with
	capital letters.  This isn't an accident; Haskell requires
	type names to start with an uppercase letter, and variable
	names must start with a lowercase letter.  As far as Haskell
	is concerned, a function is just another variable, so a
	function name must start with a lowercase letter, too.</para>
    </note>

    <para id="x_e2">Rational numbers don't look quite the same as
      integers.</para>

    &types.ghci:ratio;

    <para id="x_f2">Notice <emphasis>two</emphasis> words on the right
      hand side of the <code>::</code> above.  We can read this as a
      <quote><type>Ratio</type> of <type>Integer</type></quote>; we
      might infer that a <type>Ratio</type> must need to have values
      of type <type>Integer</type> as both numerator and denominator.
      Sure enough, if we try to construct a <type>Ratio</type> where
      the numerator and denominator are of different types, &ghci;
      complains.</para>

    &types.ghci:ratio.bad;

    <para id="x_g2">Although it's initially useful to have <userinput>:set
	+t</userinput> giving us type information for every expression
      we enter, this is a facility we'll quickly outgrow, simply
      because it will become redundant.  After a while, we'll often
      know what type we expect an expression to have, so why get
      &ghci; to remind us?  We can turn off the extra type information
      at any time, using the <command>:unset</command> command.</para>

    &types.ghci:set_t_off;
    
    <para id="x_h2">Even with this facility turned off,  we can still get that
      type information easily when we need it, using another &ghci;
      command.</para>

    &types.ghci:type;

    <para id="x_i2">The <command>:type</command> command will print type
      information for any expression we give it (including
      <varname>it</varname>, as we see above).  It won't actually
      evaluate the expression; it only checks its type and prints
      that.</para>

    <sect2 id="hs.starting.types.exercises">
      <title>Exercises</title>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_j2">Foo?</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="hs.starting.conclusion">
    <title>Conclusion</title>

    <para id="x_k2">In this chapter, we've seen how to install &GHC; for our
      environment.  We then went on to interactively explore some
      basic Haskell concepts using &ghci;, the interpreter bundled with
      &GHC;.  We saw how to evaluate simple expressions.</para>

    <para id="x_l2">We dipped a toe into the water of typing.</para>
    <para id="x_m2">We also had drilled into us the notion that we don't need to
      understand, or be intimidated by, every single gripe that &ghci;
      throws our way.  We'll do just fine with a shallow understanding
      initially, and rely on practice and more reading to round out
      our knowledge.  Onwards!</para>

  </sect1>
</chapter>


<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
