<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="starting" revision="alpha;beta">
  <title>Getting Started</title>

  <para id="x_TM">As you read this chapter and the few that follow, it's good to
    keep in mind that early on, we will sometimes introduce ideas in
    restricted, simplified form.  Haskell is a deep language, and
    presenting every aspect of a given subject all at once is likely
    to prove overwhelming.  As we build a solid foundation in Haskell,
    we'll expand upon these initial explanations.</para>

  <sect1 id="starting.ghc">
    <title>Your Haskell environment</title>

    <para id="x_g">Haskell is a language with many implementations, of
      which two are in wide use.  Hugs is an interpreter that is
      primarily used for teaching.  For real applications, the Glasgow
      Haskell Compiler (&GHC;) is much more popular.  Compared to
      Hugs, &GHC; is more suited to <quote>real work</quote>: it
      compiles to native code, supports parallel execution, and
      provides useful performance analysis and debugging tools.  For
      these reasons, &GHC; is the Haskell implementation that we will
      be using throughout this book.</para>

    <para id="x_h">&GHC; has three main components.</para>

    <itemizedlist>
      <listitem>
	<para id="x_jl">&ghc; is an optimizing compiler that generates fast
	  native code.</para>
      </listitem>
      <listitem>
	<para id="x_kl">&ghci; is an interactive interpreter and
	  debugger.</para>
      </listitem>
      <listitem>
	<para id="x_ll">&runghc; is a program for running Haskell programs as
	  scripts, without needing to compile them first.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>How we refer to the components of GHC</title>

      <para id="x_i">When we discuss the &GHC; system as a whole, we
	will refer to it as &GHC;.  If we are talking about a specific
	command, we will mention &ghc;, &ghci;, or &runghc; by
	name.</para>
    </note>

    <para id="x_j">In this book, we assume that you're using at least
      version 6.8.2 of &GHC;, which was released in 2007.  Many of our
      examples will work unmodified with older versions.  However, we
      <emphasis>recommend</emphasis> using whatever is the newest
      version available for your platform.  If you're using Windows or
      Mac OS X, you can get started easily and quickly using a
      prebuilt installer.  To obtain a copy of &GHC; for these
      platforms, visit <ulink
	url="http://www.haskell.org/ghc/download.html">the &GHC;
	download page</ulink>, and look for the list of binary
      packages and installers.</para>

    <para id="x_k">Many Linux distributors, and providers of BSD and
      other Unix variants, make custom binary packages of &GHC;
      available. Because these are built specifically for each
      environment, they are much easier to install and use than the
      generic binary packages that are available from the &GHC;
      download page. You can find a list of distributions that
      custom-build &GHC; at the &GHC; <ulink
	url="http://www.haskell.org/ghc/distribution_packages.html">distribution 
	packages</ulink> page.</para>

    <para id="x_nL">For more detailed information about how to install &GHC; on
      a variety of popular platforms, we've provided some instructions
      in <xref linkend="install"/>.</para>
  </sect1>


  <sect1 id="starting.ghci">
    <title>Getting started with ghci, the interpreter</title>

    <para id="x_L1">The interactive interpreter for &GHC; is a program named
      &ghci;.  It lets us enter and evaluate Haskell expressions,
      explore modules, and debug our code.  If you're familiar with
      Python or Ruby, &ghci; is somewhat similar to
      <filename>python</filename> and <filename>irb</filename>, the
      interactive Python and Ruby interpreters.</para>

      <para id="x_UM">The &ghci; command is not a complete interpreter
      for all of Haskell.  We typically cannot copy some code out of a
      Haskell source file and paste it into &ghci;: it only accepts
      expressions and some other directives.  In this respect, it's
      more restrictive than, say, the interactive Python interpreter,
      which can accept all Python code.</para>

    <para id="x_VM">On Unix-like systems, we run &ghci; as a command in a shell
      window.  On Windows, it's available as a menu item accessible
      from the Start Menu.  For example, if you installed using the
      &GHC; installer on Windows XP, you should go to <quote>All
	Programs</quote>, then <quote>GHC</quote>; you'll then see
      &ghci; in the list.  (See <xref linkend="install.win"/> for a
      screenshot.)</para>

    <para id="x_M1">When we run &ghci;, it displays a startup banner, followed
      by a <prompt>Prelude&gt;</prompt> prompt.  Here, we're showing
      version 6.6.1 run on a Linux box.  More recent versions print a
      shorter banner.</para>

    <screen>
<prompt>$</prompt> <userinput>ghci</userinput>
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.6.1, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.

Loading package base ... linking ... done.
<prompt>Prelude&gt;</prompt>
</screen>

    <para id="x_uK">The word <code>Prelude</code> in the prompt
      indicates that <classname role="module">Prelude</classname>, a
      standard library of useful functions, is loaded and ready to
      use. When we load other modules or source files, they will show
      up in the prompt, too.</para>

    <tip>
      <title>Getting help</title>

      <para id="x_ml">If you enter <code>:?</code> at the &ghci; prompt, it will
	print a long help message.</para>
    </tip>

    <para id="x_o1">The <classname role="module">Prelude</classname>
      module is sometimes referred to as <quote>the standard
	prelude</quote>, because its contents are defined by the
      Haskell 98 standard. Usually, it's simply shortened to
      <quote>the prelude</quote>.</para>

    <note>
      <title>About the ghci prompt</title>

      <para id="x_N1">The prompt displayed by &ghci; changes
	frequently depending on what modules we have loaded.  It can
	often grow long enough to leave little visual room on a single
	line for our input.</para>

      <para id="x_WM">For brevity and consistency, we have replaced &ghci;'s
	default prompts throughout this book with the prompt string
	<prompt>ghci&gt;</prompt>.</para>

      <para id="x_nl">If you want to do this youself, use &ghci;'s <code>:set
	  prompt</code> directive, as follows.</para>

      <screen>
<prompt>Prelude&gt;</prompt> <userinput>:set prompt "ghci> "</userinput>
<prompt>ghci&gt;</prompt></screen>
    </note>

    <para id="x_p1">The prelude is always implicitly available; we
      don't need to take any actions to use the types, values, or
      functions it defines.  To use definitions from other modules, we
      must load them into &ghci;, using the <command>:module</command>
      command.</para>

    &basics.ghci:module;
  </sect1>

  <sect1 id="starting.calc">
    <title>Basic interaction: using ghci as a calculator</title>

    <para id="x_R1">In addition to providing a convenient interface
      for testing code fragments, &ghci; can function as a readily
      accessible desktop calculator. We can easily express any
      calculator operation in &ghci; and, as an added bonus, we can
      add more complex operations as we become more familiar with
      Haskell. Even using the interpreter in this simple way can help
      us to become more comfortable with how Haskell works.</para>

    <sect2 id="starting.calc.arithmetic">
      <title>Simple arithmetic</title>

      <para id="x_S1">We can immediately start entering expressions,
	to see what &ghci; will do with them.  Basic arithmetic works
	similarly to languages like C and Python: we write
	expressions in <emphasis>infix</emphasis> form, where an
	operator appears between its operands.</para>
    
      &basics.ghci:arithmetic;

      <para id="x_ZM">The infix style of
	writing an expression is just a convenience: we can also write
	an expression in <emphasis>prefix</emphasis> form, where the
	operator precedes its arguments.  To do this, we must enclose
	the operator in parentheses.</para>

      &basics.ghci:prefix;

      <para id="x_T1">As the expressions above imply, Haskell has a
	notion of integers and floating point numbers.  Integers can
	be arbitrarily large.  Here, <function>(^)</function>
	provides integer exponentiation.</para>

      &basics.ghci:bignum;
    </sect2>

    <sect2 id="starting.calc.neg">
      <title>An arithmetic quirk: writing negative numbers</title>

      <para id="x_X1">Haskell presents us with one peculiarity in how we must
	write numbers: it's often necessary to enclose a negative
	number in parentheses.  This affects us as soon as we move
	beyond the simplest expressions.</para>

      <para id="x_bM">We'll start by writing a negative number.</para>

      &basics.ghci:neg.simple;

      <para id="x_cM">The <code>-</code> above is a unary operator.  In other
	words, we didn't write the single number <quote>-3</quote>; we
	wrote the number <quote>3</quote>, and applied the operator
	<code>-</code> to it.  The <code>-</code> operator is
	Haskell's only unary operator, and we can't mix it with infix
	operators.</para>

      &basics.ghci:neg.error;

      <para id="x_dM">If we want to use the unary minus near an infix operator,
	we must wrap the expression it applies to in
	parentheses.</para>

      &basics.ghci:neg.better;

      <para id="x_Z1"><emphasis>Most</emphasis> of the time, we can omit
	white space from expressions, and Haskell will parse them as we
	intended.  But not always.  Here's an expression that
	works:</para>

      &basics.ghci:whitespace.ok;

      <para id="x_a1">And here's one that seems similar to the
	problematic negative number example above, but results in a
	different error message.</para>

      &basics.ghci:whitespace.eek;

      <para id="x_b1">Here, the Haskell implementation is reading
	<literal>+-</literal> as a single operator.  Haskell lets us
	define new operators (a subject that we'll return to later),
	but we haven't defined this one.  Once again, a few
	parentheses get us and &ghci; looking at the expression in the
	same way.</para>

      &basics.ghci:whitespace.whew;

      <para id="x_c1">Compared to other languages, this unusual
	treatment of negative numbers might seem annoying, but it
	represents a reasoned trade-off.  Haskell lets us define new
	operators at any time.  This isn't some kind of esoteric
	language feature; we'll see quite a few user-defined operators
	in the chapters ahead. The language designers chose to accept
	a slightly cumbersome syntax for negative numbers in exchange
	for this expressive power.</para>
    </sect2>

    <sect2 id="starting.calc.comparison">
      <title>Boolean logic, operators, and value comparisons</title>

      <para id="x_j1">The values of Boolean logic in Haskell are
	&True; and &False;.  The language uses C-influenced operators
	for working with Boolean values.</para>

      &basics.ghci:boolean;

      <para id="x_eM">Here, <function>(&amp;&amp;)</function> is logical
	<quote>and</quote>, and <function>(||)</function> is logical
	<quote>or</quote>.</para>

      <para id="x_k1">Unlike some other languages, Haskell does
	<emphasis>not</emphasis> treat the
	number zero as synonymous with <literal>False</literal>, nor
	does it consider any non-zero value to be <literal>True</literal>.</para>

      &basics.ghci:boolean.bad;

      <para id="x_fM">Once again, we're faced with a substantial-looking error
	message. In brief, it tells us that the Boolean type, <type>Bool</type>,
	is not a member of the family of numeric types,
	<code>Num</code>.  The error message is rather long because
	&ghci; is pointing out the location of the problem, and
	hinting at a possible change we could make that might fix the
	problem.</para>

      <tip>
	<title>Remain dauntless in the face of error messages</title>

	<para id="x_G2">An important guideline here is one that we'll
	  be repeating over and over throughout the early sections of
	  this book. If you run into problems or error messages that
	  you do not yet understand, <emphasis>don't panic</emphasis>.
	  Early on, all you have to do is figure out enough to make
	  progress through a problem. As you acquire experience, parts
	  of error messages that now seem obscure will become easier
	  to follow.</para>

	<para id="x_gM">The numerous error messages have a purpose: they
	  actually help us in writing correct code, by making us
	  perform some amount of debugging <quote>up front</quote>,
	  before we ever run a program.  If you are coming from a
	  background of working with more permissive languages, this
	  way of working may come as something of a shock.  Bear with
	  us.</para>
    </tip>

      <para id="x_l1">Most of Haskell's comparison operators are
	similar to those used in C and languages influenced by
	C.</para>

      &basics.ghci:comparison;

      <para id="x_m1">There's one exception: the <quote>is not
	  equal to</quote> operator is <function>(/=)</function>
	(somewhat visually similar to the mathematical &notEqual;
	operator), not the <function>(!=)</function> you might expect
	from a language that borrows many other operators from
	C.</para>

      &basics.ghci:neq;

      <para id="x_hM">Also, where C and Perl use <function>!</function> for
	logical negation, Haskell uses the <function>not</function>
	function.</para>

      &basics.ghci:not;
      
    </sect2>

    <sect2 id="starting.calc.precedence">
      <title>Operator precedence and associativity</title>

      <para id="x_U1">Like other languages that use infix notation to
	write some expressions, Haskell has a notion of
	operator precedence.  We can use parentheses to explicitly
	group parts of an expression, and precedence allows us to
	omit a few parentheses. For example, the multiplication
	operator has a higher precedence than the addition operator,
	so Haskell treats the following two expressions as
	equivalent.</para>

      &basics.ghci:parens;

      <para id="x_iM">Haskell assigns numeric precedence values to operators,
	with 1 being the lowest precedence and 9 the highest.  A
	higher-precedence operator gets parsed before a
	lower-precedence operator.  We can use &ghci; to inspect the
	precedence levels of individual operators, using its
	<command>:type</command> command.</para>

      &basics.ghci:precedence;

      <para id="x_jM">Since <function>(*)</function> has a higher precedence
	than <function>(+)</function>, we can now see why <code>1 + 4
	  * 4</code> is parsed as <code>1 + (4 * 4)</code>, and not
	<code>(1 + 4) * 4</code>.</para>

      <para id="x_kM">Haskell also defines <emphasis>associativity</emphasis> of
	operators.  This determines whether an expression containing
	multiple uses of an operator is parsed from left to right, or
	right to left.  The <function>(+)</function> and
	<function>(*)</function> operators are left associative, which
	is represented as <code>infixl</code> in the &ghci; output
	above.  A right associative operator would be displayed with
	<code>infixr</code>.</para>

      <para id="x_lM">The combination of precedence and associativity rules are
	usually referred to as <emphasis>fixity</emphasis>
	rules.</para>
    </sect2>

    <sect2 id="starting.calc.undef">
      <title>Undefined values, and introducing variables</title>

      <para id="x_d1">Haskell's prelude, the standard library we
	mentioned earlier, defines at least one well-known
	mathematical constant for us.</para>

      &basics.ghci:pi;

      <para id="x_e1">But its coverage of mathematical constants is not great,
	as we can quickly see.  Let's see if Euler's number,
	<varname>e</varname>, is available.</para>

      &basics.ghci:e;

      <para id="x_f1">Oh well.</para>

      <note>
	<title>Don't worry about the error message</title>

	<para id="x_g1">If the above <quote>not in scope</quote> error message
	  seems a little daunting, don't worry.  All it means is that
	  there is no variable defined with the name
	  <varname>e</varname>.</para>
      </note>

      <para id="x_h1">Using &ghci;'s &let; construct, we can make a
	temporary definition of <varname>e</varname> ourselves.</para>

      &basics.ghci:let;

      <para id="x_mM">This is a call to the base-<varname>e</varname>
	exponential function, <function>exp</function>, and our first
	example of calling a function in Haskell.  While languages
	like Python require parentheses around the arguments to a
	function, Haskell does not.</para>

      <para id="x_i1">With <varname>e</varname> defined, we can use it
	in arithmetic expressions.</para>

      &basics.ghci:epipi;
      
      <warning>
	<title>This syntax is ghci-specific</title>

	<para id="x_nM">The syntax for &let; that &ghci; accepts is not the same
	  as we would use in a normal Haskell program.  We'll see the
	  normal syntax in <xref linkend="deftypes.locals"/>.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Navigating the thicket of fixity rules</title>

      <para id="x_V1">It's sometimes better to leave at least some
	parentheses in place, even when Haskell allows us to omit
	them.  Their presence can help future readers (including
	ourselves) to understand what we intended.</para>

      <para id="x_W1">Even more importantly, complex expressions that
	rely completely on operator precedence are notorious sources
	of bugs.  A compiler and a human can easily end up with
	different notions of what even a short, parenthesis-free
	expression is supposed to do.</para>

      <para id="x_oM">Here's a cautionary example of mixing different operators
	of the same fixities: <function>(*)</function> and
	<function>(/)</function>. The following two expressions give
	subtly different results.</para>

      &basics.ghci:grouping;

      <para id="x_pM">When deciding whether to use parentheses, you can probably
	rely on yourself and your readers to remember the language's
	precedence rules for the most common arithmetic and logical
	operators: <function>(||)</function> is <code>2</code>;
	<function>(&amp;&amp;)</function> is <code>3</code>;
	<function>(+)</function> and <function>(-)</function> are
	<code>6</code>; while <function>(*)</function> and
	<function>(/)</function> are <code>7</code>.  For
	associativities and for other operators, it's not often wise
	to assume that readers will remember the rules, so parentheses
	are often safest.</para>
    </sect2>

  </sect1>

  <sect1 id="starting.ghci.edit">
    <title>Command line editing in ghci</title>

    <para id="x_O1">On most systems, &ghci; has some amount of command
      line editing ability. In case you are not familiar with command
      line editing, it's a huge time saver.  The basics are common to
      both Unix-like and Windows systems.  Pressing the <keycap
	function="up">up</keycap> arrow key on your keyboard recalls
      the last line of input you entered; pressing <keycap
	function="up">up</keycap> repeatedly cycles through earlier
      lines of input. You can use the <keycap
	function="left">left</keycap> and <keycap
	function="right">right</keycap> arrow keys to move around
      inside a line of input.  On Unix (but not Windows,
      unfortunately), the <keycap function="tab">tab</keycap> key
      completes partially entered identifiers.</para>

    <tip>
      <title>Where to look for more information</title>

      <para id="x_XM">We've barely scratched the surface of command
	line editing here.  Since you can work more effectively if
	you're more familiar with the capabilities of your command
	line editing system, you might find it useful to do some
	further reading.</para>

      <para id="x_YM">On Unix-like systems, &ghci; uses the <ulink
	  url="http://tiswww.case.edu/php/chet/readline/rltop.html#Documentation">GNU 
	  readline library</ulink>, which is powerful and
	customisable.  On Windows, &ghci;'s command line editing
	capabilities are provided by the <ulink
	  url="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx"><command>doskey</command> 
	  command</ulink>.</para>
    </tip>
    </sect1>

  <sect1 id="starting.list">
    <title>Lists</title>

    <para id="x_K2">A list is surrounded by square brackets; the
      elements are separated by commas.</para>

    &basics.ghci:list;
    
    <note>
      <title>Commas are separators, not terminators</title>

      <para id="x_qM">Some languages permit the last element in a list to be
	followed by an optional trailing comma before a closing
	bracket, but Haskell doesn't allow this.  If you leave in a
	trailing comma, you'll get a parse error.</para>
    </note>

    <para id="x_L2">A list can be of any length.  The empty list is
      written <literal>[]</literal>.</para>

    &basics.ghci:list.shortlong;

    <para id="x_M2">All elements of a list must be of the same type.</para>

    &basics.ghci:list.bad;
    
    <para id="x_N2">Once again, &ghci;'s error message is verbose, but
      it's simply telling us that there is no way to turn the string
      into a Boolean value, so the list expression isn't properly
      typed.</para>

    <para id="x_O2">If we write a series of elements using
      <emphasis>range notation</emphasis>, Haskell will fill in the
      contents of the list for us.</para>
    
    &basics.ghci:range;

    <para id="x_rM">Here, the <literal>..</literal> characters denote a range.
      We can only use range notation for types whose elements we can
      enumerate. Range notation makes no sense for rational numbers,
      for example, because there is not a countable number of
      rationals.</para>

    <para id="x_vK">By the way, notice that the above use of range
      notation gives us a <emphasis>closed interval</emphasis>; the
      list contains both endpoints.</para>

    <para id="x_P2">When we write a range, we can optionally specify
      the size of the step to use by giving the first two elements,
      followed by the value at which to stop generating the
      range.</para>

    &basics.ghci:range.step;

    <para id="x_wK">In the latter case above, the list is quite
      sensibly missing the end point of the range, because it isn't an
      element of the series we defined.</para>

    <para id="x_sM">We can omit the end point of a range.  If the type we're
      enumerating has an upper bound on its values (or a lower bound
      if the step is negative), that bound will be the end point of
      the range.  Otherwise, the range will continue indefinitely.
      For example, if you type <literal>[1..]</literal> at the &ghci;
      prompt, you'll have to interrupt or kill &ghci; to get it to
      stop printing an infinite succession of ever-larger
      numbers.</para>

    <warning>
      <title>Beware ranges of floating point numbers</title>

      <para id="x_tM">Here's a non-intuitive bit of behaviour.</para>

      &basics.ghci:range.double;

      <para id="x_uM">Behind the scenes, the Haskell implementation is
	converting the floating point numbers into integers,
	enumerating the range as integers, then turning them back into
	floating point numbers.</para>

      <para id="x_vM">While this is peculiar, there's worse in store.  The range
	<literal>[0,0.1..1]</literal> steps in increments of 0.1
	between zero and one, but the number of elements in the list
	depends on the amount of rounding error in the
	implementation's representation of floating point numbers: you
	will <emphasis>probably</emphasis> get a list of eleven
	elements, but you <emphasis>might</emphasis> get ten.</para>

      <para id="x_wM">Because of these limitations, range notation over floating
	point numbers is not really safe to use.</para>
    </warning>

    <sect2 id="starting.list.op">
      <title>Operators on lists</title>

      <para id="x_xM">There are two ubiquitous operators for working with
	lists.  We concatenate two lists using the
	<function>(++)</function> operator.</para>

      &basics.ghci:concat;

      <para id="x_yM">More basic is the <function>(:)</function> operator, which
	adds an element to the front of a list.  This is pronounced
	<quote>cons</quote> (short for
	<quote>construct</quote>).</para>

      &basics.ghci:cons;
    </sect2>

  </sect1>

  <sect1 id="starting.string">
    <title>Strings and characters</title>

    <para id="x_H2">If you know a language like Perl or C, you'll find
      Haskell's notations for strings familiar.</para>

    <para id="x_I2">A text string is surrounded by double quotes.</para>

    &basics.ghci:string;

    <para id="x_J2">As in many languages, we can represent
      hard-to-print characters by <quote>escaping</quote> them.
      Haskell's escape characters and escaping rules follow the widely
      used conventions established by the C language.  For example,
      <literal>'\n'</literal> denotes a newline character, and
      <literal>'\t'</literal> is a tab character.  For complete
      details, see <xref linkend="escapes"/>.</para>

    &basics.ghci:newline;
    
    <para id="x_Q2">Haskell makes a distinction between single characters and
      text strings.  A single character is enclosed in single
      quotes.</para>

    &basics.ghci:char;

    <para id="x_R2">In fact, a text string is simply a list of individual
      characters.  Here's a painful way to write a short string, which
      &ghci; gives back to us in a more familiar form.</para>

    &basics.ghci:work;

  </sect1>

  <sect1 id="starting.types">
    <title>First steps with types</title>

    <para id="x_S2">While we've talked a little about types already,
      our interactions with &ghci; have so far been free of much
      type-related thinking.  We haven't told &ghci; what types we've
      been using, and it's mostly been willing to accept our
      input.</para>

    <para id="x_zM">Haskell requires type names to start with an uppercase
      letter, and variable names must start with a lowercase letter.
      Bear this in mind as you read on; it makes it much easier to
      follow the names.</para>

    <para id="x_T2">The first thing we can do to start exploring the
      world of types is to get &ghci; to tell us more about what it's
      doing.  &ghci; has a command, <command>:set</command>, that lets
      us change a few of its default behaviours.  We can tell it to
      print more type information as follows.</para>

    &types.ghci:set_t_on;

    <para id="x_U2">What the <code>+t</code> does is tell &ghci; to
      print the type of an expression after  the expression.  That
      cryptic <varname>it</varname> in the output can be very useful:
      it's actually the name of a special variable, in which &ghci;
      stores the result of the last expression we evaluated.  (This
      isn't a Haskell language feature; it's specific to &ghci;
      alone.)  Let's break down the meaning of the last line of &ghci;
      output.</para>
      
    <itemizedlist>
      <listitem>
	<para id="x_V2">It's telling us about the special variable
	  <varname>it</varname>.</para>
      </listitem>
      <listitem>
	<para id="x_W2">We can read text of the form <code>x ::
	    y</code> as meaning <quote>the expression <code>x</code>
	    has the type <code>y</code></quote>.</para>
      </listitem>
      <listitem>
	<para id="x_X2">Here, the expression <quote>it</quote> has the
	  type <type>[Char]</type>.  (The name <type>String</type>
	  is often used instead of <type>[Char]</type>.  It is simply
	  a synonym for <type>[Char]</type>.)</para>
      </listitem>
    </itemizedlist>

    <tip id="starting.it">
      <title>The joy of <quote>it</quote></title>

      <para id="x_Y2">That <varname>it</varname> variable is wonderfully handy
	when we want to use the result of the prior expression in a new
	expression.</para>

      &types.ghci:it;

      <para id="x_Z2">When evaluating an expression, &ghci; won't
	change your environment if the evaluation fails.  A successful
	evaluation will only change either the variable you specify,
	or <varname>it</varname> if you didn't name a variable to
	change.  This lets you write potentially bogus expressions
	with something of a safety net.</para>

      &types.ghci:it.bad;

      <para id="x_a2">When we couple <varname>it</varname> with
	liberal use of the arrow keys to recall and edit the last
	expression we typed, and this gives us a fairly decent
	environment for interactive experiments, where the cost of
	mistakes is very low.  Take advantage of the opportunity to
	make cheap, plentiful mistakes when you're exploring the
	language!</para>
    </tip>

    <para id="x_b2">Here are a few more of Haskell's names for types, from
      expressions of the sort we've already seen.</para>

      &types.ghci:integer;

    <para id="x_c2">Haskell's integer type is named
      <type>Integer</type>, and is unbounded; only your system's
      memory capacity limits the size of the integers it can
      represent.</para>

    <para id="x_e2">Rational numbers don't look quite the same as
      integers.</para>

    &types.ghci:ratio;

    <para id="x_f2">Notice <emphasis>two</emphasis> words on the right
      hand side of the <code>::</code> above.  We can read this as a
      <quote><type>Ratio</type> of <type>Integer</type></quote>.  We
      might infer that a <type>Ratio</type> must need to have values
      of type <type>Integer</type> as both numerator and denominator.
      Sure enough, if we try to construct a <type>Ratio</type> where
      the numerator and denominator are of different types, or of the
      same non-integral type, &ghci; complains.</para>

    &types.ghci:ratio.bad;

    <para id="x_g2">Although it's initially useful to have
      <userinput>:set +t</userinput> giving us type information for
      every expression we enter, this is a facility we'll quickly
      outgrow: after a while, we'll often know what type we expect an
      expression to have.  We can turn off the extra type information
      at any time, using the <command>:unset</command> command.</para>

    &types.ghci:set_t_off;
    
    <para id="x_h2">Even with this facility turned off,  we can still get that
      type information easily when we need it, using another &ghci;
      command.</para>

    &types.ghci:type;

    <para id="x_i2">The <command>:type</command> command will print type
      information for any expression we give it (including
      <varname>it</varname>, as we see above).  It won't actually
      evaluate the expression; it only checks its type and prints
      that.</para>

    <sect2 id="starting.types.exercises">
      <title>Exercises</title>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_j2">Foo?</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="starting.conclusion">
    <title>Conclusion</title>

    <para id="x_k2">In this chapter, we've seen how to install &GHC; for our
      environment.  We then went on to interactively explore some
      basic Haskell concepts using &ghci;, the interpreter bundled with
      &GHC;.  We saw how to evaluate simple expressions.</para>

    <para id="x_l2">We dipped a toe into the water of typing.</para>

    <para id="x_m2">We also had drilled into us the notion that we don't need to
      understand, or be intimidated by, every single gripe that &ghci;
      throws our way.  We'll do just fine with a shallow understanding
      initially, and rely on practice and more reading to round out
      our knowledge.  Onwards!</para>

  </sect1>
</chapter>


<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
