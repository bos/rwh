<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.starting" revision="alpha">
  <title>Getting Started</title>

  <sect1 id="hs.starting.ghc">
    <title>Your Haskell environment</title>

    <para id="x_g">Haskell is a language with many implementations, of
      which two are in wide use.  Hugs is an interpreter that is
      primarily used for teaching.  For real applications, the Glasgow
      Haskell Compiler (&GHC;) is much more popular.  Compared to
      Hugs, &GHC; is much more complete: it compiles to native code,
      supports parallel execution, and provides useful performance
      analysis and debugging tools.  For these reasons, &GHC; is the
      Haskell implementation that we'll be using throughout this
      book.</para>

    <para id="x_h">&GHC; has three complementary components: &ghc;, a
      compiler that generates native code; &ghci;, an interpreter that
      we can run interactively; and &runghc;, an interpreter for
      running Haskell programs as fast-turnaround scripts after the
      manner of Perl or Ruby.</para>

    <note>
      <title>How we refer to the components of GHC</title>

      <para id="x_i">When we discuss the &GHC; system as a whole,
	we'll refer to it as &GHC;.  If we're talking about one or
	another command, we'll mention &ghc;, &ghci;, or &runghc; by
	name.</para>
    </note>

    <para id="x_j">In this book, we assume that you're using at least
      version 6.6.1 of &GHC;.  If you're using Windows or Mac OS X,
      you can get started easily and quickly using a prebuilt
      installer.  To obtain a copy of &GHC; for these platforms,
      visit <ulink url="http://www.haskell.org/ghc/download.html">the
	&GHC; download page</ulink>, and look for the list of binary
      packages and installers.</para>

    <remark>With 6.8.1 due out long before the book, should we make
      that the <quote>baseline</quote> version?  We're likely to hold
      off on a decision until much closer to publication.  For now,
      we'll stick with 6.6.1.</remark>

    <para id="x_k">Many Linux distributors, and providers of BSD and
      other Unix variants, make custom binary packages of &GHC;
      available. Because these are built specifically for each
      environment, they are much easier to install and use than the
      generic binary packages that are available from the &GHC;
      download page. You can find a list of distributions that
      custom-build &GHC; at the &GHC; <ulink
	url="http://www.haskell.org/ghc/distribution_packages.html">distribution 
	packages</ulink> page.</para>

    <para id="x_nL">For more detailed information about how to install &GHC; on
      a variety of popular platforms, we've provided some instructions
      in <xref linkend="hs.install"/>.</para>
  </sect1>


  <sect1 id="hs.starting.ghci">
    <title>Getting started with ghci, the interpreter</title>

    <para id="x_L1">The interactive interpreter for &GHC; is a program named
      &ghci;.  It lets you enter and evaluate Haskell expressions, and
      explore modules and type information.  If you're familiar with
      Python, it's somewhat similar to the interactive Python
      interpreter.</para>

      <para>The &ghci; command is a tool for evaluating Haskell
      expressions, using existing code from libraries or source files
      that we've written.  It also provides commands that let us
      inspect some details of modules and expressions.  It is not a
      complete interpreter for all of Haskell.  We typically cannot
      copy some code out of a Haskell source file and paste it into
      &ghci;.  In this respect, it's more restrictive than, say, the
      interactive Python interpreter, which can accept all Python
      code.</para>

    <para>On Unix-like systems, we run &ghci; as a command in a shell
      window.  On Windows, it's available as a menu item accessible
      off the Start Menu.  For example, if you installed using the
      &GHC; installer on Windows XP, you should go to <quote>All
	Programs</quote>, then <quote>GHC</quote>; you'll then see
      &ghci; in the list.  (See <xref linkend="hs.install.win"/> for a
      screenshot.)</para>

    <para id="x_M1">When we run &ghci;, it displays a startup banner, followed
      by a <prompt>Prelude&gt;</prompt> prompt.  (Here, we're showing
      it run on a Linux box.)</para>

    <screen>
<prompt>$</prompt> <userinput>ghci</userinput>
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.6.1, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.

Loading package base ... linking ... done.
<prompt>Prelude&gt;</prompt>
</screen>

    <para id="x_uK">The word <code>Prelude</code> in the prompt
      indicates that the <quote>standard prelude</quote>, a standard
      library of useful functions, is loaded and ready to use. When we
      load other modules or source files, they'll show up in the
      prompt, too.</para>

    <para id="x_o1">The <classname role="module">Prelude</classname>
      module is sometimes referred to as <quote>the standard
	prelude</quote>, because its contents are defined by the
      Haskell 98 standard. Usually, it's simply shortened to
      <quote>the prelude</quote>.</para>

    <note>
      <title>About the ghci prompt</title>

      <para id="x_N1">The prompt displayed by &ghci; changes
	frequently depending on what modules we have loaded.  It can
	often grow long enough to leave little visual room on a single
	line for our input.</para>

      <para>For brevity and consistency, we have replaced &ghci;'s
	default prompts throughout this book with the prompt string
	<prompt>ghci&gt;</prompt>.</para>
    </note>

    <para id="x_p1">The prelude is always implicitly available; we
      don't need to take any actions to use the types, values, or
      functions it defines.  To use definitions from other modules, we
      must load them into &ghci;, using the <command>:module</command>
      command.</para>

    &basics.ghci:module;

    <sect2 id="hs.starting.ghci.edit">
      <title>Command line editing</title>

      <para id="x_O1">On most systems, &ghci; has some amount of
	command line editing ability. If you're not familiar with
	command line editing, it's a huge time saver.  The basics are
	common to both Unix-like and Windows systems.  Pressing the
	<keycap function="up">up</keycap> arrow key on your keyboard
	recalls the last line of input you entered; pressing <keycap
	  function="up">up</keycap> repeatedly cycles through earlier
	lines of input. You can use the <keycap
	  function="left">left</keycap> and <keycap
	  function="right">right</keycap> arrow keys to move around
	inside a line of input.  On Unix (but not Windows,
	unfortunately), the <keycap function="tab">tab</keycap> key
	completes partially typed identifiers.</para>

      <tip>
	<title>Where to look for more information</title>

	<para>We've barely scratched the surface of command line
	  editing here.  Since you can work more effectively if you're
	  more familiar with the capabilities of your command line
	  editing system, you might find it useful to do some further
	  reading.</para>

	<para>On Unix-like systems, &ghci; uses the <ulink
	    url="http://tiswww.case.edu/php/chet/readline/rltop.html#Documentation">GNU 
	    readline library</ulink>, which is powerful and
	  customisable.  On Windows, &ghci;'s command line editing
	  capabilities are provided by the <ulink
	    url="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx"><command>doskey</command> 
	    command</ulink>.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="hs.starting.calc">
    <title>Basic interaction: using ghci as a calculator</title>

    <para id="x_R1">In addition to providing a convenient interface
      for testing code fragments, &ghci; can function as a readily
      accessible desktop calculator. We can easily express any
      calculator operation in &ghci; and, as an added bonus, we can
      add more complex operations as we become more familiar with
      Haskell. Even using the interpreter in this simple way can help
      us to become more comfortable with how Haskell works.</para>

    <sect2 id="hs.starting.calc.arithmetic">
      <title>Simple arithmetic</title>

      <para id="x_S1">We can immediately start entering expressions,
	to see what &ghci; will do with them.  Basic arithmetic works
	similarly to familiar languages like C and Python: we write
	expression in <emphasis>infix</emphasis> form, where an
	operator appears between its operands.</para>
    
      &basics.ghci:arithmetic;

      <para>Operators are normal Haskell functions; the infix style of
	writing an expression is just a convenience.</para>

      <para id="x_T1">As the expressions above imply, Haskell has a notion of
	integers and floating point numbers.  In fact, it allows us to
	use arbitrarily large integers.  Here, the
	<function>(^)</function> is the integer exponentiation
	operator.</para>

      &basics.ghci:bignum;

      <note>
	<title>Why are there parentheses around operators?</title>

	<para>When we write an operator by itself, we'll usually
	  write it surrounded by parentheses, for example
	  <function>(+)</function>.  This is a standard Haskell way of
	  writing an operator as an ordinary function.</para>
      </note>
    </sect2>

    <sect2 id="hs.starting.calc.neg">
      <title>An arithmetic quirk: writing negative numbers</title>

      <para id="x_X1">Haskell presents us with one peculiarity in how we must
	write numbers: it's often necessary to enclose a negative
	number in parentheses.  This affects us as soon as we move
	beyond the simplest expressions.</para>

      <para>We'll start by writing a negative number.</para>

      &basics.ghci:neg.simple;

      <para>The <code>-</code> above is a unary operator.  In other
	words, we didn't write the single number <quote>-3</quote>; we
	wrote the number <quote>3</quote>, and applied the operator
	<code>-</code> to it.  The <code>-</code> operator is
	Haskell's only unary operator, and we can't mix it with infix
	operators.</para>

      &basics.ghci:neg.error;

      <para>If we want to use the unary minus near an infix operator,
	we must wrap the expression it applies to in
	parentheses.</para>

      &basics.ghci:neg.better;

      <para id="x_Z1"><emphasis>Most</emphasis> of the time, we can omit
	white space from expressions, and Haskell will parse them as we
	intended.  But not always.  Here's an expression that
	works:</para>

      &basics.ghci:whitespace.ok;

      <para id="x_a1">And here's one that seems similar to the
	problematic negative number example above, but results in a
	different error message.</para>

      &basics.ghci:whitespace.eek;

      <para id="x_b1">Here, the Haskell implementation is reading
	<literal>+-</literal> as a single operator.  Haskell lets us
	define new operators (a subject that we'll return to later),
	but we haven't defined this one.  Once again, a few
	parentheses get us and &ghci; looking at the expression in the
	same way.</para>

      &basics.ghci:whitespace.whew;

      <para id="x_c1">Compared to other languages, this unusual
	treatment of negative numbers might seem annoying, but it
	represents a reasoned trade-off.  Haskell lets us define new
	operators at any time.  This isn't some kind of esoteric
	language feature; we'll see quite a few user-defined operators
	in the chapters ahead. The language designers chose to accept
	a slightly cumbersome syntax for negative numbers in exchange
	for this expressive power.</para>
    </sect2>

    <sect2 id="hs.starting.calc.comparison">
      <title>Boolean logic, operators, and value comparisons</title>

      <para id="x_j1">The values of Boolean logic in Haskell are
	&True; and &False;.  The language uses C-influenced operators
	for working with Boolean values.</para>

      &basics.ghci:boolean;

      <para>Here, <function>(&amp;&amp;)</function> is logical
	<quote>and</quote>, and <function>(||)</function> is logical
	<quote>or</quote>.</para>

      <para id="x_k1">Unlike some other languages, Haskell does
	<emphasis>not</emphasis> treat the
	number zero as synonymous with <literal>False</literal>, nor
	does it consider any non-zero value to be <literal>True</literal>.</para>

      &basics.ghci:boolean.bad;

      <para>Once again, we're faced with a substantial-looking error
	message. It tells us that the Boolean type, <type>Bool</type>,
	is not a member of the family of numeric types,
	<code>Num</code>.  The error message is rather long because
	&ghci; is pointing out the location of the problem, and
	hinting at a possible change we could make that might fix the
	problem.</para>

      <para id="x_l1">Most of Haskell's comparison operators are
	similar to those used in C and languages influenced by
	C.</para>

      &basics.ghci:comparison;

      <para id="x_m1">There's one exception: the <quote>is not
	  equal to</quote> operator is <function>(/=)</function>
	(somewhat visually similar to the mathematical &notEqual;
	operator), not the <function>(!=)</function> you might expect
	from a language that borrows many other operators from
	C.</para>

      &basics.ghci:neq;

    </sect2>

    <sect2 id="hs.starting.calc.precedence">
      <title>Operator precedence and associativity</title>

      <para id="x_U1">Like other languages that use infix notation to
	write some expressions, Haskell has a notion of
	operator precedence.  We can use parentheses to explicitly
	group parts of an expression, and precedence allows us to
	omit a few parentheses. For example, the multiplication
	operator has a higher precedence than the addition operator,
	so Haskell treats the following two expressions as
	equivalent.</para>

      &basics.ghci:parens;

      <para>Haskell assigns numeric precedence values to operators,
	with 1 being the lowest precedence and 9 the highest.  A
	higher-precedence operator gets parsed before a
	lower-precedence operator.  We can use &ghci; to inspect the
	precedence levels of individual operators, using its
	<command>:type</command> command.</para>

      &basics.ghci:precedence;

      <para>Since <function>(*)</function> has a higher precedence
	than <function>(+)</function>, we can now see why <code>1 + 4
	  * 4</code> is parsed as <code>1 + (4 * 4)</code>, and not
	<code>(1 + 4) * 4</code>.</para>

      <para>Haskell also defines <emphasis>associativity</emphasis> of
	operators.  This determines whether an expression containing
	multiple uses of an operator is parsed from left to right, or
	right to left.  The <function>(+)</function> and
	<function>(*)</function> operators are left associative, which
	is represented as <code>infixl</code> in the &ghci; output
	above.  A right associative operator would be displayed with
	<code>infixr</code>.</para>

      <para>The combination of precedence and associativity rules are
	usually referred to as <emphasis>fixity</emphasis>
	rules.</para>
    </sect2>

    <sect2 id="hs.starting.calc.undef">
      <title>Undefined values, and introducing variables</title>

      <para id="x_d1">Haskell's prelude, the standard library we
	mentioned earlier, defines at least one well-known
	mathematical constant for us.</para>

      &basics.ghci:pi;

      <para id="x_e1">But its coverage of mathematical constants is not great,
	as we can quickly see.  Let's see if Euler's number,
	<varname>e</varname>, is available.</para>

      &basics.ghci:e;

      <para id="x_f1">Oh well.</para>

      <note>
	<title>Don't worry about the error message</title>

	<para id="x_g1">If the above <quote>not in scope</quote> error message
	  seems a little daunting, don't worry.  All it means is that
	  there is no variable defined with the name
	  <varname>e</varname>.</para>
      </note>

      <para id="x_h1">Using the &let; construct, we can define
	<varname>e</varname> ourselves.</para>

      &basics.ghci:let;

      <para id="x_i1">We can then use our definition of <varname>e</varname> in
	arithmetic expressions.</para>

      &basics.ghci:epipi;
      
      <warning>
	<title>This syntax is ghci-specific</title>

	<para>The syntax for &let; that &ghci; accepts is not the same
	  as we would use in a normal Haskell program.  We'll see the
	  normal syntax in <xref linkend="hs.funcstypes.locals"/>.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Navigating the thicket of fixity rules</title>

      <para id="x_V1">It's sometimes better to leave at least some
	parentheses in place, even when Haskell allows us to omit
	them.  Their presence can help future readers (including
	ourselves) to understand what we intended.</para>

      <para id="x_W1">Even more importantly, complex expressions that
	rely completely on operator precedence are notorious sources
	of bugs.  A compiler and a human can easily end up with
	different notions of what even a short, parenthesis-free
	expression is supposed to do.</para>

      <para>Here's a cautionary example of mixing different operators
	of the same fixities: <function>(*)</function> and
	<function>(/)</function>. The following two expressions give
	subtly different results.</para>

      &basics.ghci:grouping;

      <para>When deciding whether to use parentheses, you can probably
	rely on yourself and your readers to remember the language's
	precedence rules for the most common arithmetic and logical
	operators: <function>(||)</function> is <code>2</code>;
	<function>(&amp;&amp;)</function> is <code>3</code>;
	<function>(+)</function> and <function>(-)</function> are
	<code>6</code>; while <function>(*)</function> and
	<function>(/)</function> are <code>7</code>.  For
	associativities and for other operators, it's not often wise
	to assume that readers will remember the rules, so parentheses
	are often safest.</para>
    </sect2>

  </sect1>

  <sect1 id="hs.starting.errmsg">
    <title>Don't sweat those error messages</title>

    <para id="x_B2">Remember the point we made earlier about explicit
      parentheses often being good?  Here's an example of that idea in
      action, except here the parentheses are
      <emphasis>necessary</emphasis>, not merely a good idea.</para>

    &basics.ghci:denom.bad;

    <para id="x_C2">Look at that error message; it's detailed, and
      mentions a lot of concepts we haven't covered yet.  The best way
      to start dealing with it is to not worry early on about the
      details.  The error messages that &GHC; produces can be daunting
      to newcomers, but take heart.  As you become more familiar with
      Haskell, you'll acquire enough understanding to interpret error
      messages more easily.</para>

    <para id="x_D2">For now, however, we must make some kind of progress.
      If we step back and gloss over the error message, we can see
      that &ghci; is displaying for us the expression that it had
      trouble with.  And it has helpfully added parentheses back into
      the expression, only look!  <emphasis>They're in the wrong
	places.</emphasis></para>

    <para id="x_E2">This isn't the fault of &ghci;.  It just happens that the
      <function>(%)</function> and <function>(*)</function> operators
      have the same precedences, so &ghci; parses the expression from
      left to right.  As a result, it tries to construct a rational
      from another rational and an integer, instead of from a pair of
      integers.  (If <function>(%)</function> had a higher precedence
      than <function>(*)</function>, the expression would be parsed
      the way we might have hoped.)</para>

    <para id="x_F2">All we have to do to correct this problem is add some
      explicit parentheses to say what we really mean.</para>

    &basics.ghci:denom.good;

    <note>
      <title>Remain dauntless in the face of error messages</title>

      <para id="x_G2">The important lesson here is one that we'll be repeating
	over and over throughout the early sections of this book. If
	you run into problems, <emphasis>don't panic</emphasis>. You
	do not need to understand every little detail of what's going
	on.  Early on, all you have to do is figure out enough to make
	progress through a problem.  You don't need instantaneous
	complete understanding, so don't worry if you don't have
	it.  It will come.</para>

      <para>The numerous error messages have a purpose: they actually
	help us to write correct code, by making us perform some
	amount of debugging <quote>up front</quote>, before we ever
	run a program.  If you are coming from a background of working
	with more permissive languages, this way of working may come
	as something of a shock.  Bear with us.</para>
    </note>

  </sect1>

  <sect1 id="hs.starting.list">
    <title>Lists</title>

    <para id="x_K2">A list is surrounded by square brackets; the
      elements are separated by commas.</para>

    &basics.ghci:list;
    
    <note>
      <title>Commas are separators, not terminators</title>

      <para>Some languages permit the last element in a list to be
	followed by an optional trailing comma before a closing
	bracket, but Haskell doesn't allow this.  If you leave in a
	trailing comma, you'll get a parse error.</para>
    </note>

    <para id="x_L2">A list can be of any length.  The empty list is
      written <literal>[]</literal>.</para>

    &basics.ghci:list.shortlong;

    <para id="x_M2">All elements of a list must be of the same type.</para>

    &basics.ghci:list.bad;
    
    <para id="x_N2">Once again, &ghci;'s error message is verbose, but
      it's simply telling us that there is no way to turn the string
      into a number, so the list expression isn't properly typed.</para>

    <para id="x_O2">We can write a series of elements using range
      notation, and Haskell will fill in the contents of the list for
      us.</para>
    
    &basics.ghci:range;

    <para>Here, the <literal>..</literal> characters denote a
      range.  We can only use range notation for types we can count.
      Range notation makes no sense for rational numbers, for example,
      because there is not a countable number of rationals.</para>

    <para id="x_vK">By the way, notice that the above use of range
      notation gives us a <emphasis>closed interval</emphasis>; the
      list contains both endpoints.</para>

    <para id="x_P2">When we write a range, we can optionally specify
      the size of the step to use by giving the first two elements,
      followed by the value at which to stop generating the
      range.</para>

    &basics.ghci:range.step;

    <para id="x_wK">In the latter case above, the list is quite
      sensibly missing the end point of the range, because it isn't an
      element of the series we defined.</para>

    <para>We can omit the end point of a range.  If the type of the
      range has an upper bound on its values (or a lower bound if the
      step is negative), that bound will be the end point of the
      range.  Otherwise, the range will continue indefinitely.</para>

    <warning>
      <title>Beware ranges of floating point numbers</title>

      <para>Here's a non-intuitive bit of behaviour.</para>

      &basics.ghci:range.double;

      <para>Behind the scenes, the Haskell implementation is
	converting the floating point numbers into integers,
	enumerating the range as integers, then turning them back into
	floating point numbers.</para>

      <para>While this is peculiar, there's worse in store.  The range
	<literal>[0,0.1..1]</literal> steps in increments of 0.1
	between zero and one, but the number of elements in the list
	depends on the amount of rounding error in the
	implementation's representation of floating point numbers: you
	will <emphasis>probably</emphasis> get a list of eleven
	elements, but you <emphasis>might</emphasis> get ten.</para>

      <para>Because of these limitations, range notation over floating
	point numbers is not really safe to use.</para>
    </warning>

    <sect2 id="hs.starting.list.op">
      <title>Operators on lists</title>

      <para>There are two ubiquitous operators for working with
	lists.  We concatenate two lists using the
	<function>(++)</function> operator.</para>

      &basics.ghci:concat;

      <para>More basic is the <function>(:)</function> operator, which
	adds an element to the front of a list.  This is pronounced
	<quote>cons</quote> (short for
	<quote>construct</quote>).</para>

      &basics.ghci:concat;
    </sect2>

  </sect1>

  <sect1 id="hs.starting.string">
    <title>Strings and characters</title>

    <para id="x_H2">If you know a language like Perl or C, you'll find
      Haskell's notations for strings familiar.</para>

    <para id="x_I2">A text string is surrounded by double quotes.</para>

    &basics.ghci:string;

    <para id="x_J2">As in many languages, we can represent
      hard-to-print characters by <quote>escaping</quote> them.
      Haskell's escape characters and escaping rules follow the widely
      used conventions established by the C language.  For example,
      <literal>'\n'</literal> denotes a newline character, and
      <literal>'\t'</literal> is a tab character.  For complete
      details, see <xref linkend="hs.escapes"/>.</para>

    &basics.ghci:newline;
    
    <para id="x_Q2">Haskell makes a distinction between single characters and
      text strings.  A single character is enclosed in single
      quotes.</para>

    &basics.ghci:char;

    <para id="x_R2">In fact, a text string is simply a list of individual
      characters.  Here's a painful way to write a short string, which
      &ghci; gives back to us in a more familiar form.</para>

    &basics.ghci:work;

  </sect1>

  <sect1 id="hs.starting.types">
    <title>First steps with types</title>

    <para id="x_S2">While we've talked a little about types already,
      our interactions with &ghci; have so far been free of much
      type-related thinking.  We haven't told &ghci; what types we've
      been using, and it's mostly been willing to accept our
      input.</para>

    <para>Haskell requires type names to start with an uppercase
      letter, and variable names must start with a lowercase letter.
      Bear this in mind as you read on; it makes it much easier to
      read everything.</para>

    <para id="x_T2">The first thing we can do to start exploring the
      world of types is to get &ghci; to tell us more about what it's
      doing.  &ghci; has a command, <command>:set</command>, that lets
      us change a few of its default behaviours.  We can tell it to
      print more type information as follows.</para>

    &types.ghci:set_t_on;

    <para id="x_U2">What the <code>+t</code> does is tell &ghci; to print the
      type of an expression after  the expression.  That cryptic
      <varname>it</varname> in the output can be very useful: it's
      actually the name of a special variable, in which &ghci; stores
      the result of the last expression we evaluated.  Let's break
      down the meaning of the last line of &ghci; output.</para>
      
    <itemizedlist>
      <listitem>
	<para id="x_V2">It's telling us about the variable
	  <varname>it</varname>.</para>
      </listitem>
      <listitem>
	<para id="x_W2">We can read text of the form <code>x ::
	    y</code> as meaning <quote>the expression <code>x</code>
	    has the type <code>y</code></quote>.</para>
      </listitem>
      <listitem>
	<para id="x_X2">Here, the expression <quote>it</quote> has the
	  type <type>[Char]</type>.</para>
      </listitem>
    </itemizedlist>

    <tip id="hs.starting.it">
      <title>The joy of <quote>it</quote></title>

      <para id="x_Y2">That <varname>it</varname> variable is wonderfully handy
	when we want to use the result of a prior expression in a new
	expression.</para>

      &types.ghci:it;

      <para id="x_Z2">When evaluating an expression, &ghci; won't
	change your environment if the evaluation fails.  A successful
	evaluation will only change either the variable you specify,
	or <varname>it</varname> if you didn't name a variable to
	change.  This lets you write potentially bogus expressions
	with something of a safety net.</para>

      &types.ghci:it.bad;

      <para id="x_a2">Couple <varname>it</varname> with liberal use of the
	arrow keys to recall and edit the last expression we typed,
	and we have a fairly decent environment for interactive
	experiments, where the cost of mistakes is very low.  Take
	advantage of the opportunity to make cheap, plentiful mistakes
	when you're exploring the language!</para>
    </tip>

    <para id="x_b2">Here are a few more of Haskell's names for types, from
      expressions of the sort we've already seen.</para>

      &types.ghci:integer;

    <para id="x_c2">Haskell's unbounded integral type is named
      <type>Integer</type> .</para>

    <para id="x_e2">Rational numbers don't look quite the same as
      integers.</para>

    &types.ghci:ratio;

    <para id="x_f2">Notice <emphasis>two</emphasis> words on the right
      hand side of the <code>::</code> above.  We can read this as a
      <quote><type>Ratio</type> of <type>Integer</type></quote>.  We
      might infer that a <type>Ratio</type> must need to have values
      of type <type>Integer</type> as both numerator and denominator.
      Sure enough, if we try to construct a <type>Ratio</type> where
      the numerator and denominator are of different types, or of the
      same non-integral type, &ghci; complains.</para>

    &types.ghci:ratio.bad;

    <para id="x_g2">Although it's initially useful to have
      <userinput>:set +t</userinput> giving us type information for
      every expression we enter, this is a facility we'll quickly
      outgrow: after a while, we'll often know what type we expect an
      expression to have.  We can turn off the extra type information
      at any time, using the <command>:unset</command> command.</para>

    &types.ghci:set_t_off;
    
    <para id="x_h2">Even with this facility turned off,  we can still get that
      type information easily when we need it, using another &ghci;
      command.</para>

    &types.ghci:type;

    <para id="x_i2">The <command>:type</command> command will print type
      information for any expression we give it (including
      <varname>it</varname>, as we see above).  It won't actually
      evaluate the expression; it only checks its type and prints
      that.</para>

    <sect2 id="hs.starting.types.exercises">
      <title>Exercises</title>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_j2">Foo?</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="hs.starting.conclusion">
    <title>Conclusion</title>

    <para id="x_k2">In this chapter, we've seen how to install &GHC; for our
      environment.  We then went on to interactively explore some
      basic Haskell concepts using &ghci;, the interpreter bundled with
      &GHC;.  We saw how to evaluate simple expressions.</para>

    <para id="x_l2">We dipped a toe into the water of typing.</para>
    <para id="x_m2">We also had drilled into us the notion that we don't need to
      understand, or be intimidated by, every single gripe that &ghci;
      throws our way.  We'll do just fine with a shallow understanding
      initially, and rely on practice and more reading to round out
      our knowledge.  Onwards!</para>

  </sect1>
</chapter>


<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
