<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.starting">
  <title>Getting Started</title>

  <sect1 id="hs.starting.ghc">
    <title>Your Haskell environment</title>

    <para>There's a number of Haskell implementations available, of
      which two are in wide use.  Hugs 98 is an interpreter that is
      primarily used for teaching.  For real applications, the Glasgow
      Haskell Compiler, or &GHC; as it's usually known, is much more
      popular.</para>

    <para>&GHC; has two complementary components: &ghc;, a compiler
      that generates native code, and &ghci;, an interpreter that can
      run either interactively or in <quote>batch</quote> mode.</para>

    <note>
      <para>When we discuss the package as a whole, we'll refer to it
	as &GHC;.  If we're talking about one or another command,
	we'll mention either &ghc; or &ghci;.</para>
    </note>

    <para>In this book, we assume that you're using at least version
      6.6.1 of &GHC;.  To obtain a copy of &GHC; for your platform,
      visit <ulink url="http://www.haskell.org/ghc/download.html">the
	&GHC; download page</ulink>, and look for the list of binary
      packages.  If you're using Windows or Mac OS X, these binary
      packages are the best ones to use.</para>

    <para>Many Linux distributions, and BSD and other Unix variants,
      make pre-packaged versions of &GHC; available.  Because they are
      built specifically for each environment, these packages are less
      hassle to use than the generic binary packages. You can find a
      list of such packages at the &GHC; <ulink
	url="http://www.haskell.org/ghc/distribution_packages.html">distribution 
	packages</ulink> page.</para>

  </sect1>

  <sect1>
    <title>Installing GHC on your platform</title>

    <para>We are providing the instructions below based on our
      experience installing &GHC; in mid-2007.  Installation
      instructions inevitably become dated quickly; please bear this
      in mind as you read.</para>

    <para>Because &GHC; runs on a large number of platforms, we've
      focused on a handful of the most popular.</para>

    <sect2>
      <title>Windows</title>

      <para>The prebuilt binary packages of &GHC; should work on
	versions of Windows as old as ME, and on all newer versions
	(NT, 2000, XP, and Vista).  We have installed &GHC; 6.6.1
	under Windows XP Service Pack 2; here are the steps we
	followed.</para>

      <note>
	<para>On Windows, &GHC; requires almost 340MB of disk
	  space.</para>
      </note>
  
      <para>Our first step is to visit the &GHC; <ulink
	  url="http://www.haskell.org/ghc/download.html">download
	  page</ulink>, and follow the link to the current stable
	release.  Scroll down to the section entitled <quote>Binary
	  packages</quote>, and then again to the subsection for
	Windows.  Download the installer; in our case, it's named
	<filename>ghc-6.6.1-i386-windows.exe</filename>.</para>

      <informalfigure>
	<graphic fileref="figs/win32-download.png"/>
      </informalfigure>

      <para>After the installer has downloaded, double-clicking on it
	starts the installation process.  This simply involves
	stepping through a normal Windows installer wizard.</para>

      <informalfigure>
	<graphic fileref="figs/win32-wizard1.png"/>
      </informalfigure>

      <para>Once the installer has finished, the Start Menu's
	<quote>All Programs</quote> submenu should have a &GHC;
	folder, inside of which you'll find an icon that you can
	double-click on to run &ghci;.</para>

      <informalfigure>
	<graphic fileref="figs/win32-start-menu.png"/>
      </informalfigure>

      <para>Clicking on the &ghci; icon brings up a normal Windows
	console window, running &ghci;.</para>

      <informalfigure>
	<graphic fileref="figs/win32-ghci.png"/>
      </informalfigure>

      <note>
	<para>The &GHC; installer automatically modifies your user
	  account's <envar>PATH</envar> environment variable so that
	  commands like &ghc; will be present in the command shell's
	  search path (i.e. you can type a &GHC; command name without
	  typing its complete path).  This change will not take effect
	  until you log out and back in again.</para>
      </note>
    </sect2>

    <sect2>
      <title>Mac OS X</title>

      <para>Installing &GHC; on Mac OS X takes several steps, as &GHC;
	does not yet have a standard OS X installer.  We have
	installed &GHC; 6.6.1 under Mac OS X 10.4, on an Intel-based
	MacBook.  We're not regular Mac users, and had never tried
	installing &GHC; on OS X before, and everything worked for us
	on the first try, so take heart if these instructions seem
	daunting.  The process is neither difficult nor especially
	time-consuming.</para>

      <para>Our first step is to visit the &GHC; <ulink
	  url="http://www.haskell.org/ghc/download.html">download
	  page</ulink>, and follow the link to the current stable
	release.  Scroll down to the section entitled <quote>Binary
	  packages</quote>, and then again to the subsection for Mac
	OS X.  There are four components to download, all of which
	are necessary.</para>

      <itemizedlist>
	<listitem>
	  <para>Apple's Xcode development software.  This provides
	    compiler toolchain support that &GHC; needs.</para>
	</listitem>
	<listitem>
	  <para>The <filename>GNUreadline</filename> framework
	    provides flexible command line editing.</para>
	</listitem>
	<listitem>
	  <para>The <filename>GMP</filename> framework is required for
	    arbitrary-precision integer support.</para>
	</listitem>
	<listitem>
	  <para>The &GHC; package itself.  This will not work unless
	    both of the preceding frameworks are installed.</para>
	</listitem>
      </itemizedlist>

      <para>The Xcode software installer may have come bundled on a
	DVD with your Mac.  If not (or you can't find it), you can
	download it from Apple and install it.  Once you've finished
	installing Xcode, continue on to download the remaining three
	packages.</para>

      <para>After these downloads complete, you'll have three archive
	icons on your desktop.</para>

      <informalfigure>
	<graphic fileref="figs/osx-archives.png"/>
      </informalfigure>

      <para>Double click on each one to unpack it, giving you three
	folders.</para>

      <informalfigure>
	<graphic fileref="figs/osx-folders.png"/>
      </informalfigure>

      <para>Open a <application>Finder</application> window with
	<keycombo>
	  <keycap function="command">command</keycap>
	  <keycap>n</keycap>
	</keycombo>.  In the left sidebar, click on your system's main
	hard disk icon (often named <quote>Macintosh HD</quote>).  In
	the main portion of the window, double click on
	<filename>System</filename> to open that folder, then on
	<filename>Library</filename>.  Select the
	<filename>GMP.framework</filename> and
	<filename>GNUreadline.framework</filename> folders on your
	desktop, and drag them onto the
	<filename>Frameworks</filename> folder in the Finder window
	that is visiting <filename>/System/Library</filename>.  If the
	Finder refuses to install them because you don't have
	permission, it will probably display an
	<quote>Authenticate</quote> button in the alert it displays.
	Click it, enter your password, and installation can
	proceed.</para>

      <informalfigure>
	<graphic fileref="figs/osx-folders.png"/>
      </informalfigure>

      <para>With the prerequisites in place, you can turn to
	installing &GHC;. You'll need to open a &Terminal; window (you
	can find it in
	<filename>/Applications/Utilities</filename>).</para>

      <note>
	<para>Since most of your interactions with &GHC; will be
	  through a &Terminal; window, this might be a good time to
	  add the &Terminal; application to your dock, if you haven't
	  already done so.</para>
      </note>

      <informalfigure>
	<graphic fileref="figs/osx-ghc-install.png"/>
      </informalfigure>

      <para>Inside the &Terminal; window, change directory to
	<filename>Desktop/ghc-6.6.1</filename>, and run
	<userinput>./configure</userinput> to set up the command line
	installer.  This configures &GHC; to install to
	<filename>/usr/local</filename>.  When the
	<command>configure</command> script finishes, run
	<userinput>sudo make install</userinput>, and type your
	password when you are prompted for it.</para>

      <para>The installation process should take a minute or
	two.  If you don't already have
	<filename>/usr/local/bin</filename> in your shell's search
	path, add it.</para>

      <para>Finally, you should be able to successfully run the &ghci;
	command from your shell prompt.</para>

      <informalfigure>
	<graphic fileref="figs/osx-ghci.png"/>
      </informalfigure>

    </sect2>

    <sect2>
      <title>Ubuntu and Debian Linux</title>
      
      <remark>FIXME: actual content.</remark>
    </sect2>

    <sect2>
      <title>Fedora Linux</title>
      
      <para>&GHC; is packaged for Fedora.  From a shell, all you need
	to do is run <userinput>sudo yum -y install ghc ghc-doc
	  ghc661-prof</userinput>.  The base package, containing the
	&ghc; and &ghci; commands and libraries, is
	<filename>ghc</filename>.  The <filename>ghc-doc</filename>
	package contains the &GHC; user guide, and command and library
	documentation.  The <filename>ghc661-prof</filename> package
	contains profiling-capable versions of the standard libraries
	(note: its version number may have changed by the time you
	read this).</para>

      <para>Once installation has finished, you should be able to run
	&ghci; from the shell immediately.  You won't need to change
	your shell's search path, or set any environment
	variables.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.starting.ghci">
    <title>Getting started with ghci, the interpreter</title>

    <para>The interactive interpreter for &GHC; is a program named
      &ghci;.  It lets you enter and evaluate Haskell expressions, and
      explore modules and type information.</para>

    <para>When we run &ghci;, it displays a startup banner, followed
      by a <prompt>Prelude&gt;</prompt> prompt.</para>

    <screen>
<prompt>$</prompt> <userinput>ghci</userinput>
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.6.1, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.

Loading package base ... linking ... done.
<prompt>Prelude&gt;</prompt>
</screen>

    <note>
      <para>The prompt displayed by &ghci; changes depending on what
	we're doing, and can often grow long enough to leave little
	visual room on a single line for our input.  For brevity, we
	have replaced &ghci;'s default prompts throughout this book
	with the prompt string <prompt>ghci&gt;</prompt>.</para>
    </note>

    <sect2>
      <title>Command line editing</title>

      <para>On most systems, &ghci; has some amount of command line
	editing ability.  On Unix-like systems, it uses the GNU
	readline library, which is powerful and customisable.  On
	Windows, &ghci;'s command line editing capabilities are
	provided by the <command>doskey</command> command.</para>

      <para>If you haven't used command line editing before, it's a
	huge time saver.  The basics are common to both Unix-like and
	Windows systems.  Pressing the <keycap
	  function="up">up</keycap> arrow key on your keyboard recalls
	the last line of input you entered; pressing <keycap
	  function="up">up</keycap> repeatedly cycles through earlier
	lines of input. You can use the <keycap
	  function="left">left</keycap> and <keycap
	  function="right">right</keycap> arrow keys to move around
	inside a line of input.</para>

      <para>Just knowing this much will save you a lot of repeated
	typing.  If you want to learn more about command line editing
	on your system, consult the readline or
	<command>doskey</command> documentation.</para>
    </sect2>

  </sect1>

  <sect1>
    <title>Basic interaction: using ghci as a calculator</title>

    <para>Where some people might run a calculator program, I often
      drop into &ghci; to perform simple calculations.  Using it this
      way serves as a good way to become familiar with &ghci; itself,
      and with the basics of Haskell expressions.</para>

    <sect2>
      <title>Simple arithmetic</title>

      <para>We can immediately start typing expressions, to see what
	&ghci; will do with them.  Basic arithmetic works as we'd
	expect.</para>
    
      &basics.ghci:arithmetic;

      <para>As the expressions above imply, Haskell has a notion of
	integers and floating point numbers.  In fact, it allows us to
	use arbitrarily large integers.  Here, the
	<function>(^)</function> is the exponentiation
	operator.</para>

      &basics.ghci:bignum;

      <para>Like other languages that use infix notation to write
	mathematical expressions, Haskell has a notion of operator
	precedence.  This allows us to get rid of a few parentheses.
	For example, the multiplication operator has a higher
	precedence than the addition operator, so Haskell treats the
	two following expressions as equivalent.</para>

      &basics.ghci:parens;

      <note>
	<para>As in other languages, it's often better to leave at
	  least some parentheses in place, even when Haskell allows us
	  to omit them.  Their presence can help future readers
	  (including ourselves) to understand what we intended.</para>

	<para>Even more importantly, complex expressions that rely on
	  operator precedence are notorious sources of bugs.  A
	  compiler and a human can easily end up with different
	  notions of what a long, parenthesis-free expression is
	  supposed to do.</para>
      </note>
    </sect2>

    <sect2>
      <title>An arithmetic quirk: writing negative numbers</title>

      <para>Haskell presents us with one peculiarity in how we must
	write numbers: it's often necessary to enclose a negative
	number in parentheses.  This affects us as soon as we move
	past writing the simplest of expressions.</para>

      &basics.ghci:neg;

      <para>Later on, we'll be seeing how Haskell lets us devise
	entirely new infix operators.  Now that we've been forewarned,
	the following may not prove too surprising.</para>

      <para><emphasis>Most</emphasis> of the time, we can omit
	whitespace from expressions, and Haskell will parse them as we
	intended.  But not always.  Here's an expression that
	works:</para>

      &basics.ghci:whitespace.ok;

      <para>And here's one that similar to the problematic negative
	number example above, but results in a different error
	message.</para>

      &basics.ghci:whitespace.eek;

      <para>What's happening here is that the Haskell parser is
	reading <literal>+-</literal> as a single token, and trying to
	use it as an operator.  Once again, parentheses save the
	day.</para>

      &basics.ghci:whitespace.whew;

      <para>Compared to other languages, this unusual treatment of
	negative numbers is an annoyance, for sure, but it at least
	represents a reasoned tradeoff.  As we mentioned, Haskell lets
	us define new operators at any time, and choose the precedence
	and associativity of those operators.  The language designers
	chose to accept a slightly cumbersome syntax for negative
	numbers in exchange for this expressive power.</para>
    </sect2>

    <sect2>
      <title>Undefined values, and introducing variables</title>

      <para>&ghci; defines at least one well-known mathematical
	constant for us.</para>

      &basics.ghci:pi;

      <para>But its coverage of mathematical constants is not great,
	as we can quickly see.  Let's see if Euler's number,
	<varname>e</varname>, is available.</para>

      &basics.ghci:e;

      <para>Oh well.</para>

      <note>
	<para>If the above <quote>not in scope</quote> error message
	  seems a little daunting, don't worry.  All it means is that
	  there is no variable defined with the name
	  <varname>e</varname>.</para>
      </note>

      <para>We can define <varname>e</varname> ourselves; the &let;
	construct allows us to introduce a new variable.</para>

      &basics.ghci:let;

      <para>We can then use our definition of <varname>e</varname> in
	arithmetic expressions.</para>

      &basics.ghci:epipi;

    </sect2>

    <sect2>
      <title>Comparison and boolean operators</title>

      <para>Haskell gives us the usual operators for working with
	boolean values.</para>

      &basics.ghci:boolean;

      <para>Unlike some other languages, Haskell does not treat the
	number zero as synonymous with <literal>False</literal>, nor
	does it accept non-zero as <literal>True</literal>.</para>

      &basics.ghci:boolean.bad;

      <para>Comparison operators are mostly familiar from other
	languages.</para>

      &basics.ghci:comparison;

      <para>There's one exception: the <quote>is not equal</quote>
	operator is <function>(/=)</function>.</para>

      &basics.ghci:neq;

    </sect2>

    <sect2>
      <title>Rational numbers, the Haskell prelude, and modules</title>

      <para>In addition to integers and floating point numbers,
	Haskell supports rational numbers.  Haskell coders collect
	self-contained hunks of code into
	<emphasis>modules</emphasis>.  The integer and floating point
	numbers, and the operators we've seen so far, are packaged in
	a module named <classname
	  role="module">Prelude</classname>.</para>

      <para>(The <classname role="module">Prelude</classname> module
	is often referred to as <quote>the standard prelude</quote>,
	because its contents are defined by the Haskell 98 standard.
	Sometimes, it's simply shortened to <quote>the
	  prelude</quote>.)</para>

      <para>The prelude is always implicitly available; we don't need
	to take any actions to use the types, values, or functions it
	defines.  But to use definitions from other modules, we must
	<emphasis>import</emphasis> them.  To use rational numbers,
	the module we need to import is named <classname
	  role="module">Data.Ratio</classname>.  We can use a &ghci;
	directive named <userinput>:module</userinput> to import
	it.</para>

      &basics.ghci:module;

      <para>The notation for writing a rational number is as
	follows.</para>

      &basics.ghci:ratio;

      <para>The <function>(%)</function> operator above takes two
	integers and constructs a rational number from them.</para>

      <para>Arithmetic on rational numbers works in the same way as on
	other types of number, even allowing the same
	operators.</para>
      
      &basics.ghci:ratarith;
      
      <para>Haskell represents a rational number with the lowest
	denominator it can.  For example, the result of the following
	expression is simplified from <literal>254%7</literal> to
	something easier to read.</para>

      &basics.ghci:denom;

    </sect2>

    <sect2>
      <title>Aside: the faces of exponentiation</title>

      <remark>Is it too early to introduce this?  Does it disrupt the
	flow?</remark>

      <para>We've already seen an exponentiation operator in Haskell:
	<function>(^)</function> raises a number to an integer power.
	The word <emphasis>integer</emphasis> is significant here: if
	we try to raise a number to the power of a floating point
	number using the <function>(^)</function> operator, exciting
	things will happen.</para>

      &basics.ghci:intpower;

      <para>Notice from the second example that it doesn't matter
	whether or not the base is an integer, only that the exponent
	must be.</para>

      <para>There's a further constraint on the exponent that is not
	immediately obvious: it must be not just an integer, but a
	<emphasis>non-negative</emphasis> integer.</para>

      &basics.ghci:exponent.bad;

      <para>If you think about the simplest definition of
	exponentiation, which is a number repeatedly multiplied by
	itself a given number of times, this restriction makes
	sense.</para>

      <para>Haskell's exponentiation operator follows the convention
	that a number raised to the zeroth power is one.  This is why
	the restriction on the exponent is that it must be
	non-negative, and not that it must be positive.</para>

      &basics.ghci:exponent.zero;

      <para>Haskell also provides a generalised integer exponentiation
	operator, <function>(^^)</function>.  This accepts both
	positive and negative exponents, following the rule that a
	number raised to a negative exponent is the reciprocal of the
	number raised to the positive exponent.  Let's try this with
	both integer and rational bases.</para>

      &basics.ghci:exponent.neg;
      
      <para>Finally, Haskell also gives us a floating point
	exponentiation operator, <function>(**)</function>.</para>

      &basics.ghci:exponent.float;

    </sect2>
  </sect1>

  <sect1>
    <title>Don't sweat those error messages</title>

    <para>Remember the point we made earlier about explicit
      parentheses often being good?  Here's an example of that idea in
      action, except here the parentheses are
      <emphasis>necessary</emphasis>, not merely a good idea.</para>

    &basics.ghci:denom.bad;

    <para>Look at that error message; it's detailed, and mentions a
      lot of concepts we haven't covered yet.  We're new to Haskell!
      How are we supposed to interpret all of that?  The first thing
      we must do is take a deep breath and not worry about the
      details.</para>

    <para>If we step back and gloss over the error message, we can see
      that &ghci; is displaying for us the expression that it had
      trouble with.  And it has helpfully added parentheses back into
      the expression, only look!  <emphasis>They're in the wrong
	places</emphasis></para>

    <para>This isn't the fault of &ghci;.  It just happens that the
      <function>(%)</function> and <function>(*)</function> operators
      have the same precedences, so &ghci; parses the expession from
      left to right.  As a result, it tries to construct a rational
      from another rational and an integer, instead of from a pair of
      integers.  (If <function>(%)</function> had a higher precedence
      than <function>(*)</function>, the expression would be parsed
      the way we might have hoped.)</para>

    <para>All we have to do to correct this problem is add some
      explicit parentheses to say what we really mean.</para>

    &basics.ghci:denom.good;

    <note>
      <para>The important lesson here is one that we'll be repeating
	over and over throughout the early sections of this book. If
	you run into problems, <emphasis>don't panic</emphasis>. You
	do not need to understand every little detail of what's going
	on.  Early on, all you have to do is figure out enough to make
	progress through a problem.  You don't need instantaneous
	complete understanding, so don't worry if you don't have
	it.</para>
    </note>

  </sect1>

  <sect1>
    <title>Text, strings and lists</title>

    <para>If you are familiar with a language like Python, you'll find
      Haskell's notations for strings, lists and tuples
      familiar.</para>

    <para>A text string is surrounded by double quotes.</para>

    &basics.ghci:string;

    <para>As in many languages, we can represent hard-to-print
      characters by <quote>escaping</quote> them.  Haskell's escape
      characters and escaping rules expand on the conventions
      established by the C language (for details, see
      <xref linkend="hs.escapes"/>).</para>

    &basics.ghci:newline;
    
    <para>A list is surrounded by square brackets, with elements
      separated by commas.</para>

    &basics.ghci:list;

    <para>A list can be any length.</para>

    &basics.ghci:list.shortlong;

    <para>All elements of a list must have the same type.</para>

    &basics.ghci:list.bad;
    
    <para>Once again, &ghci;'s error message is verbose, but it's
      simply telling us that it can't figure out how to turn the
      string into a number, so the list isn't properly typed.</para>
    
    <para>When it makes sense to do so, we can write a range of
      elements, and Haskell will fill in the contents of the list for
      us.</para>
    
    &basics.ghci:range;

    <para>We can specify the size of the step to use by giving the
      first two elements, followed by the value at which to stop
      generating the range.</para>

    &basics.ghci:range.step;

    <para>Haskell makes a distinction between single characters and
      text strings.  A single character is enclosed in single
      quotes.</para>

    &basics.ghci:char;

    <para>In fact, a text string is simply a list of individual
      characters.  Here's a painful way to write a short
      string.</para>

    &basics.ghci:work;

  </sect1>

  <sect1 id="hs.starting.functions">
    <title>Haskell Programs: Source Files and Functions</title>
    <remark>FIXME: What Haskell source files look like.  How to write a simple
  function.  Hey, functions look different from traditional languages!
  How to get ghci to load the source file; using the definitions from
  it.
    </remark>
  </sect1>

  <sect1 id="hs.starting.types">
    <title>Types</title>
    <remark>FIXME: 
  Introduce types.  Use ghci to inspect the types of a few values and
  functions.  Describe what the "->" means.  Note the difference in
  case between the first character of types and functions/values.
  Take the type information ghci gave us; put it in the source file;
  reload.  Notice that ghci is still happy.
    </remark>
  </sect1>
</chapter>


<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
