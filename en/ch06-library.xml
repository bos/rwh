<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="library">
  <title>Writing a library: working with JSON data</title>

  <sect1>
    <title>A whirlwind tour of JSON</title>

    <para id="x_Fi">In this chapter, we'll develop a small, but
      complete, Haskell library.  Our library will manipulate and
      serialize data in a popular form known as JSON.</para>

    <para id="x_Gi">The JSON (JavaScript Object Notation) language is
      a small, simple representation for storing and transmitting
      structured data, for example over a network connection.  It is
      most commonly used to transfer data from a web service to a
      browser-based JavaScript application.  The JSON format is
      described at <ulink
	url="http://www.json.org/">www.json.org</ulink>, and in
      greater detail by <ulink
	url="http://www.ietf.org/rfc/rfc4627.txt">RFC
	4627</ulink>.</para>

    <para id="x_Hi">JSON supports four basic types of value: strings,
      numbers, booleans, and a special value named
      <code>null</code>.</para>

    <programlisting><![CDATA["a string" 12345 true
      null]]></programlisting>

    <para id="x_Ii">The language provides two compound types: an
      <emphasis>array</emphasis> is an ordered sequence of values, and
      an <emphasis>object</emphasis> is an unordered collection of
      name/value pairs.  The names in an object are always strings;
      the values in an object or array can be of any type.</para>

    <programlisting><![CDATA[[-3.14, true, null, "a string"]
      {"numbers": [1,2,3,4,5], "useful": false}]]></programlisting>
  </sect1>

  <sect1 id="library.jvalue">
    <title>Representing JSON data in Haskell</title>

    <para id="x_Ji">To work with JSON data in Haskell, we use an
      algebraic data type to represent the range of possible JSON
      types.</para>

    &SimpleJSON.hs:JValue;

    <para id="x_Ki">For each JSON type, we supply a distinct value
      constructor. Some of these constructors have parameters: if we
      want to construct a JSON string, we must provide a
      <type>String</type> value as an argument to the
      <code>JString</code> constructor.</para>

    <para id="x_Li">To start experimenting with this code, save the
      file <filename>SimpleJSON.hs</filename> in your editor, switch
      to a &ghci; window, and load the file into &ghci;.</para>

    &simplejson.ghci:load;

    <para id="x_Mi">We can see how to use a constructor to take a
      normal Haskell value and turn it into a <type>JValue</type>.  To
      do the reverse, we use pattern matching.  Here's a function that
      we can add to <filename>SimpleJSON.hs</filename> that will
      extract a string from a JSON value for us.  If the JSON value
      actually contains a string, our function will wrap the string
      with the <code>Just</code> constructor.  Otherwise, it will
      return <code>Nothing</code>.</para>

    &SimpleJSON.hs:getString;

    <para id="x_Ni">When we save the modified source file, we can
      reload it in &ghci; and try the new definition.  (The
      <command>:reload</command> command remembers the last source file
      we loaded, so we do not need to name it explicitly.)</para>

    &simplejson.ghci:reload;

    <para id="x_Oi">A few more accessor functions, and we've got a
      small body of code to work with.</para>

    &SimpleJSON.hs:getters;

    <para>The <function>truncate</function> function turns a floating
      point or rational number into an integer by dropping the digits
      after the decimal point.</para>

    &simplejson.ghci:truncate;

  </sect1>

  <sect1 id="library.anatomy">
    <title>The anatomy of a Haskell module</title>

    <para id="x_Pi">A Haskell source file contains a definition of a
      single <emphasis>module</emphasis>.  A module lets us determine
      which names inside the module are accessible from other
      modules.</para>

    <para id="x_Qi">A source file begins with a <emphasis>module
	declaration</emphasis>.  This must precede all other
      definitions in the source file.</para>

    &SimpleJSON.hs:module;

    <para id="x_Ri">The word <code>module</code> is reserved.  It is
      followed by the name of the module, which must begin with a
      capital letter. A source file must have the same <emphasis>base
	name</emphasis> (the component before the suffix) as the name
      of the module it contains. This is why our file
      <filename>SimpleJSON.hs</filename> contains a module named
      <code>SimpleJSON</code>.</para>

    <para id="x_Si">Following the module name is a list of
      <emphasis>exports</emphasis>, enclosed in parentheses.  The
      <code>where</code> keyword indicates that the body of the module
      follows.</para>

    <para id="x_Ti">The list of exports indicates which names in this
      module are visible to other modules.  This lets us keep
      private code hidden from the outside world. The special notation
      <code>(..)</code> that follows the name <code>JValue</code>
      indicates that we are exporting both the type and all of its
      constructors.</para>

    <para id="x_Ui">It might seem strange that we can export a type's
      name (i.e. its type constructor), but not its value
      constructors.  The ability to do this is important: it lets us
      hide the details of a type from its users, making the type
      <emphasis>abstract</emphasis>.  If we cannot see a type's value
      constructors, we cannot pattern match against a value of that
      type, nor can we construct a new value of that type.  Later in
      this chapter, we'll discuss some situations in which we might
      want to make a type abstract.</para>

    <para id="x_Vi">If we omit the exports (and the parentheses that
      enclose them) from a module declaration, every name in the
      module will be exported.</para>

    &Exporting.hs:ExportAll;
    
    <para>To export no names at all (which is rarely useful), we write
      an empty export list using a pair of parentheses.</para>

    &Exporting.hs:ExportNone;

  </sect1>

  <sect1>
    <title>Compiling Haskell source</title>

    <para id="x_Wi">In addition to the &ghci; interpreter, the &GHC;
      distribution includes a compiler, &ghc;, that generates native
      code.  If you are already familiar with a command line compiler
      such as <command>gcc</command> or <command>cl</command> (the C++
      compiler component of Microsoft's Visual Studio), you'll
      immediately be at home with &ghc;.</para>

    <para id="x_Xi">To compile a source file, we first open a terminal
      or command prompt window, then invoke &ghc; with the name of the
      source file to compile.</para>

    <programlisting><userinput>ghc -c SimpleJSON.hs</userinput></programlisting>

    <para id="x_Yi">The <option>-c</option> option tells &ghc; to only
      generate object code.  If we were to omit the
      <option>-c</option> option, the compiler would attempt to
      generate a complete executable.  That would fail, because we
      haven't written a <function>main</function> function, which
      &GHC; calls to start the execution of a standalone
      program.</para>

    <para id="x_Zi">After &ghc; completes, if we list the contents of
      the directory, it should contain two new files:
      <filename>SimpleJSON.hi</filename> and
      <filename>SimpleJSON.o</filename>.  The former is an
      <emphasis>interface file</emphasis>, in which &ghc; stores
      information about the names exported from our module in
      machine-readable form.  The latter is an <emphasis>object
	file</emphasis>, which contains the generated machine
      code.</para>
  </sect1>

  <sect1>
    <title>Generating a Haskell program, and importing modules</title>

    <para id="x_ai">Now that we've successfully compiled our minimal
      library, we'll write a tiny program to exercise it.  Create the
      following file in your text editor, and save it as
      <filename>Main.hs</filename>.</para>

    &Main.hs:module;

    <para id="x_bi">Notice the <code>import</code> directive that
      follows the module declaration.  This indicates that we want to
      take all of the names that are exported from the
      <code>SimpleJSON</code> module, and make them available in our
      module.  Any <code>import</code> directives must appear in a
      group at the beginning of a module.  They must appear after the
      module declaration, but before all other code.  We cannot, for
      example, scatter them throughout a source file.</para>

    <para id="x_ci">Our choice of naming for the source file and
      function is deliberate.  To create an executable, &ghc;
      expects a module named <code>Main</code> that contains a
      function named <function>main</function>.  The
      <function>main</function> function is the one that will be
      called when we run the program once we've built it.</para>

    <programlisting><userinput>ghc -o simple Main.hs SimpleJSON.o</userinput></programlisting>

    <para id="x_di">This time around, we're omitting the
      <option>-c</option> option when we invoke &ghc;, so it will
      attempt to generate an executable.  The process of generating an
      executable is called <emphasis>linking</emphasis>.  As our
      command line suggests, &ghc; is perfectly able to both compile
      source files and link an executable in a single
      invocation.</para>

    <para id="x_ei">We pass &ghc; a new option,
      <option>-o</option>, which takes one argument: this is the name
      of the executable that &ghc; should create<footnote>
	<para>Memory aid: <option>-o</option> stands for
	  <quote>output</quote> or <quote>object file</quote>.</para>
      </footnote>.  Here, we've decided
      to name the program <filename>simple</filename>.  On Windows,
      the program will have the suffix <filename>.exe</filename>, but
      on Unix variants there will not be a suffix.</para>

    <para id="x_fi">Finally, we supply the name of our new source
      file, <filename>Main.hs</filename>, and the object file we
      already compiled, <filename>SimpleJSON.o</filename>.  We must
      explicitly list every one of our files that contains code that
      should end up in the executable.  If we forget a source or
      object file, &ghc; will complain about <emphasis>undefined
	symbols</emphasis>, which indicates that some of the
      definitions that it needs are not provided in the files we have
      supplied.</para>

    <para id="x_gi">When compiling, we can pass &ghc; any mixture of
      source and object files.  If &ghc; notices that it has already
      compiled a source file into an object file, it will only
      recompile the source file if we've modified it.</para>

    <para id="x_hi">Once &ghc; has finished compiling and linking our
      <filename>simple</filename> program, we can run it from the
      command line.</para>
  </sect1>

  <sect1>
    <title>Printing JSON data</title>

    <para id="x_ii">Now that we have a Haskell representation for
      JSON's types, we'd like to be able to take Haskell values and
      render them as JSON data.</para>

    <para id="x_ji">There are a few ways we could go about this.
      Perhaps the most direct would be to write a rendering function
      that prints a value in JSON form.  Once we're done, we'll
      explore some more interesting approaches.</para>

    &PutJSON.hs:module;

    <para id="x_En">Good Haskell style involves separating pure code
      from code that performs I/O.  Our
      <function>renderJValue</function> function has no interaction
      with the outside world, but we still need to be able to print a
      <type>JValue</type>.</para>

    &PutJSON.hs:putJValue;

    <para id="x_Fn">Printing a JSON value is now easy.</para>

    <para id="x_Kn">Why should we separate the rendering code from the
      code that actually prints a value?  This gives us flexibility.
      For instance, if we wanted to compress the data before writing
      it out, and we intermixed rendering with printing, it would be
      much more difficult to adapt our code to that change in
      circumstances.</para>

    <para id="x_Ln">This idea of separating pure from impure code is
      powerful, and pervasive in Haskell code.  Several Haskell
      compression libraries exist, all of which have simple
      interfaces: a compression function accepts an uncompressed
      string and returns a compressed string. We can use function
      composition to render JSON data to a string, then compress to
      another string, postponing any decision on how to actually
      display or transmit the data.</para>
  </sect1>

  <sect1>
    <title>Type inference is a double-edged sword</title>

    <para id="x_Wn">A Haskell compiler's ability to infer types is
      powerful and valuable.  Early on, you'll probably be faced by a
      strong temptation to take advantage of type inference by
      omitting as many type declarations as possible: let's simply
      make the compiler figure the whole lot out!</para>

    <para id="x_Xn">Skimping on explicit type information has a
      downside, one that disproportionately affects new Haskell
      programmer.  As a new Haskell programmer, we're extremely likely
      to write code that will fail to compile due to straightforward
      type errors.</para>

    <para>When we omit explicit type information, we force the
      compiler to figure out our intentions.  It will infer types that
      are logical and consistent, but perhaps not at all what we
      meant.  If we and the compiler unknowingly disagree about what
      is going on, it will naturally take us longer to find the source
      of our problem.</para>

    <para id="x_Yn">Suppose, for instance, that we write a function
      that we believe returns a <type>String</type>, but we don't
      write a type signature for it.</para>

    &Trouble.hs:upcaseFirst;

    <para id="x_Zn">Here, we want to upper-case the first character of
      a word, but we've forgotten to append the rest of the word onto
      the result.  We think our function's type is <type>String -&gt;
	String</type>, but the compiler will correctly infer its type
      as <type>String -> Char</type>.  Let's say we then try to use
      this function somewhere else.</para>

    &Trouble.hs:camelCase;
      
    <para id="x_an">When we try to compile this code or load it into
      &ghci;, we won't necessarily get an obvious error
      message.</para>

      &trouble.ghci:load;

    <para id="x_bn">Notice that the error is reported where we
      <emphasis>use</emphasis> the <function>upcaseFirst</function>
      function.  If we're erroneously convinced that our definition
      and type for <function>upcaseFirst</function> are correct, we
      may end up staring at the wrong piece of code for quite a while,
      until enlightenment strikes.</para>

    <para id="x_cn">Every time we write a type signature, we remove a
      degree of freedom from the type inference engine.  This reduces
      the likelihood of divergence between our understanding of our
      code and the compiler's.  Type declarations also act as
      shorthand for ourselves as readers of our own code, making it
      easier for us to develop a sense of what must be going
      on.</para>

    <para id="x_dn">This is not to say that we need to pepper every
      tiny fragment of code with a type declaration.  It is, however,
      usually good form to add a signature to every top-level
      definition in our code.  It's best to start out fairly
      aggressive with explicit type signatures, and slowly ease back
      as your mental model of how type checking works becomes more
      accurate.</para>

    <tip>
      <title>Explicit types, undefined values, and error</title>

      <para id="x_en">The special value <code>undefined</code> will
	happily typecheck no matter where we use it, as will an
	expression like <code>error "argh!"</code>.  It is especially
	important that we write type signatures when we use these.
	Suppose we use <code>undefined</code> or <code>error "write
	  me"</code> to act as a placeholder in the body of a
	top-level definition.  If we omit a type signature, we may be
	able to use the value we have defined in places where a
	correctly typed version would be rejected by the compiler.
	This can easily lead us astray.</para>
    </tip>
    </sect1>

  <sect1>
    <title>A more general look at rendering</title>

    <para id="x_Mn">Our JSON rendering code is narrowly tailored to
      the exact needs of our data types and the JSON formatting
      conventions.  The output it produces can be unfriendly to human
      eyes.  We will now look at rendering as a more generic task: how
      can we build a library that is useful for rendering data in a
      variety of situations?</para>

    <para>We would like to produce output that is suitable either for
      human consumption (e.g. for debugging) or for machine
      processing.  Libraries that perform this job are referred to as
      <emphasis>pretty printers</emphasis>.  There already exist
      several Haskell pretty printing libraries.  We are creating one
      of our own not to replace them, but for the many useful insights
      we will gain into both library design and functional programming
      techniques.</para>

    <para>We will call our generic pretty printing module
      <code>Prettify</code>, so our code will go into a source file
      named <filename>Prettify.hs</filename>.</para>

    <note>
      <title>Naming</title>

      <para>In our <code>Prettify</code> module, we will base our
	names on those used by several established Haskell pretty
	printing libraries.  This will give us a degree of
	compatibility with existing mature libraries.</para>
    </note>

    <para>To make sure that <code>Prettify</code> meets practical
      needs, we write a new JSON renderer that uses the
      <code>Prettify</code> API. After we're done, we'll go back and
      fill in the details of the <code>Prettify</code> module.</para>

    <para id="x_Nn">Instead of rendering straight to a string, our
      <code>Prettify</code> module will use an abstract type that
      we'll call <type>Doc</type>. By basing our generic rendering
      library on an abstract type, we can choose an implementation
      that is flexible and efficient.  If we decide to change the
      underlying code, our users will not be able to tell.</para>

    <para id="x_Pn">We will name our new JSON rendering module
      <filename>PrettyJSON.hs</filename>, and retain the name
      <function>renderJValue</function> for the rendering function.
      Rendering one of the basic JSON values is
      straightforward.</para>

    &PrettyJSON.hs:renderJValue;

    <para id="x_Qn">The <function>text</function>,
      <function>double</function>, and <function>string</function>
      functions will be provided by our <code>Prettify</code>
      module.</para>

  </sect1>

  <sect1>
    <title>Developing Haskell code without going nuts</title>

    <para id="x_Rn">Early on, as we come to grips with Haskell development, we
      have so many new, unfamiliar concepts to keep track of at one
      time that it can be a challenge to write code that compiles at
      all.</para>

    <para id="x_Sn">As we write our first substantial body of code, it's a
      <emphasis>huge</emphasis> help to pause every few minutes and
      try to compile what we've produced so far.  Because Haskell is
      so strongly typed, if our code compiles cleanly, we're assuring
      ourselves that we're not wandering too far off into the
      programming weeds.</para>

    <para id="x_Tn">One useful technique for quickly developing the
      skeleton of a program is to write placeholder, or
      <emphasis>stub</emphasis> versions of types and functions.  For
      instance, we mentioned above that our
      <function>string</function>, <function>text</function> and
      <function>double</function> functions would be provided by our
      <code>Prettify</code> module. If we don't provide definitions
      for those functions or the <type>Doc</type> type, our attempts
      to <quote>compile early, compile often</quote> with our JSON
      renderer will fail, as the compiler won't know anything about
      those functions.  To avoid this problem, we write stub code that
      doesn't do anything.</para>

    &PrettyStub.hs:stubs;

    <para id="x_Un">The special value <code>undefined</code> has the
      type <varname role="type">a</varname>, so it always typechecks,
      no matter where we use it.  If we attempt to evaluate it, it
      will cause our program to crash.</para>

    &prettystub.ghci:crash;

    <para id="x_Vn">Even though we can't yet run our stubbed code, the
      compiler's type checker will ensure that our program is sensibly
      typed.</para>
  </sect1>

  <sect1>
    <title>Pretty printing a string</title>

    <para id="x_fn">When we must pretty print a string value, JSON has
      moderately involved escaping rules that we must follow. At the
      highest level, a string is just a series of characters wrapped
      in quotes.</para>

      &PrettyJSON.hs:string;

    <note>
      <title>Point-free style</title>

      <para>This style of writing a definition exclusively as a
	composition of other functions is called <emphasis>point-free
	  style</emphasis>.  The use of the word <quote>point</quote>
	is not related to the <quote><code>.</code></quote> character
	used for function composition.  The term
	<emphasis>point</emphasis> is roughly synonymous (in Haskell)
	with <emphasis>value</emphasis>, so a
	<emphasis>point-free</emphasis> expression makes no mention of
	the values that it operates on.</para>

      <para>Contrast the point-free definition of
	<function>string</function> above with this
	<quote>pointy</quote> version, which uses a variable
	<varname>s</varname> to refer to the value on which it
	operates.</para>

      &PrettyJSON.hs:pointyString;

    </note>

    <para id="x_hn">The <function>enclose</function> function simply wraps a
      <type>Doc</type> value with an opening and closing
      character.</para>

      &PrettyJSON.hs:enclose;

    <para id="x_in">We provide a <function>(&lt;&gt;)</function>
      function in our pretty printing library.  It appends two
      <type>Doc</type> values, so it's the <type>Doc</type> equivalent of
      <function>(++)</function>.</para>

      &PrettyStub.hs:append;

    <para id="x_jn">Our pretty printing library also provides
      <function>hcat</function>, which concatenates multiple
      <type>Doc</type> values into one: it's the analogue of
      <function>concat</function> for lists.</para>

      &PrettyStub.hs:hcat;

    <para id="x_kn">Our <function>string</function> function applies
      the <function>oneChar</function> function to every character in
      a string, concatenates the lot, and encloses the result in
      quotes.  The <function>oneChar</function> function escapes or
      renders an individual character.</para>

      &PrettyJSON.hs:oneChar;

    <para id="x_ln">The <function>simpleEscapes</function> value is a
      list of pairs.  We call a list of pairs an <emphasis>association
	list</emphasis>, or <emphasis>alist</emphasis> for short.
      Each element of our alist associates a character with
      its escaped representation.</para>

      &prettyjson.ghci:simpleEscapes;

    <para id="x_mn">Our &case; expression attempts to see if our
      character has a match in this alist.  If we find the match, we
      emit it, otherwise we might need to escape the character in a
      more complicated way. If so, we perform this escaping.  Only if
      neither kind of escaping is required do we emit the plain
      character.  To be conservative, the only unescaped characters we
      emit are printable ASCII characters.</para>

    <para id="x_nn">The more complicated escaping involves turning a character
      into the string <quote><code>\u</code></quote> followed by a
      four-character sequence of hexadecimal digits representing the
      numeric value of the Unicode character.</para>

      &PrettyJSON.hs:smallHex;

    <para id="x_on">The <function>showHex</function> function comes
      from the <code>Numeric</code> library (you will need to import
      this at the beginning of <filename>Prettify.hs</filename>), and
      returns a hexadecimal representation of a number.</para>

      &prettyjson.ghci:showHex;

    <para id="x_pn">The <function>replicate</function> function is provided by
      the Prelude, and builds a fixed-length repeating list of its
      argument.</para>

      &prettyjson.ghci:replicate;

    <para id="x_qn">There's a wrinkle: the four-digit encoding that
      <function>smallHex</function> provides can only represent
      Unicode characters up to <code>0xffff</code>.  Valid Unicode
      characters can range up to <code>0x10ffff</code>.  To properly
      represent a character above <code>0xffff</code> in a JSON
      string, we follow some complicated rules to split it into two.
      This gives us an opportunity to perform some bit-level
      manipulation of Haskell numbers.</para>

      &PrettyJSON.hs:astral;

    <para id="x_sn">The <function>shiftR</function> function comes from the
      <code>Data.Bits</code> module, and shifts a number to the right.
      The <function>(.&amp;.)</function> function, also from
      <code>Data.Bits</code>, performs a bit-level
      <emphasis>and</emphasis> of two values.</para>

      &prettyjson.ghci:bits;

    <para id="x_tn">Now that we've written <function>smallHex</function> and
      <function>astral</function>, we can provide a definition for
      <function>hexEscape</function>.</para>

      &PrettyJSON.hs:hexEscape;
  </sect1>

  <sect1>
    <title>Arrays and objects, and the module header</title>

    <para id="x_un">Compared to strings, pretty printing arrays and objects is a
      snap.  We already know that the two are visually similar: each
      starts with an opening character, followed by a series of values
      separated with commas, followed by a closing character. Let's
      write a function that captures the common structure of arrays
      and objects.</para>

      &PrettyJSON.hs:series;

    <para id="x_vn">We'll start by interpreting this function's type.  It takes
      an opening and closing character, then a function that knows how
      to pretty print a value of some unknown type <varname
	role="type">a</varname>, followed by a list of values of type
      <varname role="type">a</varname>, and it returns a value of type
      <type>Doc</type>.</para>

    <para>Notice that although our type signature mentions four
      parameters, we have only listed three in the definition of the
      function.  We are simply following the same rule that lets us
      simplify a definiton like <code>myLength xs = length xs</code>
      to <code>myLength = length</code>.</para>

    <para id="x_wn">We have already written <function>enclose</function>,
      which wraps a <type>Doc</type> value in opening and closing
      characters.  The <function>fsep</function> function will live in
      our <code>Prettify</code> module.  It combines a list of
      <type>Doc</type> values into one, possibly wrapping lines if the
      output will not fit on a single line.</para>

    &PrettyStub.hs:fsep;

    <para>By now, you should be able to define your own stubs in
      <filename>Prettify.hs</filename>, by following the examples we
      have supplied.  We will not explicitly define any more
      stubs.</para>

    <para>The <function>punctuate</function> function will also live
      in our <code>Prettify</code> module, and we can define it in
      terms of functions for which we've already written stubs.</para>

    &Prettify.hs:punctuate;

    <para id="x_xn">With this definition of <function>series</function>, pretty
      printing an array is entirely straightforward.  We add this
      equation  to the end of the block we've already written for our
      <function>renderJValue</function> function.</para>

      &PrettyJSON.hs:renderJValue.array;

    <para id="x_yn">To pretty print an object, we need to do only a little more
      work: for each element, we have both a name and a value to deal
      with.</para>

      &PrettyJSON.hs:renderJValue.object;
  </sect1>

  <sect1>
    <title>Writing a module header</title>

    <para id="x_zn">Now that we have written the bulk of our
      <filename>PrettyJSON.hs</filename> file, we must go back to the
      top and add a module declaration.</para>

    &PrettyJSON.hs:module;

    <para id="x_Ao">We export just one name from this module:
      <function>renderJValue</function>, our JSON rendering function.
      The other definitions in the module exist purely to support
      <function>renderJValue</function>, so there's no reason to make
      them visible to other modules.</para>

    <para id="x_Bo">Regarding imports, the <code>Numeric</code> and
      <code>Data.Bits</code> modules are distributed with &GHC;. We've
      already written the <code>SimpleJSON</code> module, and filled
      our <code>Prettify</code> module with skeletal definitions.
      Notice that there's no difference in the way we import standard
      modules from those we've written ourselves.</para>

    <para id="x_Co">With each <code>import</code> directive, we explicitly list
      each of the names we want to bring into our module's namespace.
      This is not required: if we omit the list of names, all of the
      names exported from a module will be available to us.  However,
      it's generally a good idea to write an explicit import
      list.</para>

    <itemizedlist>
      <listitem>
	<para id="x_Do">An explicit list makes it clear which names we're
	  importing from where.  This will make it easier for a reader
	  to look up documentation if they encounter an unfamiliar
	  function.</para>
      </listitem>
      <listitem>
	<para id="x_Eo">Occasionally, a library maintainer will remove or rename
	  a function.  If a function disappears from a third party
	  module that we use, any resulting compilation error is
	  likely to happen long after we've written the module.  The
	  explicit list of imported names can act as a reminder to
	  ourselves of where we had been importing the missing name
	  from, which will help us to pinpoint the problem more
	  quickly.</para>
      </listitem>
      <listitem>
	<para id="x_Fo">It can also occur that someone will add a name to a
	  module that is identical to a name already in our own code.
	  If we don't use an explicit import list, we'll end up with
	  the same name in our module twice.  If we use that name,
	  &GHC; will report an error due to the ambiguity.  An
	  explicit list lets us avoid the possibility of accidentally
	  importing an unexpected new name.</para>
      </listitem>
    </itemizedlist>

    <para id="x_Go">This idea of using explicit imports is a guideline that
      usually makes sense, not a hard-and-fast rule. Occasionally,
      we'll need so many names from a module that listing each one
      becomes messy.  In other cases, a module might be so widely used
      that a moderately experienced Haskell programmer will
      probably know which names come from that module.</para>
  </sect1>

  <sect1>
    <title>Fleshing out the pretty printing library</title>

    <para id="x_Ho">In our <code>Prettify</code> module, we represent our
      <type>Doc</type> type as an algebraic data type.</para>

    &Prettify.hs:Doc;

    <para id="x_Io">Observe that the <type>Doc</type> type is actually
      a tree.  The <code>Concat</code> and <code>Union</code>
      constructors create an internal node from two other
      <type>Doc</type> values, while the <code>Empty</code> and other
      simple constructors build leaves.</para>
    
    <para id="x_Jo">In the header of our module, we will export the name of the
      type, but not any of its constructors: this will prevent modules
      that use the <type>Doc</type> type from creating and pattern
      matching against <type>Doc</type> values.</para>

    <para id="x_Ko">Instead, to create a <type>Doc</type>, a user of
      the <code>Prettify</code> module will call a function that we
      provide.  Here are the simple construction functions.  As we add
      real definitions, we must replace any stubbed versions already
      in the <filename>Prettify.hs</filename> source file.</para>

    &Prettify.hs:basic;

    <para id="x_Lo">The <code>Line</code> constructor represents a line break.
      The <function>line</function> function creates
      <emphasis>hard</emphasis> line breaks, which always appear in
      the pretty printer's output.  Sometimes we'll want a
      <emphasis>soft</emphasis> line break, which is only used if a
      line is too wide to fit in a window or page.  We'll introduce a
      <function>softline</function> function shortly.</para>

    &Prettify.hs:line;

    <para id="x_Mo">Almost as simple as the basic constructors is the
      <function>(&lt;&gt;)</function> function, which concatenates two
      <type>Doc</type> values.</para>

    &Prettify.hs:append;
    
    <para id="x_No">We pattern match against <code>Empty</code> so
      that concatenating a <type>Doc</type> value with
      <code>Empty</code> on the left or right will have no effect.
      This keeps us from bloating the tree with useless values.</para>

    &prettify.ghci:append;

    <tip>
      <title>A mathematical moment</title>

      <para id="x_Oo">If we briefly put on our mathematical hats, we
	can say that <code>Empty</code> is the identity under
	concatenation, since nothing happens if we concatenate a
	<type>Doc</type> value with <code>Empty</code>.  In a similar
	vein, 0 is the identity for adding numbers, and 1 is the
	identity for multiplying them. Taking the mathematical
	perspective has useful practical consequences, as we will see
	in a number of places throughout this book.</para>
    </tip>

    <para id="x_Po">Our <function>hcat</function> and <function>fsep</function>
      functions concatenate a list of <type>Doc</type> values into
      one.  In <xref
	linkend="fp.fold.exercises"/>, we mentioned that we could
      define concatenation for lists using
      <function>foldr</function>.</para>

    &Concat.hs:concat;

    <para id="x_Qo">Since <function>(&lt;&gt;)</function> is analogous to
      <function>(++)</function>, and <function>empty</function> to
      <function>[]</function>, we can see how we might write
      <function>hcat</function> and <function>fsep</function> as
      folds, too.</para>
      
    &Prettify.hs:hcat;

    <para id="x_Ro">The definition of <function>fsep</function> depends on
      several other functions.</para>

    &Prettify.hs:fsep;

    <para id="x_So">These take a little explaining.  The
      <function>softline</function> function should insert a newline
      if the current line has become too wide, or a space otherwise.
      How can we do this if our <type>Doc</type> type doesn't contain
      any information about rendering?  Our answer is that every time
      we encounter a soft newline, we maintain
      <emphasis>two</emphasis> alternative representations of the
      document, using the <code>Union</code> constructor.</para>
     
    &Prettify.hs:group;

    <para id="x_To">Our <function>flatten</function> function replaces a
      <code>Line</code> with a space, turning two lines into one
      longer line.</para>

    &Prettify.hs:flatten;

    <para id="x_Uo">Notice that we always call
      <function>flatten</function> on the left element of a
      <code>Union</code>: the left of each <code>Union</code> is
      always the same width (in characters) as, or wider than, the
      right.  We'll be making use of this property in our rendering
      functions below.</para>

    <sect2>
      <title>Compact rendering</title>

      <para id="x_Wo">We frequently need to use a representation for a piece of
	data that contains as few characters as possible.  For
	example, if we're sending JSON data over a network connection,
	there's no sense in laying it out nicely: the software on the
	far end won't care whether the data is pretty or not, and the
	added white space needed to make the layout look good would
	add a lot of overhead.</para>

      <para id="x_Xo">For these cases, and because it's a simple piece of code
	to start with, we provide a bare-bones compact rendering
	function.</para>

      &Prettify.hs:compact;

      <para id="x_Yo">The <function>compact</function> function wraps its
	argument in a list, and applies the
	<function>transform</function> helper function to it.  The
	<function>transform</function> function treats its argument as
	a stack of items to process, where the first element of the
	list is the top of the stack.</para>

      <para id="x_Zo">The <function>transform</function> function's
	<code>(d:ds)</code> pattern breaks the stack into its head,
	<varname>d</varname>, and the remainder,
	<varname>ds</varname>. In our &case; expression, the first
	several branches recurse on <varname>ds</varname>, consuming
	one item from the stack for each recursive application.  The
	last two branches add items in front of <varname>ds</varname>:
	the <code>Concat</code> branch adds both elements to the
	stack, while the <code>Union</code> branch ignores its left
	element, on which we called <function>flatten</function>, and
	adds its right element to the stack.</para>

      <para id="x_ao">We have now fleshed out enough of our original skeletal
	definitions that we can try out our
	<function>compact</function> function in &ghci;.</para>

      &prettyjson.ghci:compact;

      <para id="x_bo">To better understand how the code works, let's look at a
	simpler example in more detail.</para>
      
      &prettyjson.ghci:foo;

      <para id="x_co">When we apply <function>compact</function>, it turns its
	argument into a list and applies
	<function>transform</function>.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_do">The <function>transform</function> function receives a
	    one-item list, which matches the <code>(d:ds)</code>
	    pattern. Thus <varname>d</varname> is the value
	    <code>Concat (Char 'f') (Text "oo")</code>, and
	    <varname>ds</varname> is the empty list,
	    <code>[]</code>.</para>
	  <para id="x_eo">Since <varname>d</varname>'s constructor is
	    <code>Concat</code>, the <code>Concat</code> pattern
	    matches in the &case; expression.  On the right hand side,
	    we add <code>Char 'f'</code> and <code>Text "oo"</code> to
	    the stack, and apply
	    <function>transform</function>recursively.</para>
	</listitem>
	<listitem>
	  <itemizedlist>
	    <listitem>
	      <para id="x_fo">The <function>transform</function> function
		receives a two-item list, again matching the
		<code>(d:ds)</code> pattern.  The variable
		<varname>d</varname> is bound to <code>Char
		  'f'</code>, and <varname>ds</varname> to <code>[Text
		  "oo"]</code>.</para>
	      <para id="x_go">The &case; expression matches in the
		<code>Char</code> branch.  On the right hand side, we
		use <function>(:)</function> to construct a list whose
		head is <code>'f'</code>, and whose body is the result
		of a recursive application of
		<function>transform</function>.</para>
	    </listitem>
	    <listitem>
	      <itemizedlist>
		<listitem>
		  <para id="x_ho">The recursive invocation receives a one-item
		    list. The variable <varname>d</varname> is bound
		    to <code>Text "oo"</code>, and
		    <varname>ds</varname> to <code>[]</code>.</para>
		  <para id="x_io">The &case; expression matches in the
		    <code>Text</code> branch.  On the right hand side,
		    we use <function>(++)</function> to concatenate
		    <code>"oo"</code> with the result of a recursive
		    application of
		    <function>transform</function>.</para>
		</listitem>
		<listitem>
		  <itemizedlist>
		    <listitem>
		      <para id="x_jo">In the final invocation,
			<function>transform</function> is invoked with
			an empty list, and returns an empty
			string.</para>
		    </listitem>
		  </itemizedlist>
		</listitem>
		<listitem>
		  <para id="x_ko">The result is <code>"oo" ++ ""</code>.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para id="x_lo">The result is <code>'f' : "oo" ++ ""</code>.</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>True pretty printing</title>

      <para id="x_mo">While our <function>compact</function> function is useful
	for machine-to-machine communication, its result is not always
	easy for a human to follow: there's very little information on
	each line. To generate more readable output, we'll write
	another function, <function>pretty</function>. Compared to
	<function>compact</function>, <function>pretty</function>
	takes one extra argument: the maximum width of a line, in
	columns.  (We're assuming that our typeface is of fixed
	width.)</para>

      &Prettify.hs:pretty.type;

      <para id="x_no">To be more precise, this <type>Int</type> parameter
	controls the behaviour of <function>pretty</function> when it
	encounters a <function>softline</function>.  Only at a
	<function>softline</function> does <function>pretty</function>
	have the option of either continuing the current line or
	beginning a new line.  Elsewhere, we must strictly follow the
	directives set out by the person using our pretty printing
	functions.</para>

      <para id="x_oo">Here's the core of our implementation</para>

      &Prettify.hs:pretty;

      <para id="x_po">Our <function>best</function> helper function takes two
	arguments: the number of columns emitted so far on the current
	line, and the list of remaining <type>Doc</type> values to
	process.</para>

      <para id="x_qo">In the simple cases, <function>best</function> updates the
	<varname>col</varname> variable in straightforward ways as it
	consumes the input.  Even the <code>Concat</code> case is
	obvious: we push the two concatenated components onto our
	stack/list, and don't touch <varname>col</varname>.</para>

      <para id="x_ro">The interesting case involves the
	<code>Union</code> constructor.  Recall that we applied
	<function>flatten</function> to the left element, and did
	nothing to the right.  Also, remember that
	<function>flatten</function> replaces newlines with spaces.
	Therefore, our job is to see which (if either) of the two
	layouts, the <function>flatten</function>ed one or the
	original, will fit into our <varname>width</varname>
	restriction.</para>

      <para id="x_so">To do this, we write a small helper that determines
	whether a single line of a rendered <type>Doc</type> value
	will fit into a given number of columns.</para>

      &Prettify.hs:fits;

    </sect2>

    <sect2>
      <title>Following the pretty printer</title>

      <para id="x_to">In order to understand how this code works, let's first
	consider a simple <type>Doc</type> value.</para>

      &prettify.ghci:simple;

      <para id="x_uo">We'll apply <function>pretty 2</function> on this value.
	When we first apply <function>best</function>, the value of
	<code>col</code> is zero.  It matches the <code>Concat</code>
	case, pushes the values <code>Union (Char ' ') Line</code> and
	<code>Char 'a'</code> onto the stack, and applies itself
	recursively.  In the recursive application, it matches on
	<code>Union (Char ' ') Line</code>.</para>

      <para id="x_vo">At this point, we're going to ignore Haskell's usual order
	of evaluation.  This keeps our explanation of what's going on
	simple, without changing the end result.  We now have two
	subexpressions, <code>best 0 [Char ' ', Char 'a']</code> and
	<code>best 0 [Line, Char 'a']</code>.  The first evaluates to
	<code>" a"</code>, and the second to <code>"\na"</code>.  We
	then substitute these into the outer expression to give
	<code>nicest 0 " a" "\na"</code>.</para>
	
      <para id="x_wo">To figure out what the result of
	<function>nicest</function> is here, we do a little
	substitution.  The values of <varname>width</varname> and
	<varname>col</varname> are 0 and 2, respectively, so
	<varname>least</varname> is 0, and <code>width - least</code>
	is 2.  We quickly evaluate <code>2 `fits` " a"</code> in
	&ghci;.</para>

      &prettify.ghci:fits;

      <para id="x_xo">Since this evaluates to <code>True</code>, the result of
	<function>nicest</function> here is <code>" a"</code>.</para>

      <para id="x_yo">If we apply our <function>pretty</function> function to
	the same JSON data as earlier, we can see that it produces
	different output depending on the width that we give
	it.</para>

      &prettyjson.ghci:pretty;

    </sect2>

    <sect2>
      <title>Exercises</title>

      <para id="x_zo">Our current pretty printer is spartan, so that
	it will fit within our space constraints, but there are a
	number of useful improvements we can make.</para>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_Ap">Write a function,
	    <function>fill</function>, with the following type signature.</para>

	    &Prettify.hs:fill;

	    <para id="x_Bp">It should add spaces to a document until
	      it is the given number of columns wide.  If it is
	      already wider than this value, it should add no
	      spaces.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para id="x_Cp">Our pretty printer does not take
	      <emphasis>nesting</emphasis> into account. Whenever we
	      open parentheses, braces, or brackets, any lines that
	      follow should be indented so that they are aligned with
	      the opening character until a matching closing character
	      is encountered.</para>

	    <para id="x_Dp">Add support for nesting, with a controllable amount
	      of indentation.</para>

	    &Prettify.hs:nest;

	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="library.package">
    <title>Creating a package</title>

    <para id="x_Ep">The Haskell community has built a standard set of
      tools, named Cabal, that help with building, installing, and
      distributing software. Cabal organises software as a
      <emphasis>package</emphasis>.  A package contains one library,
      and possibly several executable programs.</para>

    <sect2>
      <title>Writing a package description</title>

      <para id="x_Fp">To do anything with a package, Cabal needs a description
	of it.  This is contained in a text file whose name ends with
	the suffix <filename>.cabal</filename>.  This file belongs in
	the top-level directory of your project.  It has a simple
	format, which we'll describe below.</para>

      <para id="x_Gp">A Cabal package must have a name.  Usually, the
	name of the package matches the name of the
	<filename>.cabal</filename> file.  We'll call our package
	<code>mypretty</code>, so our file is
	<filename>mypretty.cabal</filename>.  Often, the directory
	that contains a <filename>.cabal</filename> file will have the
	same name as the package, e.g. <code>mypretty</code>.</para>

      <para id="x_Hp">A package description begins with a series of global
	properties, which apply to every library and executable in the
	package.</para>

      &mypretty.cabal:begin;

      <para id="x_Ip">Package names must be unique.  If you create and install a
	package that has the same name as a package already present on
	your system, &GHC; will become very confused.</para>

      <para id="x_Jp">The global properties include a substantial amount of
	information that is intended for human readers, not Cabal
	itself.</para>

      &mypretty.cabal:human;

      <para id="x_Kp">As the <code>Description</code> field indicates, a field
	can span multiple lines, provided they're indented.</para>

      <para id="x_Lp">Also included in the global properties is license
	information.  Most Haskell packages are licensed under the BSD
	license, which Cabal calls <code>BSD3</code><footnote>
	  <para id="x_Mp">The <quote>3</quote> in <code>BSD3</code> refers to
	    the number of clauses in the license.  An older version of
	    the BSD license contained 4 clauses, but it is no longer
	    used.</para>
	</footnote>.  (Obviously, you're free to choose whatever
	license you think is appropriate.)  The optional
	<code>License-File</code> field lets us specify the name of a
	file that contains the exact text of our package's licensing
	terms.</para>

      <para id="x_Np">The features supported by successive versions of Cabal
	evolve over time, so it's wise to indicate what
	versions of Cabal we expect to be compatible with.  The
	features we are describing are supported by versions 1.2 and
	higher of Cabal.</para>

      &mypretty.cabal:version;

      <para id="x_Op">To describe an individual library within a
	package, we write a <emphasis>library section</emphasis>.  The
	use of indentation here is significant: the contents of a
	section must be indented.</para>

      &mypretty.cabal:library;

      <para id="x_Pp">The <code>Exposed-Modules</code> field contains a list of
	modules that should be available to users of this package. An
	optional field, <code>Other-Modules</code>, contains a list of
	<emphasis>internal</emphasis> modules.  These are required for
	this library to function, but will not be visible to
	users.</para>

      <para id="x_Qp">The <code>Build-Depends</code> field contains a
	comma-separated list of packages that our library requires to
	build.  For each package, we can optionally specify the range
	of versions with which this library is known to work.  The
	<code>base</code> package contains many of the core Haskell
	modules, such as the Prelude, so it's effectively always
	required.</para>

      <tip>
	<title>Figuring out build dependencies</title>

	<para id="x_Rp">We don't have to guess or do any research to establish
	  which packages we depend on.  If we try to build our
	  package without a <code>Build-Depends</code> field,
	  compilation will fail with a useful error message.  Here's
	  an example where we commented out the dependency on the
	  <code>base</code> package.</para>

	<screen><prompt>$</prompt> <userinput>runghc Setup build</userinput>
Preprocessing library mypretty-0.1...
Building mypretty-0.1...

PrettyJSON.hs:8:7:
    Could not find module `Data.Bits':
      it is a member of package base, which is hidden</screen>

	<para id="x_Sp">The error message makes it clear that we need
	  to add the <code>base</code> package, even though
	  <code>base</code> is already installed.  Forcing us to be
	  explicit about every package we need has a practical
	  benefit: a command line tool named
	  <filename>cabal-install</filename> will automatically
	  download, build, and install a package and all of the
	  packages it depends on.</para>
      </tip>
    </sect2>

    <sect2>
      <title>GHC's package manager</title>

      <para id="x_Tp">&GHC; includes a simple package manager that tracks which
	packages are installed, and what the versions of those packages
	are.  A command line tool named &ghc_pkg; lets us
	work with its package databases.</para>

      <para id="x_Up">We say <emphasis>databases</emphasis> because
	&GHC; distinguishes between <emphasis>system-wide</emphasis>
	packages, which are available to every user, and
	<emphasis>per-user</emphasis> packages, which are only visible
	to the current user.  The per-user database lets us avoid the
	need for administrative privileges to install packages.</para>

      <para id="x_Wp">The &ghc_pkg; command provides subcommands to address
	different tasks. Most of the time, we'll only need two of
	them.  The <code>ghc-pkg list</code> command lets us see what
	packages are installed.  When we want to uninstall a package,
	<code>ghc-pkg unregister</code> tells &GHC; that we won't be
	using a particular package any longer.  (We will have to
	manually delete the installed files ourselves.)</para>
    </sect2>

    <sect2>
      <title>Setting up, building, and installing</title>

      <para id="x_Xp">In addition to a <filename>.cabal</filename> file, a
	package must contain a <emphasis>setup</emphasis> file.  This
	allows Cabal's build process to be heavily customised, if a
	package needs it.  The simplest setup file looks like
	this.</para>

      &Setup.hs:setup;

      <para id="x_Yp">We save this file under the name
	<filename>Setup.hs</filename>.</para>

      <para id="x_ap">Once we have the <filename>.cabal</filename> and
	<filename>Setup.hs</filename> files written, we have three
	steps left.</para>

      <para id="x_bp">To instruct Cabal how to build and where to install a
	package, we run a simple command.</para>

<screen><prompt>$</prompt> <userinput>runghc Setup configure</userinput></screen>

      <para id="x_cp">This ensures that the packages we need are available, and
	stores settings to be used later by other Cabal
	commands.</para>

      <para id="x_dp">If we do not provide any arguments to
	<code>configure</code>, Cabal will install our package in the
	system-wide package database.  To install it into our home
	directory and our personal package database, we must provide a
	little more information.</para>

<screen><prompt>$</prompt> <userinput>runghc Setup configure --prefix=$HOME --user</userinput></screen>

      <para id="x_ep">Following the <code>configure</code> step, we build the
	package.</para>

<screen><prompt>$</prompt> <userinput>runghc Setup build</userinput></screen>

      <para id="x_fp">If this succeeds, we can install the package.
	We don't need to indicate where to install to: Cabal will use
	the settings we provided in the <code>configure</code> step.
	It will install to our own directory and update &GHC;'s
	per-user package database.</para>

<screen><prompt>$</prompt> <userinput>runghc Setup install</userinput></screen>

    </sect2>
  </sect1>

  <sect1>
    <title>Practical pointers and further reading</title>

    <para id="x_gp">&GHC; already bundles a pretty printing library,
      <code>Text.PrettyPrint.HughesPJ</code>.  It provides the same
      basic API as our example, but a much richer and more useful set
      of pretty printing functions.  We recommend using it, rather
      than writing your own.</para>

    <para id="x_hp">The design of the <code>HughesPJ</code> pretty printer was
      introduced by John Hughes in <citation><biblioref
	  linkend="bib.hughes95"/></citation>. The library was
      subsequently improved by Simon Peyton Jones, hence the name.
      Hughes's paper is long, but well worth reading for his
      discussion of how to design a library in Haskell.</para>

    <para id="x_ip">In this chapter, our pretty printing library is
      based on a simpler system described by Philip Wadler in
      <citation><biblioref linkend="bib.wadler98"/></citation>.  His
      library was extended by Daan Leijen; this version is available
      for download from Hackage as <filename>wl-pprint</filename>.  If
      you use the <command>cabal</command> command line tool, you can
      download, build, and install it in one step with <command>cabal
	install wl-pprint</command>.</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
