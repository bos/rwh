<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="library" revision="unpublished">
  <title>Writing a Library</title>

  <para>In this chapter, we'll take a look at developing a small, but
    complete, Haskell library.</para>

  <sect1>
    <title>A whirlwind tour of the JSON language</title>

    <para>The JSON (JavaScript Object Notation) language is a small,
      simple representation for structured data.  Its most common use
      is to transfer data from a web service to a browser-based
      JavaScript application.</para>

    <para>JSON supports four basic types of value: strings, numbers,
      booleans, and a special value named <code>null</code>.</para>

    <programlisting>"a string"
12345
true
null</programlisting>

    <para>The language also allows for the construction of compound
      values.  Its compound types are the array, an ordered sequence
      of values; and the struct, an unordered collection of name/value
      pairs.  The values in a struct or array can be of any
      type.</para>

    <programlisting>[-3.14, true, null, "a string"]
{"numbers": [1,2,3,4,5], "useful": false}</programlisting>
  </sect1>

  <sect1>
    <title>Representing JSON data in Haskell</title>

    <para>To work with JSON data in Haskell, we use an algebraic data
      type to represent the range of possible JSON types.  In a text
      editor, create a file named <code>SimpleJSON.hs</code>, and
      insert the following contents.</para>

    &SimpleJSON.hs:JValue;

    <para>Here, we associate each JSON type with a distinct
      constructor. Some of these constructors have parameters: if we
      want to construct a JSON string, we must provide a
      <type>String</type> value as an argument to the
      <code>JString</code> constructor.</para>

    <para>To start experimenting with this code, save the file
      <code>SimpleJSON.hs</code> in your editor, switch to a &ghci;
      window, and load the file into &ghci;.</para>

    &simplejson.ghci:load;

    <para>We can see how to use a constructor to take a normal Haskell
      value and turn it into a JSON value.  To do the reverse, we use
      pattern matching.  Here's a function that we can add to
      <code>SimpleJSON.hs</code> that will extract a string from a
      JSON value for us.  If the JSON value actually contains a
      string, our function will wrap the string with the
      <code>Just</code> constructor, otherwise it will return
      <code>Nothing</code>.</para>

    &SimpleJSON.hs:getString;

    <para>If we save the modified source file, we can reload it in
      &ghci; and try the new definition.</para>

    &simplejson.ghci:reload;

    <para>A few more accessor functions, and we've got a small body of
      code to work with.</para>

    &SimpleJSON.hs:getters;

  </sect1>

  <sect1>
    <title>The anatomy of a Haskell module</title>

    <para>A Haskell source file contains a single
      <emphasis>module</emphasis>.  A module lets us determine which
      namesinside the module are accessible from other modules.</para>

    <para>Normally, a source file begins with a module
      declaration.</para>

    &SimpleJSON.hs:module;

    <para>The word <code>module</code> is reserved.  It is followed by
      the name of the module.  By convention, the source file has the
      same <quote>base name</quote> as the module, which is why our
      file <code>SimpleJSON.hs</code> contains the module
      <code>SimpleJSON</code>.</para>

    <para>Following the module name is a list of
      <emphasis>exports</emphasis>, enclosed in parentheses.  The
      <code>where</code> keyword indicates that the body of the module
      follows.</para>

    <para>The list of exports indicates which names in this module are
      visible from other modules.  This lets us keep private code
      hidden from the outside world. The special notation
      <code>(..)</code> that follows the name <code>JValue</code>
      indicates that we are exporting both the type and all of its
      constructors.</para>

    <para>It might seem strange that we can export a type's name, but
      not its constructors.  The ability to do this is important: it
      lets us hide the details of a type from its users, making the
      type <emphasis>abstract</emphasis>.  If we can't see a type's
      constructors, we can't pattern match against a value of that
      type, nor can we construct a new value of that type.  Later in
      this chapter, we'll discuss some situations in which we might
      want to make a type abstract.</para>

    <para>If we omit the list of exports (including the parentheses)
      from a module declaration, every name in the module will be
      exported: <code>module SimpleJSON where ...</code>.  To export
      no names at all (only infrequently useful), we write an empty
      list using a pair of parentheses: <code>module SimpleJSON ()
	where ...</code>.</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
