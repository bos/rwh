<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="library" revision="unpublished">
  <title>Writing a Library</title>

  <para id="x_Fi">In this chapter, we'll take a look at developing a small, but
    complete, Haskell library.</para>

  <sect1>
    <title>A whirlwind tour of the JSON language</title>

    <para id="x_Gi">The JSON (JavaScript Object Notation) language is a small,
      simple representation for structured data.  Its most common use
      is to transfer data from a web service to a browser-based
      JavaScript application.</para>

    <para id="x_Hi">JSON supports four basic types of value: strings, numbers,
      booleans, and a special value named <code>null</code>.</para>

    <programlisting>"a string"
12345
true
null</programlisting>

    <para id="x_Ii">The language also allows for the construction of compound
      values.  Its compound types are the array, an ordered sequence
      of values; and the struct, an unordered collection of name/value
      pairs.  The values in a struct or array can be of any
      type.</para>

    <programlisting>[-3.14, true, null, "a string"]
{"numbers": [1,2,3,4,5], "useful": false}</programlisting>
  </sect1>

  <sect1>
    <title>Representing JSON data in Haskell</title>

    <para id="x_Ji">To work with JSON data in Haskell, we use an algebraic data
      type to represent the range of possible JSON types.  In a text
      editor, create a file named <filename>SimpleJSON.hs</filename>,
      and insert the following contents.</para>

    &SimpleJSON.hs:JValue;

    <para id="x_Ki">Here, we associate each JSON type with a distinct
      constructor. Some of these constructors have parameters: if we
      want to construct a JSON string, we must provide a
      <type>String</type> value as an argument to the
      <code>JString</code> constructor.</para>

    <para id="x_Li">To start experimenting with this code, save the file
      <filename>SimpleJSON.hs</filename> in your editor, switch to a
      &ghci; window, and load the file into &ghci;.</para>

    &simplejson.ghci:load;

    <para id="x_Mi">We can see how to use a constructor to take a normal Haskell
      value and turn it into a JSON value.  To do the reverse, we use
      pattern matching.  Here's a function that we can add to
      <filename>SimpleJSON.hs</filename> that will extract a string
      from a JSON value for us.  If the JSON value actually contains a
      string, our function will wrap the string with the
      <code>Just</code> constructor, otherwise it will return
      <code>Nothing</code>.</para>

    &SimpleJSON.hs:getString;

    <para id="x_Ni">If we save the modified source file, we can reload it in
      &ghci; and try the new definition.</para>

    &simplejson.ghci:reload;

    <para id="x_Oi">A few more accessor functions, and we've got a small body of
      code to work with.</para>

    &SimpleJSON.hs:getters;

  </sect1>

  <sect1>
    <title>The anatomy of a Haskell module</title>

    <para id="x_Pi">A Haskell source file contains a single
      <emphasis>module</emphasis>.  A module lets us determine which
      namesinside the module are accessible from other modules.</para>

    <para id="x_Qi">Normally, a source file begins with a module
      declaration.</para>

    &SimpleJSON.hs:module;

    <para id="x_Ri">The word <code>module</code> is reserved.  It is followed by
      the name of the module, which must begin with a capital letter.
      By convention, a source file has the same <emphasis>base
	name</emphasis> (the component before the suffix) as the
      module it contains, which is why our file
      <filename>SimpleJSON.hs</filename> contains the module
      <code>SimpleJSON</code>.</para>

    <para id="x_Si">Following the module name is a list of
      <emphasis>exports</emphasis>, enclosed in parentheses.  The
      <code>where</code> keyword indicates that the body of the module
      follows.</para>

    <para id="x_Ti">The list of exports indicates which names in this module are
      visible from other modules.  This lets us keep private code
      hidden from the outside world. The special notation
      <code>(..)</code> that follows the name <code>JValue</code>
      indicates that we are exporting both the type and all of its
      constructors.</para>

    <para id="x_Ui">It might seem strange that we can export a type's name, but
      not its constructors.  The ability to do this is important: it
      lets us hide the details of a type from its users, making the
      type <emphasis>abstract</emphasis>.  If we can't see a type's
      constructors, we can't pattern match against a value of that
      type, nor can we construct a new value of that type.  Later in
      this chapter, we'll discuss some situations in which we might
      want to make a type abstract.</para>

    <para id="x_Vi">If we omit the list of exports (including the parentheses)
      from a module declaration, every name in the module will be
      exported: <code>module SimpleJSON where ...</code>.  To export
      no names at all (only infrequently useful), we write an empty
      list using a pair of parentheses: <code>module SimpleJSON ()
	where ...</code>.</para>
  </sect1>

  <sect1>
    <title>Compiling Haskell source</title>

    <para id="x_Wi">In addition to the &ghci; interpreter; the &GHC;
      distribution includes an optimising Haskell compiler, named
      &ghc;.  If you're already familiar with a command line compiler
      such as <command>gcc</command> or <command>cl</command> (the
      compiler component of Microsoft's Visual Studio), you'll
      immediately be at home with &ghc;.</para>

    <para id="x_Xi">To compile a source file, we first open a terminal or
      command prompt window, then invoke &ghc; with the name of the
      source file to compile.</para>

    <programlisting><userinput>ghc -c SimpleJSON.hs</userinput></programlisting>

    <para id="x_Yi">The <option>-c</option> option tells &ghc; to only generate
      object code.  If we were to omit the <option>-c</option> option,
      the compiler would attempt
      to generate a complete executable.  That would in turn fail,
      because we haven't written a <function>main</function> function
      yet.</para>

    <para id="x_Zi">After &ghc; completes, if we list the contents of the
      directory, it should contain two new files:
      <filename>SimpleJSON.hi</filename> and
      <filename>SimpleJSON.o</filename>
      (<filename>SimpleJSON.obj</filename> on Windows).  The former is
      an <emphasis>interface file</emphasis>, in which &ghc; stores
      information about the names exported from our module in
      machine-readable form.  The latter is an <emphasis>object
	file</emphasis>, which contains the generated code.</para>
  </sect1>

  <sect1>
    <title>Generating a Haskell program, and importing modules</title>

    <para id="x_ai">Now that we've successfully compiled our minimal library,
      we'll write a tiny program to exercise it.  Create the following
      file in your text editor, and save it as
      <filename>Main.hs</filename>.</para>

    &Main.hs:module;

    <para id="x_bi">Notice the <code>import</code> directive that follows the
      module declaration.  This indicates that we want to take all of
      the names that are exported from the <code>SimpleJSON</code>
      module, and make them available in our module.  Any
      <code>import</code> directives must appear together at the
      beginning of a module.  We cannot scatter them throughout a
      source file.</para>

    <para id="x_ci">Our choice of naming for the source file and function is
      deliberate.  In order to create an executable, &ghc; needs a
      module named <code>Main</code>, and it must contain a function
      named <function>main</function>.  The <function>main</function>
      function is the one that will be called when we run the program
      once we've built it.</para>

    <programlisting><userinput>ghc -o simple Main.hs
	SimpleJSON.o</userinput></programlisting>

    <para id="x_di">This time around, we're omitting the <option>-c</option>
      option when we invoke &ghc;, so it will attempt to generate an
      executable.  The process of generating an executable is called
      <emphasis>linking</emphasis>.  As our command line suggests,
      &ghc; is perfectly able to both compile source files and link
      an executable in a single invocation.</para>

    <para id="x_ei">We're passing &ghc; a new option, <option>-o</option>,
      which takes one argument: this is the name of the executable
      that &ghc; should create.  Here, we've decided to name the
      program <filename>simple</filename>.  On Windows, the program
      will have the suffix <filename>.exe</filename>, but on Unix
      variants there will not be a suffix.</para>

    <para id="x_fi">Finally, we're passing the name of our new source file,
      <filename>Main.hs</filename>, and the object file we already
      compiled, <filename>SimpleJSON.o</filename>.  We must explicitly
      list every one of our files that contains code that should end
      up in the executable.  If we forget a source or object file,
      &ghc; will complain about <quote>undefined symbols</quote>.</para>

    <para id="x_gi">When compiling, we can pass &ghc; any mixture of source and
      object files.  If &ghc; notices that it has already compiled a
      source file into an object once, and we invoke it a second time,
      it will only recompile the source file if we've modified
      it.</para>

    <para id="x_hi">Once &ghc; has finished compiling and linking our
      <filename>simple</filename> program, we can run it from the
      command line.</para>
  </sect1>

  <sect1>
    <title>Printing JSON data</title>

    <para id="x_ii">Now that we have a Haskell representation for
      JSON's types, we'd like to be able to take Haskell values and
      render them as JSON data.</para>

    <para id="x_ji">There are a few ways we could go about this.
      Perhaps the most direct would be to write a rendering function
      that prints a value in JSON form.  We'll quickly show how to do
      this, because it's about time we started interacting with the
      outside world.  Once we're done, we'll explore some more
      interesting approaches.</para>

    <para>Since this will be our first example of printing data, we'll
      be introducing some new functions and notation below.  Rather
      than cover these in depth, we'll skim over them, and defer a
      more extended treatment until <xref
	linkend="io"/>.</para>

    &PutJSON.hs:module;

    <para>The result type of <function>putJValue</function> is
      <type>IO ()</type>, where <type>IO</type> indicates that the
      function performs I/O.  The <function>putStr</function> function
      prints a string, and <function>show</function> returns a string
      representation of a Haskell value.</para>

    <para>Clearly, printing a simple JSON value is easy.</para>

    &putjson.ghci:simple;

    <para>A compound value requires a little more work, so we can
      ensure that it's formatted correctly.</para>
    
    &PutJSON.hs:putJValue;

    <para>We've introduced one unfamiliar piece of notation here, the
      &do; keyword.  In this context, it lets us perform a series of
      actions in sequence.</para>

    <para>To print a <code>JObject</code> value, we begin by printing
      an opening brace.  We must then determine whether we have zero
      or more than zero key/value pairs to print, in order to get the
      formatting right.  If we have no pairs to print, we print
      nothing<footnote>
	<para>If you're already somewhat familiar with Haskell, you'll
	  know that this is not an idiomatic way to do nothing. We'll
	  introduce <code>return ()</code> in <xref
	    linkend="io"/>.</para>
      </footnote>.  Otherwise, we print the first pair, then we loop
      over all the pairs that follow, and print each one preceded by a
      comma.  (The <function>forM_</function> function takes a list
      and a function that can perform I/O, and applies the function to
      every element of the list.)</para>
  </sect1>

  <sect1>
    <title>Another look at rendering JSON</title>

    <para>If simply printing JSON data is both obvious and easy, why
      might we want to consider doing something else?  For example, we
      could easily to modify our printing code above to output to an
      arbitrary file handle.  However, if we wanted to compress the
      data somehow before writing it out, we could not as easily adapt
      the code to do this.</para>

    <para>If we separate the rendering from what we do with the
      rendered data, we grant ourselves more flexibility.  There are
      several Haskell libraries that handle data compression, but they
      all do so by providing very simple compression and decompression
      functions: a compression function takes an uncompressed string
      and returns a compressed string.  If we write a function that
      takes JSON data and produces a rendered string, we can build a
      pipeline: we pass the rendered JSON into our desired compression
      function, and get compressed, rendered JSON back.
    </para>

    <para>To render JSON data, we'll begin by assuming that we already
      have a generic rendering library: we'll develop its skeleton as
      we go.  After we're done writing our client code, we'll go back
      and fill in the details of the rendering library.</para>

    <para>Instead of rendering straight to a string, we'll make our
      JSON renderer work with values of a type that we'll call
      <type>Doc</type>.  The renderer won't be able to see any of the
      internals of the <type>Doc</type> type: instead, it will call
      functions from our rendering library, which will hide the
      details from the client.</para>

    <para>By basing our generic rendering library on this abstract
      <type>Doc</type> type, we can choose an implementation that is
      flexible and efficient.</para>

    <para>We'll name our JSON rendering function
      <function>jvalue</function>.  Rendering one of the basic JSON
      values is a straightforward business.</para>

    &PrettyJSON.hs:jvalue;

    <para>We'll write the <function>text</function> and
      <function>double</function> functions as part of our generic
      rendering library.</para>

  </sect1>

  <sect1>
    <title>Developing Haskell code without going nuts</title>

    <para>During the early stages of our Haskell development
      adventure, we have so many new, unfamiliar concepts to keep
      track of at one time that it can be a challenge to write code
      that compiles at all.</para>

    <para>As we write our first substantial body of code, it's a
      <emphasis>huge</emphasis> help to pause every few minutes and
      try to compile what we've produced so far.  Because Haskell is
      so strongly typed, if our code compiles cleanly, we're assuring
      ourselves that we're not wandering too far off into the
      programming weeds.</para>

    <para>One useful technique for quickly developing the skeleton of
      a program is to write <emphasis>stub</emphasis> versions of
      functions.  For example, we mentioned above that our
      <function>text</function> and <function>double</function>
      functions would be part of our generic library.  If we don't
      provide definitions for those functions, our attempts to
      <quote>compile early, compile often</quote> with our JSON
      renderer will fail, as the compiler won't know anything about
      those functions.  To avoid this problem, we write stub functions
      that don't do anything.</para>

    &PrettyStub.hs:stubs;

    <para>The special value <code>undefined</code> always typechecks,
      no matter where we use it, but it will cause our program to
      crash if we attempt to evaluate it.</para>

    &prettystub.ghci:crash;

    <para>By providing stub definitions for these functions, we allow
      ourselves to compile our code, letting the compiler's type
      checker ensure that our program is correctly typed.</para>

    <sect2>
      <title>Beware of type inference</title>

      <para>A Haskell compiler's ability to infer types is both
	powerful and valuable.  Early on, the temptation to omit as
	many type declarations as possible can be strong: let's simply
	make the compiler figure the whole lot out!</para>

      <para>There is, however, plenty of risk to omitting type
	information: until we gain some experience, we're extremely
	likely to write code that will fail to compile due to simple
	type errors.  When we omit type information, we give the
	compiler more room to infer types that are logical, but
	possibly not at all the types we thought we were using.  The
	error messages that result can be very difficult to
	interpret.</para>

      <para>Every time we add a type signature, we remove a degree of
	freedom from the type inference engine.  This reduces the
	likelihood of divergence between our understanding of our code
	and the compiler's.  Type declarations also act as shorthand
	for us as readers, making it easier for us to do our own
	mental inference of what must be going on in a body of
	code.</para>

      <para>This is not to say that you need to pepper every tiny
	fragment of code with a type declaration.  It is, however,
	generally a good idea to add a signature to every top-level
	function and variable in your code.</para>

      <para>Because <code>undefined</code> will happily typecheck no
	matter where we use it, it's especially important to write
	type signatures when we use <code>undefined</code> to write
	temporary stub definitions for functions whose bodies we don't
	want to fill in yet.</para>
    </sect2>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
