<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="library" revision="unpublished">
  <title>Writing a Library</title>

  <para id="x_Fi">In this chapter, we'll take a look at developing a
    small, but complete, Haskell library.</para>

  <sect1>
    <title>A whirlwind tour of the JSON language</title>

    <para id="x_Gi">The JSON (JavaScript Object Notation) language is
      a small, simple representation for structured data.  Its most
      common use is to transfer data from a web service to a
      browser-based JavaScript application.</para>

    <para id="x_Hi">JSON supports four basic types of value: strings,
      numbers, booleans, and a special value named
      <code>null</code>.</para>

    <programlisting><![CDATA["a string"
12345
true
null]]></programlisting>

    <para id="x_Ii">The language also supports compound values.  Its
      compound types are the array&emdash;an ordered sequence of
      values&emdash;and the struct&emdash;an unordered collection of
      name/value pairs.  The values in a struct or array can be of any
      type.</para>

    <programlisting><![CDATA[[-3.14, true, null, "a string"]
{"numbers": [1,2,3,4,5], "useful": false}]]></programlisting>
  </sect1>

  <sect1>
    <title>Representing JSON data in Haskell</title>

    <para id="x_Ji">To work with JSON data in Haskell, we use an
      algebraic data type to represent the range of possible JSON
      types.  In a text editor, create a file named
      <filename>SimpleJSON.hs</filename>, and insert the following
      contents.</para>

    &SimpleJSON.hs:JValue;

    <para id="x_Ki">Here, we associate each JSON type with a distinct
      constructor. Some of these constructors have parameters: if we
      want to construct a JSON string, we must provide a
      <type>String</type> value as an argument to the
      <code>JString</code> constructor.</para>

    <para id="x_Li">To start experimenting with this code, save the
      file <filename>SimpleJSON.hs</filename> in your editor, switch
      to a &ghci; window, and load the file into &ghci;.</para>

    &simplejson.ghci:load;

    <para id="x_Mi">We can see how to use a constructor to take a
      normal Haskell value and turn it into a JSON value.  To do the
      reverse, we use pattern matching.  Here's a function that we can
      add to <filename>SimpleJSON.hs</filename> that will extract a
      string from a JSON value for us.  If the JSON value actually
      contains a string, our function will wrap the string with the
      <code>Just</code> constructor, otherwise it will return
      <code>Nothing</code>.</para>

    &SimpleJSON.hs:getString;

    <para id="x_Ni">If we save the modified source file, we can reload
      it in &ghci; and try the new definition.</para>

    &simplejson.ghci:reload;

    <para id="x_Oi">A few more accessor functions, and we've got a
      small body of code to work with.</para>

    &SimpleJSON.hs:getters;

  </sect1>

  <sect1>
    <title>The anatomy of a Haskell module</title>

    <para id="x_Pi">A Haskell source file contains a single
      <emphasis>module</emphasis>.  A module lets us determine which
      namesinside the module are accessible from other modules.</para>

    <para id="x_Qi">Normally, a source file begins with a module
      declaration.</para>

    &SimpleJSON.hs:module;

    <para id="x_Ri">The word <code>module</code> is reserved.  It is
      followed by the name of the module, which must begin with a
      capital letter. By convention, a source file has the same
      <emphasis>base name</emphasis> (the component before the suffix)
      as the module it contains, which is why our file
      <filename>SimpleJSON.hs</filename> contains the module
      <code>SimpleJSON</code>.</para>

    <para id="x_Si">Following the module name is a list of
      <emphasis>exports</emphasis>, enclosed in parentheses.  The
      <code>where</code> keyword indicates that the body of the module
      follows.</para>

    <para id="x_Ti">The list of exports indicates which names in this
      module are visible from other modules.  This lets us keep
      private code hidden from the outside world. The special notation
      <code>(..)</code> that follows the name <code>JValue</code>
      indicates that we are exporting both the type and all of its
      constructors.</para>

    <para id="x_Ui">It might seem strange that we can export a type's
      name, but not its constructors.  The ability to do this is
      important: it lets us hide the details of a type from its users,
      making the type <emphasis>abstract</emphasis>.  If we can't see
      a type's constructors, we can't pattern match against a value of
      that type, nor can we construct a new value of that type.  Later
      in this chapter, we'll discuss some situations in which we might
      want to make a type abstract.</para>

    <para id="x_Vi">If we omit the list of exports (including the
      parentheses) from a module declaration, every name in the module
      will be exported: <code>module SimpleJSON where ...</code>.  To
      export no names at all (only infrequently useful), we write an
      empty list using a pair of parentheses: <code>module SimpleJSON
	() where ...</code>.</para>
  </sect1>

  <sect1>
    <title>Compiling Haskell source</title>

    <para id="x_Wi">In addition to the &ghci; interpreter; the &GHC;
      distribution includes an optimising Haskell compiler, named
      &ghc;.  If you're already familiar with a command line compiler
      such as <command>gcc</command> or <command>cl</command> (the
      compiler component of Microsoft's Visual Studio), you'll
      immediately be at home with &ghc;.</para>

    <para id="x_Xi">To compile a source file, we first open a terminal
      or command prompt window, then invoke &ghc; with the name of the
      source file to compile.</para>

    <programlisting><userinput>ghc -c SimpleJSON.hs</userinput></programlisting>

    <para id="x_Yi">The <option>-c</option> option tells &ghc; to only
      generate object code.  If we were to omit the
      <option>-c</option> option, the compiler would attempt to
      generate a complete executable.  That would in turn fail,
      because we haven't written a <function>main</function> function
      yet.</para>

    <para id="x_Zi">After &ghc; completes, if we list the contents of
      the directory, it should contain two new files:
      <filename>SimpleJSON.hi</filename> and
      <filename>SimpleJSON.o</filename>
      (<filename>SimpleJSON.obj</filename> on Windows).  The former is
      an <emphasis>interface file</emphasis>, in which &ghc; stores
      information about the names exported from our module in
      machine-readable form.  The latter is an <emphasis>object
	file</emphasis>, which contains the generated code.</para>
  </sect1>

  <sect1>
    <title>Generating a Haskell program, and importing modules</title>

    <para id="x_ai">Now that we've successfully compiled our minimal
      library, we'll write a tiny program to exercise it.  Create the
      following file in your text editor, and save it as
      <filename>Main.hs</filename>.</para>

    &Main.hs:module;

    <para id="x_bi">Notice the <code>import</code> directive that
      follows the module declaration.  This indicates that we want to
      take all of the names that are exported from the
      <code>SimpleJSON</code> module, and make them available in our
      module.  Any <code>import</code> directives must appear together
      at the beginning of a module.  We cannot scatter them throughout
      a source file.</para>

    <para id="x_ci">Our choice of naming for the source file and
      function is deliberate.  In order to create an executable, &ghc;
      needs a module named <code>Main</code>, and it must contain a
      function named <function>main</function>.  The
      <function>main</function> function is the one that will be
      called when we run the program once we've built it.</para>

    <programlisting><userinput>ghc -o simple Main.hs SimpleJSON.o</userinput></programlisting>

    <para id="x_di">This time around, we're omitting the
      <option>-c</option> option when we invoke &ghc;, so it will
      attempt to generate an executable.  The process of generating an
      executable is called <emphasis>linking</emphasis>.  As our
      command line suggests, &ghc; is perfectly able to both compile
      source files and link an executable in a single
      invocation.</para>

    <para id="x_ei">We're passing &ghc; a new option,
      <option>-o</option>, which takes one argument: this is the name
      of the executable that &ghc; should create.  Here, we've decided
      to name the program <filename>simple</filename>.  On Windows,
      the program will have the suffix <filename>.exe</filename>, but
      on Unix variants there will not be a suffix.</para>

    <para id="x_fi">Finally, we're passing the name of our new source
      file, <filename>Main.hs</filename>, and the object file we
      already compiled, <filename>SimpleJSON.o</filename>.  We must
      explicitly list every one of our files that contains code that
      should end up in the executable.  If we forget a source or
      object file, &ghc; will complain about <quote>undefined
	symbols</quote>.</para>

    <para id="x_gi">When compiling, we can pass &ghc; any mixture of
      source and object files.  If &ghc; notices that it has already
      compiled a source file into an object once, and we invoke it a
      second time, it will only recompile the source file if we've
      modified it.</para>

    <para id="x_hi">Once &ghc; has finished compiling and linking our
      <filename>simple</filename> program, we can run it from the
      command line.</para>
  </sect1>

  <sect1>
    <title>Printing JSON data</title>

    <para id="x_ii">Now that we have a Haskell representation for
      JSON's types, we'd like to be able to take Haskell values and
      render them as JSON data.</para>

    <para id="x_ji">There are a few ways we could go about this.
      Perhaps the most direct would be to write a rendering function
      that prints a value in JSON form.  We'll quickly show how to do
      this, because it's about time we started interacting with the
      outside world.  Once we're done, we'll explore some more
      interesting approaches.</para>

    <para>Since this will be our first example of printing data, we'll
      be introducing some new functions and notation below.  Rather
      than cover these in depth, we'll skim over them, and defer a
      more extended treatment until <xref
	linkend="io"/>.</para>

    &PutJSON.hs:module;

    <para>The result type of <function>putJValue</function> is
      <type>IO ()</type>, where <type>IO</type> indicates that the
      function performs I/O.  The <function>putStr</function> function
      prints a string, and <function>show</function> returns a string
      representation of a Haskell value.</para>

    <para>Clearly, printing a simple JSON value is easy.</para>

    &putjson.ghci:simple;

    <para>A compound value requires a little more work, so we can
      ensure that it's formatted correctly.</para>
    
    &PutJSON.hs:putJValue;

    <para>We've introduced one unfamiliar piece of notation here, the
      &do; keyword.  In this context, it lets us perform a series of
      actions in sequence.</para>

    <para>To print a <code>JObject</code> value, we begin by printing
      an opening brace.  We must then determine whether we have zero
      or more than zero key/value pairs to print, in order to get the
      formatting right.  If we have no pairs to print, we print
      nothing<footnote>
	<para>If you're already somewhat familiar with Haskell, you'll
	  know that this is not an idiomatic way to do nothing. We'll
	  introduce <code>return ()</code> in <xref
	    linkend="io"/>.</para>
      </footnote>.  Otherwise, we print the first pair, then we loop
      over all the pairs that follow, and print each one preceded by a
      comma.  (The <function>forM_</function> function takes a list
      and a function that can perform I/O, and applies the function to
      every element of the list.)</para>
  </sect1>

  <sect1>
    <title>Another look at rendering JSON</title>

    <para>If simply printing JSON data is both obvious and easy, why
      might we want to consider doing something else?  For example, we
      could easily to modify our printing code above to output to an
      arbitrary file handle.  However, if we wanted to compress the
      data somehow before writing it out, we could not as easily adapt
      the code to do this.</para>

    <para>If we separate the rendering from what we do with the
      rendered data, we grant ourselves more flexibility.  There are
      several Haskell libraries that handle data compression, but they
      all do so by providing very simple compression and decompression
      functions: a compression function takes an uncompressed string
      and returns a compressed string.  If we write a function that
      takes JSON data and produces a rendered string, we can build a
      pipeline: we pass the rendered JSON into our desired compression
      function, and get compressed, rendered JSON back.
    </para>

    <para>To render JSON data, we'll begin by assuming that we already
      have a generic rendering library: we'll develop its skeleton as
      we go.  We'll call this module <code>Prettify</code>, so its
      code will go into a source file named
      <filename>Prettify.hs</filename>.  After we're done writing our
      client code, we'll go back and fill in the details of the
      <code>Prettify</code> module.</para>

    <para>Instead of rendering straight to a string, we'll make our
      JSON renderer work with values of a type that we'll call
      <type>Doc</type>.  The renderer won't be able to see any of the
      internals of the <type>Doc</type> type: instead, it will call
      functions from our rendering library, which will hide the
      details from the client.</para>

    <para>By basing our generic rendering library on this abstract
      <type>Doc</type> type, we can choose an implementation that is
      flexible and efficient.</para>

    <para>We'll name our JSON rendering function
      <function>jvalue</function>.  Rendering one of the basic JSON
      values is a straightforward business.</para>

    &PrettyJSON.hs:jvalue;

    <para>We'll write the <function>text</function> and
      <function>double</function> functions as part of our
      <code>Prettify</code> module.</para>

  </sect1>

  <sect1>
    <title>Developing Haskell code without going nuts</title>

    <para>Early on, as we come to grips with Haskell development, we
      have so many new, unfamiliar concepts to keep track of at one
      time that it can be a challenge to write code that compiles at
      all.</para>

    <para>As we write our first substantial body of code, it's a
      <emphasis>huge</emphasis> help to pause every few minutes and
      try to compile what we've produced so far.  Because Haskell is
      so strongly typed, if our code compiles cleanly, we're assuring
      ourselves that we're not wandering too far off into the
      programming weeds.</para>

    <para>One useful technique for quickly developing the skeleton of
      a program is to write <emphasis>stub</emphasis> versions of
      functions.  For example, we mentioned above that our
      <function>text</function> and <function>double</function>
      functions would be provided by our <code>Prettify</code> module.
      If we don't provide definitions for those functions, our
      attempts to <quote>compile early, compile often</quote> with our
      JSON renderer will fail, as the compiler won't know anything
      about those functions.  To avoid this problem, we write stub
      functions that don't do anything.</para>

    &PrettyStub.hs:stubs;

    <para>The special value <code>undefined</code> always typechecks,
      no matter where we use it, but it will cause our program to
      crash if we attempt to evaluate it.</para>

    &prettystub.ghci:crash;

    <para>By providing stub definitions for these functions, we allow
      ourselves to compile our code early on, even though we won't yet
      be able to run it.   By doing this, we can take advantage of the
      compiler's type checker to ensure that our program is sensibly
      typed.</para>

    <sect2>
      <title>Beware of type inference</title>

      <para>A Haskell compiler's ability to infer types is both
	powerful and valuable.  Early on, you'll probably be faced by
	a strong temptation to take advantage of type inference by
	omitting as many type declarations as possible: let's simply
	make the compiler figure the whole lot out!</para>

      <para>There is, however, a downside to skimping on explicit type
	information, and it has a disproportionate effect on the new
	Haskell programmer.  While we work to gain some experience,
	we're initially extremely likely to write code that will fail
	to compile due to straightforward type errors.  When we leave
	out type information, we give the compiler more leeway.  It
	will infer types that are logical and consistent, but quite
	possibly not at all what we thought we were actually using.
	When what we think we're doing diverges from what the compiler
	infers, the error messages that result can be very difficult
	to interpret: not only are we doing something wrong, but the
	compiler's attempt to make sense of what we've tried can
	sometimes briefly lead us astray.</para>

      <para>Consider an example: let's say we write a function that we
	think returns a <type>String</type>, but we don't write a type
	signature for it.</para>

      &Trouble.hs:upcaseFirst;

      <para>Here, we want to upper-case the first character of a word,
	but we've forgotten to append the rest of the word onto the
	result.  We think our function's type is <type>String -&gt;
	  String</type>, but the compiler will correctly infer its
	type as <type>String -> Char</type>.  Let's say we then try to
	use this function somewhere else.</para>

      &Trouble.hs:camelCase;
      
      <para>When we try to compile this code or load it into &ghci;,
	we won't necessarily get an obvious error message.</para>

      &trouble.ghci:load;

      <para>Notice that the error is reported where we
	<emphasis>use</emphasis> the <function>upcaseFirst</function>
	function.  If we're erroneously convinced that our definition
	and type for <function>upcaseFirst</function> are correct, we
	may end up staring at the wrong piece of code for quite a
	while, until enlightenment strikes.</para>

      <para>Every time we write a type signature, we remove a degree
	of freedom from the type inference engine.  This reduces the
	likelihood of divergence between our understanding of our code
	and the compiler's.  Type declarations also act as shorthand
	for ourselves as readers of our own code, making it easier for
	us to do our own mental inference of what must be going
	on.</para>

      <para>This is not to say that we need to pepper every tiny
	fragment of code with a type declaration.  It is, however,
	generally a good idea to add a signature to every top-level
	function and variable in our code.  It's best to start out
	fairly aggressive with explicit type signatures, and slowly
	ease back as your mental model of how type checking works
	becomes more accurate.</para>

      <tip>
	<title>Explicit types and undefined values</title>

	<para>Because the special value <code>undefined</code> will
	  happily typecheck no matter where we use it, it's especially
	  important to write type signatures when we start slinging it
	  around. If we use <code>undefined</code> to stub in a
	  temporary definition for a function, and we don't write a
	  type signature for the function, we'll potentially be able
	  to use that stubbed definition in completely nonsensical
	  contexts, thus planting the seed of later confusion.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1>
    <title>Pretty printing a string</title>

    <para>When it comes to to pretty printing a string value, our code
      gets a little complicated: JSON strings have some moderately
      involved escaping rules that we must follow.</para>

    <para>At the highest level, a string is just a series of
      characters wrapped in quotes.</para>

      &PrettyJSON.hs:string;

    <para>The <function>enclose</function> function simply wraps a
      <type>Doc</type> value with an opening and closing
      character.</para>

      &PrettyJSON.hs:enclose;

    <para>To do this, it uses the <function>(&lt;&gt;)</function>
      function from our pretty printing library, which appends two
      <type>Doc</type> values: it's the <type>Doc</type> equivalent of
      <function>(++)</function>.</para>

      &PrettyStub.hs:append;

    <para>Our pretty printing library also provides
      <function>hcat</function>, which concatenates multiple
      <type>Doc</type> values into one: it's the analogue of
      <function>concat</function> for lists.</para>

      &PrettyStub.hs:hcat;

    <para>Our <function>string</function> function thus applies the as
      yet unseen <function>oneChar</function> function to every
      character in a string, concatenates the lot, and encloses the
      result in quotes.  What does <function>oneChar</function> look
      like?</para>

      &PrettyJSON.hs:oneChar;

    <para>The <function>specialEscapes</function> value is a list of
      pairs that we call an <emphasis>association list</emphasis>, or
      <emphasis>alist</emphasis> for short: it maps a few characters
      to simple escaped representations.</para>

      &prettyjson.ghci:simpleEscapes;

    <para>Our &case; expression attempts to see if our character has a
      match in this alist.  If we find the match, we emit it,
      otherwise we might need to escape the character in a more
      complicated way. If so, we perform this more complicated
      escaping.  Only if neither kind of escaping is required do we
      emit the plain character.</para>

    <para>The more complicated escaping involves turning a character
      into the string <quote><code>\u</code></quote> followed by a
      four-character sequence of hexadecimal digits representing the
      numeric value of the Unicode code point.</para>

      &PrettyJSON.hs:smallHex;

    <para>The <function>showHex</function> function comes from the
      <code>Numeric</code> library, and returns a hexadecimal
      representation of a number.</para>

      &prettyjson.ghci:showHex;

    <para>The <function>replicate</function> function is provided by
      the Prelude, and builds a fixed-length repeating list of its
      argument.</para>

      &prettyjson.ghci:replicate;

    <para>There's a wrinkle: the four-digit encoding that
      <function>smallHex</function> provides can only represent
      Unicode code points up to <code>0xffff</code>.  This portion of
      the Unicode code space is called the <emphasis>basic
	multilingual plane</emphasis>: it contains most of the world's
      common characters and glyphs. However, the Unicode code space
      extends up to <code>0x10ffff</code>: values between
      <code>0x10000</code> and <code>0x10ffff</code> are said to
      inhabit one of the <emphasis>astral planes</emphasis>.</para>

    <para>To properly represent an astral plane code point in a JSON
      string, we must decompose it into two <emphasis>surrogate
	characters</emphasis>.  For our purposes, we don't need to
      care what a surrogate character is: we'll look at it instead as
      an opportunity to perform some bit-level manipulation of Haskell
      numbers.</para>

      &PrettyJSON.hs:astral;

    <para>The <function>shiftR</function> function comes from the
      <code>Data.Bits</code> module, and shifts a number to the right.
      The <function>(.&amp;.)</function> function, also from
      <code>Data.Bits</code>, performs a bit-level
      <emphasis>and</emphasis> of two values.</para>

      &prettyjson.ghci:bits;

    <para>Now that we've written <function>smallHex</function> and
      <function>astral</function>, we can provide a definition for
      <function>hexEscape</function>.</para>

      &PrettyJSON.hs:hexEscape;
  </sect1>

  <sect1>
    <title>Arrays and objects, and the module header</title>

    <para>Compared to strings, pretty printing arrays and objects is a
      snap.  We already know that the two are visually similar: each
      starts with an opening character, followed by a series of values
      separated with commas, followed by a closing character. Let's
      write a function that captures the common structure of arrays
      and objects.</para>

      &PrettyJSON.hs:series;

    <para>We'll start by interpreting this function's type.  It takes
      an opening and closing character, then a function that knows how
      to pretty print a value of some unknown type <varname
	role="type">a</varname>, followed by a list of values of type
      <varname role="type">a</varname>, and it returns a value of type
      <type>Doc</type>.</para>

    <para>We have already written <function>enclose</function>, a
      which wraps a <type>Doc</type> value in opening and closing
      characters.  The <function>fsep</function> function will live in
      our <code>Prettify</code> module.  It combines a series of
      <type>Doc</type> values into one, possibly wrapping lines if the
      output will not fit on a single line.  The
      <function>punctuate</function> function will also live in our
      <code>Prettify</code> module, and we can define it in terms of
      functions for which we've already written stubs.</para>

    &Prettify.hs:punctuate;

    <para>With this definition of <function>series</function>, pretty
      printing an array is entirely straightforward.  We add this
      equation  to the end of the block we've already written for our
      <function>jvalue</function> function.</para>

      &PrettyJSON.hs:jvalue.array;

    <para>To pretty print an object, we need to do only a little more
      work: for each element, we have both a name and a value to deal
      with.</para>

      &PrettyJSON.hs:jvalue.object;
  </sect1>

  <sect1>
    <title>Writing a module header, and good defensive coding</title>

    <para>The header at the beginning of our
      <filename>PrettyJSON.hs</filename> source file looks like
      this.</para>

    &PrettyJSON.hs:module;

    <para>We're only exporting one name from this module:
      <function>jvalue</function>, our pretty printing function.  The
      other functions in the module are purely present to support
      <function>jvalue</function>, so there's no reason to make them
      visible to other modules.</para>

    <para>Regarding imports, the <code>Numeric</code> and
      <code>Data.Bits</code> modules are distributed with &GHC;. We've
      already written the <code>SimpleJSON</code> module, and filled
      our <code>Prettify</code> module with skeletal definitions.
      Notice that there's no difference in the way we import standard
      modules from those we've written ourselves.</para>

    <para>With each <code>import</code> directive, we explicitly list
      each of the names we want to bring into our module's namespace.
      This is not required: if we omit the list of names, all of the
      names exported from a module will be available to us.  However,
      it's generally a good idea to write an explicit import
      list.</para>

    <itemizedlist>
      <listitem>
	<para>An explicit list makes it clear which names we're
	  importing from where.  This will make it easier for a reader
	  to look up documentation, if they run across an unfamiliar
	  module.</para>
      </listitem>
      <listitem>
	<para>Occasionally, a library maintainer will remove or rename
	  a function.  If a function disappears from a third party
	  module that we use, any resulting compilation error is
	  likely to happen long after we've written the module.  The
	  explicit list of imported names can act as a reminder to
	  ourselves of where we had been importing the missing name
	  from, which will help us to pinpoint the problem more
	  quickly.</para>
      </listitem>
      <listitem>
	<para>It can also occur that someone will add a name to a
	  module that is identical to a name already in our own code.
	  If we don't use an explicit import list, we'll end up with
	  the same name in our module twice.  If we use that name,
	  &GHC; will report an error due to the ambiguity.  An
	  explicit list lets us avoid the possibility of accidentally
	  importing an unexpected new name.</para>
      </listitem>
    </itemizedlist>

    <para>This idea of using explicit imports is a guideline that
      usually makes sense, not a hard-and-fast rule. Occasionally,
      we'll need so many names from a module that listing each one
      becomes messy.  In other cases, a module might be so widely used
      that that a moderately experienced Haskell programmer will
      probably know which names come from that module.</para>
  </sect1>

  <sect1>
    <title>Fleshing out the pretty printing library</title>

    <para>In our <code>Prettify</code> module, we represent our
      <type>Doc</type> type as an algebraic data type.</para>

    &Prettify.hs:Doc;

    <para>Notice that the <type>Doc</type> type describes a tree: the
      <code>Concat</code> and <code>Union</code> constructor create an
      internal node from two other <type>Doc</type> values, while the
      <code>Empty</code> and other simple constructors build
      leaves.</para>
    
    <para>In the header of our module, we will export the name of the
      type, but not any of its constructors: this will prevent modules
      that use the <type>Doc</type> type from creating and pattern
      matching against <type>Doc</type> values.</para>

    <para>Instead, to create a <type>Doc</type>, a user of the
      <code>Prettify</code> module will call a function that we
      provide.  Here are the simple construction functions.</para>

    &Prettify.hs:basic;

    <para>The <code>Line</code> constructor represents a line break.
      The <function>line</function> function creates
      <emphasis>hard</emphasis> line breaks, which always appear in
      the pretty printer's output.  Sometimes we'll want a
      <emphasis>soft</emphasis> line break, which is only used if a
      line is too wide.  We'll introduce a
      <function>softline</function> function shortly.</para>

    &Prettify.hs:line;

    <para>Almost as simple as the basic constructors is the
      <function>(&lt;&gt;)</function> function, which concatenates two
      <type>Doc</type> values.</para>

    &Prettify.hs:append;
    
    <para>Notice that we pattern match against <code>Empty</code>:
      concatenating a <type>Doc</type> value with <code>Empty</code>
      on the left or right has no effect.  This keeps us from bloating
      the tree with useless values.</para>

    &prettify.ghci:append;

    <tip>
      <title>A mathematical moment</title>

      <para>If we briefly put on our mathematical hats, we can say
	that <code>Empty</code> is the identity under concatenation.
	Taking the mathematical perspective has useful practical
	consequences, and we'll explain why later.</para>

      <remark>Add a reference to wherever we introduce
	monoids.</remark>
    </tip>

    <para>Our <function>hcat</function> and <function>fsep</function>
      functions concatenate a list of <type>Doc</type> values into
      one.  In <xref
	linkend="fp.fold.exercises"/>, we mentioned that we could
      define concatenation for lists using
      <function>foldr</function>.</para>

    &Concat.hs:concat;

    <para>Since <function>(&lt;&gt;)</function> is analogous to
      <function>(:)</function>, and <function>empty</function> to
      <function>[]</function>, we can see how we might write
      <function>hcat</function> and <function>fsep</function> as
      folds, too.</para>
      
    &Prettify.hs:hcat;

    <para>The definition of <function>fsep</function> depends on
      several other functions.</para>

    &Prettify.hs:fsep;

    <para>These take a little explaining.  The
      <function>softline</function> function should insert a newline
      if the current line has become too wide, or a space otherwise.
      How can we do this if our <type>Doc</type> type doesn't contain
      any information about rendering?  Our answer is that every time
      we encounter a soft newline, we maintain
      <emphasis>two</emphasis> alternative representations of the
      document, using the <code>Union</code> constructor.</para>
     
    &Prettify.hs:group;

    <para>Our <function>flatten</function> function replaces a
      <code>Line</code> with a space, turning two lines into one
      longer line.</para>

    &Prettify.hs:flatten;

    <para>Notice that we always call <function>flatten</function> on
      the left element of a <code>Union</code>: the left of each
      <code>Union</code> is always the same width as, or wider than,
      the right.  We'll be making use of this property in our rendering
      functions below.</para>

      <note>
	<title>Infix use of constructors</title>

	<para>We've used infix notation to represent the
	<code>Concat</code> and <code>Union</code> constructors in the
	final two patterns of our &case; expression.  This has no
	effect on the meaning of our code.  Just like using a
	constructor or function infix in an application, it's merely a
	small change for readability.</para>
      </note>

    <sect2>
      <title>Compact rendering</title>

      <para>We frequently need to use a representation for a piece of
	data that contains as few characters as possible.  For
	example, if we're sending JSON data over a network connection,
	there's no sense in laying it out nicely: the software on the
	far end won't care whether the data is pretty or not, and the
	added white space needed to make the layout look good would
	add a lot of overhead.</para>

      <para>For these cases, and because it's a simple piece of code
	to start with, we provide a bare-bones compact rendering
	function.</para>

      &Prettify.hs:compact;

      <para>The <function>compact</function> function wraps its
	argument in a list, and applies the
	<function>transform</function> helper function to it.  The
	<function>transform</function> function treats its argument as
	a stack of items to process, where the first element of the
	list is the top of the stack.</para>

      <para>The <function>transform</function> function's
	<code>(d:ds)</code> pattern breaks the stack into its head,
	<varname>d</varname>, and the remainder,
	<varname>ds</varname>. In our &case; expression, the first
	several branches recurse on <varname>ds</varname>, consuming
	one item from the stack for each recursive application.  The
	last two branches add items in front of <varname>ds</varname>:
	the <code>Concat</code> branch adds both elements to the
	stack, while the <code>Union</code> branch ignores its left
	element, on which we called <function>flatten</function>, and
	adds its right element to the stack.</para>

      <para>We have now fleshed out enough of our original skeletal
	definitions that we can try out our
	<function>compact</function> function in &ghci;.</para>

      &prettyjson.ghci:compact;

      <para>To better understand how the code works, let's look at a
	simpler example in more detail.</para>
      
      &prettyjson.ghci:foo;

      <para>When we apply <function>compact</function>, it turns its
	argument into a list and applies
	<function>transform</function>.</para>

      <itemizedlist>
	<listitem>
	  <para>The <function>transform</function> function receives a
	    one-item list, which matches the <code>(d:ds)</code>
	    pattern. Thus <varname>d</varname> is the value
	    <code>Concat (Char 'f') (Text "oo")</code>, and
	    <varname>ds</varname> is the empty list,
	    <code>[]</code>.</para>
	  <para>Since <varname>d</varname>'s constructor is
	    <code>Concat</code>, the <code>Concat</code> pattern
	    matches in the &case; expression.  On the right hand side,
	    we add <code>Char 'f'</code> and <code>Text "oo"</code> to
	    the stack, and call
	    <function>transform</function>recursively.</para>
	</listitem>
	<listitem>
	  <itemizedlist>
	    <listitem>
	      <para>The <function>transform</function> function
		receives a two-item list, again matching the
		<code>(d:ds)</code> pattern.  The variable
		<varname>d</varname> is bound to <code>Char
		  'f'</code>, and <varname>ds</varname> to <code>[Text
		  "oo"]</code>.</para>
	      <para>The &case; expression matches in the
		<code>Char</code> branch.  On the right hand side, we
		use <function>(:)</function> to construct a list whose
		head is <code>'f'</code>, and whose body is the result
		of a recursive application of
		<function>transform</function>.</para>
	    </listitem>
	    <listitem>
	      <itemizedlist>
		<listitem>
		  <para>The recursive invocation receives a one-item
		    list. The variable <varname>d</varname> is bound
		    to <code>Text "oo"</code>, and
		    <varname>ds</varname> to <code>[]</code>.</para>
		  <para>The &case; expression matches in the
		    <code>Text</code> branch.  On the right hand side,
		    we use <function>(++)</function> to concatenate
		    <code>"oo"</code> with the result of a recursive
		    application of
		    <function>transform</function>.</para>
		</listitem>
		<listitem>
		  <itemizedlist>
		    <listitem>
		      <para>In the final invocation,
			<function>transform</function> is invoked with
			an empty list, and returns an empty
			string.</para>
		    </listitem>
		  </itemizedlist>
		</listitem>
		<listitem>
		  <para>The result is <code>"oo" ++ ""</code>.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>The result is <code>'f' : "oo" ++ ""</code>.</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>True pretty printing</title>

      <para>While our <function>compact</function> function is useful
	for machine-to-machine communication, its result is not always
	easy for a human to follow: there's very little information on
	each line. To generate more readable output, we'll write
	another function, <function>pretty</function>. Compared to
	<function>compact</function>, <function>pretty</function>
	takes one extra argument: the maximum width of a line, in
	columns.  (We're assuming that our typeface is of fixed
	width.)</para>

      &Prettify.hs:pretty.type;

      <para>To be more precise, this <type>Int</type> parameter
	controls the behaviour of <function>pretty</function> when it
	encounters a <function>softline</function>.  Only at a
	<function>softline</function> does <function>pretty</function>
	have the option of either continuing the current line or
	beginning a new line.  Elsewhere, we must strictly follow the
	directives set out by the person using our pretty printing
	combinators.</para>

      <para>Here's the core of our implementation</para>

      &Prettify.hs:pretty;

      <para>Our <function>best</function> helper function takes two
	arguments: the number of columns emitted so far on the current
	line, and the list of remaining <type>Doc</type> values to
	process.</para>

      <para>In the simple cases, <function>best</function> updates the
	<varname>col</varname> variable in straightforward ways as it
	consumes the input.  Even the <code>Concat</code> case is
	obvious: we push the two concatenated components onto our
	stack/list, and don't touch <varname>col</varname>.</para>

      <para>The interesting case is concerned with the
	<code>Union</code> constructor.  Recall that we applied
	<function>flatten</function> to the left element, and did
	nothing to the right.  Also, remember that
	<function>flatten</function> replaces newlines with spaces.
	Therefore, our job is to see which (ir either) of the two
	layouts, the <function>flatten</function>ed one or the
	original, will fit into our <varname>width</varname>
	restriction.</para>

      &Prettify.hs:nicest;

      <para>To do this, we write a small helper that determines
	whether a single line of a rendered <type>Doc</type> value
	will fit into a given number of columns.</para>

      &Prettify.hs:fits;

    </sect2>

    <sect2>
      <title>Following the pretty printer</title>

      <para>In order to understand how this code works, let's first
	consider a very simple <type>Doc</type> value.</para>

      &prettify.ghci:simple;

      <para>We'll call <function>pretty 2</function> on this value.
	When we first apply <function>best</function>, the value of
	<code>col</code> is zero.  It matches the <code>Concat</code>
	case, pushes the values <code>Union (Char ' ') Line</code> and
	<code>Char 'a'</code> onto the stack, and applies itself
	recursively.  In the recursive application, it matches on
	<code>Union (Char ' ') Line</code>.</para>

      <para>At this point, we're going to ignore Haskell's usual order
	of evaluation.  This keeps our explanation of what's going on
	simple, without changing the end result.  We now have two
	subexpressions, <code>best 0 [Char ' ', Char 'a']</code> and
	<code>best 0 [Line, Char 'a']</code>.  The first evaluates to
	<code>" a"</code>, and the second to <code>"\na"</code>.  We
	then substitute these into the outer expression to give
	<code>nicest 0 " a" "\na"</code>.</para>
	
      <para>To figure out what the result of
	<function>nicest</function> is here, we do a little
	substitution.  The values of <varname>width</varname> and
	<varname>col</varname> are 0 and 2, respectively, so
	<varname>least</varname> is 0, and <code>width - least</code>
	is 2.  We quickly evaluate <code>2 `fits` " a"</code> in
	&ghci;.</para>

      &prettify.ghci:fits;

      <para>Since this evaluates to <code>True</code>, the result of
	<function>nicest</function> here is <code>" a"</code>.</para>

      <para>If we apply our <function>pretty</function> function to
	the same JSON data as earlier, we can see that it produces
	different output depending on the width that we give
	it.</para>

      &prettyjson.ghci:pretty;

    </sect2>

    <sect2>
      <title>Exercises</title>

      <para>We can make a number of interesting improvements to our
	pretty printer.</para>

      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para>Our pretty printer does not take
	      <emphasis>nesting</emphasis> into account. Whenever we
	      open parentheses, braces, or brackets, any lines that
	      follow should be indented so that they are aligned with
	      the opening character until a matching closing character
	      is encountered.</para>

	    <para>Add support for nesting, with a controllable amount
	      of indentation.</para>

	    &Prettify.hs:nest;

	  </question>
	</qandaentry>
      </qandaset>
    </sect2>

    <sect2>
      <title>Practical pointers, and further reading</title>

      <para>Blah.</para>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
