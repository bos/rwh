<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.find" revision="unpublished">
  <title>I/O case study: a library for searching the
    filesystem</title>

  <para>The problem of <quote>I know I have this file, but I don't
      know where it is</quote> has been around for as long as
    computers have had hierarchical filesystems.  The fifth edition of
    Unix introduced the <command>find</command> command in 1974; it
    remains indispensable today.  The state of the art has come a long
    way: modern operating systems ship with advanced document indexing
    and search capabilities.</para>

  <para>There's still a valuable place for
    <command>find</command>-like capability in the programmer's
    toolbox.  In this chapter, we'll develop a library that gives us
    many of <command>find</command>'s capabilities, without leaving
    Haskell.</para>

  <sect1 id="hs.find.getRecursiveContents">
    <title>The find command</title>

    <para>If you don't use a Unix-like operating system, or you're not
      a heavy shell user, it's quite possible you won't have heard of
      <command>find</command>.  Given a list of directories, it
      searches each one recursively and prints the name of every entry
      that matches an expression.</para>

    <para>Individual expressions can take such forms as <quote>name
	matches this glob pattern</quote>, <quote>entry is a plain
	file</quote>, <quote>last modified before this date</quote>,
      and many more.  They can be stitched together into more complex
      expressions using <quote>and</quote> and <quote>or</quote>
      operators.</para>
  </sect1>

  <sect1>
    <title>Starting simple: recursively listing a directory</title>

    <para>Before we plunge into designing our library, let's solve a
      few smaller problems.  Our first problem is to get a list of the
      contents of a directory at all, and to do so recursively.</para>

    &RecursiveContents.hs:RecursiveContents;

    <para>The <function>filter</function> expression ensures that a
      listing for a single directory won't contain the special
      directory names <literal>.</literal> or <literal>..</literal>,
      which refer to the current and parent directory, respectively.
      If we were to forget to filter these out, we'd recurse
      endlessly.</para>

    <para>The <function>forM</function> function is a
      <function>flip</function>ped version of
      <function>mapM</function>, which we first saw in <xref
	linkend="hs.io.monad"/>.</para>

    &recursivecontents.ghci:forM;

    <para>The body of the loop checks to see whether the current entry
      is a directory.  If it is, it recursively calls
      <function>getRecursiveContents</function> to list that directory.
      Otherwise, it returns a single-element list that is the name of
      the current entry.  Note that in the body of the loop, the
      <function>return</function> is returning a value
      <emphasis>from</emphasis> the anonymous function that is the
      loop body <emphasis>to</emphasis> its caller,
      <function>forM</function>.  It is <emphasis>not</emphasis>
      returning from <function>getRecursiveContents</function>.</para>

    <remark>Tie this into our earlier discussion of
      <function>return</function>.</remark>

    <para>Another thing worth pointing out is the use of the variable
      <varname>isDirectory</varname>.  In an imperative language such
      as Python, we'd normally write <code>if
	os.path.isdir(path)</code>.  However, the
      <function>doesDirectoryExist</function> function is an
      <emphasis>action</emphasis>; its return type is <type>IO
	Bool</type>, not <type>Bool</type>.  Since an &if; expression
      requires an expression of type <type>Bool</type>, we have to use
      <code>&lt;-</code> to get the <type>Bool</type> result of the
      action out of its <type>IO</type> wrapper, so we can use the
      plain, unwrapped <type>Bool</type> in the &if;.</para>

    <para>Finally, each call to the loop body yields a list of names,
      so the result of <function>forM</function> is a list of lists.
      We use <function>concat</function> to flatten it into a single
      list.</para>

    <sect2>
      <title>Revisiting anonymous and named functions</title>

      <para>In <xref linkend="hs.fp.anonymous"/>, we listed some
	reasons not to use anonymous functions, and yet here we are,
	using one as the body of a loop. This is one of the most
	common uses of anonymous functions in Haskell.</para>

      <para>We've already seen from their types that
	<function>forM</function> and <function>mapM</function> take
	functions as arguments. Most loop bodies are blocks of code
	that only appear once in a program. Since we're most likely to
	use a loop body in only one place, why give it a name?</para>

      <para>Of course, it does happen that we need to deploy exactly
	the same code in several different loops. Rather than cutting
	and pasting the same anonymous function, it makes sense here
	to take an existing anonymous function and give it a
	name.</para>
    </sect2>

    <sect2>
      <title>Why provide both mapM and forM?</title>

      <para>It might seem a bit odd that there exist two functions
	that are identical but for the order in which they accept
	their arguments.  However, <function>mapM</function> and
	<function>forM</function> are convenient in different
	circumstances.</para>

      <para>Consider our example above, using an anonymous function as
	a loop body.  If we were to use <function>mapM</function>
	instead of <function>forM</function>, we'd have to place the
	variable <varname>properNames</varname> after the body of the
	function.  In order to get the code to parse correctly, we'd
	have to wrap the entire anonymous function in parentheses, or
	replace it with a named function that would otherwise be
	unnecessary.  Try it yourself: copy the code above, replacing
	<function>forM</function> with <function>mapM</function>, and
	see what this does to the readability of the code.</para>

      <para>By contrast, if the body of the loop was already a named
	function, and the list over which we were looping was computed
	by a complicated expression, we'd have a good case for using
	<function>mapM</function> instead.</para>

      <para>The stylistic rule of thumb to follow here is to use
	whichever of <function>mapM</function> or
	<function>forM</function> lets you write the tidiest code.  If
	the loop body and the expression computing the data over which
	you're looping are both short, it doesn't matter which you
	use.  If the loop is short, but the data is long, use
	<function>mapM</function>.  If the loop is long, but the data
	short, use <function>forM</function>.  And if both are long,
	use a &let; or &where; clause to make one of them short.  With
	just a little practice, it will become obvious which of these
	approaches is best in every instance.</para>
    </sect2>
  </sect1>

  <sect1 id="hs.find.simpleFind">
    <title>A naive finding function</title>

    <para>We can use our <function>getRecursiveContents</function>
      function as the basis for a simple-minded file finder.</para>

    &SimpleFinder.hs:simpleFind;

    <para>This function takes a predicate that we use to filter the
      names returned by <function>getRecursiveContents</function>.
      Each name passed to the predicate is a complete path, so how can
      we perform a common operation like <quote>find all files ending
	in the extension <code>.c</code></quote>?</para>

    <para>The <code>System.FilePath</code> module contains numerous
      invaluable functions that help us to manipulate file names. In
      this case, we want <function>takeExtension</function>.</para>

    &simplefinder.ghci:takeExtension;

    <para>This gives us a simple matter of writing a function that
      takes a path, extracts its extension, and compares it with
      <code>.c</code>.</para>
    
    &simplefinder.ghci:find.c;

    <para>While <function>simpleFind</function> works, it has a few
      glaring problems.  The first is that the predicate is not very
      expressive.  It can only look at the name of a directory entry,
      and not for example find out whether it's a file or a directory.
      This means that our attempt to use
      <function>simpleFind</function> will list directories ending in
      <code>.c</code> as well as files with the same extension.</para>

    <para>The second problem is that <function>simpleFind</function>
      gives us no control over how it traverses the filesystem.  To
      see why this is significant, consider the problem of searching
      for a source file in a tree managed by the Subversion revision
      control system.  Subversion maintains a private
      <filename>.svn</filename> directory in every directory that it
      manages; each one contains many subdirectories and files that
      are of no interest to us.  While we can easily enough filter out
      any path containing <filename>.svn</filename>, it's more
      efficient to simply avoid traversing these directories in the
      first place.  For example, one of us has a Subversion source
      tree containing 45,000 files, 30,000 of which are stored in
      1,200 different <filename>.svn</filename> directories.  It's
      cheaper to avoid traversing those 1,200 directories than to
      filter out the 30,000 files they contain.</para>

    <para>Finally, <function>simpleFind</function> is strict.  If we
      have a million files to traverse, we get one huge result
      containing a million names, instead of a piecemeal lazy stream
      of results.  This is bad for both resource usage and
      responsiveness.</para>

    <para>In the sections that follow, we'll overcome each one of
      these problems.</para>
  </sect1>

  <sect1>
    <title>Predicates: from poverty to riches, while remaining
      pure</title>

    <para>Our predicates can only look at file names.  This excludes a
      wide variety of interesting behaviours: for instance, what if
      we'd like to list files of greater than a given size?</para>

    <para>An easy reaction to this is to reach for <type>IO</type>:
      instead of our predicate being of type <type>FilePath ->
	Bool</type>, why don't we change it to <type>FilePath -> IO
	Bool</type>?  This would let us perform arbitrary I/O as part
      of our predicate.  As appealing as this might seem, it's also
      potentially a problem: such a predicate could have arbitrary
      side effects, since a function with return type <type>IO
	a</type> can have whatever side effects it pleases.</para>

    <para>Let's enlist the type system in our quest to write more
      predictable, less buggy code: we'll keep predicates pure by
      avoiding the taint of <quote>IO</quote>.  This will ensure that
      they can't have any nasty side effects.   We'll feed them more
      information, too, so that they can gain the expressiveness we
      want without also becoming potentially dangerous.</para>

    <para>Haskell's portable <code>System.Directory</code> module
      provides a useful, albeit limited, set of file metadata.</para>

    &simplefinder.ghci:System.Directory;

    <itemizedlist>
      <listitem>
	<para>We can use <function>doesFileExist</function> and
	  <function>doesDirectoryExist</function> to determine whether
	  a directory entry is a file or a directory.  There are not
	  yet portable ways to query for other file types that have
	  become widely available in recent years, such as named
	  pipes, hard links and symbolic links.</para>

	&simplefinder.ghci:doesExist;

      </listitem>

      <listitem>
	<para>The <function>getPermissions</function> function lets us
	  find out whether certain operations on a file or directory
	  are allowed.</para>

	&simplefinder.ghci:getPermissions;

	<para>Directories are always <function>searchable</function>;
	  files never are.</para>
      </listitem>

      <listitem>
	<para>Finally, <function>getModificationTime</function> tells
	  us when an entry was last modified.</para>

	&simplefinder.ghci:getModificationTime;

      </listitem>
    </itemizedlist>

    <para>If we stick with portable, standard Haskell code, these
      functions are all we have at our disposal.  (We can also find a
      file's size using a small hack; see below.)  They're also quite
      enough to let us illustrate the principles we're interested in,
      without letting us get carried away with an example that's too
      expansive.  If you need to write more demanding code, the
      <code>System.Posix</code> and <code>System.Win32</code> module
      families provide much more detailed file metadata for the two
      major modern computing platforms.</para>

    <para>How many pieces of data does our new, richer predicate need
      to see?  Since we can find out whether an entry is a file or a
      directory by looking at its <type>Permissions</type>, we don't
      need to pass in the results of
      <function>doesFileExist</function> or
      <function>doesDirectoryExist</function>.  We thus have four
      pieces of data that a richer predicate needs to look at.</para>

    &BetterPredicate.hs:Predicate;

    <para>Notice that the return value of this predicate is
      <type>Bool</type>, not <type>IO Bool</type>: the predicate is
      pure, and cannot perform I/O. With this type in hand, our more
      expressive finder function is still quite trim.</para>

    &BetterPredicate.hs:betterFind;

    <para>Let's walk through the code.  We'll talk about
      <function>getFileSize</function> in some detail soon, so let's
      skip over it for now.</para>

    <para>We can't use <function>filter</function> to call our
      predicate <varname>p</varname>, as <varname>p</varname>'s
      purity means it cannot do the I/O needed to gather the metadata
      it requires.</para>

    <para>This leads us to the unfamiliar function
      <function>filterM</function>.  It behaves like the normal
      <function>filter</function> function, but in this case it
      evaluates its predicate in the <type>IO</type> monad, allowing
      the predicate to perform I/O.</para>

    &simplefinder.ghci:filterM;

    <para>Our <function>check</function> predicate is an I/O-capable
      wrapper for our pure predicate <varname>p</varname>. It does all
      the <quote>dirty</quote> work of I/O on <varname>p</varname>'s
      behalf, so that we can keep <varname>p</varname> incapable of
      unwanted side effects.  After gathering the metadata,
      <function>check</function> calls <varname>p</varname>, then uses
      <function>return</function> to wrap <varname>p</varname>'s
      result with <type>IO</type>.</para>
  </sect1>

  <sect1>
    <title>Sizing a file safely</title>

    <para>Although <code>System.Directory</code> doesn't let us find
      out what size a file is, we can use the similarly portable
      <code>System.IO</code> module to do this.  It contains a
      function named <function>hFileSize</function>, which returns the
      size in bytes of an open file.  Here's a simple function that
      wraps it.</para>

    &BetterPredicate.hs:simpleFileSize;

    <para>While this function works, it's not yet suitable for us to
      use.  In <function>betterFind</function>, we call
      <function>getFileSize</function> unconditionally on all kinds of
      directory entry, and expect it to return <code>Nothing</code> if
      an entry is not a plain file, or the size wrapped by
      <code>Just</code> otherwise.  This function instead throws an
      exception if an entry is not a plain file or could not be opened
      (perhaps due to insufficient permissions), and returns the size
      unwrapped.</para>

    <para>Here's a safer version of this function.</para>

    &BetterPredicate.hs:saferFileSize;

    <para>The body of the function is almost identical, save for the
      <function>handle</function> clause.  This is our first use of an
      exception handler.  Exception-related code lives in the
      <code>Control.Exception</code> module.</para>

    &simplefinder.ghci:handle;

    <para>The <function>handle</function> function works by calling
      its second argument.  If that action returns normally,
      <function>handle</function> returns its result.  If the action
      throws an exception, <function>handle</function> catches the
      exception and passes it to the first action.  That action is
      free to do whatever it wants.  It can rethrow the exception or
      throws a new exception (topics we'll return to in chapter XXX),
      or it can return some value, which will in turn be returned by
      <function>handle</function>.</para>

    <para>Our exception handler above ignores the exception it's
      passed, and returns <code>Nothing</code>.  The only change to
      the body that follows is that it wraps the file size with
      <function>Just</function>.</para>

    <para>The <function>saferFileSize</function> function now has the
      correct type signature, and it won't throw any exceptions.  But
      it's still not completely well behaved.  There are directory
      entries on which <function>openFile</function> will succeed, but
      <function>hFileSize</function> will throw an exception.  This
      can happen with, for example, named pipes.  Such an exception
      will be caught by <function>handle</function>, but our call to
      <function>hClose</function> will never occur.</para>

    <para>A Haskell implementation will automatically close the file
      handle when it notices that the handle is no longer being used,
      but that will not happen until the garbage collector runs, which
      can take a while. Until then, the file handle remains
      open.</para>

    <para>File handles are scarce resources.  Their scarcity is
      enforced by the underlying operating system.  On Linux, for
      example, a process is by default only allowed to have 1024 files
      open simultaneously.</para>

    <para>It's not hard to imagine a scenario in which a program that
      called a version of <function>betterFind</function> that used
      <function>saferFileSize</function> could crash because
      <function>betterFind</function> exhausted the supply of open
      files before enough garbage file handles could be closed.</para>

    <para>This is a particularly pernicious kind of bug, as it has
      several aspects that combine make it incredibly difficult to
      track down. It will only be triggered if
      <function>betterFind</function> visits a sufficiently large
      number of non-files to hit the process's open file limit, and
      then returns to a caller that tries to open another file before
      any of the accumulated garbage file handles is closed.  This is
      an unlikely enough combination of circumstances.  Worse, any
      subsequent error will be caused by data that is no longer
      reachable from within the program, and has yet to be garbage
      collected.  Such a bug is thus dependent on the structure of the
      program, the contents of the filesystem, and how close the
      current run of the program is to triggering the garbage
      collector.</para>

    <para>Fortunately, we can avoid this kind of error very easily, in
      fact here we can do so by making our function
      <emphasis>shorter</emphasis>.</para>

    <sect2>
      <title>The acquire-use-release cycle</title>

      <para>We need <function>hClose</function> to always be called if
	<function>openFile</function> succeeds.  The
	<code>Control.Exception</code> module provides the
	<function>bracket</function> function for exactly this
	purpose.</para>

      &simplefinder.ghci:bracket;

      <para>The <function>bracket</function> function takes three
	actions as arguments.  The first action acquires a resource.
	The second releases the resource.  The third runs in between,
	while the resource is acquired; let's call this the
	<quote>use</quote> action.  If the <quote>acquire</quote>
	action succeeds, the <quote>release</quote> action is
	<emphasis>always</emphasis> called.  This guarantees that the
	resource will always be released.  The <quote>use</quote> and
	<quote>release</quote> actions are each passed the resource
	acquired by the <quote>acquire</quote> action.</para>

      <para>If an exception occurs while the <quote>use</quote> action
	is executing, <function>bracket</function> calls the
	<quote>release</quote> action and rethrows the exception.  If
	the <quote>use</quote> action succeeds,
	<function>bracket</function> calls the <quote>release</quote>
	action, and returns the value returned by the
	<quote>use</quote> action.</para>

      <para>We can now write a function that is completely safe: it
	will not throw exceptions; neither will it accumulate garbage
	file handles that could cause spurious failures elsewhere in
	our program.</para>
    
      &BetterPredicate.hs:getFileSize;

      <para>Look closely at the arguments of
	<function>bracket</function> above.  The first opens the file,
	and returns the open file handle.  The second closes the
	handle.  The third simply calls <function>hFileSize</function>
	on the handle and wraps the result in
	<function>Just</function>.</para>

      <para>We need to use both <function>bracket</function> and
	<function>handle</function> for this function to operate
	correctly. The former ensures that we don't accumulate garbage
	file handles, while the latter gets rid of exceptions.</para>

      <sect3>
	<title>Exercises</title>

	<qandaset defaultlabel="number">
	  <qandaentry>
	    <question>
	      <para>Is the order in which <function>bracket</function>
		and <function>handle</function> are called important?
		Why?</para>
	    </question>
	  </qandaentry>
	</qandaset>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Writing a predicate</title>

    <para>Let's take a stab at writing a predicate, recalling the type
      signature for predicates.</para>

    &BetterPredicate.hs:Predicate.noid;

    <para>Our predicate will check for a C source file that is over
      100KB in size.</para>

    &BetterPredicate.hs:myTest;

    <para>This isn't especially pleasing.  The predicate takes four
      arguments, always ignores two of them, and requires two
      equations to define.  Surely we can do better.</para>

    <para>One approach we can take is to write a function that returns
      one of its arguments.  This one extracts the path from the
      arguments passed to a <type>Predicate</type>.</para>

    &BetterPredicate.hs:pathP;

    <para>If we don't provide a type signature, a Haskell
      implementation will infer a very general type for this function.
      This can later lead to error messages that are difficult to
      interpret, so let's give <function>pathP</function> a
      type.</para>

    &BetterPredicate.hs:InfoP;

    <para>We've gone a step further and created a type synonym that we
      can use as shorthand for writing other, similarly structured
      functions.</para>

    &BetterPredicate.hs:sizeP;

    <para>(We're being a little sneaky here, and returning a size of
      -1 for entries that are not files, or that we couldn't
      open.)</para>

    <para>In fact, a quick glance shows that the
      <type>Predicate</type> type that we defined near the beginning
      of this chapter is the same type as <type>InfoP
	Bool</type>.</para>

    <para>What use are <function>pathP</function> and
      <function>sizeP</function>?  With a little more glue, we can use
      them in a predicate.  This is where things start to get
      interesting.</para>

    &BetterPredicate.hs:equalP;

    <para>The type signature of <function>equalP</function> deserves a
      little attention.  It takes an <type>InfoP a</type>, which is
      compatible with both <function>equalP</function> and
      <function>sizeP</function>.  It takes an <type>a</type>.  And it
      returns an <type>InfoP Bool</type>, which we already observed is
      a synonym for <type>Predicate</type>.  In other words,
      <function>equalP</function> constructs a predicate.</para>

    <para>The <function>equalP</function> function works by returning
      an anonymous function.  That one takes the arguments accepted by
      a predicate, passes them to <varname>f</varname>, and compares
      the result to <varname>k</varname>.</para>

    <para>This equation for <function>equalP</function>  emphasises
      the fact that we think of it as taking two arguments.  Since
      Haskell curries all functions, writing
      <function>equalP</function> in this way is not actually
      necessary.  We can omit the anonymous function and rely on
      currying to work on our behalf, letting us write a function that
      behaves identically.</para>

    &BetterPredicate.hs:equalP2;

    <para>Before we continue with our explorations, let's load our
      module into &ghci;.</para>

    &betterpredicate.ghci:load;
    
    <para>Let's see if a simple predicate constructed from these
      functions will work.</para>

    &betterpredicate.ghci:betterFind;

    <para>Notice that we're not actually calling
      <function>betterFind</function>, we're merely making sure that
      our expression typechecks.  We now have a more expressive way to
      list all files that are exactly one kilobyte in size.  Our
      success gives us enough confidence to continue.</para>

    <sect2>
      <title>Avoiding boilerplate with lifting</title>

      <para>Besides <function>equalP</function>, we'd like to be able
	to write other binary functions.  We'd prefer not to write
	each one out in <quote>longhand</quote>, because that seems
	unnecessarily verbose.</para>

      <para>To address this, let's put Haskell's powers of abstraction
	to use.  We'll take the definition of
	<function>equalP</function>, and instead of calling
	<function>(==)</function> directly, we'll pass in as another
	argument the binary function that we want to call.</para>

      &BetterPredicate.hs:liftP2;

      <para>This act of taking a function, such as
	<function>(>)</function>, and transforming it into another
	function that works in a different context, here
	<function>greaterP</function>, is referred to as
	<emphasis>lifting</emphasis> it into that context.  This
	explains the choice of <function>liftP2</function> as a
	function name (the <code>2</code> indicates that it works with
	functions of two arguments).  Lifting lets us reuse code and
	reduce boilerplate.  We'll be using it a lot throughout the
	rest of this book.</para>

      <para>By the way, our placement of <varname>f</varname>, the
	function to lift, as the first argument to
	<function>liftP2</function>, was no accident.  This made it
	possible for us to write such concise definitions of
	<function>greaterP</function> and
	<function>lesserP</function>.  Partial application makes
	finding the <quote>best</quote> order for arguments a more
	important part of API design in Haskell than in other
	languages.  In languages without partial application, argument
	ordering is a matter of taste and convention.  Put an argument
	in the wrong place in Haskell, however, and you lose the
	concision that partial application gives.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Exercises</title>
    
    <para>Although the file finding code we described in this chapter
      is a good vehicle for learning, it's not ideal for real systems
      programming tasks, because Haskell's portable I/O libraries
      don't expose enough information.  As an we must open a file to
      find out what size it is. This is inefficient, and sometimes
      impossible.  We also can't find out who owns a file.</para>

    <qandaset defaultlabel="number">
      <qandaentry>
	<question>
	  <para>Port the code from this chapter to your platform's
	    native API, either <code>System.Posix</code> or
	    <code>System.Win32</code>.</para>
	</question>
      </qandaentry>

      <qandaentry>
	<question>
	  <para>Add the ability to find out who owns a directory entry
	    to your code.  Make this information available to
	    predicates.</para>
	</question>
      </qandaentry>
    </qandaset>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
