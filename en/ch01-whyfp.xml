<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="whyfp" revision="unpublished">
  <title>Why Functional Programming?  Why Haskell?</title>

  <para>
    This book, at its heart, is about different ways of solving
    problems.  Many of us, while working on some piece of code, will
    occasionally have the thought "there just has to be a better way
    to do this."  We think that, for many problems, Haskell helps
    provide this better way.
  </para>
  <para>
    Haskell is most likely quite different from any language you've
    ever used before.  To become an effective Haskell programmer,
    you're going to have to question some fundamental assumptions: for
    instance, the assumption that your system can't do anything with
    an infinite list.  It turns out that these differences can lead to
    great productivity solving everyday, real-world problems.  Plus,
    we think that programming in Haskell is just plain
    <emphasis>fun</emphasis>.
  </para>
  
  <sect1 id="whyfp.interesting">
    <title>Why is Haskell Interesting?</title>
    <para>
      To whet your appetite for Haskell, here are some things that we
      think are interesting about the language.  Don't let it scare
      you off or lead you to believe that Haskell is a toy language.
      These differences turn out to be powerful concepts.
    </para>
    <itemizedlist>
      <listitem>
        <para>Haskell has no loops because it doesn't need them.
          There is no <literal>for</literal> or
          <literal>while</literal> in Haskell.
        </para>
      </listitem>

      <listitem><para>
          Modern Haskell compilers can automatically introduce
          parallelism into your code to take advantage of multi-core
          processors.
        </para>
      </listitem>

      <listitem><para>
          Haskell has no variables in the sense you're used to.  It
          doesn't need them, either.
        </para>
      </listitem>

      <listitem><para>
          Haskell is a functional language instead of an
          object-oriented language.  In Haskell, your primary view of
          the world is the function.  One of us is fond of saying
          "Haskell manipulates functions with the same ease that Perl
          manipulates strings."  In Haskell, it's commonplace to pass
          around bits of code to functions.  Far from leading to
          unmaintainable code, this is a powerful benefit both for
          up-front development and long-term maintainability.
        </para>
      </listitem>

      <listitem><para>
          Haskell functions are pure.  Every time they're called with
          the same arguments, they return the same result.  Haskell
          functions have no side-effects.  There is no such thing as a
          global variable in Haskell.  Of course, in Haskell, there is
          no need for such things.
        </para>
      </listitem>

      <listitem><para>
          Haskell is a lazy language.  It never performs computation
          unless it must.  This isn't just an optimization; it's a a
          different world view.  Could that could result in infinite
          loops or consume vast amounts of memory in other languages
          may turn out to be a simple, everyday tool in Haskell.
        </para>
      </listitem>

    </itemizedlist>

    <para>
      All of this may leave you wondering things like: "if functions
      always return the same thing, how can I read a line of text from
      the keyboard and return it from a function?"  Such things are,
      of course, possible and easy in Haskell, thanks to a rigorous
      separation of code that could introduce side-effects from "pure"
      code.  We will discuss this separation and its benefits
      throughout the book.
    </para>
  </sect1>

  <sect1 id="whyfp.goals">
    <title>Goals of Real-World Haskell</title>
    <para>
      With this book, we want to show you how to use functional
      programming and Haskell to solve real-world problems.  This will
      be a hands-on book with plenty of real examples.  We want to
      show people that already know how to program in another language
      how to program in Haskell.
    </para>
    <para>
      As you read the book, you'll see a program to extract barcodes
      from photos taken by low-quality cell phone cameras, a program
      that downloads podcast episodes from the Internet and stores
      history in a SQL database, code that parses and generates
      JavaScript data following the JSON standard, and many more.
      Each of these examples will be used to illustrate important
      Haskell concepts and ways to solve problems.  We'll also show
      you some other fun examples, such as how to extend Haskell's
      numeric computation system to work with units (things like
      meters, feet, or seconds) paired with numbers.
    </para>

    <para>
      We started this project because there is a large community of
      people that are using Haskell to solve everyday problems.  But
      because Haskell has its roots in academia, many of the books
      discussing Haskell don't focus on the type of problems that are
      interesting for us.  In this book, I/O is of central importance,
      and we draw on our own experiences using Haskell to solve real
      business, personal, and public problems.
    </para>

    <para id="x_P">
      As a new Haskell programmer, you'll inevitably end up
      writing quite a bit of code by hand for which you could have
      used a library function or programming technique, had you but
      known of its existence. You'll also run into instances where a
      cherished feature of another language isn't available; or a
      library function you just know ought to be there isn't; or
      occasionally something will be put together in such a way that
      you know it could have been improved upon.  If you accept the
      inevitability of the occasional surprise, difficulty, and
      shortcoming, you'll have much more fun learning Haskell than if
      you step in expecting perfection, only to trip up within a few
      days or weeks of getting started.  As you become a more seasoned
      Haskell programmer, you may find the library that has that
      missing function under a different name, or that a particular
      feature is missing because there's a better way to do it, or
      even that it's pretty easy to implement a given feature in Haskell.
    </para>
  </sect1>

  <sect1 id="whyfp.fp">
    <title>The Nature of Functional Programming</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="whyfp.haskell">
    <title>Features of Haskell</title>
    <remark>FIXME</remark>
    <remark>FIXME: roots in research</remark>
    <remark>FIXME: perception that it's not practical; this book will
    refute</remark>
    

    <sect2 id="whyfp.haskell.typing">
      <title>Strong Typing and Type Inference</title>
      <remark>FIXME</remark>
    </sect2>

    <sect2 id="whyfp.haskell.laziness">
      <title>Laziness</title>
      <remark>FIXME</remark>
    </sect2>

    <sect2 id="whyfp.haskell.compilation">
      <title>Compiled or Interpreted</title>
      <remark>FIXME</remark>
    </sect2>


    <sect2 id="whyfp.haskell.purity">
      <title>Purity</title>
      <remark>FIXME</remark>
    </sect2>

    <sect2 id="whyfp.haskell.modularity">
      <title>Modularity</title>
      <remark>FIXME</remark>
    </sect2>

    <sect2 id="whyfp.haskell.expressiveness">
      <title>Expressiveness</title>
      <remark>FIXME</remark>
    </sect2>

    <sect2 id="whyfp.haskell.composability">
      <title>Composability</title>
      <remark>FIXME</remark>
    </sect2>

    <sect2 id="whyfp.haskell.robustness">
      <title>Robustness and Correctness</title>
      <remark>FIXME</remark>
    </sect2>

  </sect1>

  <sect1 id="whyfp.noths">
    <title>Things Haskell Doesn't Have (Or Need)</title>

    <sect2 id="whyfp.noths.vars">
      <title>Mutable Variables</title>
      <para id="x_Q">
        In a language such as C, you might see a statement such as
        <literal>x = x * 5 + y</literal>.  This statement modifies the place
        in memory where <literal>x</literal> is stored and changes it to
        the result of the computation.  Many, many other languages work the
        same way.  For instance, a Python programmer might say
        <literal>mylist[5] = 10</literal>, which will set the value of the
        fifth element in <literal>mylist</literal> to <literal>10</literal>.
      </para>
      <para id="x_R">
        In Haskell, all data is immutable&emdash;it cannot be modified.  If you
        need to modify an element of a list, you'll get a copy of the
        original list returned&emdash;except for the one changed element.  Then
        you will probably ignore the original list.
      </para>
      <para id="x_S">
        You might start to think that this could be slow to execute.
        That turns out not to be the case, as the Haskell compiler can
        optimize this sort of usage quite well.
      </para>
      <para id="x_T">
        It also turns out to be a powerful way to code: it makes it easy to
        "chain" functions together, the result of one being taken as input to
        another.  POSIX programmers can think of this as similar to pipes in
        the shell.  
      </para>
      <para id="x_U">
        There's another benefit of this: a lack of side-effects.  A common
        source of bugs in many languages is calling a function that does
        something unexpected: modifies a global or a class variable, for
        instance.  Later code then could behave in unexpected ways.
      </para>
      <para id="x_V">
        Some languages have partial immutability.  For instance, strings are
        immutable in Java; if you want to add something to a string in Java,
        you combine two strings and the result is a new string&emdash;not a
        modification of an existing string.  Haskell takes immutability much
        farther.  The only exception in Haskell deals with I/O, which is
        encapsulated in a special way; this will be discussed later.
      </para>
    </sect2>

    <sect2 id="whyfp.noths.loops">
      <title>Looping with for or while</title>
      <para id="x_W">
        Chances are that most languages you've used before have the notion
        of <literal>for</literal> or <literal>while</literal>.  These
        tools are often used for performing actions a fixed number of times,
        for doing something over and over until some state changes, or for
        simply repeating infinitely until the program is killed.
      </para>
      <para id="x_X">
        Haskell has no <literal>for</literal> or <literal>while</literal>.
        That's not an oversight; Haskell doesn't have <literal>for</literal>
        or <literal>while</literal> because Haskell doesn't need them.
      </para>
      <para id="x_Y">
        Let's consider a simple program to output the numbers from 1 to 10 on
        the screen.  A C programmer might work this way:
      </para>
      <programlisting><![CDATA[
#include <stdio.h>

void main(void) {
    int i;
    for (i = 1; i <= 10; i++) {
        printf("%d\n", i);
    }
}
]]>
      </programlisting>
      <para id="x_Z">
        This assigns the value 1 to <literal>i</literal> on the first time,
        then modifies that place in memory each time through, incrementing
        <literal>i</literal> until it reaches 10.
      </para>
      <para id="x_a">
        A Haskell programmer could simply say:
      </para>
      &counter1.hs:all;
      <para id="x_b">
        The <literal>[1..10]</literal> generates an <emphasis>lazy</emphasis>
        list of numbers from 1 to 10.  Each element will be created only when
        demanded.  You could just as easily say
        <literal>[1..1000000]</literal> and you'll use no more memory.
      </para>
      <para id="x_c">
        The call to <literal>mapM_</literal> takes an I/O function and runs
        it once for each element passed in.  So we never need to directly
        modify memory, yet we can express the entire operation more compactly
        than in C.
      </para>
      <para id="x_d">
        A Haskell programmer could also express this without using
        <literal>mapM_</literal> like this:
      </para>
      &counter2.hs:all;
      <para id="x_e">
        This function uses recursion and pattern matching to achieve the
        result.  You'll learn more about these techniques in the next few
        chapters in the book.
      </para>
      <para id="x_f">
        While Haskell's approach may seem foreign at first, we think that
        you'll grow to appreciate its speed and robustness as you learn about
        it.  You'll see why Haskell doesn't have loops because loops would be
        less useful!
      </para>

    </sect2>

  </sect1>

  <sect1 id="whyfp.environment">
    <title>Haskell Environment</title>
    <remark>FIXME: 
  Mention the Haskell environment that the book assumes (GHC 6.6+).
  Describe how to obtain and install it.  Refer to alternative Haskell
  implementations (Hugs), but leave any detail to an appendix.
    </remark>
  </sect1>

  <sect1 id="whyfp.resources">
    <title>Helpful Resources</title>
    <para>
      As you work with Haskell, you're sure to have questions and want
      more information about things.  Here are some Internet resources
      where you can look up information and interact with other
      Haskell programmers.
    </para>    

    <sect2 id="whyfp.resources.reference">
      <title>Reference Material</title>
      <itemizedlist>
        <listitem>
          <para>
            The Haskell Hierarchical Libraries reference provides the
            reference to the standard library that comes with your
            compiler.  This is probably the top item in the bookmarks
            for many Haskell programmers.
            <ulink
            url="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            For questions about language syntax and features, the
            Haskell 98 Report describes the Haskell 98 standard.
            <ulink url="http://haskell.org/onlinereport/"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            Various extensions to the language have become commonplace
            since the Haskell 98 Report was released.  The GHC Users's
            Guide contains detailed documentation on the extensions
            supported by GHC, as well as some GHC-specific features.
            <ulink
            url="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            Hoogle is the Haskell API search engine.  It can find
            functions for you by name or by type.  <ulink
            url="http://haskell.org/hoogle/"></ulink>
          </para>
        </listitem>

      </itemizedlist>
    </sect2>

    <sect2 id="whyfp.resources.apps">
      <title>Applications and Libraries</title>
      <para>
        If you're looking for a Haskell library to use for a
        particular task, or an application written in Haskell, check
        out the resources in this section.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            The Haskell community maintains a central repository for
            Haskell libraries and applications.  It's called Hackage
            and lets you search for software, or browse its collection
            by category.  <ulink
            url="http://hackage.haskell.org/"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            The Haskell Wiki has a large collection of information
            about particular Haskell libraries as well.  <ulink
            url="http://haskell.org/haskellwiki/Applications_and_libraries"></ulink>
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="whyfp.resources.community">
      <title>The Haskell Community</title>
      <para>
        There are a number of ways you can get in touch with other
        Haskell programmers.  You can ask questions, learn what
        Haskellers are talking about, and simply do some social
        networking with your peers.
      </para>
      
      <itemizedlist>
        <listitem>
          <para>The first stop on your search for community resources
          should be the Haskell homepage, <ulink
          url="http://www.haskell.org/"></ulink>.  This page contains
          the most current links to various communities and information.
          </para>
        </listitem>

        <listitem>
          <para>
            Mailing lists are the most common way for Haskellers to
            interact.  There are quite a few of them available.
            <ulink
            url="http://haskell.org/haskellwiki/Mailing_lists"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            For real-time chat, the Haskell IRC channel is also
            available.  <ulink
            url="http://haskell.org/haskellwiki/IRC_channel"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            There are a number of Haskell user groups, recurring
            workshops, and the like in the Haskell community.  There
            is a list of the known user groups and workshops
            available.  <ulink
            url="http://haskell.org/haskellwiki/User_groups"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            The Haskell Weekly News is a frequently-published summary
            of activities in the Haskell community.  You can find
            pointers to interesting mailing list discussions, new
            software releases, and the like.  <ulink
            url="http://sequence.complete.org/"></ulink>
          </para>
        </listitem>

        <listitem>
          <para>
            The Haskell Communities and Activities Report (HCAR) has
            been collecting information about people that use Haskell
            and what they are doing with it.  <ulink
            url="http://haskell.org/communities/"></ulink>
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
