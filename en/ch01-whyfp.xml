<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="whyfp" revision="alpha;beta">
  <title>Why functional programming?  Why Haskell?</title>

  <sect1>
    <title>Have we got a deal for you!</title>

    <para>Haskell is a deep language, and we think that learning it is
      a hugely rewarding experience.  We will focus on three elements
      as we explain why we think it worthwhile. The first is
      <emphasis>novelty</emphasis>: we invite you to think about
      programming from a different and valuable perspective.  The
      second is <emphasis>power</emphasis>: we'll show you how to
      create software that is short, fast, and safe.  Lastly, we offer
      you a lot of <emphasis>fun</emphasis>: the pleasure of applying
      beautiful programming techniques to solve real problems.</para>

    <sect2>
      <title>Novelty</title>

      <para>Haskell is most likely quite different from any language
	you've ever used before.  Compared to the usual set of
	concepts in a programmer's mental toolbox, functional
	programming offers us a profoundly different way to
	think about software.</para>

      <para>In Haskell, we de-emphasise code that modifies variables
	or objects.  Instead, we focus on functions that take
	immutable values as input and produce new values as output.
	Given a fixed input, one of these functions will always return
	the same result.  This is a core idea behind functional
	programming.</para>

      <para>Along with not modifying data, Haskell functions don't
	usually talk to the external world.  They don't read or write
	files; initiate or respond to network connections; or make
	robot arms move.</para>

      <para>We abandon some ideas that might seem fundamental, such as
	repeating an action using a looping construct.  We have other,
	more effective ways, to perform repetitive tasks.</para>

      <para>Even the way in which we evaluate expressions is different
	in Haskell.  We defer every computation until its result is
	actually needed: Haskell is a <emphasis>lazy</emphasis>
	language. This isn't just a matter of moving work around: it
	deeply affects how we write programs.</para>

    </sect2>

    <sect2>
      <title>Power</title>

      <para>Throughout this book, we're going to show you how
	Haskell's alternatives to the features of traditional
	languages are more powerful, more flexible, and safer. Haskell
	is positively crammed full of cutting edge ideas about how to
	create great software.</para>

      <para>Perhaps surprisingly, when we place some restrictions on
	how we create code, we find that it's actually becomes
	<emphasis>easier</emphasis> to write and read.  Every useful
	Haskell program talks to the outside world, and this is easy
	to do.  But the language rigorously
	<emphasis>isolates</emphasis> that code: there's a strong
	division between code that is exposed to the outside world,
	and code that is not.  Code that may have side effects even
	<emphasis>looks</emphasis> different from normal code.</para>

      <para>Since most of our Haskell code doesn't have any dealings
	with the outside world, and can't modify any data, it tends to
	be easy to understand and to reuse.  The kinds of nasty
	surprises in which one piece of code invisibly corrupts data
	used by another simply don't occur.  Whatever setting we use a
	function in, it will behave consistently.</para>

      <para>Code that lacks side effects is easy to test.  When a
	function only responds to its visible inputs, we can state a
	property of its behaviour that should always be true,
	automatically test that the property holds for a huge body of
	random inputs, and move on.  We can still unit test code that
	must interact with files, networks, or exotic hardware, but we
	get much better assurance that our software is solid.</para>

      <para>Lazy evaluation has some spooky effects.  Let's say we
	want to find the <emphasis>k</emphasis> least-valued elements
	of an unsorted list.  In a traditional language, the obvious
	approach would be to sort the list and take the first
	<emphasis>k</emphasis> elements, but this approach is
	expensive.  For efficiency, we would instead write a special
	function that takes these values in one pass, and it would
	have to perform some moderately complex book-keeping.  In
	Haskell, the sort-then-take approach actually makes
	performance sense: laziness ensures that the list will only be
	sorted enough to find the three minimal elements.</para>

      <para>Better yet, our Haskell code that operates so efficiently
	is tiny, and uses standard library functions.</para>

      &KMinima.hs:minima;
      
      <para>It can take a while to adjust to develop an intuitive feel
	for when lazy evaluation is important, but when we exploit it,
	the resulting code is often clean, brief, and
	efficient.</para>

      <para>As the above example shows, an important aspect of
	Haskell's power lies in the compactness of the code we write.
	Compared to working in popular traditional languages, we often
	write Haskell code with a tenfold reduction in code size, in
	substantially less time, and with fewer bugs.</para>
    </sect2>

    <sect2>
      <title>Enjoyment</title>

      <para>We believe that it is easy to pick up the basics of
	Haskell programming, and that you will be able to successfully
	write small programs within a matter of hours or days.</para>

      <para>Of course, programming in Haskell differs in huge ways
	from working in other languages, so mastering both the
	language and functional programming techniques does indeed
	require plenty of thought and practice.</para>

      <para>Harking back to our own days of getting started with
	Haskell, the good news is that the fun begins early: it's
	simply an entertaining challenge to dig into a new language,
	in which so many commonplace ideas are different or missing,
	and to figure out how to write simple programs.</para>

      <para>For us, the initial pleasure lasted as our experience grew
	and our understanding deepened.  In other languages, it's
	difficult to see any connection between abstract mathematics
	and programming.  In Haskell, not only have we imported some
	ideas from mathematics and put them to work, we've found that
	they're both surprisingly easy to pick up and a delight to
	deal with as we program.</para>

      <para>Furthermore, we won't be putting any <quote>brick
	  walls</quote> in your way: there are no especially difficult
	or gruesome techniques in this book that you must master in
	order to be able to program effectively.</para>

      <para>That being said, Haskell is a rigorous language: it will
	make you do more of your thinking up front than other
	languages.  It can take a little while to adjust to doing much
	of your debugging before you ever run your code, to satisfy
	the compiler that your program makes sense.  But we think that
	you'll be astonished and pleased by the number of times your
	Haskell programs simply work on the first try
	afterwards.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>What to expect from this book</title>

    <para id="x_Tl">We started this project because a growing number
      of people are using Haskell to solve everyday problems. Because
      Haskell has its roots in academia, few of the Haskell books that
      currently exist focus on the problems and techniques of everyday
      programming that we're interested in.</para>

    <para id="x_Rl">With this book, we want to show you how to use
      functional programming and Haskell to solve realistic problems.
      This is a hands-on book: every chapter contains dozens of code
      samples, and many contain complete applications.  Here are a few
      examples of the libraries, techniques and tools we'll show you
      how to develop.</para>

    <itemizedlist>
      <listitem>
	<para>Create an application that downloads podcast episodes
	  from the Internet, and stores its history in an SQL
	  database.</para>
      </listitem>
      <listitem>
	<para>Test your code in a new and powerful way.
	  Understand which parts of your code are actually being
	  covered by your tests.</para>
      </listitem>
      <listitem>
	<para>Take a grainy phone camera snapshot of a barcode, and
	  turn it into an identifier that you can use to query a
	  library or bookseller's web site.</para>
      </listitem>
      <listitem>
	<para>Write code that thrives on the web.  Exchange data with
	servers and clients written in other languages using JSON
	notation.  Develop a highly concurrent web server.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>A little bit about you</title>

      <para>What do we think you'll need to know before reading this
	book?  We expect that you already know how to program, but if
	you've never done any functional programming, that's fine.  If
	you've programmed in an expressive language like Python or
	Ruby, we think you'll pick Haskell up quite easily.</para>

      <para>No matter what your level of experience, we've tried to
	anticipate your needs: we go out of our way to explain new and
	potentially tricky ideas in depth, usually with examples and
	images to drive our points home.</para>

      <para id="x_P">As a new Haskell programmer, you'll inevitably
	start out writing quite a bit of code by hand for which you
	could have used a library function or programming technique,
	had you just known of its existence.  We've packed this book
	with information to help you to come up to speed as quickly as
	possible.</para>

      <para>Of course, there will always be a few bumps along the
	road.  If you start out anticipating an occasional surprise or
	difficulty along with the fun stuff, you'll have the best
	experience.  Any rough patches you might hit won't last
	long.</para>

      <para>As you become a more seasoned Haskell programmer, the way
	that you write code will change.  Indeed, over the course of
	this book, the way that we present code will evolve, as we
	move from the basics of the language to increasingly powerful
	and productive features and techniques.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>What to expect from Haskell</title>

    <para>Haskell is a general purpose programming language.  It was
      designed without any application niche in mind.  Although it
      takes a strong stand on how programs should be written, it does
      not favour one problem domain over others.</para>

    <para>While at its core, the language encourages a pure, lazy
      style of functional programming, this is the
      <emphasis>default</emphasis>, not the only option.  Haskell also
      supports the more traditional models of procedural code and
      strict evaluation.  Additionally, although the focus of the
      language is squarely on writing strongly typed programs, it is
      possible (though rarely seen) to write Haskell code in a
      dynamically typed manner.</para>

    <sect2>
      <title>Compared to traditional static languages</title>

      <para>Statically typed languages have been the mainstay of the
	programming world for decades.  Although Haskell is a
	statically typed language, its notion of what types are for,
	and what we can do with them, is much more flexible and
	powerful than traditional languages.</para>

      <para>In addition, Haskell's type system is often unobtrusive: a
	Haskell compiler will automatically infer the type of an
	expression or function if we don't provide it.  Compared to
	traditional static languages, to which we must spoon feed
	large amounts of type information, the combination of power
	and inference in Haskell's type system significantly reduces
	the clutter and redundancy of our code.</para>

      <para>Several of Haskell's other features combine to further
	increase the amount of work we can fit into a screenful of
	text. As a result, it is not unusual for a Haskell program to
	require one tenth the number of lines of code as an equivalent
	written in a traditional language.  With this come
	improvements in development time and agility: we can create
	reliable code quickly, and easily refactor it in response to
	changing requirements.</para>

      <para>These productivity improvements are sometimes accompanied
	by a performance penalty when it comes to running code.  It is
	not unusual for a Haskell program to run at a half to a
	quarter the speed of a comparable program written in a
	traditional language.</para>

      <para>However, a substantial and increasing number of Haskell
	programs perform as well as (sometimes better than) their
	traditional counterparts.  In part, this is due to advances in
	Haskell compilers and libraries, where progress is rapid and
	improvements benefit the entire community.  Also, Haskell's
	huge edge in developer productivity gives us more
	opportunities to focus on algorithmic improvements.</para>
    </sect2>

    <sect2>
      <title>Compared to modern dynamic languages</title>

      <para>Over the past decade, dynamically typed and interpreted
	languages have become increasingly popular.  They offer
	substantial benefits in developer productivity.  Although this
	typically comes at the cost of a huge performance hit, for
	many programming tasks productivity trumps performance, or
	performance isn't a significant factor in any case.</para>

      <para>Brevity is one area in which Haskell and dynamically typed
	languages perform similarly: in each case, you write much less
	code to solve a problem than in a traditional language.
	Programs are often around the same size in dynamically typed
	languages and Haskell.</para>

      <para>When we consider runtime performance, Haskell almost
	always has a huge advantage.  Code compiled by &GHC; is
	typically between 20 and 60 times faster than code run through
	a dynamic language's interpreter.  &GHC; also provides an
	interpreter, so you can run scripts without compiling
	them.</para>

      <para>Another big differentiator between dynamically typed
	languages and Haskell lies in the philosophy around types.  A
	major reason for the popularity of dynamically typed languages
	is that only rarely do we need to explicitly mention types.
	Through automatic type inference, Haskell offers the same
	advantage.</para>

      <para>However, beyond this surface level the differences run
	deep.  In a dynamically typed language, we can create
	constructs that are difficult or impossible to express in a
	statically typed language.  However, the same is true in
	reverse: with a type system as powerful as Haskell's, we can
	structure a program in a way that would be unmanageable or
	infeasible in a dynamically typed language.</para>

      <para>It's important to recognise that each of these approaches
	involves tradeoffs.  Very briefly put, the Haskell perspective
	emphasises safety, while the dynamically typed outlook favours
	flexibility.  If someone had already discovered one way of
	thinking about types that was always best, we imagine that
	everyone would know about it by now.</para>

      <para>Of course, we have our own opinions about which tradeoffs
	are more beneficial.  Two of us have years of experience
	programming in dynamically typed languages.  We love working
	with them; we still use them every day; but usually, we prefer
	Haskell.  In our experience, Haskell starts to outshine a
	dynamically typed language once a project grows to a handful
	of thousands of lines of code.</para>
    </sect2>

    <sect2>
      <title>Haskell in industry and open source</title>

      <para>Here are just a few examples of large software systems
	that have been created in Haskell.  Some of these are open
	source, while others are commercial products.</para>

      <itemizedlist>
	<listitem>
	  <para>Innumerable compilers and compiler-related
	    tools</para>
	</listitem>
	<listitem>
	  <para>Chip design software</para>
	</listitem>
	<listitem>
	  <para>A toolkit for music composition</para>
	</listitem>
	<listitem>
	  <para>Distributed revision control</para>
	</listitem>
	<listitem>
	  <para>Secure web middleware</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Compilation, debugging, and performance analysis</title>

      <para>For practical work, almost as important as a language
	itself is the ecosystem of libraries and tools around it.
	Haskell has a strong showing in this area.</para>

      <para>The most widely used compiler, &GHC;, has been actively
	developed for over 15 years, and provides a mature and stable
	set of features.</para>

      <itemizedlist>
	<listitem>
	  <para>It compiles to efficient native code on all major
	    modern operating systems and CPU architectures</para>
	</listitem>
	<listitem>
	  <para>Easy deployment of compiled binaries, unencumbered by
	    licensing restrictions</para>
	</listitem>
	<listitem>
	  <para>Interactive interpreter and debugger</para>
	</listitem>
	<listitem>
	  <para>Code coverage analysis</para>
	</listitem>
	<listitem>
	  <para>Detailed profiling of performance and memory
	    usage</para>
	</listitem>
	<listitem>
	  <para>Thorough documentation</para>
	</listitem>
	<listitem>
	  <para>Massively scalable support for concurrent and
	    multicore programming</para>
	</listitem>
      </itemizedlist>

    </sect2>

    <sect2>
      <title>Bundled and third party libraries</title>

      <para>The &GHC; compiler ships with a collection of useful
	libraries.  Here are a few of the common programming needs
	that these libraries address.</para>

      <itemizedlist>
	<listitem>
	  <para>File I/O, and filesystem traversal and
	  manipulation</para>
	</listitem>
	<listitem>
	  <para>Network client and server programming</para>
	</listitem>
	<listitem>
	  <para>Regular expressions and parsing</para>
	</listitem>
	<listitem>
	  <para>Concurrent programming</para>
	</listitem>
	<listitem>
	  <para>Automated testing</para>
	</listitem>
	<listitem>
	  <para>Sound and graphics</para>
	</listitem>
      </itemizedlist>

      <para>The Hackage package database is the Haskell community's
	collection of open source libraries and applications.  Most
	libraries published on Hackage are licensed under liberal
	terms that permit both commercial and open source use.  Some
	of the areas covered by open source libraries include the
	following.</para>

      <itemizedlist>
	<listitem>
	  <para>Interfaces to all major open source and commercial
	    databases</para>
	</listitem>
	<listitem>
	  <para>XML, HTML, and XQuery processing</para>
	</listitem>
	<listitem>
	  <para>Network and web client and server development</para>
	</listitem>
	<listitem>
	  <para>Desktop GUIs, including cross-platform toolkits</para>
	</listitem>
	<listitem>
	  <para>Support for Unicode and other text encodings</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1>
    <title>A brief sketch of Haskell's history</title>

    <para>The history that led to the development of Haskell is rooted
      in mathematics and computer science research.</para>

    <sect2>
      <title>Prehistory</title>

      <para>A few decades before modern computers were invented, the
	mathematician Alonzo Church developed a language named the
	lambda calculus.  He intended it as a tool for investigating
	the foundations of mathematics.  The first person to
	successfully capture the idea of using the lambda calculus to
	write software was John McCarthy, who created Lisp in
	1958.</para>

      <para>During the 1960s, computer scientists began to recognise
	and study the importance of the lambda calculus.  Peter Landin
	and Christopher Strachey developed ideas about the foundations
	of programming languages: how to reason about what they do
	(operational semantics) and how to understand what they mean
	(denotational semantics).</para>

      <para>In the early 1970s, Robin Milner created a more rigorous
	functional programming language named ML.  While ML was
	developed to help with automated proofs of mathematical
	theorems, it gained a following for more general computing
	tasks.</para>

      <para>The 1970s saw the emergence of lazy evaluation as a novel
	strategy.  David Turner developed SASL and KRC, while Rod
	Burstall and John Darlington developed a NPL and Hope.  NPL,
	KRC and ML influenced the development of several more
	languages in the 1980s, including Lazy ML, Clean, and
	Miranda.</para>
    </sect2>

    <sect2>
      <title>Early antiquity</title>

      <para>By the late 1980s, the efforts of researchers working on
	lazy functional languages were scattered across more than a
	dozen languages.  Concerned by this diffusion of effort, a
	number of researchers decided to form a committee to design a
	common language.  After three years of work, the committee
	published the Haskell 1.0 specification in 1990.</para>

      <para>We are generally blind to the tired cliche of
	<quote>design by committee</quote> except when a
	counterexample is thrown our way, and the work of the Haskell
	committee is a beautiful example of the best a committee can
	do.  They produced an elegant, considered language design, and
	succeeded in unifying the fractured efforts of their research
	community.  Of the thicket of lazy functional languages that
	existed in 1990, only Clean and Haskell still exist.</para>
    
      <para>Since its publication in 1990, the Haskell language
	standard has seen five revisions, most recently in 1998.
	Researchers have built around half a dozen implementations of
	the language. Of those, about half are still under active
	development.</para>

      <para>During the 1990s, Haskell served two main purposes.  On
	one side, it gave language researchers a stable way to
	experiment with making lazy functional programs run
	efficiently.  Other researchers explored how to construct
	programs using lazy functional techniques.</para>
    </sect2>

    <sect2>
      <title>The modern era</title>

      <para>While these basic explorations of the 1990s proceeded,
	Haskell remained firmly an academic affair.  The informal
	slogan of those inside the community was to <quote>avoid
	  success at all costs</quote>. Few outsiders had heard of the
	language (or even functional programming) at all.</para>

      <para>During this time, the mainstream programming world was
	experimenting with relatively small tweaks: from programming
	in C, to C++, to Java.  Meanwhile, on the fringes, programmers
	were beginning to tinker with new, more expressive languages.
	Guido van Rossum designed Python, and Yukihiro Matsumoto
	developed Ruby.</para>

      <para>As these newer languages began to seep into wider use,
	they spread some crucial ideas. The first was that programmers
	are perfectly capable of working in expressive languages; in
	fact, they flourish.  The second was in part a byproduct of
	the rapid growth in raw computing power of that era: it's
	often smart to sacrifice some execution performance in
	exchange for a big increase in programmer productivity.
	Finally, the creators of these languages explicitly credited
	functional programming as a source of inspiration.</para>
      
      <para>Over the past half a decade, Haskell has successfully
	escaped from academia, buoyed in part by the visibility of
	Python, Ruby, and even Javascript.  The language now has a
	vibrant and fast-growing culture of open source and commercial
	users, and researchers continue to use it to push the
	boundaries of performance and expressiveness.</para>
    </sect2>
  </sect1>

  <sect1 id="whyfp.resources">
    <title>Helpful resources</title>
    <para id="x_Ul">
      As you work with Haskell, you're sure to have questions and want
      more information about things.  Here are some Internet resources
      where you can look up information and interact with other
      Haskell programmers.
    </para>    

    <sect2 id="whyfp.resources.reference">
      <title>Reference material</title>
      <itemizedlist>
        <listitem>
          <para id="x_Vl"><ulink
	      url="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">The 
	      Haskell Hierarchical Libraries reference</ulink>
	    provides the reference to the standard library that comes
	    with your compiler.  This is probably the top item in the
	    bookmarks for many Haskell programmers.</para>
        </listitem>

        <listitem>
          <para id="x_Wl">For questions about language syntax and
	    features, the <ulink
	      url="http://haskell.org/onlinereport/">Haskell 98
	      Report</ulink> describes the Haskell 98 language
	    standard.</para>
        </listitem>

        <listitem>
          <para id="x_Xl">Various extensions to the language have
	    become commonplace since the Haskell 98 Report was
	    released.  The <ulink
	      url="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html">&GHC; 
	      Users's Guide</ulink> contains detailed documentation on
	    the extensions supported by &GHC;, as well as some
	    GHC-specific features.</para>
        </listitem>

        <listitem>
          <para id="x_Yl"><ulink
	      url="http://haskell.org/hoogle/">Hoogle</ulink> is the
	    Haskell API search engine.  It can find functions for you
	    by name or by type.</para>
        </listitem>

      </itemizedlist>
    </sect2>

    <sect2 id="whyfp.resources.apps">
      <title>Applications and libraries</title>
      <para id="x_Zl">
        If you're looking for a Haskell library to use for a
        particular task, or an application written in Haskell, check
        out the resources in this section.
      </para>
      <itemizedlist>
        <listitem>
          <para id="x_al">The Haskell community maintains a central
	    repository of open source Haskell libraries and
	    applications.  It's called <ulink
	      url="http://hackage.haskell.org/">Hackage</ulink>, and
	    it lets you search for software to download, or browse its
	    collection by category.</para>
        </listitem>

        <listitem>
          <para id="x_bl">The <ulink
	      url="http://haskell.org/haskellwiki/Applications_and_libraries">Haskell 
	      Wiki</ulink> contains a section dedicated to information
	    about particular Haskell libraries.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="whyfp.resources.community">
      <title>The Haskell community</title>

      <para id="x_cl">There are a number of ways you can get in touch
	with other Haskell programmers, to ask questions, learn what
	other people are talking about, and simply do some social
	networking with your peers.</para>
      
      <itemizedlist>
        <listitem>
          <para id="x_dl">The first stop on your search for community
	    resources should be the <ulink
	      url="http://www.haskell.org/">Haskell web site</ulink>.
	    This page contains the most current links to various
	    communities and information, as well as a huge and
	    actively maintained wiki.</para>
        </listitem>

        <listitem>
          <para id="x_el">Haskellers use a number of <ulink
	      url="http://haskell.org/haskellwiki/Mailing_lists">mailing 
	      lists</ulink> for topical discussions.  Of these, the
	    most generally interesting is named
	    <code>haskell-cafe</code>.  It has a relaxed,
	    friendly atmosphere, where professionals and academics rub
	    shoulders with casual hackers and beginners.</para>
        </listitem>

        <listitem>
          <para id="x_fl">For real-time chat, the <ulink
	      url="http://haskell.org/haskellwiki/IRC_channel">Haskell
	      IRC channel</ulink>, named <code>#haskell</code>, is
	    large and lively.  Like <code>haskell-cafe</code>, the
	    atmosphere stays friendly and helpful in spite of the huge
	    number of concurrent users.</para>
        </listitem>

        <listitem>
          <para id="x_gl">There are many local user groups, meetups,
	    academic workshops, and the like; here is <ulink
	      url="http://haskell.org/haskellwiki/User_groups">a list
	      of the known user groups and workshops</ulink>.</para>
        </listitem>

        <listitem>
          <para id="x_hl">The <ulink
	      url="http://sequence.complete.org/">Haskell Weekly
	      News</ulink> is a very-nearly-weekly summary of
	    activities in the Haskell community.  You can find
	    pointers to interesting mailing list discussions, new
	    software releases, and the like.</para>
        </listitem>

        <listitem>
          <para id="x_il">The <ulink
	      url="http://haskell.org/communities/">Haskell
	      Communities and Activities Report</ulink> collects
	    information about people that use Haskell, and what they
	    are doing with it.  It has been running for years, so it
	    provides a good way to peer into Haskell's past.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
