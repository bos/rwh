<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="monadtrans" revision="unpublished">
  <title>Monad transformers</title>

  <sect1>
    <title>Motivation: boilerplate avoidance</title>

    <para>Monads provide a powerful way to build computations with
      effects.  Each of the standard monads is specialised to do
      exactly one thing.  Quite often, this does not fit our real
      world needs.</para>

    <para>Recall the <type>Parse</type> type that we developed in
      <xref linkend="binary"/>.  When we introduced monads, we
      mentioned that this type was a state monad in disguise. In fact,
      it's a little more complex than the standard <type>State</type>
      monad, because it uses the <type>Either</type> type to allow the
      possibility of a parsing failure.  If a parse fails early on, we
      want to stop parsing, not continue in some broken state.</para>

    <para>The normal <type>State</type> monad doesn't let us exit
      early in this way.  It uses the default implementation of
      <function>fail</function>: this calls
      <function>error</function>, which throws an exception that we
      can't catch in pure code.  The <type>State</type> monad thus
      <emphasis>appears</emphasis> to allow for failure, without
      actually being any use.  (Once again, we recommend that you
      almost always avoid using <function>fail</function>!)</para>

    <para>Obviously, it would be ideal if we could somehow take the
      standard <type>State</type> monad and add failure handling to
      it, without resorting to the wholesale construction of custom
      monads by hand. The standard monads in the <code>mtl</code>
      library don't allow us to combine them.  Instead, the library
      provides a set of <emphasis>monad
	transformers</emphasis><footnote><para>The name
	  <code>mtl</code> stands for <quote>monad transformer
	    library</quote>.</para></footnote> to achieve the same
      result.</para>

    <para>A monad transformer is similar to a regular monad, but it's
      not a standalone entity: instead, it modifies the behaviour of
      an underlying monad.  Most of the monads in the <code>mtl</code>
      library have transformer equivalents.  By convention, the
      transformer version of a monad has the same name, with a
      <code>T</code> stuck on the end.  For example, the transformer
      equivalent of <type>State</type> is <type>StateT</type>; it adds
      mutable state to an underlying monad.  The <type>WriterT</type>
      monad transformer makes it possible to write data when stacked
      on top of another monad.</para>
  </sect1>

  <sect1>
    <title>A simple monad transformer example</title>

    <para>This function recurses into a directory tree, and returns a
      list of the number of entries it finds at each level of the
      tree.</para>

    &CountEntries.hs:countEntriesTrad;

    <para>Let's consider a different approach, using the
      <type>Writer</type> monad.  Since it lets us record a value
      wherever we want, our code doesn't need to explicitly return a
      result.</para>

    <para>As our function executes in the <type>IO</type> monad, we
      can't use the <type>Writer</type> monad directly.  Instead, we
      use <type>WriterT</type> to add the recording capability to
      <type>IO</type>.  To do this, it helps to understand the types
      involved.</para>

    <para>The normal <type>Writer</type> monad has two type
      parameters, so it's more properly written <type>Writer w
	a</type>.  The first parameter <varname
	role="type">w</varname> is the type of the values to be
      recorded, while <varname role="type">a</varname> is the usual
      type that the <type>Monad</type> type class requires. Thus
      <type>Writer [(FilePath, Int)]</type> is a writer monad that
      records a list of directory names and sizes.</para>
      
    <para>The <type>WriterT</type> transformer has a similar
      structure, but it adds another type parameter, <varname
	role="type">m</varname>: this is the underlying monad whose
      behaviour we are augmenting. The full signature of
      <type>WriterT</type> is <type>WriterT w m a</type>.</para>

    <para>Because we need to traverse directories, which requires
      access to the <type>IO</type> monad, we'll stack our writer on
      top of the <type>IO</type> monad.  Our combination of monad
      transformer and underlying monad will thus have the type
      <type>WriterT [(FilePath, Int)] IO a</type>.  This stack of
      monad transformer and monad is itself a monad.</para>

    &CountEntries.hs:countEntries;

    <para>This code is not terribly different from our earlier
      version. We use <function>liftIO</function> to expose the
      <type>IO</type> monad where necessary, and
      <function>tell</function> to record a visit to a
      directory.</para>

    <para>To run our code, we must use one of <type>WriterT</type>'s
      execution functions.</para>
    
    &countEntries.ghci:runWriterT;

    <para>These functions execute the action, then remove the
      <type>WriterT</type> wrapper and give a result that is wrapped
      in the underlying monad.  The <function>runWriterT</function>
      function gives both the result of the action and whatever was
      recorded as it ran, while <function>execWriterT</function>
      throws away the result and just gives us what was
      recorded.</para>

    &countEntries.ghci:countEntries;

  </sect1>

  <sect1>
    <title>Common patterns in monads and monad transformers</title>

    <para>Most of the monads and monad transformers in the
      <code>mtl</code> library follow a few common patterns around
      naming and type classes.  It's helpful to know these rules of
      thumb, because they are both useful and few in number.</para>

    <para>Rather than speak in general terms, we'll focus on a single
      straightforward monad: the reader monad. This provides a piece
      of immutable, implicit state, often called the
      <emphasis>environment</emphasis>.  The environment is usually
      used to carry around static information, where we don't want to
      be burdened with the bother of passing it around as an explicit
      parameter.  One common use for the reader monad is to store
      configuration information for a program, so that it's available
      when needed, without needing to be passed around as an explicit
      function parameter.</para>

    <para>The reader monad's API is detailed in the
      <type>MonadReader</type> type class.  Most <code>mtl</code>
      monads have similarly named type classes:
      <type>MonadWriter</type> defines the API of the writer monad,
      and so on.</para>

    &Reader.hs:class;

    <para>The type variable <varname role="type">r</varname>
      represents the immutable state that the reader monad carries
      around.  The <type>Reader r</type> monad is an instance of the
      <type>MonadReader</type> class, as is the <type>ReaderT r
	m</type> monad transformer.  Again, this pattern is repeated
      by other <type>mtl</type> monads: there usually exist both a
      concrete monad and a transformer, each of which are instances of
      the type class that defines the monad's API.</para>

    <para>Returning to the specifics of the reader monad, we haven't
      touched upon the <function>local</function> function before.  It
      temporarily modifies the current environment using the <type>r
	-&gt; r</type> function, and executes its action in the
      modified environment.  To make this idea more concrete, here is
      a simple example.</para>

    &LocalReader.hs:localExample;

    <para>If we execute the <function>localExample</function> action
      in &ghci;, we can see that the effect of modifying the
      environment is confined to one place.</para>

    &localReader.ghci:localExample;

    <para>When the underlying monad <varname role="type">m</varname>
      is an instance of <type>MonadIO</type>, the <code>mtl</code>
      library provides an instance for <type>ReaderT r m</type>, and
      also for a number of other type classes.  Here are a few.</para>

    &Reader.hs:instances;

    <para>Once again, most <code>mtl</code> monad transformers define
      instances like these, to make it easier for us to work with
      them.</para>
  </sect1>

  <sect1>
    <title>Stacking multiple monad transformers</title>

    <para>As we have already mentioned, when we stack a monad
      transformer on a normal monad, the result is another monad. This
      suggests the possobility that we can again stack a monad
      transformer on top of our combined monad, to give a new monad,
      and in fact this is a common thing to do.  Under what
      circumstances might we want to create such a stack?</para>

    <itemizedlist>
      <listitem>
	<para>Often, we'll have <type>IO</type> at the base of the
	  stack, because we're interested in programs that need to
	  talk to the outside world.</para>
      </listitem>
      <listitem>
	<para>If we add a <type>ReaderT</type> layer, we give
	  ourselves access to read-only configuration
	  information.</para>
      </listitem>
      <listitem>
	<para>Add a <type>StateT</type> layer, and we gain global
	  state that we can modify.</para>
      </listitem>
      <listitem>
	<para>Should we need the ability to log events, we can add a
	  <type>WriterT</type> layer.</para>
      </listitem>
    </itemizedlist>

    <para>The power of this approach is that we can customise the
      stack to our exact needs, specifying which kinds of effects we
      want to support.</para>

    <para>As a small example of stacked monad transformers in action,
      here is a reworking of the <function>countEntries</function>
      function we developed earlier.  We use <type>ReaderT</type> to
      store configuration data, in the form of the maximum depth of
      recursion we will perform.  We also use <type>StateT</type> to
      record the maximum depth we reach during an actual
      traversal.</para>

    &UglyStack.hs:App;

    <para>Our transformer stack has <type>IO</type> on the bottom,
      then <type>StateT</type>, with <type>ReaderT</type> on top. Even
      a small stack of monad transformers quickly develops an unwieldy
      type name.  We use a &type; alias to reduce the lengths of the
      type signatures that we write.</para>

    <para>The execution function for our monad stack is simple.</para>

    &UglyStack.hs:runApp;

    <para>Our application of <function>runReaderT</function> removes
      the <type>ReaderT</type> transformer wrapper, while
      <function>runStateT</function> removes the <type>StateT</type>
      wrapper, leaving us with a result in the <type>IO</type>
      monad.</para>

    <para>Compared to earlier versions, the only complications we have
      added to  our traversal function are slight: we track our
      current depth, and record the maximum depth we reach.</para>

    &UglyStack.hs:constrainedCount;

    <para>Our use of monad transformers here is admittedly a little
      contrived.  Because we're writing a single straightforward
      function, we're not really winning anything.  What's useful
      about this approach, though, is that it
      <emphasis>scales</emphasis> to bigger programs.</para>

    <para>We can write most of an application's imperative-style code
      in a monad stack similar to our <type>App</type> monad.  In a
      real program, we'd carry around more complex configuration data,
      but we'd still use <type>ReaderT</type> to keep the it read-only
      and hidden except when needed.  We'd have more mutable state to
      manage, but we'd still use <type>StateT</type> to encapsulate
      it.</para>

    <sect2>
      <title>Hiding our work</title>

      <para>We can use the usual &newtype; technique to erect a solid
	barrier between the implementation of our custom monad and its
	interface.</para>

      &UglyStack.hs:MyApp;

      <para>If we export the <type>MyApp</type> type constructor and
	the <function>runMyApp</function> execution function from a
	module, client code will not be able to tell that the
	internals of our monad is a stack of monad
	transformers.</para>

      <para>The large <code>deriving</code> clause requires the
	<code>GeneralizedNewtypeDeriving</code> language pragma.  It
	seems somehow magical that the compiler can derive all of
	these instances for us.  How does this work?</para>

      <para>Earlier, we mentioned that the <code>mtl</code> library
	provides instances of a number of type classes for each monad
	transformer.  For example, the <type>IO</type> monad
	implements <type>MonadIO</type>.  If the underlying monad is
	an instance of <type>MonadIO</type>, <code>mtl</code> makes
	<type>StateT</type> an instance, too, and likewise for
	<type>ReaderT</type>.</para>

      <para>There is thus no magic going on: the top-level monad
	transformer in the stack is an instance of all of the type
	classes that we're rederiving with our <code>deriving</code>
	clause. This is a consequence of <code>mtl</code> providing a
	carefully coordinated set of type classes and instances that
	fit together well.  We can still make progress in the absence
	of this framework, and we'll shortly see how.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Moving down the stack</title>

    <para>So far, our uses of monad transformers have been simple, and
      the plumbing of the <code>mtl</code> library has allowed us to
      avoid the details of how a stack of monads is constructed.
      Indeed, we already know enough about monad transformers to
      simplify many common programming tasks.</para>

    <para>There exist a few common ways in which we can depart from
      the comfort of <code>mtl</code>.  Most often, a custom monad
      sits at the bottom of the stack, or a custom monad transformer
      lies somewhere within the stack.  To understand the potential
      difficulty, let's look at an example.</para>

    <para>Suppose we have a custom monad transformer,
      <type>CustomT</type>.</para>

    &CustomT.hs:CustomT;

    <para>In the framework that <code>mtl</code> provides, each monad
      transformer in the stack makes the API of a lower level
      available by providing instances of a host of type classes.  We
      could follow this pattern, and write a number of boilerplate
      instances.</para>

    &CustomT.hs:mtl;

    <para>If the underlying monad was an instance of
      <type>MonadReader</type>, we would write a
      <type>MonadReader</type> instance for <type>CustomT</type> in
      which each function in the API passes through to the
      corresponding function in the underlying instance.  This would
      allow higher level code to only care that the stack as a whole
      is an instance of <type>MonadReader</type>, without knowing or
      caring about which layer provides the <emphasis>real</emphasis>
      implementation.</para>

    <para>Sometimes, it is desirable to access the underlying monad in
      a generic way: we need a monad, but don't care which kind.  The
      <type>MonadTrans</type> type class defines a
      <function>lift</function> function for exactly this
      situation.</para>

    &monadTrans.ghci:MonadTrans;

    <para>This function takes a monadic action from one layer down the
      stack, and turns it into an action in the current monad
      transformer.</para>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
