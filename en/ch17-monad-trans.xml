<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="monadtrans" revision="unpublished">
  <title>Monad transformers</title>

  <sect1>
    <title>Motivation: boilerplate avoidance</title>

    <para>Monads provide a powerful way to build computations with
      effects.  Each of the standard monads is specialised to do
      exactly one thing.  Quite often, this does not fit our real
      world needs.</para>

    <para>Recall the <type>Parse</type> type that we developed in
      <xref linkend="binary"/>.  When we introduced monads, we
      mentioned that this type was a state monad in disguise. In fact,
      it's a little more complex than the standard <type>State</type>
      monad, because it uses the <type>Either</type> type to allow the
      possibility of a parsing failure.  If a parse fails early on, we
      want to stop parsing, not continue in some broken state.</para>

    <para>The normal <type>State</type> monad doesn't let us exit
      early in this way.  It uses the default implementation of
      <function>fail</function>: this calls
      <function>error</function>, which throws an exception that we
      can't catch in pure code.  The <type>State</type> monad thus
      <emphasis>appears</emphasis> to allow for failure, without
      actually being any use.  (Once again, we recommend that you
      almost always avoid using <function>fail</function>!)</para>

    <para>Obviously, it would be ideal if we could somehow take the
      standard <type>State</type> monad and add failure handling to
      it, without resorting to the wholesale construction of custom
      monads by hand. The standard monads in the <code>mtl</code>
      library don't allow us to combine them.  Instead, the library
      provides a set of <emphasis>monad
	transformers</emphasis><footnote><para>The name
	  <code>mtl</code> stands for <quote>monad transformer
	    library</quote>.</para></footnote> to achieve the same
      result.</para>

    <para>A monad transformer is similar to a regular monad, but it's
      not a standalone entity: instead, it modifies the behaviour of
      an underlying monad.  Most of the monads in the <code>mtl</code>
      library have transformer equivalents.  By convention, the
      transformer version of a monad has the same name, with a
      <code>T</code> stuck on the end.  For example, the transformer
      equivalent of <type>State</type> is <type>StateT</type>; it adds
      mutable state to an underlying monad.  The <type>WriterT</type>
      monad transformer makes it possible to write data when stacked
      on top of another monad.</para>
  </sect1>

  <sect1>
    <title>A simple monad transformer example</title>

    <para>This function recurses into a directory tree, and returns a
      list of the number of entries it finds at each level of the
      tree.</para>

    &CountEntries.hs:countEntriesTrad;

    <para>Let's consider a different approach, using the
      <type>Writer</type> monad.  Since it lets us record a value
      wherever we want, our code doesn't need to explicitly return a
      result.</para>

    <para>As our function executes in the <type>IO</type> monad, we
      can't use the <type>Writer</type> monad directly.  Instead, we
      use <type>WriterT</type> to add the recording capability to
      <type>IO</type>.  To do this, it helps to understand the types
      involved.</para>

    <para>The normal <type>Writer</type> monad has two type
      parameters, so it's more properly written <type>Writer w
	a</type>.  The first parameter <varname
	role="type">w</varname> is the type of the values to be
      recorded, while <varname role="type">a</varname> is the usual
      type that the <type>Monad</type> type class requires. Thus
      <type>Writer [(FilePath, Int)]</type> is a writer monad that
      records a list of directory names and sizes.</para>
      
    <para>The <type>WriterT</type> transformer has a similar
      structure, but it adds another type parameter, <varname
	role="type">m</varname>: this is the underlying monad whose
      behaviour we are augmenting. The full signature of
      <type>WriterT</type> is <type>WriterT w m a</type>.</para>

    <para>Because we need to traverse directories, which requires
      access to the <type>IO</type> monad, we'll stack our writer on
      top of the <type>IO</type> monad.  Our combination of monad
      transformer and underlying monad will thus have the type
      <type>WriterT [(FilePath, Int)] IO a</type>.  This stack of
      monad transformer and monad is itself a monad.</para>

    &CountEntries.hs:countEntries;

    <para>This code is not terribly different from our earlier
      version. We use <function>liftIO</function> to expose the
      <type>IO</type> monad where necessary, and
      <function>tell</function> to record a visit to a
      directory.</para>

    <para>To run our code, we must use one of <type>WriterT</type>'s
      execution functions.</para>
    
    &countEntries.ghci:runWriterT;

    <para>These functions execute the action, then remove the
      <type>WriterT</type> wrapper and give a result that is wrapped
      in the underlying monad.  The <function>runWriterT</function>
      function gives both the result of the action and whatever was
      recorded as it ran, while <function>execWriterT</function>
      throws away the result and just gives us what was
      recorded.</para>

    &countEntries.ghci:countEntries;

  </sect1>

  <sect1>
    <title>Common patterns in monads and monad transformers</title>

    <para>Most of the monads and monad transformers in the
      <code>mtl</code> library follow a few common patterns around
      naming and type classes.  It's helpful to know these rules of
      thumb, because they are both useful and few in number.</para>

    <para>Rather than speak in general terms, we'll focus on a single
      straightforward monad: the reader monad. This provides a piece
      of immutable, implicit state, often called the
      <emphasis>environment</emphasis>.  The environment is usually
      used to carry around static information, where we don't want to
      be burdened with the bother of passing it around as an explicit
      parameter.  One common use for the reader monad is to store
      configuration information for a program, so that it's available
      when needed, without needing to be passed around as an explicit
      function parameter.</para>

    <para>The reader monad's API is detailed in the
      <type>MonadReader</type> type class.  Most <code>mtl</code>
      monads have similarly named type classes:
      <type>MonadWriter</type> defines the API of the writer monad,
      and so on.</para>

    &Reader.hs:class;

    <para>The type variable <varname role="type">r</varname>
      represents the immutable state that the reader monad carries
      around.  The <type>Reader r</type> monad is an instance of the
      <type>MonadReader</type> class, as is the <type>ReaderT r
	m</type> monad transformer.  Again, this pattern is repeated
      by other <type>mtl</type> monads: there usually exist both a
      concrete monad and a transformer, each of which are instances of
      the type class that defines the monad's API.</para>

    <para>Returning to the specifics of the reader monad, we haven't
      touched upon the <function>local</function> function before.  It
      temporarily modifies the current environment using the <type>r
	-&gt; r</type> function, and executes its action in the
      modified environment.  To make this idea more concrete, here is
      a simple example.</para>

    &LocalReader.hs:localExample;

    <para>If we execute the <function>localExample</function> action
      in &ghci;, we can see that the effect of modifying the
      environment is confined to one place.</para>

    &localReader.ghci:localExample;

    <para>When the underlying monad <varname role="type">m</varname>
      is an instance of <type>MonadIO</type>, the <code>mtl</code>
      library provides an instance for <type>ReaderT r m</type>, and
      also for a number of other type classes.  Here are a few.</para>

    &Reader.hs:instances;

    <para>Once again, most <code>mtl</code> monad transformers define
      instances like these, to make it easier for us to work with
      them.</para>
  </sect1>

  <sect1>
    <title>Stacking multiple monad transformers</title>

    <para>As we have already mentioned, when we stack a monad
      transformer on a normal monad, the result is another monad. This
      suggests the possobility that we can again stack a monad
      transformer on top of our combined monad, to give a new monad,
      and in fact this is a common thing to do.  Under what
      circumstances might we want to create such a stack?</para>

    <itemizedlist>
      <listitem>
	<para>Often, we'll have <type>IO</type> at the base of the
	  stack, because we're interested in programs that need to
	  talk to the outside world.</para>
      </listitem>
      <listitem>
	<para>If we add a <type>ReaderT</type> layer, we give
	  ourselves access to read-only configuration
	  information.</para>
      </listitem>
      <listitem>
	<para>Add a <type>StateT</type> layer, and we gain global
	  state that we can modify.</para>
      </listitem>
      <listitem>
	<para>Should we need the ability to log events, we can add a
	  <type>WriterT</type> layer.</para>
      </listitem>
    </itemizedlist>

    <para>The power of this approach is that we can customise the
      stack to our exact needs, specifying which kinds of effects we
      want to support.</para>

    <para>As a small example of stacked monad transformers in action,
      here is a reworking of the <function>countEntries</function>
      function we developed earlier.  We will modify it to recurse no
      deeper into a directory tree than a given amount, and to record
      the maximum depth it reaches.</para>

    &UglyStack.hs:AppData;

    <para>We use <type>ReaderT</type> to store configuration data, in
      the form of the maximum depth of recursion we will perform.  We
      also use <type>StateT</type> to record the maximum depth we
      reach during an actual traversal.</para>

    &UglyStack.hs:App;

    <para>Our transformer stack has <type>IO</type> on the bottom,
      then <type>StateT</type>, with <type>ReaderT</type> on top. Even
      a small stack of monad transformers quickly develops an unwieldy
      type name.  We use a &type; alias to reduce the lengths of the
      type signatures that we write.</para>

    <note>
      <title>Where's the missing type parameter?</title>

      <para>You might have noticed that our &type; synonym doesn't
	have the usual type parameter <varname>a</varname> that we
	associate with a monadic type:</para>

      &UglyStack.hs:App2;

      <para>Both <type>App</type> and <type>App2</type> work fine in
	normal type signatures.  The difference arises when we try to
	construct another type from one of these.  Say we want to add
	another monad transformer to the stack: the compiler will
	allow <type>WriterT [String] App a</type>, but reject
	<type>WriterT [String] App2 a</type>.</para>

      <para>The reason for this is that Haskell does not allow us to
	partially apply a type synonym.  The synonym <type>App</type>
	doesn't take a type parameter, so it doesn't pose a problem.
	However, because <type>App2</type> takes a type parameter, we
	must supply some type for that parameter if we want to use
	<type>App2</type> to create another type.</para>

      <para>This restriction is limited to type synonyms.  When we
	create a monad transformer stack, we usually wrap it with a
	&newtype; (as we will see below).  As a result, we will rarely
	run into this problem in practice.</para>
    </note>

    <para>The execution function for our monad stack is simple.</para>

    &UglyStack.hs:runApp;

    <para>Our application of <function>runReaderT</function> removes
      the <type>ReaderT</type> transformer wrapper, while
      <function>runStateT</function> removes the <type>StateT</type>
      wrapper, leaving us with a result in the <type>IO</type>
      monad.</para>

    <para>Compared to earlier versions, the only complications we have
      added to  our traversal function are slight: we track our
      current depth, and record the maximum depth we reach.</para>

    &UglyStack.hs:constrainedCount;

    <para>Our use of monad transformers here is admittedly a little
      contrived.  Because we're writing a single straightforward
      function, we're not really winning anything.  What's useful
      about this approach, though, is that it
      <emphasis>scales</emphasis> to bigger programs.</para>

    <para>We can write most of an application's imperative-style code
      in a monad stack similar to our <type>App</type> monad.  In a
      real program, we'd carry around more complex configuration data,
      but we'd still use <type>ReaderT</type> to keep the it read-only
      and hidden except when needed.  We'd have more mutable state to
      manage, but we'd still use <type>StateT</type> to encapsulate
      it.</para>

    <sect2>
      <title>Hiding our work</title>

      <para>We can use the usual &newtype; technique to erect a solid
	barrier between the implementation of our custom monad and its
	interface.</para>

      &UglyStack.hs:MyApp;

      <para>If we export the <type>MyApp</type> type constructor and
	the <function>runMyApp</function> execution function from a
	module, client code will not be able to tell that the
	internals of our monad is a stack of monad
	transformers.</para>

      <para>The large <code>deriving</code> clause requires the
	<code>GeneralizedNewtypeDeriving</code> language pragma.  It
	seems somehow magical that the compiler can derive all of
	these instances for us.  How does this work?</para>

      <para>Earlier, we mentioned that the <code>mtl</code> library
	provides instances of a number of type classes for each monad
	transformer.  For example, the <type>IO</type> monad
	implements <type>MonadIO</type>.  If the underlying monad is
	an instance of <type>MonadIO</type>, <code>mtl</code> makes
	<type>StateT</type> an instance, too, and likewise for
	<type>ReaderT</type>.</para>

      <para>There is thus no magic going on: the top-level monad
	transformer in the stack is an instance of all of the type
	classes that we're rederiving with our <code>deriving</code>
	clause. This is a consequence of <code>mtl</code> providing a
	carefully coordinated set of type classes and instances that
	fit together well.  We can still make progress in the absence
	of this framework, and we'll shortly see how.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Moving down the stack</title>

    <para>So far, our uses of monad transformers have been simple, and
      the plumbing of the <code>mtl</code> library has allowed us to
      avoid the details of how a stack of monads is constructed.
      Indeed, we already know enough about monad transformers to
      simplify many common programming tasks.</para>

    <para>There exist a few common ways in which we can depart from
      the comfort of <code>mtl</code>.  Most often, a custom monad
      sits at the bottom of the stack, or a custom monad transformer
      lies somewhere within the stack.  To understand the potential
      difficulty, let's look at an example.</para>

    <para>Suppose we have a custom monad transformer,
      <type>CustomT</type>.</para>

    &CustomT.hs:CustomT;

    <para>In the framework that <code>mtl</code> provides, each monad
      transformer in the stack makes the API of a lower level
      available by providing instances of a host of type classes.  We
      could follow this pattern, and write a number of boilerplate
      instances.</para>

    &CustomT.hs:mtl;

    <para>If the underlying monad was an instance of
      <type>MonadReader</type>, we would write a
      <type>MonadReader</type> instance for <type>CustomT</type> in
      which each function in the API passes through to the
      corresponding function in the underlying instance.  This would
      allow higher level code to only care that the stack as a whole
      is an instance of <type>MonadReader</type>, without knowing or
      caring about which layer provides the <emphasis>real</emphasis>
      implementation.</para>

    <para>Instead of relying on all of these type class instances to
      work for us behind the scenes, we can be explicit. The
      <type>MonadTrans</type> type class defines a useful function
      named <function>lift</function>.</para>

    &monadTrans.ghci:MonadTrans;

    <para>This function takes a monadic action from one layer down the
      stack, and turns it&emdash;in other words,
      <emphasis>lifts</emphasis> it&emdash;into an action in the
      current monad transformer. Every monad transformer is an
      instance of <type>MonadTrans</type>.</para>

    <para>Let's revisit the <type>App</type> monad stack we defined
      earlier (before we wrapped it with a &newtype;).</para>

    &UglyStack.hs:App.noid;

    <para>If we want to access the <type>AppState</type> carried by
      the <type>StateT</type>, we would usually rely on
      <code>mtl</code>'s type classes and instances to handle the
      plumbing for us.</para>
    
    &UglyStack.hs:implicitGet;

    <para>The <function>lift</function> function lets us achieve the
      same effect, by lifting <function>get</function> from
      <type>StateT</type> into <type>ReaderT</type>.</para>

    &UglyStack.hs:explicitGet;

    <para>Obviously, when we can let <code>mtl</code> do this work for
      us, we end up with cleaner code, but this is not always
      possible.</para>

    <sect2>
      <title>When explicit lifting is necessary</title>

      <para>One case in which we <emphasis>must</emphasis> use
	<function>lift</function> is when we create a monad
	transformer stack in which instances of the same type class
	appear at multiple levels.</para>

      &StackStack.hs:Foo;

      <para>If we try to use <type>MonadState</type>'s
	<function>put</function> action, <type>StateT Int</type>'s
	instance of <type>MonadState</type> is the one we get, because
	it's at the top of the stack.</para>

      &StackStack.hs:outerPut;

      <para>The only way we can access the underlying
	<type>State</type> monad's <function>put</function> is through
	use of <function>lift</function>.</para>

      &StackStack.hs:innerPut;

      <para>Sometimes, we need to access a monad more than one level
	down the stack, in which case we must compose calls to
	<function>lift</function>.  Each composed use of
	<function>lift</function> gives us access to one deeper
	level.</para>

      &StackStack.hs:Bar;

      <para>When we need to use <function>lift</function>, it can be
	good style to write wrapper functions that do the lifting for
	us, as above, and to use those.  The alternative of sprinkling
	explicit uses of <function>lift</function> throughout our code
	tends to look messy.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>Understanding monad transformers by building one</title>

    <para>To give ourselves some insight into how monad transformers
      in general work, we will create one and describe its machinery
      as we go.  Our target is simple and useful, but surprisingly
      it's missing from the <code>mtl</code> library:
      <type>MaybeT</type>.</para>

    <para>This monad transformer modifies the behaviour of an
      underlying monad <type>m a</type> by wrapping its type parameter
      with <type>Maybe</type>, to give <type>m (Maybe a)</type>.   As
      with the <type>Maybe</type> monad, if we call
      <function>fail</function> in the <type>MaybeT</type> monad
      transformer, execution terminates early.</para>

    <para>In order to turn <type>m (Maybe a)</type> into a
      <type>Monad</type> instance, we must make it a distinct type,
      via a &newtype; declaration.</para>

    &MaybeT.hs:newtype;

    <para>We now need to define the three standard monad functions.
      The most complex is &bind;, and its innards shed the most light
      on what we are actually doing.  Before we delve into its
      operation, let us first take a look at its type.</para>

    &MaybeT.hs:bindMT.type;

    <para>To understand this type signature, hark back to our
      discussion of multi-parameter type classes in <xref
	linkend="monadcase.mptc"/>.  The thing that we intend to make
      a <type>Monad</type> instance is the <emphasis>partial
	type</emphasis> <type>MaybeT m</type>: this has the usual
      single type parameter, <varname>a</varname>, that satisfies the
      requirements of the <type>Monad</type> type class.</para>

    <para>The trick to understanding the body of our &bind;
      implementation is that everything inside the &do; block executes
      in the <emphasis>underlying</emphasis> monad <type>m</type>,
      whatever that is.</para>

    &MaybeT.hs:bindMT;

    <para>Our <function>runMaybeT</function> function unwraps the
      result contained in <varname>x</varname>.  Next, recall that the
      <code>&lt;-</code> symbol desugars to &bind;: a monad
      transformer's &bind; must use the underlying monad's &bind;. The
      final bit of case analysis determines whether we short circuit
      or chain our computation.  Finally, look back at the top of the
      body: here, we must wrap the result with the <type>MaybeT</type>
      constructor, to once again hide the underlying monad.</para>

    <para>The &do; notation above might be pleasant to read, but it
      hides the fact that we are relying on the underlying monad's
      &bind; implementation.  Here is a more idiomatic version of
      &bind; for <type>MaybeT</type> that makes this clearer.</para>

    &MaybeT.hs:altBindMT;

    <para>Now that we understand what &bind; is doing, our
      implementations of <function>return</function> and
      <function>fail</function> need no explanation, and neither does
      our <type>Monad</type> instance.</para>

    &MaybeT.hs:Monad;

    <sect2>
      <title>Creating a monad transformer</title>

      <para>To turn our type into a monad transformer, we must provide
	an instance of the <type>MonadTrans</type> class, so that a
	user can access the underlying monad.</para>

      &MaybeT.hs:MonadTrans;

      <para>The underlying monad starts out with a type parameter of
	<type>a</type>: we <quote>inject</quote> the <code>Just</code>
	constructor so it will acquire the type that we need,
	<type>Maybe a</type>.  We then hide the monad with our
	<type>MaybeT</type> constructor.</para>
    </sect2>

    <sect2>
      <title>More type class instances</title>

      <para>Once we have an instance for <type>MonadTrans</type>
	defined, we can use it to define instances for the umpteen
	other <code>mtl</code> type classes.</para>

      &MaybeT.hs:mtl;

      <para>Because several of the <code>mtl</code> type classes use
	functional dependencies, some of our instance declarations
	require us to considerably relax &GHC;'s usual strict type
	checking rules. (If we were to forget any of these directives,
	the compiler would helpfully advise us which ones we needed in
	its error messages.)</para>

      &MaybeT.hs:LANGUAGE;

      <para>Is it better to use <function>lift</function> explicitly,
	or to spend time writing these boilerplate instances?  That
	depends on what we expect to do with our monad transformer.
	If we're going to use it in just a few restricted situations, we
	can get away with providing an instance for
	<type>MonadTrans</type> alone.  A few more instances might
	make sense, such as <type>MonadIO</type>.  If the transformer
	is going to pop up in diverse situations throughout a body of
	code, spending a dull hour to write those instances might be a
	good investment.</para>
    </sect2>

    <sect2>
      <title>Replacing the Parse type with a monad stack</title>

      <para>Now that we have developed a monad transformer that can
	exit early, we can use it to bail if, for example, a parse
	fails partway through. We could thus replace the
	<type>Parse</type> type that we developed in <xref
	  linkend="binary.implicit"/> with a monad customised to our
	needs.</para>

      &MaybeTParse.hs:Parse;

    </sect2>

    <sect2>
      <title>Exercises</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Our <type>Parse</type> monad is not a perfect
	      replacement for its earlier counterpart.  Because we are
	      using <type>Maybe</type> instead of <type>Either</type>
	      to represent a result, we can't report any useful
	      information if a parse fails.</para>

	    <para>Create an <type>EitherT sometype</type> monad
	      transformer, and use it to implement a more capable
	      <type>Parse</type> monad that can report an error
	      message if parsing fails.</para>

	    <tip>
	      <para>If you like to explore the Haskell libraries for
		fun, you may have run across an existing
		<type>Monad</type> instance for the
		<type>Either</type> type in the
		<code>Control.Monad.Error</code> module.  Don't use
		that as a guide; its design is too restrictive.</para>
	    </tip>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>Transformer stacking order is important</title>

    <para>From our early examples using monad transformers like
      <type>ReaderT</type> and <type>StateT</type>, it might be easy
      to conclude that the order in which we stack monad transformers
      doesn't matter.</para>

    <para>When we stack <type>StateT</type> on top of
      <type>State</type>, it should be clearer that order can indeed
      make a difference.  The types <type>StateT Int (State
	String)</type> and <type>StateT String (State Int)</type>
      might carry around the same information, but we can't use them
      interchangeably.  The ordering determines when we need to use
      <function>lift</function> to get at one or the other piece of
      state.</para>

    <para>Here's a case that more dramatically demonstrates the
      importance of ordering.  Suppose we have a computation that
      might fail, and we want to log the circumstances under which it
      does so.</para>

    &MTComposition.hs:problem;

    <para>Which of these monad stacks will give us the information we
      need?</para>

    &MTComposition.hs:types;

    <para>Let's try the alternatives in &ghci;.</para>

    &mtComposition.ghci:problem;

    <para>This difference in results should not come as a surprise:
      just look at the signatures of the execution functions.</para>

    &mtComposition.ghci:runWriterT;

    <para>Our <type>WriterT</type>-on-<type>Maybe</type> stack has
      <type>Maybe</type> as the underlying monad, so
      <function>runWriterT</function> must give us back a result of
      type <type>Maybe</type>.  In our test case, we only get to see
      the log of what happened if nothing actually went wrong!</para>

    <para>Stacking monad transformers is analogous to composing
      functions.  We are not surprised when we change the order in
      which we apply functions and thus get different results, and so
      it is with monad transformers, too.</para>
  </sect1>

  <sect1>
    <title>Putting monads and monad transformers into
      perspective</title>
    
    <para>It's useful to step back from details for a few moments, and
      look at the strengths and weaknesses of programming with monads
      and monad transformers.</para>

    <para>Probably the biggest irritation of working with monads is
      that a monad's type constructor often prevents us from using
      pure code.  Many useful pure functions need monadic
      counterparts.</para>

    &monadProblems.ghci:filter;

    <para>However, the standard libraries don't always provide monadic
      versions of pure functions.</para>

    &monadProblems.ghci:zip;

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
