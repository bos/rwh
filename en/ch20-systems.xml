<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.systems" revision="unpublished">
  <title>Systems Programming in Haskell</title>

  <para>
    So far, we've been talking mostly about high-level concepts.  Haskell can
    also be used for lower-level systems programming.  It is quite possible
    to write programs that interface with the operating system at a low level
    using Haskell.
  </para>
  <para>
    In this chapter, we are going to attempt something ambitious: a Perl-like
    "language" that is valid Haskell, implemented in pure Haskell, that makes
    shell scripting easy.  We are going to implement piping, easy command
    invocation, and some simple tools to handle tasks that might otherwise be
    performed with <literal>grep</literal> or <literal>sed</literal>.
  </para>
  <para>
    Specialized modules exist for different operating systems.  In this
    chapter, we will use generic OS-independent modules as much as possible.
    However, we will be focusing on the POSIX environment for much of the
    chapter.  POSIX is a standard for Unix-like operating systems such as
    Linux, FreeBSD, MacOS X, or Solaris.  Windows does not support POSIX by
    default, but the Cygwin environment provides a POSIX compatibility layer
    for Windows.
  </para>

  <sect1 id="hs.systems.running">
    <title>Running External Programs</title>
    <para>
      It is possible to invoke external commands from Haskell.  To do that,
      we suggest using <literal>rawSystem</literal> from the
      <literal>System.Cmd</literal> module.  This will invoke a specified
      program, with the specified arguments, and return the exit code from
      that program.  You can play with it in &ghci;:
    </para>
    &rawSystem.ghci:s1;
    <para>
      Here, we run the equivolent of the shell command <literal>ls -l /usr</literal>.  
      <literal>rawSystem</literal> does not parse arguments from a string or
      expand wildcards.<footnote><para>There is also a function
          <literal>system</literal> that takes only a single string and
          passes it through the shell to parse.  We recommend using
          <literal>rawSystem</literal> instead, because the shell attaches
          special meaning to certain characters, which could lead to security
          issues or unexpected behavior.</para></footnote>
      Instead, it expects every argument to be contained
      in a list.  If you don't want to pass any arguments, you can simply
      pass an empty list like this:
    </para>
    &rawSystem.ghci:s2;
  </sect1>

  <sect1 id="hs.systems.directories">
    <title>Directory and File Information</title>
    <para>
      The <literal>System.Directory</literal> module contains quite a few
      functions that can be used to obtain information from the filesystem.
      You can get a list of files in a directory, rename or delete files,
      copy files, change the current working directory, or create new
      directories.  <literal>System.Directory</literal> is portable and works
      on any platform where GHC itself works.
    </para>
    <para>
      The <ulink
        url="http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html">library
        reference for <literal>System.Directory</literal></ulink> provides a
      comprehensive list of the functions available.  Let's use &ghci; to
      demonstrate a few of them.  Most of these functions are straightforward
      equivolents to C library calls or shell commands.
    </para>
    &dir.ghci:setdir;
    <para>
      Here we saw commands to change the current working directory and obtain
      the current working directory from the system.  These are similar to
      the <literal>cd</literal> and <literal>pwd</literal> commands in the
      POSIX shell.
    </para>
    &dir.ghci:contents;
    <para>
      <literal>getDirectoryContents</literal> returns a list for every item
      in a given directory.  Note that on POSIX systems, this list normally
      includes the special values <literal>"."</literal> and
      <literal>".."</literal>.  You will usually want to filter these out
      when processing the content of the directory, perhaps like this:
    </para>
    &dir.ghci:contents2;
    <para>
      You can also query the system about the location of certain
      directories.   This query will ask the underlying operating system for
      the information.
    </para>
    &dir.ghci:query;
  </sect1>

  <sect1 id="hs.system.termination">
    <title>Program Termination</title>
    <para>
      Developers often write individual programs to accomplish particular
      tasks.  These individual parts may be combined to accomplish larger
      tasks.  A shell script or another program may execute them.  The
      calling script often needs a way to discover whether the program was
      able to complete its task successfully.  Haskell automatically
      indicates a non-successful exit whenever a program is aborted by an
      exception.
    </para>
    <para>However, you may need more fine-grained control over the
      exit code than that.   Perhaps you need to return different codes for
      different types of errors.
      The <literal>System.Exit</literal> module provides a way to exit the
      program and return a specific exit status code to the caller.  You can
      call <literal>exitWith ExitSuccess</literal> to return a code
      indicating a successful termination (0 on POSIX systems).  Or, you can
      call something like <literal>exitWith (ExitFailure 5)</literal>, which
      will return code 5 to the calling program.
    </para>
  </sect1>

  <sect1 id="hs.systems.datetime"> 
    <title>Dates and Times</title>
    <para>
      Everything from file timestamps to business transactions involve dates
      and times.  Haskell provides ways for manipulating dates and times, as
      well as features for obtaining date and time information from the
      system.
    </para>
    <sect2 id="hs.systems.datetime.types">
      <title>ClockTime and CalendarTime</title>
      <para> In Haskell, the
        <literal>System.Time</literal> module is primarily responsible for
        date and time handling.  It defines two types: &ClockTime; and
        &CalendarTime;.  </para> <para> &ClockTime; is the Haskell version of
        the traditional POSIX epoch.  A &ClockTime; represents the number of
        seconds since midnight the morning of January 1, 1970, UTC.  A
        negative &ClockTime; represents times prior to that date, while a
        positive number represents times after it.  
      </para> 
      <para>
        &ClockTime; is convenient for computations.  Since it tracks
        Coordinated Universal Time (UTC), it doesn't have to adjust for local
        timezones, daylight saving time, or other special cases in time
        handling.  Every day is exactly (60 * 60 * 24) or 86,400
        seconds<footnote><para>Some will note that UTC defines leap seconds
            at irregular intervals.  The POSIX standard, which Haskell
            follows, states that every day is exactly 86,400 seconds in
            length in its representation, so you need not be concerned about
            leap seconds when performing routine calculations.  The exact
            manner of handling leap seconds is system-dependant and complex,
            though usually it can be explained as having a "long second".
            This nuance is generally only of interest when performing precise
            subsecond calculations.</para></footnote>, which makes time
        interval calculations simple.  You can, for instance, check the
        &ClockTime; at the start of a long task, again at the end, and simply
        subtract the start time from the end time to determine how much time
        elapsed.  You can then divide by 24 and display the elapsed time as a
        count of hours if you wish.
      </para>
      <para>
        &ClockTime; is ideal for answering questions such as these:
      </para>
      <itemizedlist>
        <listitem><para>How much time has elapsed?</para></listitem>
        <listitem><para>What will be the &ClockTime; 14 days ahead of this
            precise instant?</para></listitem>
        <listitem><para>When was the file last modified?</para></listitem>
        <listitem><para>What is the precise time right now?</para></listitem>
      </itemizedlist>
      <para>
        These are good uses of &ClockTime; because they refer to precise,
        unambiguous moments in time.  However, &ClockTime; is not as easily
        used for questions such as:
      </para>
      <itemizedlist>
        <listitem><para>Is today Monday?</para></listitem>
        <listitem><para>What will be the time on this date next
            month?</para></listitem>
        <listitem><para>What day of the week will May 1 fall on next
            year?</para></listitem>
        <listitem><para>What is the current time in my local timezone,
            taking the potential presence of Daylight Saving Time (DST) into
            account?</para></listitem>
      </itemizedlist>
      <para>
        &CalendarTime; stores a time the way humans do: with a year, month,
        day, hour, minute, second, timezone, and DST information.  It's easy
        to convert this into a conveniently-displayable string, or to answer
        questions about the local time.
      </para>
      <para>
        You can convert between &ClockTime; and &CalendarTime; at will.
        Haskell includes functions to convert a &ClockTime; to a
        &CalendarTime; in the local timezone, or to a &CalendarTime;
        representing UTC.
      </para>
      <sect3 id="hs.systems.clocktime">
        <title>Using ClockTime</title>
        <para>
          &ClockTime; is defined in <literal>System.Time</literal> like this:
        </para>
        <programlisting>
data ClockTime = TOD Integer Integer
        </programlisting>
        <para>
          The first &Integer; represents the number of seconds since the
          epoch.  The second &Integer; represents an additional number of
          picoseconds.  Because &ClockTime; in Haskell uses the unbounded
          &Integer; type, it can effectively represent a date range limited only
          by computational resources.
        </para>
        <para>
          Let's look at some ways to use &ClockTime;.  First, there is the
          <literal>getClockTime</literal> function that returns the current
          time according to the system's clock.
        </para>
        &time.ghci:getClockTime;
        <para>
          If you wait a second and run <literal>getClockTime</literal> again,
          you'll see it returning an updated time.  Notice that the output
          from this command was a nice-looking string, complete with
          day-of-week information.  That's due to the &Show; instance for
          &ClockTime;.  Let's look at the &ClockTime; at a lower level:
        </para>
        &time.ghci:ClockTime2;
        <para>
          Here we first construct a &ClockTime; representing the point in
          time 1500 seconds after midnight on January 1, 1970, UTC.
          Depending on your timezone, this moment in time may correspond to
          the evening of December 31, 1969, in your local timezone.
        </para>
        <para>
          The second example shows us pulling the number of seconds out of
          the value returned by <literal>getClockTime</literal>.  We can now
          manipulate it, like so:
        </para>
        &time.ghci:ClockTime3;
        <para>
          This will display what the time will be exactly 24 hours from now
          in your local timezone, since there are 86,400 seconds in 24 hours.
        </para>
      </sect3>

      <sect3 id="hs.system.calendartime">
        <title>Using CalendarTime</title>
        <para>
          As its name implies, &CalendarTime; represents time like we would
          on a calendar.  It has fields for information such as year, month,
          and day.  &CalendarTime; and its associated types are defined like
          this:
        </para>
        <programlisting>
data CalendarTime = CalendarTime
   {ctYear :: Int,         -- Year (post-Gregorian)
    ctMonth :: Month, 
    ctDay :: Int,          -- Day of the month (1 to 31)
    ctHour :: Int,         -- Hour of the day (0 to 23)
    ctMin :: Int,          -- Minutes (0 to 59)
    ctSec :: Int,          -- Seconds (0 to 61, allowing for leap seconds)
    ctPicosec :: Integer,  -- Picoseconds
    ctWDay :: Day,         -- Day of the week
    ctYDay :: Int,         -- Day of the year (0 to 364 or 365)
    ctTZName :: String,    -- Name of timezone
    ctTZ :: Int,           -- Variation from UTC in seconds
    ctIsDST :: Bool        -- True if Daylight Saving Time in effect
   }

data Month = January | February | March | April | May | June 
             | July | August | September | October | November | December

data Day = Sunday | Monday | Tuesday | Wednesday
           | Thursday | Friday | Saturday
        </programlisting>
        <para>
          There are a few things about these structures that should be
          highlighted:
        </para>
        <itemizedlist>
          <listitem><para>
              &ctWDay;, &ctYDay;, and &ctTZName; are generated by the library
              functions that create a &CalendarTime;, but are not used
              in calculations.  If you are creating a &CalendarTime; by hand,
              it is not necessary to put accurate values into these fields,
              unless your later calculations will depend upon them.
            </para>
          </listitem>
          <listitem><para>
              All of these three types are members of the &Eq;, &Ord;,
              &Read;, and &Show; typeclasses.  In addition, 
              &Month; and &Day; are declared as members of the
              &Enum; and &Bounded; typeclasses.  For more information on
              these typeclasses, refer to
              <xref linkend="hs.typeclasses.wellknown"/>.
            </para>
            <para>
              You can generate &CalendarTime; values several ways.  You could
              start by converting a &ClockTime; to a &CalendarTime; such as
              this:
            </para>
            &calendartime.ghci:conv;
            <para>
              We used <literal>getClockTime</literal> to obtain the current
              &ClockTime; from the system's clock.  Next,
              <literal>toCalendarTime</literal> converts the &ClockTime; to a
              &CalendarTime; representing the time in the local timezone.
              <literal>toUTCtime</literal> performs a similar conversion,
              but its result is in the UTC timezone instead of the local
              timezone.
            </para>
            <para>
              Notice that <literal>toCalendarTime</literal> is an &IO;
              function, but <literal>toUTCTime</literal> is not.  The reason
              is that <literal>toCalendarTime</literal> returns a different
              result depending upon the locally-configured timezone, but
              <literal>toUTCTime</literal> will return the exact same result
              whenever it is passed the same source &ClockTime;.
            </para>
            <para>
              It's easy to modify a &CalendarTime; value:
            </para>
            &calendartime.ghci:mod;
            <para>
              In this example, we first took the &CalendarTime; value from
              earlier and simply switched its year to 1960.  Then, we used
              <literal>toClockTime</literal> to convert the unmodified value
              to a &ClockTime;, and then the modified value, so you can see
              the difference.  Notice that the modified value shows a
              negative number of seconds once converted to &ClockTime;.
              That's to be expected, since a &ClockTime; is an offset from
              midnight on January 1, 1970, UTC, and this value is in 1960.
            </para>
            <para>
              You can also create &CalendarTime; values manually:
            </para>
            &calendartime.ghci:create;
            <para>
              Note that even though January 15, 2010, isn't a Sunday -- and
              isn't day 0 in the year -- the system was able to process this
              just fine.  In fact, if we convert the value to a &ClockTime;
              and then back to a &CalendarTime;, you'll find those fields
              properly filled in:
            </para>
            &calendartime.ghci:norm;
          </listitem>
        </itemizedlist>

      </sect3>

      <sect3 id="hs.system.timediff">
        <title>TimeDiff for ClockTime</title>
        <para>
          Because it can be difficult to manage differences between
          &ClockTime; values in a human-friendly way, the
          <literal>System.Time</literal> module includes a &TimeDiff; type.
          &TimeDiff; can be used, where convenient, to handle these
          differences.  It is defined like this:
        </para>
        <programlisting>
data TimeDiff = TimeDiff
   {tdYear :: Int,
    tdMonth :: Int,
    tdDay :: Int,
    tdHour :: Int,
    tdMin :: Int,
    tdSec :: Int,
    tdPicosec :: Integer}
        </programlisting>
        <para>
          Functions such as <literal>diffClockTimes</literal> and
          <literal>addToClockTime</literal> take a &ClockTime; and a
          &TimeDiff; and handle the calculations internally by converting to
          a &CalendarTime; in UTC, applying the differences, and converting
          back to a &ClockTime;.
        </para>
        <para>
          Let's see how it works:
        </para>
        &timediff.ghci:all;
        <para>
          We started by generating a &ClockTime; representing midnight
          February 5, 2008 in UTC.  Note that, unless your timezone is the
          same as UTC, when this time is printed out on the display, it may
          show up as the evening of February 4 because it is formatted for
          your local timezone.
        </para>
        <para>
          Next, we add one month to to it by calling
          <literal>addToClockTime</literal>.  2008 is a leap year, but the
          system handled that properly and we get a result that has the same
          date and time in March.  By using <literal>toUTCTime</literal>, we
          can see the effect on this in the original UTC timezone.
        </para>
        <para>
          For a second experiment, we set up a time representing midnight 
          on January 30, 2009 in UTC.  2009 is not a leap year, so we might
          wonder what will happen when trying to add one month to it.  We can
          see that, since neither February 29 or 30 exist in 2009, we wind up
          with March 2.
        </para>
        <para>
          Finally, we can see how <literal>diffClockTimes</literal> turns two
          &ClockTime; values into a &TimeDiff;, though only the seconds and
          picoseconds are filled in.  The
          <literal>normalizeTimeDiff</literal> function takes such a
          &TimeDiff; and reformats it as a human might expect to see it.
        </para>
      </sect3>

    </sect2>
    <sect2 id="hs.systems.modtime">
      <title>File Modification Times</title>
      <para>
        Many programs need to find out when particular files were last
        modified.  Programs such as <literal>ls</literal> or graphical file
        managers typically display the modification time of files.
        The <literal>System.Directory</literal> module contains a
        cross-platform <literal>getModificationTime</literal> function.  It
        takes a filename and returns a &ClockTime; representing the time the
        file was last modified.  For instance:
      </para>
      &modtime.ghci:all;
      <para>
        POSIX platforms maintain not just a modification time (known as
        mtime), but also the time of last read or write access (atime) and
        the time of last status change (ctime).  Since this information is
        POSIX-specific, the cross-platform
        <literal>System.Directory</literal> module does not provide access to
        it.  Instead, you will need to use functions in
        <literal>System.Posix.Files</literal>.  Here is an example function
        to do that:
      </para>
      &posixtime.hs:all;
      <para>
        Notice that call to <literal>getFileStatus</literal>.  That call maps
        directly to the C function <literal>stat()</literal>.  Its return
        value stores a vast assortment of information, including file
        type, permissions, owner, group, and the three time values we're
        interested in.  <literal>System.Posix.Files</literal> provides
        various functions, such as <literal>accessTime</literal>, that
        extract the information we're interested out of the opaque
        <literal>FileStatus</literal> type returned by
        <literal>getFileStatus</literal>.
      </para>
      <para>
        <literal>System.Posix.Files</literal> also provides a
        <literal>setFileTimes</literal> function to set the atime and mtime
        for a file.<footnote><para>It is not normally possible to set the
            ctime on POSIX systems.</para></footnote>
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.systems.cmd">
    <title>Invoking External Commands</title>
    <para>
      The <literal>System.Cmd</literal> module provides a cross-platform way
      to invoke external commands.  This could let you call system utilities
      or
      start up programs to gather data from the user.  The functions in
      <literal>System.Cmd</literal> pause execution of your Haskell program
      while the new program runs, then continue where it left off after the
      called program terminates.
    </para>
    <para>
      The most useful if the functions in <literal>System.Cmd</literal> is
      <literal>rawSystem</literal>.  It takes an executble name and a list of
      command-line arguments to pass to it, and returns an exit code.  You
      can even test it from &ghci; like this:
    </para>
    &cmd.ghci:all;
    <para>
      <literal>rawSystem</literal> does not pass the command or its arguments
      through the shell.  This is an important safety and integrity feature.
      The shell may perform wildcard expansion, argument parsing, and other
      tasks on the input.  This can lead to problems or even security risks
      when dealing with things as simple as filenames containing spaces or
      strings containing punctuation.  For this reason, we recommend using
      <literal>rawSystem</literal> instead of alternatives such as
      <literal>system</literal> at all times.
    </para>
  </sect1>

  <sect1 id="hs.systems.piping">
    <title>Piping</title>
    <para>
      We've just seen how to invoke external programs.  Sometimes we need
      more control that that.  Perhaps we need to obtain the output from
      those programs, provide input, or even chain together multiple external
      programs.  Piping can help with all of these needs.
      Piping is often used in shell
      scripts.  When you set up a pipe in the shell, you run multiple
      programs.  The output of the first program is sent to the input of the
      second.  Its output is sent to the third as input, and so on.  The last
      program's output normally goes to the terminal, or it could go to a
      file.  Here's an example session with the POSIX
      shell to illustrate piping:
    </para>
    <screen>
$ <userinput>ls /etc | grep 'm.*ap' | tr a-z A-Z</userinput>
IDMAPD.CONF
MAILCAP
MAILCAP.ORDER
MEDIAPRM
TERMCAP
    </screen>
    <para>
      This command runs three programs, piping data between them.  It starts
      with <literal>ls /etc</literal>, which outputs a list of all files or
      directories in <literal>/etc</literal>.  The output of
      <literal>ls</literal> is sent as input to <literal>grep</literal>.  We
      gave <literal>grep</literal> a regular expression that will cause it to
      output only the lines that start with <literal>'m'</literal> and then
      contain <literal>"ap"</literal> somewhere in the line.  Finally, the
      result of that is sent to <literal>tr</literal>.  We gave
      <literal>tr</literal> options to convert everything to uppercase.  The
      output of <literal>tr</literal> isn't set anywhere in particular, so it
      is displayed on the screen.
    </para>
    <para>
      In this situation, the shell handles setting up all the pipelines
      between programs.  Let's take a look at how we might accomplish this
      ourselves using Haskell.  The <literal>System.Process</literal> module
      defines two functions that will be useful:
      <literal>runProcess</literal>, which takes &Handle;s to use for input
      and output; and
      <literal>runInteractiveCommand</literal>, which returns &Handle;s for
      input and output.  By combining these together,
      we can send the output of one command to the input of another.
    </para>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
