<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.systems" revision="unpublished">
  <title>Systems Programming in Haskell</title>

  <para>
    So far, we've been talking mostly about high-level concepts.  Haskell can
    also be used for lower-level systems programming.  It is quite possible
    to write programs that interface with the operating system at a low level
    using Haskell.
  </para>
  <para>
    In this chapter, we are going to attempt something ambitious: a Perl-like
    "language" that is valid Haskell, implemented in pure Haskell, that makes
    shell scripting easy.  We are going to implement piping, easy command
    invocation, and some simple tools to handle tasks that might otherwise be
    performed with <literal>grep</literal> or <literal>sed</literal>.
  </para>
  <para>
    Specialized modules exist for different operating systems.  In this
    chapter, we will use generic OS-independent modules as much as possible.
    However, we will be focusing on the POSIX environment for much of the
    chapter.  POSIX is a standard for Unix-like operating systems such as
    Linux, FreeBSD, MacOS X, or Solaris.  Windows does not support POSIX by
    default, but the Cygwin environment provides a POSIX compatibility layer
    for Windows.
  </para>

  <sect1 id="hs.systems.running">
    <title>Running External Programs</title>
    <para>
      It is possible to invoke external commands from Haskell.  To do that,
      we suggest using <literal>rawSystem</literal> from the
      <literal>System.Cmd</literal> module.  This will invoke a specified
      program, with the specified arguments, and return the exit code from
      that program.  You can play with it in &ghci;:
    </para>
    &rawSystem.ghci:s1;
    <para>
      Here, we run the equivolent of the shell command <literal>ls -l /usr</literal>.  
      <literal>rawSystem</literal> does not parse arguments from a string or
      expand wildcards.<footnote><para>There is also a function
          <literal>system</literal> that takes only a single string and
          passes it through the shell to parse.  We recommend using
          <literal>rawSystem</literal> instead, because the shell attaches
          special meaning to certain characters, which could lead to security
          issues or unexpected behavior.</para></footnote>
      Instead, it expects every argument to be contained
      in a list.  If you don't want to pass any arguments, you can simply
      pass an empty list like this:
    </para>
    &rawSystem.ghci:s2;
  </sect1>

  <sect1 id="hs.systems.directories">
    <title>Directory and File Information</title>
    <para>
      The <literal>System.Directory</literal> module contains quite a few
      functions that can be used to obtain information from the filesystem.
      You can get a list of files in a directory, rename or delete files,
      copy files, change the current working directory, or create new
      directories.  <literal>System.Directory</literal> is portable and works
      on any platform where GHC itself works.
    </para>
    <para>
      The <ulink
        url="http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html">library
        reference for <literal>System.Directory</literal></ulink> provides a
      comprehensive list of the functions available.  Let's use &ghci; to
      demonstrate a few of them.  Most of these functions are straightforward
      equivolents to C library calls or shell commands.
    </para>
    &dir.ghci:setdir;
    <para>
      Here we saw commands to change the current working directory and obtain
      the current working directory from the system.  These are similar to
      the <literal>cd</literal> and <literal>pwd</literal> commands in the
      POSIX shell.
    </para>
    &dir.ghci:contents;
    <para>
      <literal>getDirectoryContents</literal> returns a list for every item
      in a given directory.  Note that on POSIX systems, this list normally
      includes the special values <literal>"."</literal> and
      <literal>".."</literal>.  You will usually want to filter these out
      when processing the content of the directory, perhaps like this:
    </para>
    &dir.ghci:contents2;
    <para>
      You can also query the system about the location of certain
      directories.   This query will ask the underlying operating system for
      the information.
    </para>
    &dir.ghci:query;
  </sect1>

  <sect1 id="hs.system.termination">
    <title>Program Termination</title>
    <para>
      Developers often write individual programs to accomplish particular
      tasks.  These individual parts may be combined to accomplish larger
      tasks.  A shell script or another program may execute them.  The
      calling script often needs a way to discover whether the program was
      able to complete its task successfully.  Haskell automatically
      indicates a non-successful exit whenever a program is aborted by an
      exception.
    </para>
    <para>However, you may need more fine-grained control over the
      exit code than that.   Perhaps you need to return different codes for
      different types of errors.
      The <literal>System.Exit</literal> module provides a way to exit the
      program and return a specific exit status code to the caller.  You can
      call <literal>exitWith ExitSuccess</literal> to return a code
      indicating a successful termination (0 on POSIX systems).  Or, you can
      call something like <literal>exitWith (ExitFailure 5)</literal>, which
      will return code 5 to the calling program.
    </para>
  </sect1>

  <sect1 id="hs.systems.datetime"> 
    <title>Dates and Times</title>
    <para>
      Everything from file timestamps to business transactions involve dates
      and times.  Haskell provides ways for manipulating dates and times, as
      well as features for obtaining date and time information from the
      system.
    </para>
    <sect2 id="hs.systems.datetime.types">
      <title>ClockTime and CalendarTime</title>
      <para> In Haskell, the
        <literal>System.Time</literal> module is primarily responsible for
        date and time handling.  It defines two types: &ClockTime; and
        &CalendarTime;.  </para> <para> &ClockTime; is the Haskell version of
        the traditional POSIX epoch.  A &ClockTime; represents the number of
        seconds since midnight the morning of January 1, 1970, UTC.  A
        negative &ClockTime; represents times prior to that date, while a
        positive number represents times after it.  
      </para> 
      <para>
        &ClockTime; is convenient for computations.  Since it tracks
        Coordinated Universal Time (UTC), it doesn't have to adjust for local
        timezones, daylight saving time, or other special cases in time
        handling.  Every day is exactly (60 * 60 * 24) or 86,400
        seconds<footnote><para>Some will note that UTC defines leap seconds
            at irregular intervals.  The POSIX standard, which Haskell
            follows, states that every day is exactly 86,400 seconds in
            length in its representation, so you need not be concerned about
            leap seconds when performing routine calculations.  The exact
            manner of handling leap seconds is system-dependant and complex,
            though usually it can be explained as having a "long second".
            This nuance is generally only of interest when performing precise
            subsecond calculations.</para></footnote>, which makes time
        interval calculations simple.  You can, for instance, check the
        &ClockTime; at the start of a long task, again at the end, and simply
        subtract the start time from the end time to determine how much time
        elapsed.  You can then divide by 24 and display the elapsed time as a
        count of hours if you wish.
      </para>
      <para>
        &ClockTime; is ideal for answering questions such as these:
      </para>
      <itemizedlist>
        <listitem><para>How much time has elapsed?</para></listitem>
        <listitem><para>What will be the &ClockTime; 14 days ahead of this
            precise instant?</para></listitem>
        <listitem><para>When was the file last modified?</para></listitem>
        <listitem><para>What is the precise time right now?</para></listitem>
      </itemizedlist>
      <para>
        These are good uses of &ClockTime; because they refer to precise,
        unambiguous moments in time.  However, &ClockTime; is not as easily
        used for questions such as:
      </para>
      <itemizedlist>
        <listitem><para>Is today Monday?</para></listitem>
        <listitem><para>What will be the time on this date next
            month?</para></listitem>
        <listitem><para>What day of the week will May 1 fall on next
            year?</para></listitem>
        <listitem><para>What is the current time in my local timezone,
            taking the potential presence of Daylight Saving Time (DST) into
            account?</para></listitem>
      </itemizedlist>
      <para>
        &CalendarTime; stores a time the way humans do: with a year, month,
        day, hour, minute, second, timezone, and DST information.  It's easy
        to convert this into a conveniently-displayable string, or to answer
        questions about the local time.
      </para>
      <para>
        You can convert between &ClockTime; and &CalendarTime; at will.
        Haskell includes functions to convert a &ClockTime; to a
        &CalendarTime; in the local timezone, or to a &CalendarTime;
        representing UTC.
      </para>
      <sect3 id="hs.systems.clocktime">
        <title>Using ClockTime</title>
        <para>
          &ClockTime; is defined in <literal>System.Time</literal> like this:
        </para>
        <programlisting>
data ClockTime = TOD Integer Integer
        </programlisting>
        <para>
          The first &Integer; represents the number of seconds since the
          epoch.  The second &Integer; represents an additional number of
          picoseconds.  Because &ClockTime; in Haskell uses the unbounded
          &Integer; type, it can effectively represent a date range limited only
          by computational resources.
        </para>
        <para>
          Let's look at some ways to use &ClockTime;.  First, there is the
          <literal>getClockTime</literal> function that returns the current
          time according to the system's clock.
        </para>
        &time.ghci:getClockTime;
        <para>
          If you wait a second and run <literal>getClockTime</literal> again,
          you'll see it returning an updated time.  Notice that the output
          from this command was a nice-looking string, complete with
          day-of-week information.  That's due to the &Show; instance for
          &ClockTime;.  Let's look at the &ClockTime; at a lower level:
        </para>
        &time.ghci:ClockTime2;
        <para>
          Here we first construct a &ClockTime; representing the point in
          time 1500 seconds after midnight on January 1, 1970, UTC.
          Depending on your timezone, this moment in time may correspond to
          the evening of December 31, 1969, in your local timezone.
        </para>
        <para>
          The second example shows us pulling the number of seconds out of
          the value returned by <literal>getClockTime</literal>.  We can now
          manipulate it, like so:
        </para>
        &time.ghci:ClockTime3;
        <para>
          This will display what the time will be exactly 24 hours from now
          in your local timezone, since there are 86,400 seconds in 24 hours.
        </para>
      </sect3>

      <sect3 id="hs.system.calendartime">
        <title>Using CalendarTime</title>
        <para>


      <!-- Todo: file modification times -->
    </sect2>

  </sect1>


  <sect1 id="hs.systems.piping">
    <title>Piping</title>
    <para>
      Let's start with a discussing of piping.  Piping is often used in shell
      scripts.  When you set up a pipe in the shell, you run multiple
      programs.  The output of the first program is sent to the input of the
      second.  Its output is sent to the third as input, and so on.  The last
      program's output normally goes to the terminal, or it could go to a
      file.  Here's an example session with the POSIX
      shell to illustrate piping:
    </para>
    <screen>
$ <userinput>ls /etc | grep 'm.*ap' | tr a-z A-Z</userinput>
IDMAPD.CONF
MAILCAP
MAILCAP.ORDER
MEDIAPRM
TERMCAP
    </screen>
    <para>
      This command runs three programs, piping data between them.  It starts
      with <literal>ls /etc</literal>, which outputs a list of all files or
      directories in <literal>/etc</literal>.  The output of
      <literal>ls</literal> is sent as input to <literal>grep</literal>.  We
      gave <literal>grep</literal> a regular expression that will cause it to
      output only the lines that start with <literal>'m'</literal> and then
      contain <literal>"ap"</literal> somewhere in the line.  Finally, the
      result of that is sent to <literal>tr</literal>.  We gave
      <literal>tr</literal> options to convert everything to uppercase.  The
      output of <literal>tr</literal> isn't set anywhere in particular, so it
      is displayed on the screen.
    </para>
    <para>
      In this situation, the shell handles setting up all the pipelines
      between programs.  Let's take a look at how we might accomplish this
      ourselves using Haskell.  The <literal>System.Process</literal> module
      defines two functions that will be useful:
      <literal>runProcess</literal>, which takes &Handle;s to use for input
      and output; and
      <literal>runInteractiveCommand</literal>, which returns &Handle;s for
      input and output.  By combining these together,
      we can send the output of one command to the input of another.
    </para>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
