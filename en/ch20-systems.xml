<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.systems" revision="unpublished">
  <title>Systems Programming in Haskell</title>

  <para id="x_Ia">
    So far, we've been talking mostly about high-level concepts.  Haskell can
    also be used for lower-level systems programming.  It is quite possible
    to write programs that interface with the operating system at a low level
    using Haskell.
  </para>
  <para id="x_Ja">
    In this chapter, we are going to attempt something ambitious: a Perl-like
    "language" that is valid Haskell, implemented in pure Haskell, that makes
    shell scripting easy.  We are going to implement piping, easy command
    invocation, and some simple tools to handle tasks that might otherwise be
    performed with <literal>grep</literal> or <literal>sed</literal>.
  </para>
  <para id="x_Ka">
    Specialized modules exist for different operating systems.  In this
    chapter, we will use generic OS-independent modules as much as possible.
    However, we will be focusing on the POSIX environment for much of the
    chapter.  POSIX is a standard for Unix-like operating systems such as
    Linux, FreeBSD, MacOS X, or Solaris.  Windows does not support POSIX by
    default, but the Cygwin environment provides a POSIX compatibility layer
    for Windows.
  </para>

  <sect1 id="hs.systems.running">
    <title>Running External Programs</title>
    <para id="x_La">
      It is possible to invoke external commands from Haskell.  To do that,
      we suggest using <literal>rawSystem</literal> from the
      <literal>System.Cmd</literal> module.  This will invoke a specified
      program, with the specified arguments, and return the exit code from
      that program.  You can play with it in &ghci;:
    </para>
    &rawSystem.ghci:s1;
    <para id="x_Ma">
      Here, we run the equivolent of the shell command <literal>ls -l /usr</literal>.  
      <literal>rawSystem</literal> does not parse arguments from a string or
      expand wildcards.<footnote><para id="x_Na">There is also a function
          <literal>system</literal> that takes only a single string and
          passes it through the shell to parse.  We recommend using
          <literal>rawSystem</literal> instead, because the shell attaches
          special meaning to certain characters, which could lead to security
          issues or unexpected behavior.</para></footnote>
      Instead, it expects every argument to be contained
      in a list.  If you don't want to pass any arguments, you can simply
      pass an empty list like this:
    </para>
    &rawSystem.ghci:s2;
  </sect1>

  <sect1 id="hs.systems.directories">
    <title>Directory and File Information</title>
    <para id="x_Oa">
      The <literal>System.Directory</literal> module contains quite a few
      functions that can be used to obtain information from the filesystem.
      You can get a list of files in a directory, rename or delete files,
      copy files, change the current working directory, or create new
      directories.  <literal>System.Directory</literal> is portable and works
      on any platform where GHC itself works.
    </para>
    <para id="x_Pa">
      The <ulink
        url="http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html">library
        reference for <literal>System.Directory</literal></ulink> provides a
      comprehensive list of the functions available.  Let's use &ghci; to
      demonstrate a few of them.  Most of these functions are straightforward
      equivolents to C library calls or shell commands.
    </para>
    &dir.ghci:setdir;
    <para id="x_Qa">
      Here we saw commands to change the current working directory and obtain
      the current working directory from the system.  These are similar to
      the <literal>cd</literal> and <literal>pwd</literal> commands in the
      POSIX shell.
    </para>
    &dir.ghci:contents;
    <para id="x_Ra">
      <literal>getDirectoryContents</literal> returns a list for every item
      in a given directory.  Note that on POSIX systems, this list normally
      includes the special values <literal>"."</literal> and
      <literal>".."</literal>.  You will usually want to filter these out
      when processing the content of the directory, perhaps like this:
    </para>
    &dir.ghci:contents2;
    <para id="x_Sa">
      You can also query the system about the location of certain
      directories.   This query will ask the underlying operating system for
      the information.
    </para>
    &dir.ghci:query;
  </sect1>

  <sect1 id="hs.system.termination">
    <title>Program Termination</title>
    <para id="x_Ta">
      Developers often write individual programs to accomplish particular
      tasks.  These individual parts may be combined to accomplish larger
      tasks.  A shell script or another program may execute them.  The
      calling script often needs a way to discover whether the program was
      able to complete its task successfully.  Haskell automatically
      indicates a non-successful exit whenever a program is aborted by an
      exception.
    </para>
    <para id="x_Ua">However, you may need more fine-grained control over the
      exit code than that.   Perhaps you need to return different codes for
      different types of errors.
      The <literal>System.Exit</literal> module provides a way to exit the
      program and return a specific exit status code to the caller.  You can
      call <literal>exitWith ExitSuccess</literal> to return a code
      indicating a successful termination (0 on POSIX systems).  Or, you can
      call something like <literal>exitWith (ExitFailure 5)</literal>, which
      will return code 5 to the calling program.
    </para>
  </sect1>

  <sect1 id="hs.systems.datetime"> 
    <title>Dates and Times</title>
    <para id="x_Va">
      Everything from file timestamps to business transactions involve dates
      and times.  Haskell provides ways for manipulating dates and times, as
      well as features for obtaining date and time information from the
      system.
    </para>
    <sect2 id="hs.systems.datetime.types">
      <title>ClockTime and CalendarTime</title>
      <para id="x_Wa"> In Haskell, the
        <literal>System.Time</literal> module is primarily responsible for
        date and time handling.  It defines two types: &ClockTime; and
        &CalendarTime;.  </para> <para id="x_Xa"> &ClockTime; is the Haskell version of
        the traditional POSIX epoch.  A &ClockTime; represents the number of
        seconds since midnight the morning of January 1, 1970, UTC.  A
        negative &ClockTime; represents times prior to that date, while a
        positive number represents times after it.  
      </para> 
      <para id="x_Ya">
        &ClockTime; is convenient for computations.  Since it tracks
        Coordinated Universal Time (UTC), it doesn't have to adjust for local
        timezones, daylight saving time, or other special cases in time
        handling.  Every day is exactly (60 * 60 * 24) or 86,400
        seconds<footnote><para id="x_Za">Some will note that UTC defines leap seconds
            at irregular intervals.  The POSIX standard, which Haskell
            follows, states that every day is exactly 86,400 seconds in
            length in its representation, so you need not be concerned about
            leap seconds when performing routine calculations.  The exact
            manner of handling leap seconds is system-dependant and complex,
            though usually it can be explained as having a "long second".
            This nuance is generally only of interest when performing precise
            subsecond calculations.</para></footnote>, which makes time
        interval calculations simple.  You can, for instance, check the
        &ClockTime; at the start of a long task, again at the end, and simply
        subtract the start time from the end time to determine how much time
        elapsed.  You can then divide by 24 and display the elapsed time as a
        count of hours if you wish.
      </para>
      <para id="x_aa">
        &ClockTime; is ideal for answering questions such as these:
      </para>
      <itemizedlist>
        <listitem><para id="x_ba">How much time has elapsed?</para></listitem>
        <listitem><para id="x_ca">What will be the &ClockTime; 14 days ahead of this
            precise instant?</para></listitem>
        <listitem><para id="x_da">When was the file last modified?</para></listitem>
        <listitem><para id="x_ea">What is the precise time right now?</para></listitem>
      </itemizedlist>
      <para id="x_fa">
        These are good uses of &ClockTime; because they refer to precise,
        unambiguous moments in time.  However, &ClockTime; is not as easily
        used for questions such as:
      </para>
      <itemizedlist>
        <listitem><para id="x_ga">Is today Monday?</para></listitem>
        <listitem><para id="x_ha">What will be the time on this date next
            month?</para></listitem>
        <listitem><para id="x_ia">What day of the week will May 1 fall on next
            year?</para></listitem>
        <listitem><para id="x_ja">What is the current time in my local timezone,
            taking the potential presence of Daylight Saving Time (DST) into
            account?</para></listitem>
      </itemizedlist>
      <para id="x_ka">
        &CalendarTime; stores a time the way humans do: with a year, month,
        day, hour, minute, second, timezone, and DST information.  It's easy
        to convert this into a conveniently-displayable string, or to answer
        questions about the local time.
      </para>
      <para id="x_la">
        You can convert between &ClockTime; and &CalendarTime; at will.
        Haskell includes functions to convert a &ClockTime; to a
        &CalendarTime; in the local timezone, or to a &CalendarTime;
        representing UTC.
      </para>
      <sect3 id="hs.systems.clocktime">
        <title>Using ClockTime</title>
        <para id="x_ma">
          &ClockTime; is defined in <literal>System.Time</literal> like this:
        </para>
        <programlisting>
data ClockTime = TOD Integer Integer
        </programlisting>
        <para id="x_na">
          The first &Integer; represents the number of seconds since the
          epoch.  The second &Integer; represents an additional number of
          picoseconds.  Because &ClockTime; in Haskell uses the unbounded
          &Integer; type, it can effectively represent a date range limited only
          by computational resources.
        </para>
        <para id="x_oa">
          Let's look at some ways to use &ClockTime;.  First, there is the
          <literal>getClockTime</literal> function that returns the current
          time according to the system's clock.
        </para>
        &time.ghci:getClockTime;
        <para id="x_pa">
          If you wait a second and run <literal>getClockTime</literal> again,
          you'll see it returning an updated time.  Notice that the output
          from this command was a nice-looking string, complete with
          day-of-week information.  That's due to the &Show; instance for
          &ClockTime;.  Let's look at the &ClockTime; at a lower level:
        </para>
        &time.ghci:ClockTime2;
        <para id="x_qa">
          Here we first construct a &ClockTime; representing the point in
          time 1500 seconds after midnight on January 1, 1970, UTC.
          Depending on your timezone, this moment in time may correspond to
          the evening of December 31, 1969, in your local timezone.
        </para>
        <para id="x_ra">
          The second example shows us pulling the number of seconds out of
          the value returned by <literal>getClockTime</literal>.  We can now
          manipulate it, like so:
        </para>
        &time.ghci:ClockTime3;
        <para id="x_sa">
          This will display what the time will be exactly 24 hours from now
          in your local timezone, since there are 86,400 seconds in 24 hours.
        </para>
      </sect3>

      <sect3 id="hs.system.calendartime">
        <title>Using CalendarTime</title>
        <para id="x_ta">
          As its name implies, &CalendarTime; represents time like we would
          on a calendar.  It has fields for information such as year, month,
          and day.  &CalendarTime; and its associated types are defined like
          this:
        </para>
        <programlisting>
data CalendarTime = CalendarTime
   {ctYear :: Int,         -- Year (post-Gregorian)
    ctMonth :: Month, 
    ctDay :: Int,          -- Day of the month (1 to 31)
    ctHour :: Int,         -- Hour of the day (0 to 23)
    ctMin :: Int,          -- Minutes (0 to 59)
    ctSec :: Int,          -- Seconds (0 to 61, allowing for leap seconds)
    ctPicosec :: Integer,  -- Picoseconds
    ctWDay :: Day,         -- Day of the week
    ctYDay :: Int,         -- Day of the year (0 to 364 or 365)
    ctTZName :: String,    -- Name of timezone
    ctTZ :: Int,           -- Variation from UTC in seconds
    ctIsDST :: Bool        -- True if Daylight Saving Time in effect
   }

data Month = January | February | March | April | May | June 
             | July | August | September | October | November | December

data Day = Sunday | Monday | Tuesday | Wednesday
           | Thursday | Friday | Saturday
        </programlisting>
        <para id="x_ua">
          There are a few things about these structures that should be
          highlighted:
        </para>
        <itemizedlist>
          <listitem><para id="x_va">
              &ctWDay;, &ctYDay;, and &ctTZName; are generated by the library
              functions that create a &CalendarTime;, but are not used
              in calculations.  If you are creating a &CalendarTime; by hand,
              it is not necessary to put accurate values into these fields,
              unless your later calculations will depend upon them.
            </para>
          </listitem>
          <listitem><para id="x_wa">
              All of these three types are members of the &Eq;, &Ord;,
              &Read;, and &Show; typeclasses.  In addition, 
              &Month; and &Day; are declared as members of the
              &Enum; and &Bounded; typeclasses.  For more information on
              these typeclasses, refer to
              <xref linkend="hs.typeclasses.wellknown"/>.
            </para>
            <para id="x_xa">
              You can generate &CalendarTime; values several ways.  You could
              start by converting a &ClockTime; to a &CalendarTime; such as
              this:
            </para>
            &calendartime.ghci:conv;
            <para id="x_ya">
              We used <literal>getClockTime</literal> to obtain the current
              &ClockTime; from the system's clock.  Next,
              <literal>toCalendarTime</literal> converts the &ClockTime; to a
              &CalendarTime; representing the time in the local timezone.
              <literal>toUTCtime</literal> performs a similar conversion,
              but its result is in the UTC timezone instead of the local
              timezone.
            </para>
            <para id="x_za">
              Notice that <literal>toCalendarTime</literal> is an &IO;
              function, but <literal>toUTCTime</literal> is not.  The reason
              is that <literal>toCalendarTime</literal> returns a different
              result depending upon the locally-configured timezone, but
              <literal>toUTCTime</literal> will return the exact same result
              whenever it is passed the same source &ClockTime;.
            </para>
            <para id="x_Ab">
              It's easy to modify a &CalendarTime; value:
            </para>
            &calendartime.ghci:mod;
            <para id="x_Bb">
              In this example, we first took the &CalendarTime; value from
              earlier and simply switched its year to 1960.  Then, we used
              <literal>toClockTime</literal> to convert the unmodified value
              to a &ClockTime;, and then the modified value, so you can see
              the difference.  Notice that the modified value shows a
              negative number of seconds once converted to &ClockTime;.
              That's to be expected, since a &ClockTime; is an offset from
              midnight on January 1, 1970, UTC, and this value is in 1960.
            </para>
            <para id="x_Cb">
              You can also create &CalendarTime; values manually:
            </para>
            &calendartime.ghci:create;
            <para id="x_Db">
              Note that even though January 15, 2010, isn't a Sunday -- and
              isn't day 0 in the year -- the system was able to process this
              just fine.  In fact, if we convert the value to a &ClockTime;
              and then back to a &CalendarTime;, you'll find those fields
              properly filled in:
            </para>
            &calendartime.ghci:norm;
          </listitem>
        </itemizedlist>

      </sect3>

      <sect3 id="hs.system.timediff">
        <title>TimeDiff for ClockTime</title>
        <para id="x_Eb">
          Because it can be difficult to manage differences between
          &ClockTime; values in a human-friendly way, the
          <literal>System.Time</literal> module includes a &TimeDiff; type.
          &TimeDiff; can be used, where convenient, to handle these
          differences.  It is defined like this:
        </para>
        <programlisting>
data TimeDiff = TimeDiff
   {tdYear :: Int,
    tdMonth :: Int,
    tdDay :: Int,
    tdHour :: Int,
    tdMin :: Int,
    tdSec :: Int,
    tdPicosec :: Integer}
        </programlisting>
        <para id="x_Fb">
          Functions such as <literal>diffClockTimes</literal> and
          <literal>addToClockTime</literal> take a &ClockTime; and a
          &TimeDiff; and handle the calculations internally by converting to
          a &CalendarTime; in UTC, applying the differences, and converting
          back to a &ClockTime;.
        </para>
        <para id="x_Gb">
          Let's see how it works:
        </para>
        &timediff.ghci:all;
        <para id="x_Hb">
          We started by generating a &ClockTime; representing midnight
          February 5, 2008 in UTC.  Note that, unless your timezone is the
          same as UTC, when this time is printed out on the display, it may
          show up as the evening of February 4 because it is formatted for
          your local timezone.
        </para>
        <para id="x_Ib">
          Next, we add one month to to it by calling
          <literal>addToClockTime</literal>.  2008 is a leap year, but the
          system handled that properly and we get a result that has the same
          date and time in March.  By using <literal>toUTCTime</literal>, we
          can see the effect on this in the original UTC timezone.
        </para>
        <para id="x_Jb">
          For a second experiment, we set up a time representing midnight 
          on January 30, 2009 in UTC.  2009 is not a leap year, so we might
          wonder what will happen when trying to add one month to it.  We can
          see that, since neither February 29 or 30 exist in 2009, we wind up
          with March 2.
        </para>
        <para id="x_Kb">
          Finally, we can see how <literal>diffClockTimes</literal> turns two
          &ClockTime; values into a &TimeDiff;, though only the seconds and
          picoseconds are filled in.  The
          <literal>normalizeTimeDiff</literal> function takes such a
          &TimeDiff; and reformats it as a human might expect to see it.
        </para>
      </sect3>

    </sect2>
    <sect2 id="hs.systems.modtime">
      <title>File Modification Times</title>
      <para id="x_Lb">
        Many programs need to find out when particular files were last
        modified.  Programs such as <literal>ls</literal> or graphical file
        managers typically display the modification time of files.
        The <literal>System.Directory</literal> module contains a
        cross-platform <literal>getModificationTime</literal> function.  It
        takes a filename and returns a &ClockTime; representing the time the
        file was last modified.  For instance:
      </para>
      &modtime.ghci:all;
      <para id="x_Mb">
        POSIX platforms maintain not just a modification time (known as
        mtime), but also the time of last read or write access (atime) and
        the time of last status change (ctime).  Since this information is
        POSIX-specific, the cross-platform
        <literal>System.Directory</literal> module does not provide access to
        it.  Instead, you will need to use functions in
        <literal>System.Posix.Files</literal>.  Here is an example function
        to do that:
      </para>
      &posixtime.hs:all;
      <para id="x_Nb">
        Notice that call to <literal>getFileStatus</literal>.  That call maps
        directly to the C function <literal>stat()</literal>.  Its return
        value stores a vast assortment of information, including file
        type, permissions, owner, group, and the three time values we're
        interested in.  <literal>System.Posix.Files</literal> provides
        various functions, such as <literal>accessTime</literal>, that
        extract the information we're interested out of the opaque
        <literal>FileStatus</literal> type returned by
        <literal>getFileStatus</literal>.
      </para>
      <para id="x_Ob">
        <literal>System.Posix.Files</literal> also provides a
        <literal>setFileTimes</literal> function to set the atime and mtime
        for a file.<footnote><para id="x_Pb">It is not normally possible to set the
            ctime on POSIX systems.</para></footnote>
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.systems.cmd">
    <title>Invoking External Commands</title>
    <para id="x_Qb">
      The <literal>System.Cmd</literal> module provides a cross-platform way
      to invoke external commands.  This could let you call system utilities
      or
      start up programs to gather data from the user.  The functions in
      <literal>System.Cmd</literal> pause execution of your Haskell program
      while the new program runs, then continue where it left off after the
      called program terminates.
    </para>
    <para id="x_Rb">
      The most useful if the functions in <literal>System.Cmd</literal> is
      <literal>rawSystem</literal>.  It takes an executble name and a list of
      command-line arguments to pass to it, and returns an exit code.  You
      can even test it from &ghci; like this:
    </para>
    &cmd.ghci:all;
    <para id="x_Sb">
      <literal>rawSystem</literal> does not pass the command or its arguments
      through the shell.  This is an important safety and integrity feature.
      The shell may perform wildcard expansion, argument parsing, and other
      tasks on the input.  This can lead to problems or even security risks
      when dealing with things as simple as filenames containing spaces or
      strings containing punctuation.  For this reason, we recommend using
      <literal>rawSystem</literal> instead of alternatives such as
      <literal>system</literal> at all times.
    </para>
  </sect1>

  <sect1 id="hs.systems.piping">
    <title>Extended Example: Piping</title>
    <para id="x_Tb">
      We've just seen how to invoke external programs.  Sometimes we need
      more control that that.  Perhaps we need to obtain the output from
      those programs, provide input, or even chain together multiple external
      programs.  Piping can help with all of these needs.
      Piping is often used in shell
      scripts.  When you set up a pipe in the shell, you run multiple
      programs.  The output of the first program is sent to the input of the
      second.  Its output is sent to the third as input, and so on.  The last
      program's output normally goes to the terminal, or it could go to a
      file.  Here's an example session with the POSIX
      shell to illustrate piping:
    </para>
    <screen>
$ <userinput>ls /etc | grep 'm.*ap' | tr a-z A-Z</userinput>
IDMAPD.CONF
MAILCAP
MAILCAP.ORDER
MEDIAPRM
TERMCAP
    </screen>
    <para id="x_Ub">
      This command runs three programs, piping data between them.  It starts
      with <literal>ls /etc</literal>, which outputs a list of all files or
      directories in <literal>/etc</literal>.  The output of
      <literal>ls</literal> is sent as input to <literal>grep</literal>.  We
      gave <literal>grep</literal> a regular expression that will cause it to
      output only the lines that start with <literal>'m'</literal> and then
      contain <literal>"ap"</literal> somewhere in the line.  Finally, the
      result of that is sent to <literal>tr</literal>.  We gave
      <literal>tr</literal> options to convert everything to uppercase.  The
      output of <literal>tr</literal> isn't set anywhere in particular, so it
      is displayed on the screen.
    </para>
    <para id="x_Vb">
      In this situation, the shell handles setting up all the pipelines
      between programs.  By using some of the POSIX tools in Haskell, we can
      accomplish the same thing.
    </para>
    <para id="x_Wb">
      Before describing how to do this, we should first warn you that the
      <literal>System.Posix</literal> modules expose a very low-level
      interface to Unix systems.  The interfaces can be complex and their
      interactions can be complex as well, regardless of the programming
      language you use to access them.  The full nature of these low-level
      interfaces has been the topic of entire books themselves, so in this
      chapter we will just scratch the surface.  <remark>FIXME: suggest some
      other ORA title?</remark>
    </para>
    <sect2 id="hs.systems.piping.theory">
      <title>Using Pipes for Redirection</title>
      <para id="x_Xb">
        POSIX defines a function that creates a pipe.  This function returns
        two file descriptors (FDs), which are similar in concept to a Haskell
        &Handle;.  One FD is the reading end of the pipe, and the other is the
        writing end.  Anything that is written to the writing end can be read
        by the reading end.  The data is "shoved through a pipe".
        In Haskell, you call <literal>createPipe</literal> to access this
        interface.
      </para>
      <para id="x_Yb">
        Having a pipe is the first step to being able to pipe data between
        external programs.  We must also be able to redirect the output of a
        program to a pipe, and the input of another program from a pipe.  The
        Haskell function <literal>dupTo</literal> accomplishes this.  It takes
        a FD and makes a copy of it at another FD number.  POSIX FDs for
        standard input, standard output, and standard error have the predefined
        FD numbers of 0, 1, and 2, respectively.  By renumbering an endpoint of
        a pipe to one of those numbers, we effectively can cause programs to
        have their input or output redirected.
      </para>
      <para id="x_Zb">
        There is another piece of the puzzle, however.  We can't just use
        <literal>dupTo</literal> before a call such as
        <literal>rawSystem</literal> because this would mess up the stdandard
        input or output of our main Haskell process.  Moreover,
        <literal>rawSystem</literal> blocks until the invoked program executes,
        leaving us no way to start multiple processes running in parallel.  To
        make this happen, we must use <literal>forkProcess</literal>.
        This is a very special function.  It actually makes a copy of the
        currently-running program and you wind up with two copies of the
        program running at the same time.  Haskell's
        <literal>forkProcess</literal> function takes a function to execute in
        the new process (known as the child).  We have that function call
        <literal>dupTo</literal>.  After it has done that, it calls
        <literal>executeFile</literal> to actually invoke the command.  This is
        also a special function: if all goes well, it <emphasis>never
          returns</emphasis>.  That's because <literal>executeFile</literal>
        replaces the running process with a different program.  Eventually, the
        original Haskell process will call <literal>getProcessStatus</literal>
        to wait for the child processes to terminate and learn of their exit
        codes.
      </para>
      <para id="x_ab">
        Whenever you run a command on POSIX systems, whether you've just typed
        <literal>ls</literal> on the command line or used
        <literal>rawSystem</literal> in Haskell, under the hood,
        <literal>forkProcess</literal>, <literal>executeFile</literal>, and
        <literal>getProcessStatus</literal> (or their C equivolents) are always
        being used.  To set up pipes, we are duplicating the process that the
        system uses to start up programs, and adding a few steps involving
        piping and redirection along the way.
      </para>
      <para id="x_bb">
        There are a few other housekeeping things we must be careful about.
        When you call <literal>forkProcess</literal>, just about everything
        about your program is cloned<footnote><para id="x_cb">The main exception is
            threads, which are not cloned.</para></footnote>  That includes
        the set of open file descriptors (handles).  Programs detect when
        they're done receiving input from a pipe by checking the end-of-file
        indicator.  When the process at the writing end of a pipe closes the
        pipe, the process at the reading end will receive an end-of-file
        indication.  However, if the writing file descriptor exists in more
        than one process, the end-of-file indicator won't be sent until all
        processes have closed that particular FD.  Therefore, we must keep
        track of which FDs are opened so we can close them all in the child
        processes.  We must also close the child ends of the pipes in the
        parent process as soon as possible.
      </para>
      <para id="x_db">
        Here is an initial implementation of a system of piping in Haskell.
      </para>
      &RunProcessSimple.hs:all;
      <para id="x_eb">
        Let's experiment with this in &ghci; a bit before looking at how it
        works.
      </para>
      &rps.ghci:all;
      <para id="x_fb">
        We start by running a simple command, <literal>pwd</literal>, which
        just prints the name of the current working directory.  We pass
        <literal>[]</literal> for the list of arguments, because
        <literal>pwd</literal> doesn't need any arguments.  Due to the
        typeclasses used, Haskell can't infer the type of
        <literal>[]</literal>, so we specifically mention that it's a
        &String;.
      </para>
      <para id="x_gb">
        Then we get into more complex commands.  We run
        <literal>ls</literal>, sending it through <literal>grep</literal>.
        At the end, we set up a pipe to run the exact same command that we
        ran via a shell-built pipe at the start of this section.  It's not
        yet as pleasant as it was in the shell, but then again our program is
        still relatively simple when compared to the shell.
      </para>
      <para id="x_hb">
        Let's look at the program.  The very first line has a special
        <literal>OPTIONS_GHC</literal> clause.  This is the same as passing
        <literal>-fglasgow-exts</literal> to &ghc; or &ghci;.  We are using a
        GHC extension that permits us to use a <literal>(String,
          [String])</literal> type as an instance of a
        typeclass.<footnote><para id="x_ib">This extension is well-supported in the
            Haskell community; Hugs users can access the same thing with
            <literal>hugs -98 +o</literal>.</para></footnote>  By putting
        it in the source file, we don't have to remember to specify it every
        time we use this module.
      </para>
      <para id="x_jb">
        After the <literal>import</literal> lines, we define a few types.
        First, we define <literal>type SysCommand = (String,
          [String])</literal> as an alias.  This is the type a command to be
        executed by the system will take.  We used data of this type for each
        command in the example execution above.  The
        <literal>CommandResult</literal> type represents the result from
        executing a given command, and the <literal>CloseFDs</literal> type
        represents the list of FDs that we must close upon forking a new
        child process.
      </para>
      <para id="x_kb">
        Next, we define a class named <literal>CommandLike</literal>.  This
        class will be used to run "things", where a "thing" might be a
        standalone program, a pipe set up between two or more programs, or in
        the future, even pure Haskell functions.  To be a member of this
        class, only one function -- <literal>invoke</literal> -- needs to be
        present for a given type.  This will let us use
        <literal>runIO</literal> to start either a standalone command or a
        pipeline.  It will also be useful for defining a pipeline, since we
        may have a whole stack of commands on one or both sides of a given
        command.
      </para>
      <para id="x_lb">
        Our piping infrastructure is going to use strings as the way of
        sending data from one process to another.  We can take advantage of
        Haskell's support for lazy reading via &hGetContents; while reading
        data, and use <literal>forkIO</literal> to let writing occur in the
        background.  This will work well, although not as fast as connecting
        the endpoints of two processes directly together.<footnote><para id="x_mb">The
            Haskell library HSH provides a similar API to that presented
            here, but uses a more efficient (and much more complex) mechanism
            of connecting pipes directly between external processes without
            the data needing to pass through Haskell.  This is the same
            approach that the shell takes, and reduces the CPU load of
            handling piping.</para></footnote>  It makes implementation quite
        simple, however.  We need only take care to do nothing that would
        require the entire &String; to be buffered, and let Haskell's
        laziness do the rest.
      </para>
      <para id="x_nb">
        Next, we define an instance of
        <literal>CommandLike</literal> for <literal>SysCommand</literal>.  We
        create two pipes: one to use for the new process's standard input,
        and the other for its standard output.  This creates four endpoints,
        and thus four file descriptors.  We add the parent file descriptors
        to the list of those that must be closed in all children.  These
        would be the write end of the child's standard input, and the read
        end of the child's standard output.  Next, we fork the child process.
        In the parent, we can then close the file descriptors that correspond
        to the child.  We can't do that before the fork, because then they
        wouldn't be available to the child.  We obtain a handle for the
        <literal>stdinwrite</literal> file descriptor, and start a thread via
        <literal>forkIO</literal> to write the input data to it.  We then
        define <literal>waitfunc</literal>, which is the action that the
        caller will invoke when it is ready to wait for the called process to
        terminate.  Meanwhile, the child uses <literal>dupTo</literal>,
        closes the file descriptors it doesn't need, and executes the
        command.
      </para>
      <para id="x_ob">
        Next, we define some utility functions to manage the list of file
        descriptors.  After that, we define the tools that help set up
        pipelines.  First, we define a new type
        <literal>PipeCommand</literal> that has a source and destination.
        Both the source and destination must be members of
        <literal>CommandLike</literal>.  We also define the
        <literal>-|-</literal> convenience operator.  Then, we make
        <literal>PipeCommand</literal> an instance of
        <literal>CommandLike</literal>.  Its <literal>invoke</literal>
        implementation starts the first command with the given input, obtains
        its output, and passes that output to the invocation of the second
        command.  It then returns the output of the second command, and
        causes the <literal>getExitStatus</literal> function to wait for and
        check the exit statuses from both commands.
      </para>
      <para id="x_pb">
        We finish by defining <literal>runIO</literal>.  This function
        establishes the list of FDs that must be closed in the client, starts
        the command, displays its output, and checks its exit status.
      </para>
    </sect2>
    <sect2 id="hs.piping.extended">
      <title>Better Piping</title>
      <para id="x_qb">
        Our previous example solved the basic need of letting us set up
        shell-like pipes.  There are some other features that it would be
        nice to have though:
      </para>
      <itemizedlist><listitem><para id="x_rb">Supporting more shell-like
            syntax</para></listitem>
        <listitem><para id="x_sb">Letting people pipe data into external programs or
            regular Haskell functions, freely mixing and matching the
            two</para></listitem>
        <listitem><para id="x_tb">Returning the final output and exit code in a way
            that Haskell programs can readily use</para></listitem>
      </itemizedlist>
      <para id="x_ub">
        Fortunately, we already have most of the pieces to support this in
        place.  We need only add a few more instances of
        <literal>CommandLike</literal> to support this, and a few more
        functions similar to <literal>runIO</literal>.  Here is a revised
        example that implements all of these features:
      </para>
      &RunProcess.hs:all;
      <para id="x_vb">
        Here's what has changed:
      </para>
      <itemizedlist>
        <listitem><para id="x_wb">A new <literal>CommandLike</literal> instance for
            &String; that uses the shell to evaluate and invoke the string.
        </para></listitem>
        <listitem><para id="x_xb">New <literal>CommandLike</literal> instances for 
            <literal>String -> IO String</literal> and various other types
            that are implemented in terms of this one.  These process Haskell
            functions as commands.
        </para></listitem>
        <listitem><para id="x_yb">A new <literal>RunResult</literal> typeclass that
            defines a function <literal>run</literal> that returns
            information about the command in many different ways.  See the
            comments in the source for more information.
            <literal>runIO</literal> is now just an alias for one particular
            <literal>RunResult</literal> instance.
        </para></listitem>
        <listitem><para id="x_zb">A few utility functions providing Haskell
            implementations of familiar Unix shell commands.
          </para>
        </listitem>
      </itemizedlist>
      <para id="x_Ac">
        Let's try out the new shell features.  First, let's make sure that
        the command we used in the previous example still works.  Then,
        let's try it using a more shell-like syntax.
      </para>
      &rp.ghci:shell;
      <para id="x_Bc">
        That was a lot easier to type.  Let's try substituting our native
        Haskell implementation of <literal>grep</literal> and try out some
        other new features as well:
      </para>
      &rp.ghci:hask;
    </sect2>

    <sect2 id="hs.systems.piping.finalwords">
      <title>Final Words on Pipes</title>
      <para id="x_Cc">
        We have developed a sophisticated system here.  We warned you earlier
        that POSIX can be complex.  One other thing we need to highlight: you
        must always make sure to evaluate the &String; returned by these
        functions before you attempt to evaluate the exit code of the child
        process.  The child process will often not exit until it can write all of
        its data, and if you do this in the wrong order, your program will
        hang.
      </para>
      <para id="x_Dc">
        In this chapter, we have developed, from the ground up, a simplified
        version of HSH.  If you wish to use these shell-like capabilities in
        your own programs, we recommend HSH instead of the example developed
        here due to optimizations present in HSH.  HSH also comes with a
        larger set of utility functions and more capabilities, but the source
        code behind the library is much more complex and large.  Some of the
        utility functions presented here, in fact, were copied verbatim from
        HSH.  HSH is available from <ulink
          url="http://software.complete.org/hsh"/>.
      </para>
    </sect2>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
