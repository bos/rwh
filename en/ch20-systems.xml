<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.systems" revision="unpublished">
  <title>Systems Programming in Haskell</title>

  <para>
    So far, we've been talking mostly about high-level concepts.  Haskell can
    also be used for lower-level systems programming.  It is quite possible
    to write programs that interface with the operating system at a low level
    using Haskell.
  </para>
  <para>
    In this chapter, we are going to attempt something ambitious: a Perl-like
    "language" that is valid Haskell, implemented in pure Haskell, that makes
    shell scripting easy.  We are going to implement piping, easy command
    invocation, and some simple tools to handle tasks that might otherwise be
    performed with <literal>grep</literal> or <literal>sed</literal>.
  </para>
  <para>
    Specialized modules exist for different operating systems.  In this
    chapter, we will use generic OS-independent modules as much as possible.
    We will alert you to OS-specific code where it occurs.  Most of the
    example sessions with &ghci; in this chapter require Linux, MacOS X, or
    the Cygwin environment for Windows.
  </para>

  <sect1 id="hs.systems.running">
    <title>Running External Programs</title>
    <para>
      It is possible to invoke external commands from Haskell.  To do that,
      we suggest using <literal>rawSystem</literal> from the
      <literal>System.Cmd</literal> module.  This will invoke a specified
      program, with the specified arguments, and return the exit code from
      that program.  You can play with it in &ghci;:
    </para>
    &rawSystem.ghci:s1;
    <para>
      Here, we run the equivolent of the shell command <literal>ls -l /usr</literal>.  
      <literal>rawSystem</literal> does not parse arguments from a string or
      expand wildcards.<footnote><para>There is also a function
          <literal>system</literal> that takes only a single string and
          passes it through the shell to parse.  We recommend using
          <literal>rawSystem</literal> instead, because the shell attaches
          special meaning to certain characters, which could lead to security
          issues or unexpected behavior.</para></footnote>
      Instead, it expects every argument to be contained
      in a list.  If you don't want to pass any arguments, you can simply
      pass an empty list like this:
    </para>
    &rawSystem.ghci:s2;
  </sect1>

  <sect1 id="hs.systems.piping">
    <title>Piping</title>
    <para>
      Let's start with a discussing of piping.  Piping is often used in shell
      scripts.  When you set up a pipe in the shell, you run multiple
      programs.  The output of the first program is sent to the input of the
      second.  Its output is sent to the third as input, and so on.  The last
      program's output normally goes to the terminal, or it could go to a
      file.  Here's an example session with the POSIX<footnote><para>POSIX is
          a standard for Unix-like operating systems.  Linux, FreeBSD,
          Solaris, and MacOS X are all examples of operating systems that
          present a POSIX shell and many POSIX-like features.  Windows
          doesn't, but the Cygwin package can provide many POSIX features for
          Windows.</para></footnote>
      shell to illustrate piping:
    </para>
    <screen>
$ <userinput>ls /etc | grep 'm.*ap' | tr a-z A-Z</userinput>
IDMAPD.CONF
MAILCAP
MAILCAP.ORDER
MEDIAPRM
TERMCAP
    </screen>
    <para>
      This command runs three programs, piping data between them.  It starts
      with <literal>ls /etc</literal>, which outputs a list of all files or
      directories in <literal>/etc</literal>.  The output of
      <literal>ls</literal> is sent as input to <literal>grep</literal>.  We
      gave <literal>grep</literal> a regular expression that will cause it to
      output only the lines that start with <literal>'m'</literal> and then
      contain <literal>"ap"</literal> somewhere in the line.  Finally, the
      result of that is sent to <literal>tr</literal>.  We gave
      <literal>tr</literal> options to convert everything to uppercase.  The
      output of <literal>tr</literal> isn't set anywhere in particular, so it
      is displayed on the screen.
    </para>
    <para>
      In this situation, the shell handles setting up all the pipelines
      between programs.  Let's take a look at how we might accomplish this
      ourselves using Haskell.  The <literal>System.Process</literal> module
      defines two functions that will be useful:
      <literal>runProcess</literal>, which takes &Handle;s to use for input
      and output; and
      <literal>runInteractiveCommand</literal>, which returns &Handles; for
      input and output.  By combining these together,
      we can send the output of one command to the input of another.
    </para>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
