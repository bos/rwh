<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.io">
  <title>I/O</title>

  <para>
    Just about any program of any consequence is going to have to deal with
    input and output at some point.  Many programs, in fact, are devoted to
    reading data, processing it, and writing it back out.
  </para>

  <para>
    Haskell's I/O system is powerful and expressive.  It is easy to work
    with and important to understand.  I/O is the one area where the rest of
    Haskell's lack of side effects doesn't always apply.  Haskell provides
    nice tools for separating I/O from computation, which helps isolate code
    that could introduce side effects.
  </para>

  <para>
    We'll begin this chapter with simple, standard-looking I/O in Haskell.
    Then we'll discuss some of the more powerful options as well as provide
    more detail on how I/O fits into the pure, lazy, functional Haskell
    world.
  </para>

  <sect1 id="hs.io.basics">
    <title>Classic I/O in Haskell</title>
    <remark>FIXME: have we already explained main?</remark>
    <remark>FIXME: have we already explained $ ?</remark>
    <para>
      Let's get started with I/O by looking at a program that looks
      surprisingly similar to I/O in other languages.
    </para>
    &basicio.hs:all;
    <remark>FIXME: have we explained how to compile to a standalone
    program?</remark>
    <para>
      You can compile this program to a standalone executable, run it with
      &runghc;, run it with &hugs;, or invoke &main; from within &ghci;.
      Here's a sample session using &runghc;:
    </para>
    <screen>
$ <userinput>runghc basicio.hs</userinput>
Greetings!  What is your name?
<userinput>John</userinput>
Welcome to Haskell, John!
</screen>
    <para>
      That's a fairly simple, obvious result.  You can see that &putStrLn;
      writes out a &String;, followed by an end-of-line character.  &getLine;
      reads a line from standard input.  The &larrow; operator may be new to
      you.  Put simply, that operator assigns the result from executing an
      I/O action to a name.
      <footnote><para>You will later see that it has a more
        broad application, but it is sufficient to think of it in these terms
        for now.</para></footnote>
      We use the simple list concatenation operator
      <literal>++</literal> to join the input string with our own text.
    </para>
    <para>
      &do; is a convenient way to define a sequence of actions.  As you'll
      see later, there are other ways.  When you use &do; in this way,
      indentation is significant; make sure you line up your actions
      properly.
    </para>
    <para>
      Let's take a look at the types of &putStrLn; and &getLine;.  You can
      find that information in the library reference, or just ask &ghci;:
    </para>
    &basicio.ghci:all;
    <para>
      Notice that both of these types have &IO; in their return value.  That
      is your key to knowing that they may have side-effects or return
      different values at different times.  The type of &putStrLn; looks like
      a function.  It takes a parameter -- a &String; -- and returns an
      <literal>IO ()</literal>.  Just what is an <literal>IO ()</literal>
      though?
    </para>
    <para>
      Anything that is type <literal>IO
        <replaceable>something</replaceable></literal> is an I/O
      <emphasis>action</emphasis>.  You can store it and nothing will happen.
      I could say <literal>writefoo = putStrLn "foo"</literal> and nothing
      happens right then.  But if I later call <literal>writefoo</literal> in
      the middle of another I/O action, it will be executed.  The
      <literal>()</literal> is, essentially, an empty return value; there is
      no return value to speak of from <literal>putstrLn</literal>.
    </para>
    <para>
      The type of &getLine; may look strange to you.  It looks like a value,
      rather than a function.  And in fact, that is one way to look at it:
      &getLine; is storing an I/O action.  When that action is run, you get
      a &String;.  The &larrow; operator is used to "pull out" the result
      from an I/O action and store it in a variable.
    </para>
    <para>
      Finally, &main; itself is an I/O action with type <literal>IO
        ()</literal>.  You can only execute I/O actions or use &larrow; from
      within other I/O actions.  So all I/O in Haskell programs is driven
      from the top at &main;, which is where execution of every Haskell
      program begins.  This, then, is the mechanism that provides
      isolation from side-effects in Haskell: you perform I/O in
      your <literal>IO</literal> actions, and call pure (non-I/O) functions
      from there.
    </para>

    <para>
      Let's consider an example of calling pure code from within
      an I/O action:
    </para>

    &callingpure.hs:all;

    <para>
      Notice the <literal>name2reply</literal> function in this example.  It
      is a regular Haskell function and obeys all the rules we've told you
      about: it always returns the same result when given the same input, it
      has no side-effects, and it operates lazily.  It uses other Haskell
      functions: <literal>(++)</literal>, <literal>show</literal>, and
      <literal>length</literal>.   You can play with it in &ghci; just as you
      would any other function.
    </para>
    <para>
      Down in <literal>main</literal>, we assign the result of
      <literal>name2reply inpStr</literal> to <literal>outStr</literal>.
      When you're working in a &do; block, remember: you use &larrow; to get
      results from &IO; actions and &let; to get results from pure code.
    </para>
    <para>
      You can see here how we read from the keyboard the person's name.
      Then, that data got passed to a pure function, and its result was
      printed.  In fact, the last line of &main; could have been replaced
      with <literal>putStrLn (name2reply inpStr)</literal>.  So, while &main;
      did have side-effects -- it caused things to appear on the terminal,
      for instance -- <literal>name2reply</literal> did not and could not.
    </para>
    <para>
      Let's examine this with &ghci;:
    </para>

    &callingpure.ghci:all;

    <para>
      The <literal>\n</literal> within the string is the end-of-line
      (newline) character, which causes the terminal to begin a new line in
      its output.  Just calling <literal>name2reply "John"</literal> in
      &ghci; will show you the <literal>\n</literal> literally, because it is
      using &show; to display the return value.  But using &putStrLn; sends
      it to the terminal, and the terminal interprets <literal>\n</literal>
      to start a new line.
    </para>
    <para>
      What do you think will happen if you simply type
      <userinput>main</userinput> at the &ghci; prompt?  Give it a try.
    </para>

    <para>
      After looking at these example programs, you may be wondering if Haskell
      is really imperative rather than lazy.  It sure looks like a sequence
      of actions to be followed in order.  There's more to it than that,
      though.  We'll discuss that question later in this chapter in 
        <xref
          linkend="hs.io.imperative"/> and <xref linkend="hs.io.lazy"/>.
    </para>

    <para>
      Haskell defines quite a few basic functions for I/O.  The library
      reference for <literal>System.IO</literal> provides a good summary of
      them all, should you need one that we haven't demonstrated here.
    </para>
  </sect1>

  <sect1 id="hs.io.files">
    <title>Working With Files</title>
    <para>
      You can easily read and write data from specific files.  
    <remark>FIXME</remark>
    <remark>FIXME: deleting files, renaming them, directory contents</remark>
  </sect1>

  <sect1 id="hs.io.lazy">
    <title>Lazy I/O</title>
    <remark>FIXME</remark>
    <remark>comment on side-effects potentially being problematic</remark>
  </sect1>

  <sect1 id="hs.io.monad">
    <title>The IO Monad</title>
    <para>
      You may recall from <remark>FIXME: add ref</remark> that Haskell is a
      pure language.  That is, if you give a certain function a specific
      argument, the function will return the same result every time you give
      it that argument.  Moreover, the function will not change anything
      about the program's overall state.
    </para>
    <para>
      You may be wondering, then, how I/O fits into this picture.  Surely if
      you want to read a line of input from the keyboard, the function to
      read input can't possibly return the same result every time it is run,
      right?  Moreover, I/O is all about changing state.  I/O could cause
      pixels on a terminal to light up, to cause paper to start coming out of
      a printer, or even to cause a package to be shipped from a warehouse on
      a different continent.  I/O doesn't just change the state of a program.
      You can think of I/O as changing the state of the world.
    </para>
    <para>
      Most languages do not make a distinction between a pure function and an
      impure one.  Haskell has functions in the mathematical sense: they are
      purely computations which cannot be impacted by anything external.
      Moreover, the computation can be performed at any time -- or even
      never, if its result is never needed.
    </para>
    <para>
      Clearly, then, we need some other tool to work with I/O.  That tool in
      Haskell is called <emphasis>actions</emphasis>.  Actions resemble
      functions.  They do nothing when they are defined, but perform some
      task when they are invoked.  I/O actions are defined within the &IO;
      monad.  Monads are actually a powerful way of chaining data together
      purely and are covered in <remark>FIXME: insert ref</remark>.  It's not
      necessary to understand monads in order to understand I/O.  Just
      understand that the return value of actions is "tagged" with 
      &IO;.  Let's take a look at some types:
    </para>

    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.imperative">
    <title>Is Haskell Really Imperative?</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.let">
    <title>let in the IO Monad</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.args">
    <title>Reading Command-Line Arguments</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.environ">
    <title>Environment Variables</title>
    <remark>FIXME</remark>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
