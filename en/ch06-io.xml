<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.io">
  <title>I/O</title>

  <para>
    Just about any program of any consequence is going to have to deal with
    input and output at some point.  Many programs, in fact, are devoted to
    reading data, processing it, and writing it back out.
  </para>

  <para>
    Haskell's I/O system is powerful and expressive.  It is easy to work
    with and important to understand.  I/O is the one area where the rest of
    Haskell's lack of side effects doesn't always apply.  Haskell provides
    nice tools for separating I/O from computation, which helps isolate code
    that could introduce side effects.
  </para>

  <para>
    We'll begin this chapter with simple, standard-looking I/O in Haskell.
    Then we'll discuss some of the more powerful options as well as provide
    more detail on how I/O fits into the pure, lazy, functional Haskell
    world.
  </para>

  <sect1 id="hs.io.basics">
    <title>Classic I/O in Haskell</title>
    <remark>FIXME: have we already explained main?</remark>
    <remark>FIXME: have we already explained $ ?</remark>
    <para>
      Let's get started with I/O by looking at a program that looks
      surprisingly similar to I/O in other languages.
    </para>
    &basicio.hs:all;
    <remark>FIXME: have we explained how to compile to a standalone
    program?</remark>
    <para>
      You can compile this program to a standalone executable, run it with
      &runghc;, run it with &hugs;, or invoke &main; from within &ghci;.
      Here's a sample session using &runghc;:
    </para>
    <screen>
$ <userinput>runghc basicio.hs</userinput>
Greetings!  What is your name?
<userinput>John</userinput>
Welcome to Haskell, John!
</screen>
    <para>
      That's a fairly simple, obvious result.  You can see that &putStrLn;
      writes out a &String;, followed by an end-of-line character.  &getLine;
      reads a line from standard input.  The &larrow; operator may be new to
      you.  Put simply, that operator assigns the result from executing an
      I/O action to a name.
      <footnote><para>You will later see that it has a more
        broad application, but it is sufficient to think of it in these terms
        for now.</para></footnote>
      We use the simple list concatenation operator
      <literal>++</literal> to join the input string with our own text.
    </para>
    <para>
      After looking at this example program, you may be wondering if Haskell
      is really imperative rather than lazy.  It sure looks like a sequence
      of actions to be followed in order.  There's more to it than that,
      though.  We'll discuss that question later in this chapter in <xref
        linkend="hs.io.imperative"/>.
    </para>
    <para>
      Haskell defines quite a few basic functions for I/O.  The library
      reference for <literal>System.IO</literal> provides a good summary of
      them all, should you need one that we haven't demonstrated here.
    </para>
  </sect1>

  <sect1 id="hs.io.files">
    <title>Working With Files</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.lazy">
    <title>Lazy I/O</title>
    <remark>FIXME</remark>
    <remark>comment on side-effects potentially being problematic</remark>
  </sect1>

  <sect1 id="hs.io.monad">
    <title>The IO Monad</title>
    <para>
      You may recall from <remark>FIXME: add ref</remark> that Haskell is a
      pure language.  That is, if you give a certain function a specific
      argument, the function will return the same result every time you give
      it that argument.  Moreover, the function will not change anything
      about the program's overall state.
    </para>
    <para>
      You may be wondering, then, how I/O fits into this picture.  Surely if
      you want to read a line of input from the keyboard, the function to
      read input can't possibly return the same result every time it is run,
      right?  Moreover, I/O is all about changing state.  I/O could cause
      pixels on a terminal to light up, to cause paper to start coming out of
      a printer, or even to cause a package to be shipped from a warehouse on
      a different continent.  I/O doesn't just change the state of a program.
      You can think of I/O as changing the state of the world.
    </para>
    <para>
      Most languages do not make a distinction between a pure function and an
      impure one.  Haskell has functions in the mathematical sense: they are
      purely computations which cannot be impacted by anything external.
      Moreover, the computation can be performed at any time -- or even
      never, if its result is never needed.
    </para>
    <para>
      Clearly, then, we need some other tool to work with I/O.  That tool in
      Haskell is called <emphasis>actions</emphasis>.  Actions resemble
      functions.  They do nothing when they are defined, but perform some
      task when they are invoked.  I/O actions are defined within the &IO;
      monad.  Monads are actually a powerful way of chaining data together
      purely and are covered in <remark>FIXME: insert ref</remark>.  It's not
      necessary to understand monads in order to understand I/O.  Just
      understand that the return value of actions is "tagged" with 
      &IO;.  Let's take a look at some types:
    </para>

    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.imperative">
    <title>Is Haskell Really Imperative?</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.let">
    <title>let in the IO Monad</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.args">
    <title>Reading Command-Line Arguments</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.environ">
    <title>Environment Variables</title>
    <remark>FIXME</remark>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
