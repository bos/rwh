<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.io">
  <title>I/O</title>

  <para>
    Just about any program of any consequence is going to have to deal with
    input and output at some point.  Many programs, in fact, are devoted to
    reading data, processing it, and writing it back out.
  </para>

  <para>
    Haskell's I/O system is powerful and expressive.  It is easy to work
    with and important to understand.  I/O is the one area where the rest of
    Haskell's lack of side effects doesn't always apply.  Haskell provides
    nice tools for separating I/O from computation, which helps isolate code
    that could introduce side effects.
  </para>

  <para>
    We'll begin this chapter with simple, standard-looking I/O in Haskell.
    Then we'll discuss some of the more powerful options as well as provide
    more detail on how I/O fits into the pure, lazy, functional Haskell
    world.
  </para>

  <sect1 id="hs.io.basics">
    <title>Classic I/O in Haskell</title>
    <remark>FIXME: have we already explained main?</remark>
    <remark>FIXME: have we already explained $ ?</remark>
    <para>
      Let's get started with I/O by looking at a program that looks
      surprisingly similar to I/O in other languages.
    </para>
    &basicio.hs:all;
    <remark>FIXME: have we explained how to compile to a standalone
    program?</remark>
    <para>
      You can compile this program to a standalone executable, run it with
      &runghc;, run it with &hugs;, or invoke &main; from within &ghci;.
      Here's a sample session using &runghc;:
    </para>
    <screen>
$ <userinput>runghc basicio.hs</userinput>
Greetings!  What is your name?
<userinput>John</userinput>
Welcome to Haskell, John!
</screen>
    <para>
      That's a fairly simple, obvious result.  You can see that &putStrLn;
      writes out a &String;, followed by an end-of-line character.  &getLine;
      reads a line from standard input.  The &larrow; operator may be new to
      you.  Put simply, that operator assigns the result from executing an
      I/O action to a name.
      <footnote><para>You will later see that it has a more
        broad application, but it is sufficient to think of it in these terms
        for now.</para></footnote>
      We use the simple list concatenation operator
      <literal>++</literal> to join the input string with our own text.
    </para>
    <para>
      &do; is a convenient way to define a sequence of actions.  As you'll
      see later, there are other ways.  When you use &do; in this way,
      indentation is significant; make sure you line up your actions
      properly.
    </para>
    <para>
      Let's take a look at the types of &putStrLn; and &getLine;.  You can
      find that information in the library reference, or just ask &ghci;:
    </para>
    &basicio.ghci:all;
    <para>
      Notice that both of these types have &IO; in their return value.  That
      is your key to knowing that they may have side-effects or return
      different values at different times.  The type of &putStrLn; looks like
      a function.  It takes a parameter -- a &String; -- and returns an
      <literal>IO ()</literal>.  Just what is an <literal>IO ()</literal>
      though?
    </para>
    <para>
      Anything that is type <literal>IO
        <replaceable>something</replaceable></literal> is an I/O
      <emphasis>action</emphasis>.  You can store it and nothing will happen.
      I could say <literal>writefoo = putStrLn "foo"</literal> and nothing
      happens right then.  But if I later call <literal>writefoo</literal> in
      the middle of another I/O action, it will be executed.  The
      <literal>()</literal> is, essentially, an empty return value; there is
      no return value to speak of from <literal>putstrLn</literal>.
    </para>
    <para>
      The type of &getLine; may look strange to you.  It looks like a value,
      rather than a function.  And in fact, that is one way to look at it:
      &getLine; is storing an I/O action.  When that action is run, you get
      a &String;.  The &larrow; operator is used to "pull out" the result
      from an I/O action and store it in a variable.
    </para>
    <para>
      Finally, &main; itself is an I/O action with type <literal>IO
        ()</literal>.  You can only execute I/O actions or use &larrow; from
      within other I/O actions.  So all I/O in Haskell programs is driven
      from the top at &main;, which is where execution of every Haskell
      program begins.  This, then, is the mechanism that provides
      isolation from side-effects in Haskell: you perform I/O in
      your <literal>IO</literal> actions, and call pure (non-I/O) functions
      from there.
    </para>

    <para>
      Let's consider an example of calling pure code from within
      an I/O action:
    </para>

    &callingpure.hs:all;

    <para>
      Notice the <literal>name2reply</literal> function in this example.  It
      is a regular Haskell function and obeys all the rules we've told you
      about: it always returns the same result when given the same input, it
      has no side-effects, and it operates lazily.  It uses other Haskell
      functions: <literal>(++)</literal>, <literal>show</literal>, and
      <literal>length</literal>.   You can play with it in &ghci; just as you
      would any other function.
    </para>
    <para>
      Down in <literal>main</literal>, we assign the result of
      <literal>name2reply inpStr</literal> to <literal>outStr</literal>.
      When you're working in a &do; block, remember: you use &larrow; to get
      results from &IO; actions and &let; to get results from pure code.
    </para>
    <para>
      You can see here how we read from the keyboard the person's name.
      Then, that data got passed to a pure function, and its result was
      printed.  In fact, the last line of &main; could have been replaced
      with <literal>putStrLn (name2reply inpStr)</literal>.  So, while &main;
      did have side-effects -- it caused things to appear on the terminal,
      for instance -- <literal>name2reply</literal> did not and could not.
    </para>
    <para>
      Let's examine this with &ghci;:
    </para>

    &callingpure.ghci:all;

    <para>
      The <literal>\n</literal> within the string is the end-of-line
      (newline) character, which causes the terminal to begin a new line in
      its output.  Just calling <literal>name2reply "John"</literal> in
      &ghci; will show you the <literal>\n</literal> literally, because it is
      using &show; to display the return value.  But using &putStrLn; sends
      it to the terminal, and the terminal interprets <literal>\n</literal>
      to start a new line.
    </para>
    <para>
      What do you think will happen if you simply type
      <userinput>main</userinput> at the &ghci; prompt?  Give it a try.
    </para>

    <para>
      After looking at these example programs, you may be wondering if Haskell
      is really imperative rather than lazy.  It sure looks like a sequence
      of actions to be followed in order.  There's more to it than that,
      though.  We'll discuss that question later in this chapter in 
        <xref
          linkend="hs.io.imperative"/> and <xref linkend="hs.io.lazy"/>.
    </para>

    <para>
      Haskell defines quite a few basic functions for I/O.  The library
      reference for <literal>System.IO</literal> provides a good summary of
      them all, should you need one that we haven't demonstrated here.
    </para>
  </sect1>

  <sect1 id="hs.io.files">
    <title>Working With Files and Handles</title>
    <remark>FIXME: deleting files, renaming them, directory contents</remark>
    <para>
      So far,  you've seen how to work with the terminal.  Of course, you'll
      often need to manipulate specific files.  That's easy to do, too.  
    </para>
    <para>
      You can easily read and write data from specific files.  You will
      generally begin by using &openFile;, which will give you a file &Handle;.
      That &Handle; is then used to perform specific operations on the file.
      Haskell provides functions such as &hPutStrLn; that work just like
      &putStrLn; but take an additional argument -- a &Handle; -- that
      specifies which file to operate upon.  When you're done, you'll use
      &hClose; to close the &Handle; again.  These functions are all defined
      in <literal>System.IO</literal>, so you'll need to import that module
      when working with files.  There are "h" functions corresponding to
      virtually all of the non-"h" functions; for instance, there is &print;
      for printing to the screen and &hPrint; for printing to a file.
    </para>

    <para>
      Let's start with an imperative way to read and write files.  This will
      probably seem familiar to a <literal>while</literal> loop that you may
      find in other languages.  This isn't the best way to write it in
      Haskell; later, you'll see examples of more Haskellish approaches.
    </para>

    &toupper-imp.hs:all;

    <para>
      Like every Haskell program, execution of this program begins as
      <literal>main</literal>.  Two files are opened:
      <literal>input.txt</literal> is opened for reading, and
      <literal>output.txt</literal> is opened for writing.  Then we call
      <literal>mainloop</literal>.
    </para>
    <para>
      <literal>mainloop</literal> begins by checking to see if we're at the
      end of file (EOF) for the input.  If we are, then we <literal>return
        ()</literal> -- this function doesn't return any other specific
      value.  Otherwise, we read a line from the input.  We write out the
      same line to the output, after first converting it to uppercase.  Then
      we recursively call <literal>mainloop</literal> again to continue
      processing the file.
    </para>
    <para>
      Notice that &return; call.  This is not really the same as &return; in
      C or Python.  In those languages, &return; is used to terminate
      execution of the current function immediately, and to return a value to
      the caller.  In Haskell, &return; is the opposite of &larrow;.  That
      is, &return; takes a pure value and wraps it inside &IO;.  Since every
      I/O action must return some &IO; type, if your result came from pure
      computation, you must use &return; to wrap it in &IO;.
    </para>
    <para>
      Let's try running the program.  We've got a file named
      <literal>input.txt</literal> that looks like this:
    </para>
    <programlisting>
This is ch06/input.txt

Test Input
I like Haskell
Haskell is great
I/O is fun

123456789
    </programlisting>
    <para>
      Now, you can use <literal>runghc toupper-imp.hs</literal> and you'll
      find <literal>output.txt</literal> in your directory.  It should look
      like this:
    </para>
    <programlisting>
THIS IS CH06/INPUT.TXT

TEST INPUT
I LIKE HASKELL
HASKELL IS GREAT
I/O IS FUN

123456789
    </programlisting>
    <sect2 id="hs.io.files.openFile">
      <title>More on openFile</title>
      <para>
        Let's use &ghci; to check on the type of &openFile;:
      </para>
      &openFile.ghci:all;
      <para>
        &FilePath; is simply another name for &String;.  It is used in the
        types of I/O functions to help clarify that the parameter is being
        used as a filename, and not as regular data.
      </para>
      <para>
        &IOMode; specifies how the file is to be managed.  The possible
        values for &IOMode; are listed in <xref
          linkend="hs.io.files.openFile.IOModes"/>.
      </para>
      <remark>FIXME: check formatting on this table for final book; openjade
      doesn't render it well</remark>
      <table id="hs.io.files.openFile.IOModes" tocentry="1">
        <title>Possible IOMode Values</title>
        <tgroup cols='4' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <colspec colname='c3'/>
          <colspec colname='c4'/>
          <colspec colname='c5'/>
          <thead>
            <row>
              <entry>&IOMode;</entry>
              <entry>Can read?</entry>
              <entry>Can write?</entry>
              <entry>Starting position</entry>
              <entry>Notes</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&ReadMode;</entry>
              <entry>Yes</entry>
              <entry>No</entry>
              <entry>Beginning of file</entry>
              <entry>File must exist already</entry>
            </row>
            <row>
              <entry>&WriteMode;</entry>
              <entry>No</entry>
              <entry>Yes</entry>
              <entry>Beginning of file</entry>
              <entry>File is truncated if it already existed</entry>
            </row>
            <row>
              <entry>&ReadWriteMode;</entry>
              <entry>Yes</entry>
              <entry>Yes</entry>
              <entry>Beginning of file</entry>
              <entry>File is created if it didn't exist; otherwise, existing
                data is left intact</entry>
            </row>
            <row>
              <entry>&AppendMode;</entry>
              <entry>No</entry>
              <entry>Yes</entry>
              <entry>End of file</entry>
              <entry>File is created if it didn't exist; otherwise, existing
                data is left intact.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
        While we are mostly working with text examples in this chapter,
        binary files can also be used in Haskell.  If you are working with a
        binary file, you should use &openBinaryFile; instead of &openFile;.
        Operating systems such as Windows process files differently if they
        are opened as binary instead of as text.  On operating systems such
        as Linux, both &openFile; and &openBinaryFile; perform the same
        operation.  Nevertheless, for portability, it is still wise to always
        use &openBinaryFile; if you will be dealing with binary data.
      </para>

    </sect2>

    <sect2 id="hs.io.files.closing">
      <title>Closing Handles</title>
      <para>
        You've already seen that &hClose; is used to close file handles.
        Let's take a moment and think about why this is important.
      </para>
      <para>
        As you'll see in <xref linkend="hs.io.buffering"/>, Haskell maintains
        internal buffers for files.  This provides an important performance
        boost.  However, it means that if you fail to &hClose; a file that is
        open for writing, your data may not all be flushed out to disk until
        you call &hClose;.
      </para>
      <para>
        Another reason to make sure to &hClose; files is that open file take
        up memory on the system.  If your program runs for a long time, and
        opens many files but fails to close them, it is conceivable that your
        program could even crash due to resource exhaustion.
      </para>
      <para>
        When a program exits, Haskell will normally take care of closing any
        files that remain open.  However, there are some circumstances in
        which this may not happen<footnote><para>If there was a bug in the C
            part of a hybrid program, for instance</para></footnote>, so once
        again, it is best to be responsible and call &hClose; all the time.
      </para>
    </sect2>

    <sect2 id="hs.io.files.seeking">
      <title>Seek and Tell</title>
      <para>
        When reading and writing from a file, the operating system maintains
        an internal idea of the current position.  Each time to do another
        read, the operating system returns the next chunk of data that begins
        at the current position, and increments the position to reflect the
        data that you read.
      </para>
      <para>
        You can use &hTell; to find out your current position in the file.
        When the file is initially created, it is empty and your position
        will be 0.  After you write out 5 characters, your position will be
        5, and so on.  &hTell; takes a &Handle; and returns an <literal>IO
          Integer</literal> with your position.
      </para>
      <para>
        The companion to &hTell; is &hSeek;.  &hSeek; lets you reposition the
        file position.  It takes three parameters: a &Handle;, a &SeekMode;,
        and a position.
      </para>
      <para>
        &SeekMode; can be one of three different values, which specify how
        the given position is to be interpreted.  &AbsoluteSeek; means that
        the position is a precise location in the file.  This is the same
        kind of information that &hTell; gives you.  &RelativeSeek; means to
        seek from the current position.  A positive number requests going 
        forwards in the file, and a negative number means going backwards.
      <remark>FIXME: do we need an example?</remark>
        Finally, &SeekFromEnd; will seek to the specified number of bytes
        before the end of the file.  <literal>hSeek handle SeekFromEnd
          0</literal> will take you to the end of the file.
      </para>
      <remark>FIXME: do we need an example?</remark>
      <para>
        Not all &Handle;s are seekable.  A &Handle; usually corresponds to a
        file, but it can also correspond to other things such as network
        connections, tape drives, or terminals.  You can use &hIsSeekable; to
        see if a given &Handle; is seekable.
      </para>
    </sect2>

    <sect2 id="hs.io.files.stdin">
      <title>Standard Input, Output, and Error</title>
      <para>
        Earlier, I pointed out that for each non-"h" function, there is
        usually also a corresponding "h" function that works on any &Handle;.
        The non-"h" functions nothing more than shortcuts, in fact.
      </para>
      <para>
        There are three pre-defined &Handle;s in
        <literal>System.IO</literal>.  These &Handle;s are always available
        for your use.
      </para>
      <para>
        They are &stdin;, which corresponds to standard input; &stdout; for
        standard output; and &stderr; for standard error.  Standard input
        normally refers to the keyboard, standard output to the monitor, and
        standard error also normally goes to the monitor.
      </para>
      <para>
        Functions such as &getLine; can thus be trivially defined like this:
      </para>
<programlisting>
getLine = hGetLine stdin
putStrLn = hPutStrLn stdout
print = hPrint stdout
</programlisting>
      <para>
        Earlier, I told you what the three standard file handles "normally"
        correspond to.  That's because some operating systems let you
        redirect the file handles to come from (or go to) different places --
        files, devices, or even other programs.  This feature is used
        extensively in shell scripting on POSIX (Linux, BSD, Mac)
        operating systems, but can
        also be used on Windows.
      </para>
      <para>
        It often makes sense to use standard input and output instead of
        specific files.  This lets you interact with a human at the terminal.
        But it also lets you work with input and output files -- or even
        combine your code with other programs -- if that's
        what's requested.
      </para>
      <para>
        As an example, we can provide input to
        <literal>callingpure.hs</literal> in advance like this:
      </para>
      <screen>
$ <userinput>echo John | runhaskell callingpure.hs</userinput>
Greetings once again.  What is your name?
Pleased to meet you, John.
Your name contains 4 characters.
      </screen>
      <remark>FIXME: does this work on windows?</remark>
      <para>
        While <literal>callingpure.hs</literal> was running, it did not wait
        for input at the keyboard; instead it received
        <literal>John</literal> from the <literal>echo</literal> program.
        Notice also that the output didn't contain the word
        <literal>John</literal> on a separate line as it did when this
        program was run at the keyboard.  The terminal normally echoes
        everything you type back to you, but that is technically input, and
        this not included in the output stream.
      </para>
    </sect2>

    <sect2 id="hs.io.files.ops">
      <title>Deleting and Renaming Files</title>
      <para>
        So far in this chapter, we've discussed the contents of the files.
        Let's now talk a bit about the files themselves.
      </para>
      <para>
        &System.Directory; provides two functions you may find useful.
        &removeFile; takes a single argument, a filename, and deletes that
        file.<footnote><para>POSIX programmers may be interested to know that
            this corresponds to <literal>unlink()</literal> in
            C.</para></footnote>  &renameFile; takes two filenames: the first
        is the old name and the second is the new name.  If the new filename
        is in a different directory, you can also think of this as a move.
        The old filename must exist prior to the call to &renameFile;.  If
        the new file already exists, it is removed before the rename takes
        place.
      </para>
      <para>
        There are many other functions in &System.Directory; for doing things
        such as creating and removing directories, finding lists of files in
        directories, and testing for file existance.  These are discussed in
        <remark>FIXME: add ref to appropriate section of chapter 19</remark>.
      </para>
    </sect2>

    <sect2 id="hs.io.files.temp">
      <title>Temporary Files</title>
      <para>
        Programmers frequently have a need for temporary files.  These files
        may be used to store large amounts of data needed for computations, data to be
        used by other programs, or any number of other uses.
      </para>
      <para>
        While you could craft a way to manually open files with unique names,
        the details of doing this in a secure way differ from platform to
        platform.  Haskell provides a convenient function called
        &openTempFile; (and a corresponding &openBinaryTempFile;) to handle
        the difficult bits for you.
      </para>
      <para>
        &openTempFile; takes two parameters: the directory in which to create
        the file, and a "template" for naming the file.  The directory could
        simply be <literal>"."</literal> for the current working directory.
        Or you could use
        <literal>System.Directory.getTemporaryDirectory</literal> to find the
        best place for temporary files on a given machine.  The template is used
        as the basis for the file name; it will have some random characters
        added to it to ensure that the result is truly unique.  
      </para>
      <para>
        The result of this function is <literal>IO (FilePath,
          Handle)</literal>.  The first part of the tuple is the name of the
        file created, and the second is a &Handle; opened in &ReadWriteMode;
        over that file.  When you're done with the file, you'll want to
        &hClose; it and then call &removeFile; to delete it.  See the
        following example for a sample function to use.
      </para>
        
    </sect2>
  </sect1>

  <sect1 id="hs.io.example">
    <title>Extended Example: Functional I/O and Temporary Files</title>
    <para>
      Here's a larger example that puts together some concepts from this
      chapter, from some earlier chapters, and a few you haven't seen yet.
      Take a look at the program and see if you can figure out what it does
      and how it works.
    </para>

    &tempfile.hs:all;

    <para>
      Let's start looking at this program from the end.  The
      <literal>withTempFile</literal> function demonstrates that Haskell
      doesn't forget its functional nature when I/O is introduced.  This
      function takes a &String; and another function.  The passed function is
      passed the name and &Handle; of a temporary file.  When that function
      exits, the temporary file is closed and deleted.
    </para>
    <para>
      There is some exception handling going on to make the program more
      robust in the face of errors.  You normally want the temporary files to
      be deleted all the time, even if something went wrong.  So we make sure
      that happens.  For more on exception handling, and the use of &catch;
      and &finally; see <remark>FIXME: add ref (ch 18 or 24?)</remark>.
    </para>
    <para>Let's return to the start of the program.  &main; is defined simply
      as <literal>withTempFile "mytemp.txt" myAction</literal>.
      <literal>myAction</literal>, then, will be invoked with the name and
      &Handle; of the temporary file.
    </para>
    <para>
      <literal>myAction</literal> displays some information to the terminal,
      writes some data to the file, seeks to the beginning of the file, 
      and reads the data back with
      &hGetContents;.<footnote><para>&hGetContents; will be discussed in
          <xref linkend="hs.io.lazy"/></para></footnote>  It then displays
      the contents of the file byte-for-byte, and also as a Haskell literal
      via <literal>print c</literal>.  That's the same as <literal>putStrLn
        (show c)</literal>.
    </para>
    <para>
      Let's look at the output:
    </para>
    <screen>
$ <userinput>runhaskell tempfile.hs</userinput>
Welcome to tempfile.hs
I have a temporary file at /tmp/mytemp8572.txt
My initial position is 0
Writing one line containing 22 bytes: [1,2,3,4,5,6,7,8,9,10]
After writing, my new position is 23
The file content is:
[1,2,3,4,5,6,7,8,9,10]

Which could be expressed as this Haskell literal:
"[1,2,3,4,5,6,7,8,9,10]\n"
    </screen>
    <para>
      Every time you run this program, your temporary file name should be
      slightly different since it contains a randomly-generated component.
      Looking at this output, there are a few questions that might occur to
      you:
    </para>
    <itemizedlist>
      <listitem><para>Why is your position 23 after writing a line with 22
          bytes?</para></listitem>
      <listitem><para>Why is there an empty line after the file content
          display?</para></listitem>
      <listitem><para>Why is there a <literal>\n</literal> at the end of the
          Haskell literal display?</para></listitem>
    </itemizedlist>
    <para>
      You might be able to guess that the answers to all three questions are
      related.  See if you can work out the answers for a moment.  If you
      need some help, here are the explanations:
    </para>
    <itemizedlist>
      <listitem><para>That's because we used &hPutStrLn; instead of &hPutStr;
          to write the data.  &hPutStrLn; always terminates the line by
          writing a <literal>\n</literal> at the end, which didn't appear in
          <literal>tempdata</literal>.</para></listitem>
      <listitem><para>We used <literal>putStrLn c</literal> to display the
          file contents <literal>c</literal>.  Because the data was written
          originally with &hPutStrLn;, <literal>c</literal> ends with the
          newline character, and &putStrLn; adds a second newline character.
          The result is a blank line.</para></listitem>
      <listitem><para>The <literal>\n</literal> is the newline character from
          the original &hPutStrLn;.</para></listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="hs.io.lazy">
    <title>Lazy I/O</title>
    <para>
      So far in this chapter, you've seen examples of fairly traditional I/O.
      Each line, or block of data, is requested individually and processed
      individually.
    </para>
    <para>
      Haskell has another approach available to you as well.  Since Haskell
      is a lazy language, meaning that any given piece of data is only
      evaluated when its value must be known, there are some novel ways of
      approaching I/O.
    </para>
    <sect2 id="hs.io.lazy.hGetContents">
      <title>hGetContents</title>
      <para>
        One novel way to approach I/O is the &hGetContents; function.<footnote><para>There is
            also a shortcut function &getContents; that operates on standard
            input.</para></footnote>  &hGetContents; has the type
        <literal>Handle -> IO String</literal>.  The &String; it returns
        represents the entire data in the file given by the
        &Handle;.<footnote><para>More precisely, it is the entire data from the
            current position of the file pointer to the end of the
            file.</para></footnote>
      </para>
      <para>
        In an imperative language, use of such a function is often a bad idea.
        It may be fine to read the entire contents of a 2KB file, but if you
        try to read the entire contents of a 500GB file, you are likely to
        crash due to lack of RAM to store all that data.
      </para>
      <para>
        But &hGetContents; is different.  The &String; it returns is evaluated
        lazily.  At the moment you call &hGetContents;, nothing is actually
        read.  Data is only read from the &Handle; as the elements (characters)
        of the list are processed.  As elements of the &String; are no longer
        used, Haskell automatically frees that memory.  All of this happens
        completely transparently to you.  And since you have what looks like --
        and, really, is -- a pure &String;, you can pass it to pure (non-&IO;)
        code.
      </para>
      <para>
        Let's take a quick look at an example.  Back in
        <xref linkend="hs.io.files"/>, you saw an imperative program
        that converted the entire content of a file to uppercase.  Its
        imperative algorithm was similar to what you'd see in many other
        languages.  Here now is the much simpler lazy algorithm:
      </para>
      &toupper-lazy1.hs:all;
      <para>
        Notice that &hGetContents; handled <emphasis>all</emphasis> of the
        reading for us.  Also, take a look at <literal>processData</literal>.
        It's a pure function since it has no side-effects and always returns
        the same result each time it is called.  It has no need to know --
        and no way to tell -- that its input is being read lazily from a file
        in this case.  It can work perfectly well with a 20-character literal
        or a 500GB data dump on disk.
      </para>
      <para>
        You can even verify that with &ghci;:
      </para>
      &toupper-lazy1.ghci:all;
      <para>
        This program was a bit verbose to make it clear that there was pure
        code in use.  Here's a bit more concise version, which we will build
        on in the next examples:
      </para>
      &toupper-lazy2.hs:all;
    </sect2>
    <sect2 id="hs.io.lazy.readFile">
      <title>readFile and writeFile</title>
      <para>
        Haskell programmers use &hGetContents; as a filter quite often.  They
        read from one file, do something to the data, and write the result
        out elsewhere.  This is so common that there are some shortcuts for
        doing it.  &readFile; and &writeFile; are shortcuts for working with
        files as strings.  They handle all the details of opening files,
        closing files, reading data, and writing data.  &readFile; uses
        &hGetContents; internally.
      </para>
      <para>
        Can you guess the Haskell types of these functions?  Let's check with
        &ghci;:
      </para>
      &toupper-lazy3.hs:all;
      <para>
        Look at that -- the guts of the program takes up only two lines!
        &readFile; returned a lazy &String;, which we stored in
        <literal>inpStr</literal>.  We then took that, processed it, and
        passed it to &writeFile; for writing.
      </para>
    </sect2>
    <sect2 id="hs.io.lazy.output">
      <title>A Word On Lazy Output</title>
      <para>
        By now, you should understand how lazy input works in Haskell.  But
        what about laziness during output?
      </para>
      <para>
        As you know, nothing in Haskell is evaluated before its value is
        needed.  Since functions such as &putStr; write out the entire
        &String; passed to them, that entire &String; must be evaluated.  So
        you are guaranteed that the argument to &putStr; will be evaluated in
        full.<footnote><para>Excepting I/O errors such as a full
            disk, of course.</para></footnote> 
      </para>
      <para>
        But what does that mean for laziness of the input?  In the examples
        above, will the call to &putStr; or &writeFile; force the entire
        input string to be loaded into memory at once, just to be written
        out?
      </para>
      <para>
        The answer is no.  &putStr; (and all the similar output functions)
        write out data as it becomes available.  They also have no need for
        keeping around data already written, so as long as nothing else in
        the program needs it, the memory can be freed immediately.
      </para>
      <para>
        You can verify this yourself by generating a large
        <literal>input.txt</literal> for <literal>toupper-lazy3.hs</literal>.
        It may take a bit to process, but you should see a constant -- and
        low -- memory usage while it is being processed.
      </para>
    </sect2>

    <sect2 id="hs.io.lazy.interact">
      <title>interact</title>
      <para>
        You learned that &readFile; and &writeFile; address the common situation of
        reading from one file, making a conversion, and writing to a
        different file.  There's a situation that's even more common than
        that: reading from standard input, making a conversion, and writing
        the result to standard output.  For that situation, there is a
        function called &interact;.  &interact; takes one argument: a
        function of type <literal>String -> String</literal>.  That function
        is passed the result of <literal>getContents</literal> -- that is,
        standard input read lazily.  The result of that function is sent to
        stnadard output.
      </para>
      <para>
        We can convert our example program to operate on standard input
        and standard input by using <literal>interact</literal>.  Here's one
        way to do that:
      </para>
      &toupper-lazy4.hs;
      <para>
        Look at that -- <emphasis>one</emphasis> line of code to achieve our
        transformation!  To achieve the same effect as with the previous
        examples, you could run this one like this:
      </para>
      <screen>
$ <userinput>runghc toupper-lazy4.hs < input.txt &gt; output.txt</userinput>
      </screen>
      <para>
        Or, if you'd like to see the output printed to the screen, you could
        type:
      </para>
      <screen>
$ <userinput>runghc toupper-lazy4.hs < input.txt</userinput>
      </screen>
      <para>
        If you want to see that Haskell output truly does write out chunks of
        data as soon as they are received, run <literal>runghc
          toupper-lazy4.hs</literal> without any other command-line
        parameters.  You should see each character echoed back out as soon as
        you type it, but in uppercase.  Buffering may change this behavior;
        see <xref linkend="hs.io.buffering"/> later in this chapter for more
        on buffering.  If you see each line echoed as soon as you type it, or
        even nothing at all for awhile, buffering is causing this behavior.
      </para>
      <para>
        You can also write interactive programs using &interact;.  Let's
        start with a simple example: adding a line of text before the
        uppercase output.
      </para>
      &toupper-lazy5.hs;
      <para>
        Here we add a string at the beginning of the output.  Can you spot
        the problem, though?
      </para>
      <para>
        Since we're calling &map; on the <emphasis>result</emphasis> of
        <literal>(++)</literal>, that header itself will appear in uppercase.
        We can fix that in this way:
      </para>
      &toupper-lazy6.hs:all;
      <para>
        This moved the header outside of the &map;.
      </para>
      <para>
        Another common use of &interact; is filtering.  Let's say that you
        want to write a program that reads a file and prints out every line
        that contains the character "a".  Here's how you might do that with
        &interact;:
      </para>
      &filter.hs:all;
      <para>
        This may have introduced three functions that you aren't familiar
        with yet.  Let's inspect their types with &ghci;:
      </para>
      &filter.ghci:all;
      <para>
        Back in <xref linkend="hs.io.basics"/>, you saw a program that asked
        the user for a name, then printed a greeting.  Do you think we could
        do that with &interact;?
      </para>

    </sect2>

    <!--
    <remark>comment on side-effects potentially being problematic</remark>
    -->
  </sect1>

  <sect1 id="hs.io.monad">
    <title>The IO Monad</title>
    <para>
      You may recall from <remark>FIXME: add ref</remark> that Haskell is a
      pure language.  That is, if you give a certain function a specific
      argument, the function will return the same result every time you give
      it that argument.  Moreover, the function will not change anything
      about the program's overall state.
    </para>
    <para>
      You may be wondering, then, how I/O fits into this picture.  Surely if
      you want to read a line of input from the keyboard, the function to
      read input can't possibly return the same result every time it is run,
      right?  Moreover, I/O is all about changing state.  I/O could cause
      pixels on a terminal to light up, to cause paper to start coming out of
      a printer, or even to cause a package to be shipped from a warehouse on
      a different continent.  I/O doesn't just change the state of a program.
      You can think of I/O as changing the state of the world.
    </para>
    <para>
      Most languages do not make a distinction between a pure function and an
      impure one.  Haskell has functions in the mathematical sense: they are
      purely computations which cannot be impacted by anything external.
      Moreover, the computation can be performed at any time -- or even
      never, if its result is never needed.
    </para>
    <para>
      Clearly, then, we need some other tool to work with I/O.  That tool in
      Haskell is called <emphasis>actions</emphasis>.  Actions resemble
      functions.  They do nothing when they are defined, but perform some
      task when they are invoked.  I/O actions are defined within the &IO;
      monad.  Monads are actually a powerful way of chaining data together
      purely and are covered in <remark>FIXME: insert ref</remark>.  It's not
      necessary to understand monads in order to understand I/O.  Just
      understand that the return value of actions is "tagged" with 
      &IO;.  Let's take a look at some types:
    </para>

    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.imperative">
    <title>Is Haskell Really Imperative?</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.buffering">
    <title>Buffering</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.let">
    <title>let in the IO Monad</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.args">
    <title>Reading Command-Line Arguments</title>
    <remark>FIXME</remark>
  </sect1>

  <sect1 id="hs.io.environ">
    <title>Environment Variables</title>
    <remark>FIXME</remark>
    <remark>CWD</remark>
  </sect1>


</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
