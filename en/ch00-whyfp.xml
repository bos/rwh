<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<preface id="whyfp">
  <title>Why functional programming?  Why Haskell?</title>

  <sect1>
    <title>Have we got a deal for you!</title>

    <para id="x_Jx">Haskell is a deep language, and we think that learning it is
      a hugely rewarding experience.  We will focus on three elements
      as we explain why. The first is
      <emphasis>novelty</emphasis>: we invite you to think about
      programming from a different and valuable perspective.  The
      second is <emphasis>power</emphasis>: we'll show you how to
      create software that is short, fast, and safe.  Lastly, we offer
      you a lot of <emphasis>fun</emphasis>: the pleasure of applying
      beautiful programming techniques to solve real problems.</para>

    <sect2>
      <title>Novelty</title>

      <para id="x_Kx">Haskell is most likely quite different from any language
	you've ever used before.  Compared to the usual set of
	concepts in a programmer's mental toolbox, functional
	programming offers us a profoundly different way to
	think about software.</para>

      <para id="x_Lx">In Haskell, we de-emphasise code that modifies
	data.  Instead, we focus on functions that take immutable
	values as input and produce new values as output. Given the
	same inputs, these functions always return the same results.
	This is a core idea behind functional programming.</para>

      <para id="x_Mx">Along with not modifying data, our Haskell
	functions usually don't talk to the external world; we call
	these functions <emphasis>pure</emphasis>.  We make a strong
	distinction between pure code and the parts of our programs
	that read or write files, communicate over network
	connections, or make robot arms move.  This makes it easier to
	organize, reason about, and test our programs.</para>

      <para id="x_Nx">We abandon some ideas that might seem
	fundamental, such as having a <code>for</code> loop built into
	the language.  We have other, more flexible, ways to perform
	repetitive tasks.</para>

      <para id="x_Ox">Even the way in which we evaluate expressions is
	different in Haskell.  We defer every computation until its
	result is actually needed: Haskell is a
	<emphasis>lazy</emphasis> language. Laziness is not merely a
	matter of moving work around: it profoundly affects how we
	write programs.</para>

    </sect2>

    <sect2>
      <title>Power</title>

      <para id="x_Px">Throughout this book, we will show you how
	Haskell's alternatives to the features of traditional
	languages are powerful, flexible, and lead to reliable code.
	Haskell is positively crammed full of cutting edge ideas about
	how to create great software.</para>

      <para id="x_Rx">Since pure code has no dealings with the outside
	world, and the data it works with is never modified, the kinds
	of nasty surprise in which one piece of code invisibly
	corrupts data used by another are very rare. Whatever context
	we use a pure function in, it will behave consistently.</para>

      <para id="x_Sx">Pure code is easier to test than code that deals
	with the outside world.  When a function only responds to its
	visible inputs, we can easily state properties of its
	behavior that should always be true.  We can automatically
	test that those properties hold for a huge body of random
	inputs, and when our tests pass, we move on.  We still use
	traditional techniques to test code that must interact with
	files, networks, or exotic hardware.  Since there is much less
	of this impure code than we would find in a traditional
	language, we gain much more assurance that our software is
	solid.</para>

      <para id="x_Tx">Lazy evaluation has some spooky effects.  Let's
	say we want to find the <emphasis>k</emphasis> least-valued
	elements of an unsorted list.  In a traditional language, the
	obvious approach would be to sort the list and take the first
	<emphasis>k</emphasis> elements, but this is expensive.  For
	efficiency, we would instead write a special function that
	takes these values in one pass, and it would have to perform
	some moderately complex book-keeping.  In Haskell, the
	sort-then-take approach actually performs well: laziness
	ensures that the list will only be sorted enough to find the
	<emphasis>k</emphasis> minimal elements.</para>

      <para id="x_Ux">Better yet, our Haskell code that operates so efficiently
	is tiny, and uses standard library functions.</para>

      &KMinima.hs:minima;
      
      <para id="x_Vx">It can take a while to develop an intuitive feel
	for when lazy evaluation is important, but when we exploit it,
	the resulting code is often clean, brief, and
	efficient.</para>

      <para id="x_Wx">As the above example shows, an important aspect
	of Haskell's power lies in the compactness of the code we
	write. Compared to working in popular traditional languages,
	when we develop in Haskell we often write much less code, in
	substantially less time, and with fewer bugs.</para>
    </sect2>

    <sect2>
      <title>Enjoyment</title>

      <para id="x_Xx">We believe that it is easy to pick up the basics of
	Haskell programming, and that you will be able to successfully
	write small programs within a matter of hours or days.</para>

      <para id="x_Yx">Since effective programming in Haskell differs
	greatly from other languages, you should expect that mastering
	both the language itself and functional programming techniques
	will require plenty of thought and practice.</para>

      <para id="x_Zx">Harking back to our own days of getting started with
	Haskell, the good news is that the fun begins early: it's
	simply an entertaining challenge to dig into a new language,
	in which so many commonplace ideas are different or missing,
	and to figure out how to write simple programs.</para>

      <para id="x_ax">For us, the initial pleasure lasted as our
	experience grew and our understanding deepened.  In other
	languages, it's difficult to see any connection between
	science and the nuts-and-bolts of programming. In Haskell, we
	have imported some ideas from abstract mathematics and put
	them to work.  Even better, we find that not only are these
	ideas easy to pick up, they have a practical payoff in helping
	us to write more compact, reusable code.</para>

      <para id="x_bx">Furthermore, we won't be putting any <quote>brick
	  walls</quote> in your way: there are no especially difficult
	or gruesome techniques in this book that you must master in
	order to be able to program effectively.</para>

      <para id="x_cx">That being said, Haskell is a rigorous language:
	it will make you perform more of your thinking up front.  It
	can take a little while to adjust to debugging much of your
	code before you ever run it, in response to the compiler
	telling you that something about your program does not make
	sense.  Even with years of experience, we remain astonished and
	pleased by how often our Haskell programs simply work on the
	first try, once we fix those compilation errors.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>What to expect from this book</title>

    <para id="x_Tl">We started this project because a growing number
      of people are using Haskell to solve everyday problems. Because
      Haskell has its roots in academia, few of the Haskell books that
      currently exist focus on the problems and techniques of everyday
      programming that we're interested in.</para>

    <para id="x_Rl">With this book, we want to show you how to use
      functional programming and Haskell to solve realistic problems.
      This is a hands-on book: every chapter contains dozens of code
      samples, and many contain complete applications.  Here are a few
      examples of the libraries, techniques and tools that we'll show you
      how to develop.</para>

    <itemizedlist>
      <listitem>
	<para id="x_dx">Create an application that downloads podcast episodes
	  from the Internet, and stores its history in an SQL
	  database.</para>
      </listitem>
      <listitem>
	<para id="x_ex">Test your code in an intuitive and powerful
	  way.  Describe properties that ought to be true, then let
	  the QuickCheck library generate test cases
	  automatically.</para>
      </listitem>
      <listitem>
	<para id="x_fx">Take a grainy phone camera snapshot of a barcode, and
	  turn it into an identifier that you can use to query a
	  library or bookseller's web site.</para>
      </listitem>
      <listitem>
	<para id="x_gx">Write code that thrives on the web.  Exchange
	  data with servers and clients written in other languages
	  using JSON notation.  Develop a concurrent link
	  checker.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>A little bit about you</title>

      <para id="x_hx">What will you need to know before reading this
	book?  We expect that you already know how to program, but if
	you've never used a functional language, that's fine.</para>

      <para id="x_ix">No matter what your level of experience is, we
	have tried to anticipate your needs: we go out of our way to
	explain new and potentially tricky ideas in depth, usually
	with examples and images to drive our points home.</para>

      <para id="x_P">As a new Haskell programmer, you'll inevitably
	start out writing quite a bit of code by hand for which you
	could have used a library function or programming technique,
	had you just known of its existence.  We've packed this book
	with information to help you to come up to speed as quickly as
	possible.</para>

      <para id="x_jx">Of course, there will always be a few bumps along the
	road.  If you start out anticipating an occasional surprise or
	difficulty along with the fun stuff, you will have the best
	experience.  Any rough patches you might hit won't last
	long.</para>

      <para id="x_kx">As you become a more seasoned Haskell programmer, the way
	that you write code will change.  Indeed, over the course of
	this book, the way that we present code will evolve, as we
	move from the basics of the language to increasingly powerful
	and productive features and techniques.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>What to expect from Haskell</title>

    <para id="x_lx">Haskell is a general purpose programming language.  It was
      designed without any application niche in mind.  Although it
      takes a strong stand on how programs should be written, it does
      not favour one problem domain over others.</para>

    <para id="x_mx">While at its core, the language encourages a pure, lazy
      style of functional programming, this is the
      <emphasis>default</emphasis>, not the only option.  Haskell also
      supports the more traditional models of procedural code and
      strict evaluation.  Additionally, although the focus of the
      language is squarely on writing statically typed programs, it is
      possible (though rarely seen) to write Haskell code in a
      dynamically typed manner.</para>

    <sect2>
      <title>Compared to traditional static languages</title>

      <para id="x_nx">Languages that use simple static type systems
	have been the mainstay of the programming world for decades.
	Haskell is statically typed, but its notion of what types are
	for, and what we can do with them, is much more flexible and
	powerful than traditional languages.  Types make a major
	contribution to the brevity, clarity, and efficiency of
	Haskell programs.</para>

      <para id="x_ox">Although powerful, Haskell's type system is
	often also unobtrusive.  If we omit explicit type information,
	a Haskell compiler will automatically infer the type of an
	expression or function. Compared to traditional static
	languages, to which we must spoon-feed large amounts of type
	information, the combination of power and inference in
	Haskell's type system significantly reduces the clutter and
	redundancy of our code.</para>

      <para id="x_px">Several of Haskell's other features combine to
	further increase the amount of work we can fit into a
	screenful of text.  This brings improvements in development
	time and agility: we can create reliable code quickly, and
	easily refactor it in response to changing
	requirements.</para>

      <para id="x_qx">Sometimes, Haskell programs may run more slowly
	than similar programs written in C or C++.  For most of the
	code we write, Haskell's large advantages in productivity and
	reliability outweigh any small performance
	disadvantage.</para>

      <para id="x_mA1">Multicore processors are now ubiquitous, but they remain
	notoriously difficult to program using traditional techniques.
	Haskell provides unique technologies to make multicore
	programming more tractable.  It supports parallel programming,
	software transactional memory for reliable concurrency, and
	scales to hundreds of thousands of concurrent threads.</para>
    </sect2>

    <sect2>
      <title>Compared to modern dynamic languages</title>

      <para id="x_sx">Over the past decade, dynamically typed, interpreted
	languages have become increasingly popular.  They offer
	substantial benefits in developer productivity.  Although this
	often comes at the cost of a huge performance hit, for
	many programming tasks productivity trumps performance, or
	performance isn't a significant factor in any case.</para>

      <para id="x_tx">Brevity is one area in which Haskell and dynamically typed
	languages perform similarly: in each case, we write much less
	code to solve a problem than in a traditional language.
	Programs are often around the same size in dynamically typed
	languages and Haskell.</para>

      <para id="x_ux">When we consider runtime performance, Haskell
	almost always has a huge advantage.  Code compiled by the
	Glasgow Haskell Compiler (&GHC;) is typically between 20 and
	60 times faster than code run through a dynamic language's
	interpreter.  &GHC; also provides an interpreter, so you can
	run scripts without compiling them.</para>

      <para id="x_vx">Another big difference between dynamically typed
	languages and Haskell lies in their philosophies around types.  A
	major reason for the popularity of dynamically typed languages
	is that only rarely do we need to explicitly mention types.
	Through automatic type inference, Haskell offers the same
	advantage.</para>

      <para id="x_wx">Beyond this surface similarity, the differences run
	deep.  In a dynamically typed language, we can create
	constructs that are difficult to express in a
	statically typed language.  However, the same is true in
	reverse: with a type system as powerful as Haskell's, we can
	structure a program in a way that would be unmanageable or
	infeasible in a dynamically typed language.</para>

      <para id="x_xx">It's important to recognise that each of these approaches
	involves tradeoffs.  Very briefly put, the Haskell perspective
	emphasises safety, while the dynamically typed outlook favours
	flexibility.  If someone had already discovered one way of
	thinking about types that was always best, we imagine that
	everyone would know about it by now.</para>

      <para id="x_yx">Of course, we have our own opinions about which tradeoffs
	are more beneficial.  Two of us have years of experience
	programming in dynamically typed languages.  We love working
	with them; we still use them every day; but usually, we prefer
	Haskell.</para>
    </sect2>

    <sect2>
      <title>Haskell in industry and open source</title>

      <para id="x_zx">Here are just a few examples of large software systems
	that have been created in Haskell.  Some of these are open
	source, while others are proprietary products.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_By">ASIC and FPGA design software (Lava,
	    products from Bluespec Inc.)</para>
	</listitem>
	<listitem>
	  <para id="x_Cy">Music composition software (Haskore)</para>
	</listitem>
	<listitem>
	  <para id="x_Ay">Compilers and compiler-related tools (most
	    notably &GHC;)</para>
	</listitem>
	<listitem>
	  <para id="x_Dy">Distributed revision control (Darcs)</para>
	</listitem>
	<listitem>
	  <para id="x_Ey">Web middleware (HAppS, products from Galois
	    Inc.)</para>
	</listitem>
      </itemizedlist>

      <para id="x_nA1"> is a sample of some of the companies using Haskell in
	late 2008, taken from the <ulink
	  url="http://www.haskell.org/haskellwiki/Haskell_in_industry">Haskell 
	  wiki</ulink>.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_oA1">ABN AMRO is an international bank. It uses Haskell in
	    investment banking, to measure the counterparty risk on
	    portfolios of financial derivatives. </para>
	</listitem>
	<listitem>
	  <para id="x_pA1">Anygma is a startup company.  It develops multimedia
	    content creation tools using Haskell.</para>
	</listitem>
	<listitem>
	  <para id="x_qA1">Amgen is a biotech company. It creates mathematical
	    models and other complex applications in Haskell.</para>
	</listitem>
	<listitem>
	  <para id="x_rA1">Bluespec is an ASIC and FPGA design software vendor.
	    Its products are developed in Haskell, and the chip design
	    languages that its products provide are influenced by
	    Haskell.</para>
	</listitem>
	<listitem>
	  <para id="x_sA1">Eaton uses Haskell for the design and verification of
	    hydraulic hybrid vehicle systems.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Compilation, debugging, and performance analysis</title>

      <para id="x_Fy">For practical work, almost as important as a language
	itself is the ecosystem of libraries and tools around it.
	Haskell has a strong showing in this area.</para>

      <para id="x_Gy">The most widely used compiler, &GHC;, has been actively
	developed for over 15 years, and provides a mature and stable
	set of features.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_Hy">Compiles to efficient native code on all major
	    modern operating systems and CPU architectures</para>
	</listitem>
	<listitem>
	  <para id="x_Iy">Easy deployment of compiled binaries, unencumbered by
	    licensing restrictions</para>
	</listitem>
	<listitem>
	  <para id="x_Ky">Code coverage analysis</para>
	</listitem>
	<listitem>
	  <para id="x_Ly">Detailed profiling of performance and memory
	    usage</para>
	</listitem>
	<listitem>
	  <para id="x_My">Thorough documentation</para>
	</listitem>
	<listitem>
	  <para id="x_Ny">Massively scalable support for concurrent and
	    multicore programming</para>
	</listitem>
	<listitem>
	  <para id="x_Jy">Interactive interpreter and debugger</para>
	</listitem>
      </itemizedlist>

    </sect2>

    <sect2>
      <title>Bundled and third party libraries</title>

      <para id="x_Oy">The &GHC; compiler ships with a collection of useful
	libraries.  Here are a few of the common programming needs
	that these libraries address.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_Py">File I/O, and filesystem traversal and
	  manipulation</para>
	</listitem>
	<listitem>
	  <para id="x_Qy">Network client and server programming</para>
	</listitem>
	<listitem>
	  <para id="x_Ry">Regular expressions and parsing</para>
	</listitem>
	<listitem>
	  <para id="x_Sy">Concurrent programming</para>
	</listitem>
	<listitem>
	  <para id="x_Ty">Automated testing</para>
	</listitem>
	<listitem>
	  <para id="x_Uy">Sound and graphics</para>
	</listitem>
      </itemizedlist>

      <para id="x_Vy">The Hackage package database is the Haskell community's
	collection of open source libraries and applications.  Most
	libraries published on Hackage are licensed under liberal
	terms that permit both commercial and open source use.  Some
	of the areas covered by open source libraries include the
	following.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_Wy">Interfaces to all major open source and commercial
	    databases</para>
	</listitem>
	<listitem>
	  <para id="x_Xy">XML, HTML, and XQuery processing</para>
	</listitem>
	<listitem>
	  <para id="x_Yy">Network and web client and server development</para>
	</listitem>
	<listitem>
	  <para id="x_Zy">Desktop GUIs, including cross-platform toolkits</para>
	</listitem>
	<listitem>
	  <para id="x_ay">Support for Unicode and other text encodings</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1>
    <title>A brief sketch of Haskell's history</title>

    <para id="x_by">The development of Haskell is rooted in
      mathematics and computer science research.</para>

    <sect2>
      <title>Prehistory</title>

      <para id="x_cy">A few decades before modern computers were
	invented, the mathematician Alonzo Church developed a language
	called the lambda calculus.  He intended it as a tool for
	investigating the foundations of mathematics.  The first
	person to realize the practical connection between programming
	and the lambda calculus was John McCarthy, who created Lisp in
	1958.</para>

      <para id="x_dy">During the 1960s, computer scientists began to recognise
	and study the importance of the lambda calculus.  Peter Landin
	and Christopher Strachey developed ideas about the foundations
	of programming languages: how to reason about what they do
	(operational semantics) and how to understand what they mean
	(denotational semantics).</para>

      <para id="x_ey">In the early 1970s, Robin Milner created a more rigorous
	functional programming language named ML.  While ML was
	developed to help with automated proofs of mathematical
	theorems, it gained a following for more general computing
	tasks.</para>

      <para id="x_fy">The 1970s saw the emergence of lazy evaluation as a novel
	strategy.  David Turner developed SASL and KRC, while Rod
	Burstall and John Darlington developed NPL and Hope.  NPL,
	KRC and ML influenced the development of several more
	languages in the 1980s, including Lazy ML, Clean, and
	Miranda.</para>
    </sect2>

    <sect2>
      <title>Early antiquity</title>

      <para id="x_gy">By the late 1980s, the efforts of researchers working on
	lazy functional languages were scattered across more than a
	dozen languages.  Concerned by this diffusion of effort, a
	number of researchers decided to form a committee to design a
	common language.  After three years of work, the committee
	published the Haskell 1.0 specification in 1990.  It named the
	language after Haskell Curry, an influential logician.</para>

      <para id="x_hy">Many people are rightfully suspicious of
	<quote>design by committee</quote>, but the work of the
	Haskell committee is a beautiful example of the best work a
	committee can do.  They produced an elegant, considered
	language design, and succeeded in unifying the fractured
	efforts of their research community.  Of the thicket of lazy
	functional languages that existed in 1990, only Haskell is
	still actively used.</para>
    
      <para id="x_iy">Since its publication in 1990, the Haskell
	language standard has seen five revisions, most recently in
	1998. A number of Haskell implementations have been written,
	and several are still actively developed.</para>

      <para id="x_jy">During the 1990s, Haskell served two main
	purposes.  On one side, it gave language researchers a stable
	language in which to experiment with making lazy functional
	programs run efficiently.  Other researchers explored how to
	construct programs using lazy functional techniques.  Still
	others used it as a teaching language.</para>
    </sect2>

    <sect2>
      <title>The modern era</title>

      <para id="x_ky">While these basic explorations of the 1990s
	proceeded, Haskell remained firmly an academic affair.  The
	informal slogan of those inside the community was to
	<quote>avoid success at all costs</quote>. Few outsiders had
	heard of the language at all.  Indeed, functional programming
	as a field was quite obscure.</para>

      <para id="x_ly">During this time, the mainstream programming
	world experimented with relatively small tweaks: from
	programming in C, to C++, to Java.  Meanwhile, on the fringes,
	programmers were beginning to tinker with new, more dynamic
	languages. Guido van Rossum designed Python; Larry Wall
	created Perl; and Yukihiro Matsumoto developed Ruby.</para>

      <para id="x_my">As these newer languages began to seep into
	wider use, they spread some crucial ideas. The first was that
	programmers are not merely capable of working in expressive
	languages; in fact, they flourish.  The second was in part a
	byproduct of the rapid growth in raw computing power of that
	era: it's often smart to sacrifice some execution performance
	in exchange for a big increase in programmer productivity.
	Finally, several of these languages borrowed from functional
	programming.</para>
      
      <para id="x_ny">Over the past half a decade, Haskell has successfully
	escaped from academia, buoyed in part by the visibility of
	Python, Ruby, and even Javascript.  The language now has a
	vibrant and fast-growing culture of open source and commercial
	users, and researchers continue to use it to push the
	boundaries of performance and expressiveness.</para>
    </sect2>
  </sect1>

  <sect1 id="whyfp.resources">
    <title>Helpful resources</title>
    <para id="x_Ul">
      As you work with Haskell, you're sure to have questions and want
      more information about things.  Here are some Internet resources
      where you can look up information and interact with other
      Haskell programmers.
    </para>    

    <sect2 id="whyfp.resources.reference">
      <title>Reference material</title>
      <itemizedlist>
        <listitem>
          <para id="x_Vl"><ulink
	      url="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">The 
	      Haskell Hierarchical Libraries reference</ulink>
	    provides the documentation for the standard library that comes
	    with your compiler.  This is one of the most valuable
	    online assets for Haskell programmers.</para>
        </listitem>

        <listitem>
          <para id="x_Wl">For questions about language syntax and
	    features, the <ulink
	      url="http://haskell.org/onlinereport/">Haskell 98
	      Report</ulink> describes the Haskell 98 language
	    standard.</para>
        </listitem>

        <listitem>
          <para id="x_Xl">Various extensions to the language have
	    become commonplace since the Haskell 98 Report was
	    released.  The <ulink
	      url="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html">&GHC; 
	      Users's Guide</ulink> contains detailed documentation on
	    the extensions supported by &GHC;, as well as some
	    GHC-specific features.</para>
        </listitem>

        <listitem>
          <para id="x_Yl"><ulink
	      url="http://haskell.org/hoogle/">Hoogle</ulink> and
	    <ulink
	      url="http://holumbus.fh-wedel.de/hayoo/hayoo.html">Hayoo</ulink> 
	    are Haskell API search engines.  They can search for
	    functions by name or by type.</para>
        </listitem>

      </itemizedlist>
    </sect2>

    <sect2 id="whyfp.resources.apps">
      <title>Applications and libraries</title>
      <para id="x_Zl">
        If you're looking for a Haskell library to use for a
        particular task, or an application written in Haskell, check
        out the following resources.
      </para>
      <itemizedlist>
        <listitem>
          <para id="x_al">The Haskell community maintains a central
	    repository of open source Haskell libraries and
	    applications.  It's called <ulink
	      url="http://hackage.haskell.org/">Hackage</ulink>, and
	    it lets you search for software to download, or browse its
	    collection by category.</para>
        </listitem>

        <listitem>
          <para id="x_bl">The <ulink
	      url="http://haskell.org/haskellwiki/Applications_and_libraries">Haskell 
	      Wiki</ulink> contains a section dedicated to information
	    about particular Haskell libraries.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="whyfp.resources.community">
      <title>The Haskell community</title>

      <para id="x_cl">There are a number of ways you can get in touch
	with other Haskell programmers, to ask questions, learn what
	other people are talking about, and simply do some social
	networking with your peers.</para>
      
      <itemizedlist>
        <listitem>
          <para id="x_dl">The first stop on your search for community
	    resources should be the <ulink
	      url="http://www.haskell.org/">Haskell web site</ulink>.
	    This page contains the most current links to various
	    communities and information, as well as a huge and
	    actively maintained wiki.</para>
        </listitem>

        <listitem>
          <para id="x_el">Haskellers use a number of <ulink
	      url="http://haskell.org/haskellwiki/Mailing_lists">mailing 
	      lists</ulink> for topical discussions.  Of these, the
	    most generally interesting is named
	    <code>haskell-cafe</code>.  It has a relaxed,
	    friendly atmosphere, where professionals and academics rub
	    shoulders with casual hackers and beginners.</para>
        </listitem>

        <listitem>
          <para id="x_fl">For real-time chat, the <ulink
	      url="http://haskell.org/haskellwiki/IRC_channel">Haskell
	      IRC channel</ulink>, named <code>#haskell</code>, is
	    large and lively.  Like <code>haskell-cafe</code>, the
	    atmosphere stays friendly and helpful in spite of the huge
	    number of concurrent users.</para>
        </listitem>

        <listitem>
          <para id="x_gl">There are many local user groups, meetups,
	    academic workshops, and the like; here is <ulink
	      url="http://haskell.org/haskellwiki/User_groups">a list
	      of the known user groups and workshops</ulink>.</para>
        </listitem>

        <listitem>
          <para id="x_hl">The <ulink
	      url="http://sequence.complete.org/">Haskell Weekly
	      News</ulink> is a very-nearly-weekly summary of
	    activities in the Haskell community.  You can find
	    pointers to interesting mailing list discussions, new
	    software releases, and the like.</para>
        </listitem>

        <listitem>
          <para id="x_il">The <ulink
	      url="http://haskell.org/communities/">Haskell
	      Communities and Activities Report</ulink> collects
	    information about people that use Haskell, and what they
	    are doing with it.  It has been running for years, so it
	    provides a good way to peer into Haskell's past.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1>
    <title>Acknowledgments</title>

    <sect2>
      <title>Bryan</title>

      <para>XXX</para>
    </sect2>

    <sect2>
      <title>John</title>

      <para>XXX</para>
    </sect2>

    <sect2>
      <title>Don</title>

      <para>XXX</para>
    </sect2>

    <sect2>
      <title>Thank you to our reviewers</title>

      <para>We developed this book in the open, posting drafts of
	chapters to our web site as we completed them. Readers then
	submitted feedback using a web application that we developed.
	By the time we finished writing the book, about 800 people had
	submitted nearly 8,000 comments, an astounding figure.</para>

      <para>We deeply appreciate the time that so many people
	volunteered to help us to improve our book.  Their
	encouragement and enthusiasm over the 15 months we spent
	writing made the process a pleasure.</para>

      <para>The breadth and depth of the comments we received have
	profoundly improved the quality of this book.  Nevertheless,
	all errors and omissions are, of course, ours.</para>

      <para>The following people each contributed over 1% of the total
	number of review comments that we received.  We would like to
	thank them for their care in providing us with so much
	detailed feedback.</para>

      <para>
	Alex Stangl,
	Andrew Bromage,
	Brent Yorgey,
	Bruce Turner,
	Calvin Smith,
	David Teller,
	Henry Lenzi,
	Jay Scott,
	John Dorsey,
	Justin Dressel,
	Lauri Pesonen,
	Lennart Augustsson,
	Luc Duponcheel,
	Matt Hellige,
	Michael T. Richter,
	Peter McLain,
	Rob deFriesse,
	R&#252;diger Hanke,
	Tim Chevalier,
	Tim Stewart,
	William N. Halchin.
      </para>

      <para>We are also grateful to the people below, each of whom
	contributed at least 0.2% of all comments.</para>

      <para>
	Achim Schneider,
	Adam Jones,
	Alexander Semenov,
	Andrew Wagner,
	Arthur van Leeuwen,
	Bartek &#262;wik&#322;owski,
	Bas Kok,
	Bj&#246;rn Buckwalter,
	Bryn Keller,
	Chris Holliday,
	Chris Smith,
	Dan Scott,
	Dan Weston,
	Daniel Larsson,
	Davide Marchignoli,
	Derek Elkins,
	Dirk Ullrich,
	Dmitry Astapov,
	Douglas Silas,
	Emmanuel Delaborde,
	Eric Lavigne,
	Erik Haugen,
	Erik Jones,
	Fred Ross,
	Geoff King,
	George Moschovitis,
	Hans van Thiel,
	Isaac Dupree,
	Isaac Freeman,
	Jared Updike,
	Jeremy Fitzhardinge,
	Joe Thornber,
	Joeri van Eekelen,
	Joey Hess,
	Johan Tibell,
	John Lenz,
	Josef Svenningsson,
	Joseph Garvin,
	Justin Bailey,
	Kai Gellien,
	Kevin Watters,
	Konrad Hinsen,
	Lee Duhem,
	Luke Palmer,
	Magnus Therning,
	Marc DeRosa,
	Marcus Eskilsson,
	Mark Lee Smith,
	Matthew Danish,
	Matthew Manela,
	Michael Orlitzky,
	Michael Vanier,
	Mike Brauwerman,
	Neil Mitchell,
	Nick Seow,
	Pat Rondon,
	Raynor Vliegendhart,
	Richard Smith,
	Runar Bjarnason,
	Ryan W. Porter,
	Salvatore Insalaco,
	Sean Brewer,
	Sebastian Sylvan,
	Sebastien Bocq,
	Sengan Baring-Gould,
	Serge Le Huitouze,
	Shahbaz Chaudhary,
	Shawn M Moore,
	Tom Tschetter,
	Valery V. Vorotyntsev,
	Will Newton,
	Wolfgang Meyer,
	Wouter Swierstra.
      </para>

      <para>We would like to acknowledge the following
	people, many of whom submitted a number of comments.</para>

      <para>
	Abhishek Dasgupta,
	Adam Copp,
	Adam Langley,
	Adam Warrington,
	Adam Winiecki,
	Aditya Mahajan,
	Al Hoang,
	Alan Hawkins,
	Alejandro Dubrovsky,
	Alex Hirzel,
	Alex Rudnick,
	Alex Young,
	Alexander Battisti,
	Alexander Macdonald,
	Alexander Strange,
	Alf Richter,
	Alistair Bayley,
	Allan Clark,
	Allan Erskine,
	Allen Gooch,
	Andre Nathan,
	Andreas Bernstein,
	Andreas H.,
	Andreas Schropp,
	Andrei Formiga,
	Andrew Calleja,
	Andrew Rimes,
	Andy Carson,
	Andy Payne,
	Angelos Sphyris,
	Ankur Sethi,
	Anthony Moralez,
	Antoine Hersen,
	Antoine Latter,
	Antoine S.,
	Antonio Cangiano,
	Antonio Piccolboni,
	Antonios Antoniadis,
	Antonis Antoniadis,
	Aristotle Pagaltzis,
	Arjen van Schie,
	Arnar Birgisson,
	Artyom Shalkhakov,
	Ash Logan,
	Austin Seipp,
	Avik Das,
	Avinash Meetoo,
	BVK Chaitanya,
	Babu Srinivasan,
	Barry Gaunt,
	Bas van Dijk,
	Ben Burdette,
	Ben Ellis,
	Ben Franksen,
	Ben Moseley,
	Ben Sinclair,
	Benedikt Huber,
	Benjamin Terry,
	Benoit Jauvin-Girard,
	Bernie Pope,
	Bob Holness,
	Bobby Moretti,
	Boyd Adamson,
	Brad Ediger,
	Bradley Unterrheiner,
	Brett Morgan,
	Brian Palmer,
	Brice Lin,
	C Russell,
	Cale Gibbard,
	Carlos Aya,
	Chad Scherrer,
	Chadda&#239; Fouch&#233;,
	Chance Coble,
	Charles Krohn,
	Cheng Wei,
	Chris Ball,
	Chris Brew,
	Chris Czub,
	Chris Gallagher,
	Chris Jenkins,
	Chris Kuklewicz,
	Chris Wright,
	Christian Lasarczyk,
	Christian Vest Hansen,
	Christophe Poucet,
	Chung-chieh Shan,
	Conal Elliott,
	Conor McBride,
	Conrad Parker,
	Cosmo Kastemaa,
	Creighton Hogg,
	Curtis Warren,
	D Hardman,
	Dafydd Harries,
	Dale Jordan,
	Dan Doel,
	Dan Dyer,
	Dan Grover,
	Dan Orias,
	Dan Schmidt,
	Dan Zwell,
	Daniel Karch,
	Daniel Patterson,
	Daniel Wagner,
	Daniil Elovkov,
	Danny Yoo,
	Darren Mutz,
	Darrin Thompson,
	Dave Bayer,
	Dave Hinton,
	Dave Leimbach,
	Dave Peterson,
	Dave Ward,
	David Altenburg,
	David B. Wildgoose,
	David Carter,
	David Einstein,
	David Ellis,
	David Fox,
	David Frey,
	David Goodlad,
	David Mathers,
	David Sabel,
	Dean Pucsek,
	Denis Bueno,
	Denis Volk,
	Devin Mullins,
	Diego Moya,
	Dino Morelli,
	Dirk Markert,
	Doug Kirk,
	Dougal Stanton,
	Dr Bean,
	Drew Smathers,
	Duane Johnson,
	Durward McDonell,
	E. Jones,
	Edwin DeNicholas,
	Emre Sevinc,
	Eric Frey,
	Eric Kidd,
	Eric Kow,
	Erik Hesselink,
	Erling Alf,
	Eruc Frey,
	Eugene Grigoriev,
	Evan Klitzke,
	Evan Martin,
	Fawzi Mohamed,
	Filippo Tampieri,
	Frank Berthold,
	Fred Rotbart,
	Frederick Ross,
	Friedrich Dominicus,
	Gal Amram,
	Ganesh Sittampalam,
	Gen Zhang,
	Geoffrey King,
	George Rogers,
	German Vidal,
	Gilson Silveira,
	Gleb Alexeyev,
	Glenn Ehrlich,
	Graham Fawcett,
	Graham Lowe,
	Greg Bacon,
	Greg Chrystall,
	Greg Steuck,
	Grzegorz Chrupa&#322;a,
	Haggai Eran,
	Harald Armin Massa,
	Henning Hasemann,
	Henry Laxen,
	Hitesh Jasani,
	Ilmari Vacklin,
	Imam Tashdid ul Alam,
	Ivan Lazar Miljenovic,
	Ivan Miljenovic,
	J. Pablo Fern&#225;ndez,
	J.A. Zaratiegui,
	Jaap Weel,
	Jacques Richer,
	Jake McArthur,
	Jakub Kotowski,
	Jakub Labath,
	James Cunningham,
	James Smith,
	Jamie Brandon,
	Jan Sabbe,
	Jared Roberts,
	Jason F,
	Jason Kikel,
	Jason Mobarak,
	Jason Morton,
	Jason Rogers,
	Jeff Balogh,
	Jeff Caldwell,
	Jeffrey Bolden,
	Jeremy Crosbie,
	Jeremy O'Donoghue,
	Jeroen Pulles,
	Jim Apple,
	Jim Crayne,
	Joe Fredette,
	Joe Healy,
	Joel Lathrop,
	Joeri Samson,
	John Cowan,
	John Doe,
	John Hamilton,
	John Hornbeck,
	John Lien,
	John Stracke,
	Jonathan Guitton,
	Joseph Bruce,
	Joseph H. Buehler,
	Josh Goldfoot,
	Josh Szepietowski,
	Judah Jacobson,
	Justin George,
	Justin Goguen,
	Kamal Al-Marhubi,
	Kamil Dworakowski,
	Keegan Carruthers-Smith,
	Keith Fahlgren,
	Keith Willoughby,
	Ken Allen,
	Kent Hunter,
	Kevin Hely,
	Kevin Scaldeferri,
	Kingdon Barrett,
	Kristjan Kannike,
	Kurt Jung,
	Lally Singh,
	Lanny Ripple,
	Lauren&#539;iu Nicola,
	Laurie Cheers,
	Lennart Kolmodin,
	Liam Groener,
	Lin Sun,
	Lionel Barret de Nazaris,
	Loup Vaillant,
	Luke Plant,
	Lutz Donnerhacke,
	Marco Piccioni,
	Mark Woodward,
	Marko Tosic,
	Markus Schnell,
	Martijn van Egdom,
	Martin Bayer,
	Martin DeMello,
	Martin Dybdal,
	Martin Geisler,
	Martin Grabmueller,
	Mathew Manela,
	Matt Brandt,
	Matt Russell,
	Matti Nyk&#228;nen,
	Max Cantor,
	Maxime Henrion,
	Michael Albert,
	Michael Brauwerman,
	Michael Campbell,
	Michael Chermside,
	Michael Cook,
	Michael Dougherty,
	Michael Feathers,
	Michael Grinder,
	Michael Kagalenko,
	Michael Kaplan,
	Michael Smith,
	Michael Stone,
	Michael Walter,
	Michel Salim,
	Mikael Vejdemo Johansson,
	Mike Coleman,
	Mike Depot,
	Mike Tremoulet,
	Mike Vanier,
	Mirko Rahn,
	Miron Brezuleanu,
	Morten Andersen,
	Nathan Bronson,
	Nathan Stien,
	Naveen Nathan,
	Neil Bartlett,
	Neil Whitaker,
	Nick Messenger,
	Nick Okasinski,
	Nicola Paolucci,
	Nicolas Frisby,
	Niels Aan de Brugh,
	Niels Holmgaard Andersen,
	Nima Negahban,
	Olaf Leidinger,
	Oleg Anashkin,
	Oleg Dopertchouk,
	Oleg Taykalo,
	Olivier Boudry,
	Omar Antol&#237;n Camarena,
	Parnell Flynn,
	Patrick Carlisle,
	Paul Brown,
	Paul Delhanty,
	Paul Johnson,
	Paul Lotti,
	Paul Moore,
	Paul Stanley,
	Paulo Tanimoto,
	Per Vognsen,
	Pete Kazmier,
	Peter Aarestad,
	Peter Ipacs,
	Peter Kovaliov,
	Peter Merel,
	Peter Seibel,
	Peter Sumskas,
	Philip Armstrong,
	Philip Craig,
	Philip Neustrom,
	Philip Turnbull,
	Piers Harding,
	Piet Delport,
	Pragya Agarwal,
	Ra&#250;l Guti&#233;rrez,
	Rafael Alemida,
	Rajesh Krishnan,
	Ralph Glass,
	Rauli Ruohonen,
	Ravi Nanavati,
	Raymond Pasco,
	Reto Kramer,
	Reza Ziaei,
	Rhys Ulerich,
	Ricardo Herrmann,
	Richard Harris,
	Richard Warburton,
	Rick van Hattem,
	Rob Grainger,
	Rogan Creswick,
	Roman Gonzalez,
	Rory Winston,
	Ruediger Hanke,
	Rusty Mellinger,
	Ryan Ingram,
	Ryan Janzen,
	Ryan Kaulakis,
	Ryan Stutsman,
	Ryan T. Mulligan,
	S Pai,
	Sam Lee,
	Sandy Nicholson,
	Scott Brickner,
	Scott Rankin,
	Scott Ribe,
	Sean Cross,
	Sean Leather,
	Seth Gordon,
	Seth Tisue,
	Shawn Boyette,
	Simon Brenner,
	Simon Farnsworth,
	Simon Marlow,
	Simon Meier,
	Simon Morgan,
	Sriram Srinivasan,
	Sriram Srinivasan,
	Stefan Aeschbacher,
	Stefan Muenzel,
	Stephan Nies,
	Stephan-A. Posselt,
	Stephyn Butcher,
	Steven Ashley,
	Stuart Dootson,
	Terry Michaels,
	Thomas Fuhrmann,
	Thomas Hunger,
	Thomas Schilling,
	Thorsten Seitz,
	Tibor Simic,
	Tim Clark,
	Tim Eves,
	Tim Massingham,
	Tim Rakowski,
	Tim Wiess,
	Timo B. H&#252;bel,
	Timothy Fitz,
	Tom Moertel,
	Tom&#225;&#353; Janou&#353;ek,
	Tony Colston,
	Travis B. Hartwell,
	Tristan Allwood,
	Tristan Seligmann,
	Vesa Kaihlavirta,
	Victor M.,
	Victor Nazarov,
	Ville Aine,
	Vincent Foley,
	Vipul Ved Prakash,
	Will Leinweber,
	Wei Cheng,
	Wei Hu,
	Will Barrett,
	Will Leinweber,
	Will Robertson,
	Will Thompson,
	Yuval Kogman,
	Zach Kozatek,
	Zachary Smestad,
	Zohar Kelrich.
      </para>

      <para>Finally, we wish to thank those readers who submitted over
	800 comments anonymously.</para>
    </sect2>
  </sect1>
</preface>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
