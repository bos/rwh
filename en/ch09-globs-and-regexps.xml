<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="glob">
  <title>Efficient file processing, regular expressions, and file
    name matching</title>

  <sect1 id="glob.bytestring">
    <title>Efficient file processing</title>

    <para>This simple microbenchmark reads a text file full of
      numbers, and prints their sum.</para>

    &SumFile.hs:main;

    <para>Although the <type>String</type> type is the default used
      for reading and writing files, it is not efficient, so a simple
      program like this will perform badly.</para>

    <para>A <type>String</type> is represented as a list of
      <type>Char</type> values; each element of a list is allocated
      individually, and has some book-keeping overhead. These factors
      affect the memory consumption and performance of a program that
      must read or write text or binary data.  On simple benchmarks
      like this, even programs written in interpreted languages such
      as Python can outperform Haskell code that uses
      <type>String</type> by an order of magnitude.</para>

    <para>The <code>bytestring</code> library provides a fast, cheap
      alternative to the <type>String</type> type. Code written with
      <code>bytestring</code> can often match or exceed the
      performance and memory footprint of C, while maintaining
      Haskell's expressivity and conciseness.</para>

    <para>The library supplies two modules.  Each defines functions
      that are nearly drop-in replacements for their
      <type>String</type> counterparts.</para>

    <itemizedlist>
      <listitem>
	<para>The <code>Data.ByteString</code> module defines a
	  <emphasis>strict</emphasis> type named
	  <type>ByteString</type>.  This represents a string of binary
	  or text data in a single array.</para>
      </listitem>

      <listitem>
	<para>The <code>Data.ByteString.Lazy</code> module provides a
	  <emphasis>lazy</emphasis> type, also named
	  <type>ByteString</type>.  This represents a string of data
	  as a list of <emphasis>chunks</emphasis>, arrays of up to
	  64KB in size.</para>
      </listitem>
    </itemizedlist>

    <para>Each <type>ByteString</type> type performs better under
      particular circumstances.  For streaming a large quantity
      (hundreds of megabytes to terabytes) of data, the lazy
      <type>ByteString</type> type is usually best.  Its chunk size is
      tuned to be friendly to a modern CPU's L1 cache, and a garbage
      collector can quickly discard chunks of streamed data that are
      no longer being used.</para>

    <para>The strict <type>ByteString</type> type performs best for
      applications that are less concerned with memory footprint, or
      that need to access data randomly.</para>

    <sect2>
      <title>Binary I/O and qualified imports</title>

      <para>Let's develop a small function to illustrate some of the
	<code>ByteString</code> API.  We will determine if a file is
	an ELF object file: this is the format used for executables on
	almost all modern Unix-like systems.</para>

      <para>This is a simple matter of looking at the first four bytes
	in the file, and seeing if they match a specific sequence of
	bytes.  A byte sequence that identifies a file's type is often
	known as a <emphasis>magic number</emphasis>.</para>

      &ElfMagic.hs:hasElfMagic;

      <para>We import the <code>ByteString</code> modules using
	Haskell's <emphasis>qualified import</emphasis> syntax, the
	<code>import qualified</code> that we see above. This lets us
	refer to a module with a name of our choosing.</para>

      <para>For instance, when we want to refer to the lazy
	<code>ByteString</code> module's <function>take</function>
	function, we must write <function>L.take</function>, since we
	imported the module under the name <code>L</code>.  	If we
	are not explicit about which version of e.g.
	<function>take</function> we want, the compiler will report an
	error.</para>

      <para>We will always use qualified import syntax with the
	<code>ByteString</code> modules, because they provide many
	functions that have the same names as Prelude
	functions.</para>

      <tip>
	<para>Qualified imports make it easy to switch between
	  <type>ByteString</type> types. All you should need to do is
	  modify an <code>import</code> declaration at the top of your
	  source file; the rest of your code will probably not need
	  any changes.  You can thus handily benchmark the two types,
	  to see which is best suited to your application's needs</para>
      </tip>

      <para>Whether or not we use qualified imports, we can always use
	the entire name of a module to identify something
	unambiguously.  For instance, both
	<function>Data.ByteString.Lazy.length</function> and
	<function>L.length</function> identify the same function, as
	do <function>Prelude.sum</function> and
	<function>sum</function>.</para>

      <para>The lazy and strict <code>ByteString</code> modules are
	intended for binary I/O.  The Haskell data type for
	representing bytes is <type>Word8</type>; if we need to refer
	to it by name, we import it from the <code>Data.Word</code>
	module.</para>

      <para>The <function>L.pack</function> function takes a list of
	<type>Word8</type> values, and packs them into a lazy
	<type>ByteString</type>.  (The <function>L.unpack</function>
	function performs the reverse conversion.)  Our
	<function>hasElfMagic</function> function simply compares the
	first four bytes of a <code>ByteString</code> against a magic
	number.</para>

      <para>We are writing in classic Haskell style, where our
	<function>hasElfMagic</function> function does not perform
	I/O.  Here is the function that uses it on a file.</para>

      &ElfMagic.hs:isElfFile;
      
      <para>The <function>L.readFile</function> function is the lazy
	<type>ByteString</type> equivalent of
	<function>readFile</function>.  It operates lazily, reading
	the file as data is demanded.  It is also efficient, reading
	chunks of up to 64KB at once.  The lazy
	<type>ByteString</type> is a good choice for our task: since
	we only need to read at most the first four bytes of the file,
	we can safely use this function on a file of any size.</para>
    </sect2>

    <sect2>
      <title>Text I/O</title>

      <para>For convenience, the <code>bytestring</code> library
	provides two other modules with limited text I/O capabilities,
	<code>Data.ByteString.Char8</code> and
	<code>Data.ByteString.Lazy.Char8</code>.  These expose
	individual string elements as <type>Char</type> instead of
	<type>Word8</type>.</para>

      <warning>
	<para>The functions in these modules only work with byte-sized
	  <type>Char</type> values, so they are only suitable for use
	  with ASCII and some European character sets.  Values above
	  255 are truncated.</para>
      </warning>

      <para>The character-oriented <code>bytestring</code> modules
	provide useful functions for text processing.  Here is a file
	that contains monthly stock prices for a well-known Internet
	company from mid-2008.</para>

      &highestClose.ghci:readFile;

      <para>How can we find the highest closing price from a series of
	entries like this?  Closing prices are in the fourth
	comma-separated column.  This function obtains a closing price
	from one line of data.</para>

      &HighestClose.hs:closing;

      <para>Since this function is written in point-free style, we
	read from right to left.  The <function>L.split</function>
	function splits a lazy <type>ByteString</type> into a list of
	them, every time it finds a matching character.  The
	<function>(!!)</function> operator retrieves the
	<emphasis>k</emphasis>th element of a list.  Our
	<function>readPrice</function> function turns a string
	representing a fractional price into a whole number.</para>

      &HighestClose.hs:readPrice;

      <para>We use the <function>L.readInt</function> function, which
	parses an integer.  It returns both the integer and the
	remainder of the string once a run of digits is consumed. Our
	definition is slightly complicated by
	<function>L.readInt</function> returning <code>Nothing</code>
	if parsing fails.</para>

      <para>Our function for finding the highest closing price is
	straightforward.</para>

      &HighestClose.hs:highestClose;

      <para>We use one trick to work around the fact that we cannot
	supply an empty list to the <function>maximum</function>
	function.</para>

      &highestClose.ghci:maximum;

      <para>Since we do not want our code to throw an exception if we
	have no stock data, the <code>(Nothing:)</code> expression
	ensures that the list of <type>Maybe Int</type> values that we
	supply to <function>maximum</function> will never be
	empty.</para>

      &highestClose.ghci:maxList;

      <para>Does our function work?</para>

      &highestClose.ghci:highestClose;

      <para>Since we have separated our I/O from our logic, we can
	test the no-data case without having to create an empty
	file.</para>

      &highestClose.ghci:highestEmpty;

    </sect2>
  </sect1>

  <sect1 id="glob.fnmatch">
    <title>File name matching</title>

    <para id="x_BF">Many systems-oriented programming languages
      provide library routines that let us match a file name against a
      pattern, or that will give a list of files that match the
      pattern.  In other languages, this function is often named
      <function>fnmatch</function>.)  Although Haskell's standard
      library generally has good systems programming
      facilities, it doesn't provide these kinds of pattern matching
      functions.  We'll take this as an opportunity to develop our
      own.</para>

    <para id="x_CF">The kinds of patterns we'll be dealing with are
      commonly referred to as <emphasis>glob patterns</emphasis> (the
      term we'll use), wild card patterns, or shell-style patterns.
      They have just a few simple rules.  You probably already know
      them, but we'll quickly recap here.</para>

    <itemizedlist>
      <listitem>
	<para id="x_DF">Matching a string against a pattern starts at the
	  beginning of the string, and finishes at the end.</para>
      </listitem>
      <listitem>
	<para id="x_EF">Most literal characters match themselves.  For example,
	  the text <literal>foo</literal> in a pattern will match
	  <literal>foo</literal>, and only <literal>foo</literal>, in
	  an input string.</para>
      </listitem>
      <listitem>
	<para id="x_FF">The <literal>*</literal> (asterisk) character
	  means <quote>match anything</quote>; it will match any text,
	  including the empty string.  For instance, the pattern
	  <code>foo*</code> will match any string that begins with
	  <code>foo</code>, such as <code>foo</code> itself,
	  <code>foobar</code>, or <code>foo.c</code>.  The pattern
	  <code>quux*.c</code> will match any string that begins with
	  <code>quux</code> and ends in <code>.c</code>, such as
	  <code>quuxbaz.c</code>.</para>
      </listitem>
      <listitem>
	<para id="x_GF">The <literal>?</literal> (question mark)
	  character matches any single character.  The pattern
	  <code>pic??.jpg</code> will match names like
	  <code>picaa.jpg</code> or <code>pic01.jpg</code>.</para>
      </listitem>
      <listitem>
	<para id="x_HF">A <literal>[</literal> (open square bracket) character
	  begins a <emphasis>character class</emphasis>, which is
	  ended by a <literal>]</literal>.  Its meaning is
	  <quote>match any character in this class</quote>.  A
	  character class can be <emphasis>negated</emphasis> by
	  following the opening <literal>[</literal> with a
	  <literal>!</literal>, so that it means <quote>match any
	    character <emphasis>not</emphasis> in this
	    class</quote>.</para>
	<para id="x_IF">As a shorthand, a character followed by a
	  <literal>-</literal> (dash), followed by another character,
	  denotes a <emphasis>range</emphasis>: <quote>match any
	    character within this set</quote>.</para>
	<para id="x_JF">Character classes have an added subtlety; they
	  can't be empty.  The first character after the opening
	  <literal>[</literal> or <literal>[!</literal> is part of the
	  class, so we can write a class containing the
	  <literal>]</literal> character as
	  <literal>[]aeiou]</literal>.  The pattern
	  <code>pic[0-9].[pP][nN][gG]</code> will match a name
	  consisting of the string <code>pic</code>, followed by a
	  single digit, followed by any capitalization of the strig
	  <code>.png</code>.</para>
      </listitem>
    </itemizedlist>

    <para id="x_KF">While Haskell doesn't provide a way to match glob
      patterns among its standard libraries, it provides a good
      regular expression matching library.  Glob patterns are nothing
      more than cut-down regular expressions with slightly different
      syntax.  It's easy to convert glob patterns into regular
      expressions, but to do so, we must first understand how to use
      regular expressions in Haskell.</para>
  </sect1>

  <sect1 id="glob.regex">
    <title>Regular expressions in Haskell</title>

    <para id="x_LF">In this section, we will be assume that you are
      already familiar with regular expressions by way of some other
      language, such as Python, Perl, or Java<footnote>
	<para>If you are not acquainted with regular expressions, we
	  recommend Jeffrey Friedl's book <emphasis>Mastering Regular
	    Expressions</emphasis>.</para>
      </footnote>.</para>
    <note>
      <para>For brevity, we will abbreviate <quote>regular
	  expression</quote> as <emphasis>regexp</emphasis> from here
	on.</para>
    </note>

    <para>Rather than introduce regexps as something new, we will
      focus on what's different about regexp handling in Haskell,
      compared to other languages. Haskell's regular expression
      matching libraries are a lot more expressive than those of other
      languages, so there's plenty to talk about.</para>

    <para id="x_MF">To begin our exploration of the regexp libraries,
      the only module we'll need to work with is <classname
	role="module">Text.Regex.Posix</classname>.  As usual, the
      most convenient way to explore this module is by interacting
      with it via <command>ghci</command>.</para>

    &regexp.ghci:load;

    <para id="x_NF">The only function that we're likely to need for
      normal use is the regexp matching function, an infix operator
      named <function>(=~)</function> (borrowed from Perl).  The first
      hurdle to overcome is that Haskell's regexp libraries make heavy
      use of polymorphism.  As a result, the type signature of the
      <function>(=~)</function> operator is difficult to understand,
      so we will not explain it here. </para>

    <para id="x_OF">The
      <function>=~</function> operator uses typeclasses for both of
      its arguments, and also for its return type.  The first argument
      (on the left of the <function>=~</function>) is the text to
      match; the second (on the right) is the regular expression to
      match against.  We can pass either a <type>String</type> or a
      <type>ByteString</type> as either argument.</para>

    <sect2>
      <title>The many types of result</title>

      <para id="x_PF">The <function>=~</function> operator is
	polymorphic in its return type, so the Haskell compiler needs
	some way to know what type of result we would like.  In real
	code, it may be able to infer the right type, due to the way
	we subsequently use the result.  But such cues are often
	lacking when we're exploring with <command>ghci</command>.  If
	we omit a specific type for the result, we'll get an
	error from the interpreter, as it does not have enough
	information to successfuly infer the result type.</para>

      <para id="x_QF">When <command>ghci</command> can't infer the
	<varname condition="tyvar">target</varname> type, we tell it
	what we'd like the type to be.  If we want a result of
	type <type>Bool</type>, we'll get a pass/fail answer.</para>

      &regexp.ghci:bool.passfail;

      <para id="x_RF">In the bowels of the regexp libraries,
	there's a typeclass named <classname>RegexContext</classname>
	that describes how a <varname
	  condition="tyvar">target</varname> type should behave; the
	base library defines many instances of this typeclass for us.
	The <type>Bool</type> type is an instance of this typeclass,
	so we get back a usable result. Another such instance is
	<type>Int</type>, which gives us a count of the number of
	times the regexp matches.</para>

      &regexp.ghci:int.count;

      <para id="x_SF">If we ask for a <type>String</type> result,
	we'll get the first substring that matches, or an empty string
	if nothing matches.</para>

      &regexp.ghci:string;

      <para id="x_TF">Another valid type of result is
	<type>[String]</type>, which returns a list of
	<emphasis>all</emphasis> matching strings.</para>

      &regexp.ghci:list.string;

      <note>
	<para id="x_UF">If you want a result that's a plain
	  <type>String</type>, beware.  Since
	  <function>(=~)</function> returns an empty string to signify
	  <quote>no match</quote>, this poses an obvious difficulty if
	  the empty string could also be a valid match for the regexp.
	  If such a case arises, you should use a different return
	  type instead, such as <type>[String]</type>.</para>
      </note>
      
      <para id="x_VF">That's about it for <quote>simple</quote> result
	types, but we're not by any means finished.  Before we
	continue, let's use a single pattern for our remaining
	examples.  We can define this pattern as a variable in &ghci;,
	to save a little typing.</para>
      
      &regexp.ghci:let;

      <para id="x_WF">We can obtain quite a lot of information about
	the context in which a match occurs.  If we ask for a
	<type>(String, String, String)</type> tuple, we'll get back the text
	<emphasis>before</emphasis> the first match, the text
	<emphasis>of</emphasis> that match, and the text that
	<emphasis>follows</emphasis> it.</para>

      &regexp.ghci:3tuple.match;

      <para id="x_XF">If the match fails, the entire text is returned
	as the <quote>before</quote> element of the tuple, with the
	other two elements left empty.</para>

      &regexp.ghci:3tuple.nomatch;

      <para id="x_YF">Asking for a four-element tuple gives us a
	fourth element that's a list of all groups in the pattern that
	matched.</para>

      &regexp.ghci:4tuple;

      <para id="x_ZF">We can get  numeric information about matches,
	too.  A pair of <type>Int</type>s gives us the starting offset
	of the first match, and its length.  If we ask for a list of
	these pairs, we'll get this information for all
	matches.</para>

      &regexp.ghci:2tuple.match;

      <para id="x_aF">A failed match is represented by the value
	<literal>-1</literal> as the first element of the tuple (the
	match offset) if we've asked for a single tuple, or an empty
	list if we've asked for a list of tuples.</para>

      &regexp.ghci:2tuple.nomatch;

      <para id="x_bF">This is not a comprehensive list of built-in
	instances of the <classname>RegexContext</classname>
	typeclass.  For a complete list, see the documentation for the
	<classname role="module">Text.Regex.Base.Context</classname>
	module.</para>

      <para>This ability to make a function polymorphic in its result
	type is an unusual feature for a statically typed language.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>More about regular expressions</title>

    <sect2>
      <title>Mixing and matching string types</title>

      <para id="x_cF">As we noted earlier, the <function>=~</function>
	operator uses typeclasses for its argument types and its
	return type. We can use either <type>String</type> or
	strict <type>ByteString</type> values for both the
	regular expression and the text to match against.</para>

      &regexp.ghci:mix.pack;
      
      <para id="x_dF">We can then try using different combinations of
	<type>String</type> and <type>ByteString</type>.</para>

      &regexp.ghci:mix.simple;

      <para id="x_eF">However, we need to be aware that if we want a
	string value in the result of a match, the text we're matching
	against must be the same type of string.  Let's see what this
	means in practice.</para>

      &regexp.ghci:mix.match;

      <para id="x_fF">In the above example, we've used the
	<function>pack</function> to turn a <type>String</type> into a
	<type>ByteString</type>.  The type checker accepts this
	because <type>ByteString</type> appears in the result type.
	But if we try getting a <type>String</type> out, that
	<emphasis>won't</emphasis> work.</para>

      &regexp.ghci:mix.nomatch;

      <para id="x_gF">We can easily fix this problem by making the
	string types of the left hand side and the result match once
	again.</para>

      &regexp.ghci:mix.rematch;

      <para id="x_hF">This restriction does <emphasis>not</emphasis>
	apply to the type of the regexp we're matching against.  It
	can be either a <type>String</type> or
	<type>ByteString</type>, unconstrained by the other types in
	use.</para>
    </sect2>

    <sect2>
      <title>Other things you should know</title>

      <para id="x_iF">When you look through Haskell library
	documentation, you'll see several regexp-related modules.  The
	modules under <classname
	  role="module">Text.Regex.Base</classname> define the common
	API adhered to by all of the other regexp modules. It's
	possible to have multiple implementations of the regexp API
	installed at one time.  At the time of writing,
	<application>GHC</application> is bundled with one
	implementation, <classname
	  role="module">Text.Regex.Posix</classname>.  As its name
	suggests, this package provides POSIX regexp semantics.</para>

      <note>
	<para id="x_jF">If you're coming to Haskell from a language
	  like Perl, Python, or Java, and you've used regular
	  expressions in one of those languages, you should be aware
	  that the POSIX regexps handled by the <classname
	    role="module">Text.Regex.Posix</classname> module are
	  different in some significant ways from Perl-style regexps.
	  Here are a few of the more notable differences.</para>

	<para id="x_kF">Perl regexp engines perform left-biased matching
	  when matching alternatives, whereas POSIX engines choose the
	  greediest match.  What this means is that given a regexp of
	  <literal>(foo|fo*)</literal> and a text string of
	  <literal>foooooo</literal>, a Perl-style engine will give a
	  match of <literal>foo</literal> (the leftmost match), while
	  a POSIX engine will match the entire string (the greediest
	  match).</para>

	<para id="x_lF">POSIX regexps have less uniform syntax than
	  Perl-style regexps.  They also lack a number of capabilities
	  provided by Perl-style regexps, such as zero-width
	  assertions and control over greedy matching.</para>
      </note>

      <para id="x_mF">Other Haskell regexp packages are available for
	download from Hackage.  Some provide better performance than
	the current POSIX engine (e.g. <code>regex-tdfa</code>);
	others provide the Perl-style matching that most programmers
	are now familiar with (e.g. <code>regex-pcre</code>). All
	follow the standard API that we have covered in this
	section.</para>

    </sect2>

  </sect1>

  <sect1 id="glob.translate">
    <title>Translating a glob pattern into a regular
      expression</title>

    <para id="x_nF">Now that we've seen the myriad of ways to match text against
      regular expressions, let's turn our attention back to glob
      patterns.  We want to write a function that will take a glob
      pattern and return its representation as a regular expression.
      Both glob patterns and regexps are text strings, so the type
      that our function ought to have seems clear.</para>

    &GlobRegex.hs:type;

    <para id="x_oF">The regular expression that we generate must be
      <emphasis>anchored</emphasis>, so that it starts matching from
      the beginning of a string and finishes at the end.</para>
    
    &GlobRegex.hs:rooted;

    <para id="x_pF">Recall that the <type>String</type> is just a synonym for
      <type>[Char]</type>, a list of <type>Char</type>s.  The
      <function>:</function> operator puts a value (the
      <literal>^</literal> character in this case) onto the front of a
      list, where the list is the value returned by the yet-to-be-seen
      <function>globToRegex'</function> function.</para>

    <note>
      <para id="x_rF">Haskell does not require that a value or function be
	declared or defined in a source file before it's used.  It's
	perfectly normal for a definition to come
	<emphasis>after</emphasis> the first place it's used.  The
	Haskell compiler doesn't care about ordering at this level.
	This grants us the flexibility to structure our code in the
	manner that makes most logical sense to us, rather than follow
	an order that makes the compiler writer's life easiest.</para>

      <para id="x_sF">Haskell module writers often use this
	flexibility to put <quote>more important</quote> code earlier
	in a source file, relegating <quote>plumbing</quote> to later.
	This is exactly how we are presenting the
	<function>globToRegex</function> function and its helpers
	here.</para>
    </note>

    <para id="x_tF">With the regular expression rooted, the
      <function>globToRegex'</function> function will do the bulk of
      the translation work.  We'll use the convenience of Haskell's
      pattern matching to enumerate each of the cases we'll need to
      cover.</para>

    &GlobRegex.hs:asterisk;

    <para id="x_uF">Our first
      clause stipulates that if we hit the end of our glob pattern (by
      which time we'll be looking at the empty string), we return
      <literal>$</literal>, the regular expression symbol for
      <quote>match end-of-line</quote>.  Following this is a series of
      clauses that switch our pattern from glob syntax to regexp syntax.
      The last clause passes every other character through, possibly
      escaping it first.</para>

    <para id="x_CG">The <function>escape</function> function ensures that the
      regexp engine will not interpret certain characters as pieces of
      regular expression syntax.</para>

    &GlobRegex.hs:escape;

    <para id="x_DG">The <function>charClass</function> helper function
      only checks that a character class is correctly terminated.  It
      passes its input through unmodified until it hits a
      <literal>]</literal>, when it hands control back to
      <function>globToRegex'</function>.</para>

    &GlobRegex.hs:charClass;

    <para id="x_EG">Now that we've finished defining
      <function>globToRegex</function> and its helpers, let's load it
      into &ghci; and try it out.</para>

    &glob-regexp.ghci:real;

    <para id="x_FG">Sure enough, that looks like a reasonable regexp.  Can we
      use it to match against a string?</para>

    &glob-regexp.ghci:matches;

    <para id="x_GG">It works!  Now let's play around a little with
      &ghci;.  We can create a temporary definition for
      <function>fnmatch</function> and try it out.</para>

    &glob-regexp.ghci:fnmatch;

    <para id="x_HG">The name <function>fnmatch</function> doesn't
      really have the <quote>Haskell nature</quote>, though.  By far
      the most common Haskell style is for functions to have
      descriptive, <quote>camel cased</quote> names.  Camel casing
      concatenates words, capitalising all but possibly the first
      word.  For instance, the words <quote>file name matches</quote>
      would become the name <code>fileNameMatches</code>. The name
      <quote>camel case</quote> comes from the <quote>humps</quote>
      introduced by the capital letters.  In our library, we'll give
      this function the name <function>matchesGlob</function>.</para>

    &GlobRegex.hs:matchesGlob;

    <para>You may have noticed that most of the names that we have
      used for variables so far have been short.  As a rule of thumb,
      descriptive variable names are more useful in longer function
      definitions, as they aid readability.  For a two-line function,
      a long variable name has less value.</para>
    <sect2>
      <title>Exercises</title>

      <qandaset defaultlabel="number">

	<qandaentry>
          <question id="ch07.q.error">
	    <para id="x_JG">Use &ghci; to explore what happens if you pass a
	      malformed pattern, such as <literal>[</literal>, to
	      <function>globToRegex</function>.  Write a small
	      function that calls <function>globToRegex</function>,
	      and pass it a malformed pattern.  What happens?</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para id="x_KG">While filesystems on Unix are usually sensitive to
	      case (e.g. <quote>G</quote> vs. <quote>g</quote>) in
	      file names, Windows filesystems are not. Add a parameter
	      to the <function>globToRegex</function> and
	      <function>matchesGlob</function> functions that allows
	      control over case sensitive matching.</para>
	  </question>
	</qandaentry>

      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="glob.lazyfn">
    <title>An important aside: writing lazy functions</title>

    <para id="x_LG">In an imperative language, the
      <function>globToRegex'</function> function is one that we'd
      usually express as a loop. For example, Python's standard
      <package>fnmatch</package> module includes a function named
      <function>translate</function> that does exactly the same job as
      our <function>globToRegex</function> function.  It's written as
      a loop.</para>

    <para id="x_MG">If you've been exposed to functional programming
      through a language such as Scheme or ML, you've probably had
      drilled into your head the notion that <quote>the way to emulate
	a loop is via tail recursion</quote>.</para>

    <para id="x_NG">Looking at the <function>globToRegex'</function>
      function, we can see that it is <emphasis>not</emphasis> tail
      recursive. To see why, examine its final clause again
      (several of its other clauses are structured similarly).</para>

    &GlobRegex.hs:last;

    <para id="x_OG">It applies itself recursively, and the result of
      the recursive application is used as a parameter to the
      <function>(++)</function> function. Since the recursive
      application <emphasis>isn't</emphasis> the last thing the
      function does, <function>globToRegex'</function> is not tail
      recursive. </para>

    <para id="x_PG">Why is our definition of this function not tail
      recursive?  The answer lies with Haskell's non-strict evaluation
      strategy.  Before we start talking about that, let's quickly
      talk about why, in a traditional language, we'd try to
      avoid this kind of recursive definition.  Here is a simpler
      definition, of the <function>(++)</function> operator.  It is
      recursivem, but not tail recursive.</para>

    &append.hs:append;

    <para>In a strict language, if we evaluate <code>"foo" ++
	"bar"</code>, the entire list is constructed, then returned.
      Non-strict evaluation defers much of the work until it is
      needed.</para>

    <para id="x_bG">If we demand an element of the expression
      <code>"foo" ++ "bar"</code>, the first pattern of the function's
      definition matches, and we return the expression <code>x : (xs
	++ ys)</code>. Because the <code>(:)</code> constructor is
      non-strict, the evaluation of <code>xs ++ ys</code> can be
      deferred: we generate more elements of the result at whatever
      rate they are demanded.  When we generate more of the result, we
      will no longer be using <varname>x</varname>, so the garbage
      collector can reclaim it.  Since we generate elements of the
      result on demand, and do not hold onto parts that we are done
      with, the compiler can evaluate our code in constant
      space.</para>
  </sect1>

  <sect1 id="glob.use">
    <title>Making use of our pattern matcher</title>

    <para id="x_cG">It's all very well to have a function that can
      match glob patterns, but we'd like to be able to put this to
      practical use. On Unix-like systems, the
      <function>glob</function> function returns the names of all
      files and directories that match a given glob pattern.  Let's
      build a similar function in Haskell. Following the Haskell norm
      of descriptive naming, we'll call our function
      <function>namesMatching</function>.</para>

    &Glob.hs:module;

    <para>We specify that <function>namesMatching</function> is the
      only name that users of our <code>Glob</code> module will be
      able to see.</para>

    <para id="x_dG">This function will obviously have to manipulate
      filesystem paths a lot, splicing and joining them as it goes.
      We'll need to use a few previously unfamiliar modules along the
      way.</para>

    <para id="x_eG">The <classname
	role="module">System.Directory</classname> module provides
      standard functions for working with directories and their
      contents.</para>

    &Glob.hs:import.directory;

    <para id="x_fG">The <classname
	role="module">System.FilePath</classname> module abstracts the
      details of an operating system's path name conventions.  The
      <function>(&lt;/&gt;)</function> function joins two path
      components.</para>

    &filepath.ghci:join;

    <para>The name of the
      <function>dropTrailingPathSeparator</function> function is
      perfectly descriptive.</para>

    &filepath.ghci:dropTrailingPathSeparator;

    <para>The <function>splitFileName</function> function splits a
      path at the last slash.</para>

    &filepath.ghci:splitFileName;

    <para>Using <code>System.FilePath</code> together with the
      <classname role="module">System.Directory</classname> module, we
      can write a portable <function>namesMatching</function> function
      that will run on both Unix-like and Windows systems.</para>

    &Glob.hs:import.filepath;

    <para id="x_gG">In this module, we'll be emulating a
      <quote>for</quote> loop; getting our first taste of exception
      handling in Haskell; and of course using the
      <function>matchesGlob</function> function we just wrote.</para>

    &Glob.hs:import.rest;

    <para id="x_hG">Since directories and files live in the
      <quote>real world</quote> of activities that have effects, our
      globbing function will have to have <classname>IO</classname> in
      its result type.</para>

    <para id="x_iG">If the string we're passed contains no pattern
      characters, we simply check that the given name exists in the
      filesystem.  (Notice that we use Haskell's function guard syntax
      here to write a nice tidy definition.  An <quote>if</quote>
      would do, but isn't as aesthetically pleasing.)</para>

    &Glob.hs:namesMatching;

    <para id="x_jG">The name <function>doesNameExist</function> refers
      to a function that we will define shortly.</para>

    <para id="x_kG">What if the string <emphasis>is</emphasis> a glob
      pattern?  Our function definition continues.</para>

    &Glob.hs:namesMatching2;

    <para id="x_lG">We use <function>splitFileName</function> to split
      the string into a pair of <quote>everything but the final
	name</quote> and <quote>the final name</quote>.  If the first
      element is empty, we're looking for a pattern in the current
      directory. Otherwise, we must check the directory name and see
      if it contains patterns.  If it does not, we create a singleton
      list of the directory name.  If it contains a pattern, we list
      all of the matching directories.</para>

    <note>
      <para id="x_nG">The <classname
	  role="module">System.FilePath</classname> module can be a
	little tricky.  Above is a case in point; the
	<function>splitFileName</function> function leaves a trailing
	slash on the end of the directory name that it returns.</para>

      &glob.ghci:split;

      <para id="x_oG">If we didn't remember (or know enough) to remove
	that slash, we'd recurse endlessly in
	<function>namesMatching</function>, because of the following
	behaviour of <function>splitFileName</function>.</para>

      &glob.ghci:tricksy;

      <para id="x_pG">You can guess what happened to us that led us to
	add this note!</para>
    </note>

    <para id="x_qG">Finally, we collect all matches in every
      directory, giving us a list of lists, and concatenate them into
      a single list of names.</para>

    <para id="x_rG">The unfamiliar <function>forM</function> function
      above acts a little like a <quote>for</quote> loop: it maps its
      second argument (an action) over its first (a list), and returns
      the list of results.</para>

    <para id="x_sG">We have a few loose ends to clean up.  The first
      is the definition of the <function>doesNameExist</function>
      function, used above.  The <classname
	role="module">System.Directory</classname> module doesn't let
      us check to see if a name exists in the filesystem.  It forces
      us to decide whether we want to check for a file or a directory.
      This API is ungainly, so we roll the two checks into a single
      function.  In the name of performance, we make the check for a
      file first, since files are far more common than
      directories.</para>

    &Glob.hs:doesNameExist;

    <para id="x_tG">We have two other functions to define, each of
      which returns a list of names in a directory.  The
      <function>listMatches</function> function returns a list of all
      files matching the given glob pattern in a directory.</para>

    &Glob.hs:listMatches;

    <para>The <function>listPlain</function> function returns either
      an empty or singleton list, depending on whether the single name
      it's passed exists.</para>

    &Glob.hs:listPlain;

    <para id="x_uG">If we look closely at the definition of
      <function>listMatches</function> above, we'll see a call to a
      function named <function>handle</function>.  Earlier on, we
      imported this from the <classname
	role="module">Control.Exception</classname> module; as that
      import implies, this gives us our first taste of exception
      handling in Haskell.  Let's drop into &ghci; and see what we can
      find out.</para>

    &handle.ghci:type.handle;

    <para id="x_vG">This is telling us that
      <function>handle</function> takes two arguments.  The first is a
      function that is passed an exception value, and can have side
      effects (see the <type>IO</type> type in its return value); this
      is the handler to run if an exception is thrown. The second
      argument is the code that might throw an exception.</para>

    <para id="x_wG">As for the exception handler, the type of the
      <function>handle</function> constrains it to return the same
      type of value as the body of code that threw the exception.  So
      its choices are to either throw an exception or, as in our case,
      return a list of <type>String</type>s.</para>

    <para id="x_xG">The <function>const</function> function takes two
      arguments; it always returns its first argument, no matter what
      its second argument is.</para>

    &handle.ghci:type.const;

    <para>We use <function>const</function> to write an exception
      handler that ignores the exception it is passed.  Instead, it
      causes our code to return an empty list if we catch an
      exception.</para>

    <para id="x_yG">We won't have anything more to say about exception
      handling here.  There's plenty more to cover, though, so we'll
      be returning to the subject of exceptions in chapter <xref
	linkend="errors"/>.</para>

    <sect2>
      <title>Exercises</title>
      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_zG">Although we've gone to some lengths to
	      write a portable <function>namesMatching</function>
	      function, the function uses our case sensitive
	      <function>globToRegex</function> function.  Find a way
	      to modify <function>namesMatching</function> to be case
	      sensitive on Unix, and case insensitive on Windows,
	      without modifying its type signature.</para>
	  </question>
	  <answer>
	    <para id="x_AH"><emphasis>Hint</emphasis>: consider
	      reading the documentation for <classname
		role="module">System.FilePath</classname> to look for
	      a variable that tells us whether we're running on a
	      Unix-like system, or on Windows.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para id="x_BH">If you're on a Unix-like system, look
	      through the documentation for the <classname
		role="module">System.Posix.Files</classname> module,
	      and see if you can find a replacement for the
	      <function>doesNameExist</function> function.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para id="x_CH">The <literal>*</literal> wild card only
	      matches names within a single directory.  Many shells
	      have an extended wild card syntax,
	      <literal>**</literal>, that matches names recursively in
	      all directories.  For example, <literal>**.c</literal>
	      would mean <quote>match a name ending in
		<literal>.c</literal> in this directory or any
		subdirectory at any depth</quote>.  Implement matching
	      on <literal>**</literal> wildcards.</para>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="glob.errapi">
    <title>Handling errors through API design</title>

    <para id="x_DH">It's not necessarily a disaster if our
      <function>globToRegex</function> is passed a malformed pattern.
      Perhaps a user mistyped a pattern, in which case we'd like to be
      able to report a meaningful error message.</para>

    <para id="x_EH">Calling the <function>error</function> function when this
      kind of problem occurs can be a drastic response (exploring its
      consequences was the focus of exercise <xref
	linkend="ch07.q.error"/>).  The <function>error</function>
      throws an exception.  Pure Haskell code cannot deal with
      exceptions, so control is going to rocket out of our pure code
      into the nearest caller that lives in <classname>IO</classname>
      and has an appropriate exception handler installed.  If no such
      handler is installed, the Haskell runtime will default to
      terminating our program (or print a nasty error message, in
      &ghci;).</para>

    <para id="x_FH">So calling <function>error</function> is a little like
      pulling the handle of a fighter plane's ejection seat.  We're
      bailing out of a catastrophic situation that we can't deal with
      gracefully, and there's likely to be a lot of flaming wreckage
      strewn about by the time we hit the ground.</para>

    <para id="x_GH">We've established that <function>error</function> is for
      disasters, but we're still using it in
      <function>globToRegex</function>.  In that case, malformed input
      should be rejected, but not turned into a big deal.  What would
      be a better way to handle this?</para>

    <para id="x_HH">Haskell's type system and libraries to the rescue!  We can
      encode the possibility of failure in the type signature of
      <function>globToRegex</function>, using the predefined
      <type>Either</type> type.</para>

    &GlobRegexEither.hs:type;

    <para id="x_IH">A value returned by <function>globToRegex</function> will
      now be either <literal>Left "an error message"</literal> or
      <literal>Right "a valid regexp"</literal>.  This return type
      forces our callers to deal with the possibility of error.
      (You'll find that this use of the <type>Either</type> type
      occurs frequently in Haskell code.)</para>

    <sect2>
      <title>Exercises</title>
      <qandaset defaultlabel="number">
	<qandaentry>
	  <question>
	    <para id="x_JH">Write a version of <function>globToRegex</function>
	      that uses the type signature above.</para>
	  </question>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para id="x_KH">Modify the type signature of
	      <function>namesMatching</function> so that it encodes
	      the possibility of a bad pattern, and make it use your
	      rewritten <function>globToRegex</function>
	      function.</para>

	    <tip>
	      <para>You may find the amount of work involved to be
		surprisingly large.  Don't worry; we will introduce
		more concise and sophisticated ways of dealing with
		errors in later chapters.</para>
	    </tip>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="glob.work">
    <title>Putting our code to work</title>

    <para id="x_LH">The <function>namesMatching</function> function isn't very
      exciting by itself, but it's a useful building block.  Combine
      it with a few more functions, and we can start to do interesting
      things.</para>

    <para id="x_MH">Here's one such example.  Let's define a
      <function>renameWith</function> function that, instead of simply
      renaming a file, applies a function to the file's name, and
      renames the file to whatever that function returns.</para>

    &Useful.hs:renameWith;

    <para id="x_NH">Once again, we work around the ungainly
      file/directory split in <classname
	role="module">System.Directory</classname> with a helper
      function.</para>

    &Useful.hs:rename;

    <para id="x_OH">The <classname role="module">System.FilePath</classname>
      module provides many useful functions for manipulating file
      names.  These functions mesh nicely with our
      <function>renameWith</function> and
      <function>namesMatching</function> functions, so that we can
      quickly use them to create functions with complex behaviour.  As
      an example, this terse function changes the file name suffixing
      convention for C++ source files.</para>

    &Useful.hs:cc2cpp;

    <para id="x_PH">The <function>cc2cpp</function> function uses a
      few functions we'll be seeing over and over.  The
      <function>flip</function> function takes another function as
      argument, and swaps the order of its arguments (inspect the type
      of <function>replaceExtension</function> in &ghci; to see why).
      The <function>=&lt;&lt;</function> function feeds the result of
      the action on its right side to the action on its left.</para>
  </sect1>

  <sect1 id="glob.exercises">
    <title>Exercises</title>
    <qandaset defaultlabel="number">
      <qandaentry>
	<question>
	  <para id="x_QH">Glob patterns are simple enough to interpret that it's
	    easy to write a matcher directly in Haskell, rather than
	    going through the regexp machinery.  Give it a try.</para>
	</question>
      </qandaentry>
    </qandaset>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
