<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="monads" revision="alpha;beta">
  <title>Monads</title>

  <sect1>
    <title>Introduction</title>

    <para id="x_XW">In <xref linkend="io"/>, we talked about the
      <type>IO</type> monad, but we intentionally kept the discussion
      narrowly focused on how to communicate with the outside world.
      We didn't discuss what a monad <emphasis>is</emphasis>.</para>

    <para id="x_YW">Monads have a reputation of being abstract and difficult to
      understand. If you've heard such concerns, please put aside for
      a while any doubts you might have.  Concerning abstraction, we've
      already seen in <xref linkend="io"/> that the <type>IO</type>
      monad is easy to work with.  Notational differences aside,
      writing code in the <type>IO</type> monad isn't much different
      from coding in any other imperative language.</para>

    <para id="x_ZW">As for difficulty, we quietly infiltrated monads into
      several earlier chapters of this book, when we had practical
      problems to solve.  What we aim to show you is that, far from
      being difficult to understand, a monad is often an
      <emphasis>obvious</emphasis> and <emphasis>practical</emphasis>
      tool to help solve a problem.  We'll define a few monads in this
      chapter, to show how easy it is.</para>

    <para id="x_aW">In this chapter, we'll reveal where we hid those monads,
      explain what they really are, and discuss each of the most
      widely used monads.</para>
  </sect1>

  <sect1>
    <title>Revisiting earlier code examples</title>

    <sect2>
      <title>Maybe chaining</title>

      <para id="x_bW">Let's take another look at the
	<function>parseP5</function> function that we wrote in <xref
	  linkend="binary"/>.</para>

      &PNM.hs:parseP5.noid;

      <para id="x_cW">That function threatened to march off the right side of
	the page if it got much longer.  We brought the staircasing
	under control using the <function>(&gt;&gt;?)</function>
	function.</para>

      &PNM.hs:bind.noid;

      <para id="x_dW">We carefully chose the type of
	<function>(&gt;&gt;?)</function> to let us chain together
	functions that return <type>Maybe</type>.  So long as the
	result type of one function matches the parameter of the next,
	we can chain functions returning <type>Maybe</type> together
	indefinitely.  The body of <function>(&gt;&gt;?)</function>
	hides the details of whether the functions we pass in are
	actually called.</para>
    </sect2>

    <sect2>
      <title>Implicit state</title>

      <para id="x_eW">Useful as <function>(&gt;&gt;?)</function> was for
	cleaning up the structure of <function>parseP5</function>, we
	had to incrementally consume pieces of a string as we parsed
	it.  This forced us to pass the current value of the string
	down our chain of <type>Maybe</type>s, wrapped up in a tuple.
	Each function in the chain put a result into one element of
	the tuple, and the unconsumed remainder of the string into the
	other.</para>

      &PNM.hs:parseP5_take2.noid;

      <para id="x_fW">Once again, we were faced with a pattern of repeated
	behaviour: consume some string, return a result, and return
	the remaining string for the next function to consume.
	However, this pattern was more insidious: if we wanted to pass
	another piece of information down the chain, we'd have to
	modify nearly every element of the chain, turning each
	two-tuple into a three-tuple!</para>

      <para id="x_gW">We addressed this by moving the responsibility for
	managing the current piece of string out of the individual
	functions in the chain, and into the function that we used to
	chain them together.</para>

      &Parse.hs:bind.noid;

      <para id="x_hW">We also hid the details of the parsing state in the
	<type>ParseState</type> type.  Even the
	<function>getState</function> and
	<function>putState</function> functions don't inspect the
	parsing state, so any modification to <type>ParseState</type>
	will have no effect on any existing code.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Looking for shared patterns</title>

    <para id="x_iW">When we look at the above examples in detail, they don't
      seem to have much in common.  Obviously, they're both concerned
      with chaining functions together, and with hiding details to let
      us write tidier code.  However, let's take a step back and
      consider them in <emphasis>less</emphasis> detail.</para>

    <para id="x_jW">First, let's look at the type definitions.</para>

    &Maybe.hs:Maybe.noid;

    &Parse.hs:Parse.noid;

    <para id="x_kW">The common feature of these two types is that each has a
      single free type variable on the left of the definition, which
      is used somewhere on the right.</para>

    <para id="x_lW">Next, we'll examine the chaining functions that we wrote for
      the two types.</para>

    &monadness.ghci:Maybe;

    &monadness.ghci:Parse;

    <para id="x_mW">These functions have strikingly similar types.  If we were
      to turn those type constructors into a type variable, we'd end
      up with a single more abstract type.</para>

    &Maybe.hs:chain;

    <para id="x_nW">Finally, in each case we have a function that takes a
      <quote>plain</quote> value, and <quote>injects</quote> it into
      the target type.  For <type>Maybe</type>, this function is
      simply the value constructor <code>Just</code>, but the injector
      for <type>Parse</type> is more complicated.</para>

    &Parse.hs:identity.noid;

    <para id="x_oW">Again, it's not the details or complexity that we're
      interested in, it's the fact that each of these types has this
      <quote>injector</quote> function.</para>

    &Maybe.hs:inject;

    <para id="x_pW">It is <emphasis>exactly</emphasis> these three properties,
      and a few rules about how we can use them together, that define
      a monad in Haskell.  Let's revisit the above list in condensed
      form.</para>

    <itemizedlist>
      <listitem>
	<para id="x_qW">A type <varname role="type">m</varname> with one free
	  type variable <varname role="type"></varname>.</para>
      </listitem>
      <listitem>
	<para id="x_rW">A function of type <type>m a -> (a -> m b) -> m b</type>
	  for chaining the output of one function into the input of
	  another.</para>
      </listitem>
      <listitem>
	<para id="x_sW">A function of type <type>a -> m a</type> for injecting a
	  normal value into the chain, i.e. it wraps a type
	  <type>a</type> with the type constructor
	  <type>m</type>.</para>
      </listitem>
    </itemizedlist>

    <para id="x_tW">The properties that make the <type>Maybe</type> type a monad
      are its type constructor <type>Maybe a</type>, our chaining
      function <function>(&gt;&gt;?)</function>, and the injector
      function <function>Just</function>.</para>

    <para id="x_uW">For <type>Parse</type>, the corresponding properties are the
      type constructor <type>Parse a</type>, the chaining function
      <function>(==&gt;)</function>, and the injector function
      <function>identity</function>.</para>

    <para id="x_vW">We have intentionally said nothing about how the chaining
      and injection functions of a monad should behave, and that's
      because it very nearly doesn't matter.  In fact, monads are
      ubiquitous in Haskell code precisely because they are so simple:
      many common programming patterns have a monadic structure.</para>
  </sect1>

  <sect1 id="monads.class">
    <title>The Monad typeclass</title>

    <para id="x_wW">We can capture the notions of chaining and injection, and
      the types that we want them to have, in a Haskell typeclass.
      The standard Prelude already defines just such a typeclass,
      named <code>Monad</code>.</para>

    &Maybe.hs:Monad;

    <para id="x_xW">Here, &bind; is our chaining function.  We've already been
      introduced to it in <xref linkend="io.bind"/>.  It's often
      referred to as <quote>bind</quote>, as it binds two adjacent
      functions together so that one uses the result of the
      other.</para>

    <para id="x_yW">Our injection function is &return;.  As we noted in <xref
      linkend="io.return"/>, the choice of the name &return; is a
      little unfortunate.  That name is widely used in imperative
      languages, where it has a fairly well understood meaning.  In
      Haskell, its behaviour is much less constrained.  In particular,
      calling &return; in the middle of a chain of functions won't
      cause the chain to exit early.  It's more helpful to remember it
      as <quote>inject</quote>.</para>

    <para id="x_zW">While &bind; and &return; are the core functions of the
      <code>Monad</code> typeclass, it also defines two other
      functions.  The first is &bind_;.  Like &bind;, it performs
      chaining, but it ignores the value on the left.</para>

    &Maybe.hs:bind_;

    <para id="x_AX">We use this function when we want to perform actions in a
      certain order, but don't care what the result of one is.  This
      might seem pointless: why would we not care what a function's
      return value is?  Consider a function like &print;, which
      returns nothing useful.</para>

    &bind.ghci:print;

    <para id="x_BX">If we use plain &bind;, we have to provide as its right hand
      side a function that ignores its argument.</para>

    &bind.ghci:bind;

    <para id="x_CX">But if we use &bind_;, we can omit the needless
      function.</para>

    &bind.ghci:bind_;

    <para id="x_DX">As we showed above, the default implementation of &bind_; is
      defined in terms of &bind;.</para>

    <para id="x_EX">The second non-core <code>Monad</code> function is &fail;,
      which takes an error message and does something to make the
      chain of functions fail.</para>

    &Maybe.hs:fail;

    <warning id="monads.monad.fail">
      <title>Beware of fail</title>

      <para id="x_FX">Many <code>Monad</code> instances don't override the
	default implementation of &fail; that we show here, which
	means that &fail; calls <function>error</function>.  Calling
	<function>error</function> is usually highly undesirable, so
	don't call &fail; unless you know that you're inside a monad
	that implements it to do something more sensible.  If you're
	writing code that doesn't care what monad it is in, don't use
	&fail; at all.</para>
    </warning>

    <para id="x_GX">To revisit the parser that we developed in <xref
	linkend="binary"/>, here is its <code>Monad</code>
      instance.</para>

    &Parse.hs:Monad;

  </sect1>

  <sect1>
    <title>And now, a jargon moment</title>

    <para id="x_HX">There are a few terms of jargon around monads that you may
      not be familiar with.  These aren't formal terms, but they're in
      common use, so it's helpful to know about them.</para>

    <itemizedlist>
      <listitem>
	<para id="x_IX"><quote>Monadic</quote> simply means <quote>pertaining to
	    monads</quote>.  A monadic <emphasis>type</emphasis> is an
	  instance of the <code>Monad</code> typeclass; a monadic
	  <emphasis>value</emphasis> has a monadic type.</para>
      </listitem>

      <listitem>
	<para id="x_JX">When we say that a type <quote>is a monad</quote>, this
	  is really an shorthand way of saying that it's an instance
	  of the <code>Monad</code> typeclass.  Being an instance of
	  <code>Monad</code> gives us the necessary monadic triple of
	  type constructor, injection function, and chaining
	  function.</para>
      </listitem>

      <listitem>
	<para id="x_KX">In the same way, a reference to <quote>the
	    <type>Foo</type> monad</quote> implies that we're talking
	  about the type named <type>Foo</type>, and that it's an
	  instance of <code>Monad</code>.</para>
      </listitem>

      <listitem>
	<para id="x_LX">An <quote>action</quote> is another name for a monadic
	  value.  This use of the word probably originated with the
	  introduction of monads for I/O, where a monadic value like
	  <code>print "foo"</code> can have an observable side effect.
	  A function with a monadic return type might also be referred
	  to as an action, though this is a little less common.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="monads.logger">
    <title>Using a new monad: show your work!</title>

    <para id="x_MX">In our introduction to monads, we showed how some
      pre-existing code was already monadic in form.  Now that we are
      beginning to grasp what a monad is, and we've seen the
      <code>Monad</code> typeclass, let's build a monad with
      foreknowledge of what we're doing.  We'll start out by defining
      its interface, then we'll put it to use.  Once we have those out
      of the way, we'll finally build it.</para>

    <para id="x_NX">Pure Haskell code is wonderfully clean to write, but of
      course it can't perform I/O.  Sometimes, though, we'd like to
      have a record of decisions we took.  Let's develop a small
      library to help with this.</para>

    <para id="x_OX">Recall the <function>globToRegex</function> function that we
      developed in <xref linkend="glob.translate"/>.  We will
      modify it so that it keeps a record of each of the special
      pattern sequences that it translates.  We are revisiting
      familiar territory for a reason: it lets us compare non-monadic
      and monadic versions of the same code.</para>

    <para id="x_PX">To start off, we'll wrap our result type with a
      <code>Logger</code> type constructor.</para>

    &Logger.hs:globToRegex.type;

    <sect2>
      <title>Information hiding</title>

      <para id="x_QX">We'll intentionally keep the internals of the
	<type>Logger</type> module abstract.</para>

      &Logger.hs:module;

      <para id="x_RX">Hiding the details like this has two benefits: it grants
	us considerable flexibility in how we implement our monad, and
	more importantly, it gives users a simple interface.</para>

      <para id="x_SX">The <type>Logger</type> type is purely a
	<emphasis>type</emphasis> constructor.  We don't export the
	<emphasis>value</emphasis> constructor that a user would need
	to create a value of this type.  All they can can use
	<type>Logger</type> for is writing type signatures.</para>

      <para id="x_TX">The <type>Log</type> type is just a synonym for a list of
	strings, to make a few signatures more readable.  We're using
	a list of strings to keep the implementation simple.</para>

      &Logger.hs:Log;

      <para id="x_UX">Instead of giving our users a value constructor, we
	provide them with a function, <function>execLogger</function>,
	that evaluates a logged action.  This returns both the result
	of an action and whatever was logged while the result was
	being computed.</para>

      &Logger.hs:execLogger.type;

    </sect2>

    <sect2 id="monads.escape">
      <title>Controlled escape</title>

      <para id="x_VX">The <code>Monad</code> typeclass doesn't provide any means
	for values to escape their monadic shackles.  We can inject a
	value into a monad using &return;.  We can extract a value
	from a monad using &bind; but the function on the right that
	can see an unwrapped value has to wrap its own result back up
	again.</para>

      <para id="x_WX">Most monads have one or more
	<function>execLogger</function>-like functions.  The notable
	exception is of course <type>IO</type>, which we usually only
	escape from by exiting a program.</para>

      <para id="x_XX">A monad execution function runs the code inside the monad
	and unwraps its result.  Such a function are usually the only
	means provided for a value to escape from its monadic wrapper.
	The author of a monad thus has complete control over how
	whatever happens inside the monad gets out.</para>

      <para id="x_YX">Some monads have several execution functions.  In our
	case, we can imagine a few alternatives to
	<function>execLogger</function>: one might only return the log
	messages, while another might return just the result and drop
	the log messages.</para>
    </sect2>

    <sect2>
      <title>Leaving a trace</title>

      <para id="x_ZX">When executing inside a <type>Logger</type> action, user
	code calls <function>record</function> to record
	something.</para>

      &Logger.hs:record.type;

      <para id="x_aX">Again, most monads provide helper functions that add
	functionality on top of the base <code>Monad</code>
	typeclass.</para>

      <para id="x_bX">Our module also defines the <code>Monad</code> instance
	for the <type>Logger</type> type.  These definitions are all
	that a client module needs in order to be able to use this
	monad.</para>

      <para id="x_cX">We'll use &ghci; to produce a simple example of our monad
	in use.</para>

      &logger.ghci:simple;

      <para id="x_dX">When we run the logged action using
	<function>execLogger</function>, we get back a two-tuple.  The
	first element is the result, and the second is the list of
	items logged while the action executed.  We haven't logged
	anything, so the list is empty.  Let's fix that.</para>

      &logger.ghci:logged;

    </sect2>

    <sect2>
      <title>Using the Logger monad</title>

      <para id="x_eX">Here's how we kick off our glob-to-regexp conversion
	inside the <type>Logger</type> monad.</para>

      &Logger.hs:rooted;

      <para id="x_fX">Remember the type of &bind;: it extracts the value on the
	left from its <type>Logger</type> wrapper, and passes the
	unwrapped value to the function on the right.  The function on
	the right must, in turn, wrap <emphasis>its</emphasis> result
	with the <type>Logger</type> wrapper.  This is exactly what
	&return; does.</para>

      &logger.ghci:bind.type;

      <para id="x_gX">There are a few coding style issues worth mentioning here.
	The body of the function starts on the line after its name. By
	doing this, we gain some horizontal white space.  We've also
	<quote>hung</quote> the parameter of the anonymous function at
	the end of the line. This is common practice in monadic
	code.</para>

      <para id="x_hX">Even when we write a function that does almost nothing, we
	must call <function>return</function> to wrap the result with
	the correct type.</para>

      &Logger.hs:eof;

      <para id="x_iX">When we call <function>record</function> to save a log
	entry, we use &bind_; instead of &bind; to chain it with the
	following action.</para>

      &Logger.hs:question;

      <para id="x_jX">Recall that this is a variant of &bind; that ignores the
	result on the left.  We know that the result of
	<function>record</function> will always be <code>()</code>, so
	there's no point in capturing it.</para>

      <para id="x_kX">We can use &do; notation, which we first encountered in
	<xref linkend="io.bind"/>, to somewhat tidy up our
	code.</para>

      &Logger.hs:asterisk;

      <para id="x_lX">The choice of &do; notation versus explicit &bind; with
	anonymous functions is mostly a matter of taste. There is one
	significant difference between the two, though, which we'll
	return to in <xref linkend="monads.do"/>.</para>

      <para id="x_mX">Parsing a character class mostly follows the same pattern
	that we've already seen.</para>

      &Logger.hs:class;

      <para id="x_nX">The interesting exception is in the final clause above.
	Where we called <function>error</function> in
	<xref linkend="glob.translate"/>, we now call
	<function>fail</function> from the <code>Monad</code>
	typeclass instead.</para>
    </sect2>
  </sect1>

  <sect1 id="monads.liftM">
    <title>Mixing pure and monadic code</title>

    <para id="x_oX">Based on the code we've seen so far, monads seem to have a
      substantial shortcoming: the type constructor that wraps a
      monadic value makes it tricky to use a normal, pure function on
      a value trapped inside a monadic wrapper.  Here's a simple
      illustration of the apparent problem.  Let's say we have a
      trivial piece of code that runs in the <type>Logger</type> monad
      and returns a string.</para>

    &logger.ghci:m;

    <para id="x_pX">If we want to find out the length of that string, we can't
      simply call <function>length</function>: the string is wrapped,
      so the types don't match up.</para>

    &logger.ghci:m.length;

    <para id="x_qX">What we've done so far to work around this is something like
      the following.</para>

    &logger.ghci:m.length2;

    <para id="x_rX">We use &bind; to unwrap the string, then write a small
      anonymous function that calls <function>length</function> and
      rewraps the result using <function>return</function>.</para>

    <para id="x_sX">This need crops up so often in Haskell code that we won't be
      surprised to learn that a shorthand already exists.  We reuse
      the <emphasis>lifting</emphasis> technique that we introduced
      for functors in <xref linkend="binary.functor"/>.  Lifting a
      pure function into a functor usually involves unwrapping the
      value inside the functor, calling the function on it, and
      rewrapping the result with the same constructor.</para>

    <para id="x_tX">We do exactly the same thing with a monad.  Because the
      <code>Monad</code> typeclass already provides the &bind; and
      &return; functions that know how to wrap and unwrap a value, the
      <function>liftM</function> function doesn't need any details of
      a monad's implementation.</para>

    &Logger.hs:liftM;

    <para id="x_uX">When we declare a type to be an instance of the
      <code>Functor</code> typeclass, we have to write our own version
      of <function>fmap</function> specially tailored to that type. By
      contrast, <function>liftM</function> doesn't need to know
      anything of a monad's internals, because they're abstracted by
      &bind; and &return;.  We only need to write it once, with the
      appropriate type constraint.</para>

    <para id="x_vX">The <function>liftM</function> function is predefined for us
      in the standard <code>Control.Monad</code> module.</para>

    <para id="x_wX">To see how <function>liftM</function> can help readability,
      we'll compare two otherwise identical pieces of code. First, the
      familiar kind that does not use
      <function>liftM</function>.</para>

    &Logger.hs:charClass_wordy;

    <para id="x_xX">Now we can eliminate the &bind; and anonymous function cruft
      with <function>liftM</function>.</para>

    &Logger.hs:charClass;

    <para id="x_yX">As with <function>fmap</function>, we often use
      <function>liftM</function> in infix form.  An easy way to read
      such an expression is <quote>apply the pure function on the left
	to the result of the monadic action on the
	right</quote>.</para>

    <para id="x_zX">So useful is <function>liftM</function> that
      <code>Control.Monad</code> defines several variants that combine
      longer chains of actions.  We can see one in the last clause of
      our <function>globToRegex'</function> function.</para>

    &Logger.hs:last;

    <para id="x_AY">The <function>liftM2</function> function that it uses is
      defined as follows.</para>

    &Logger.hs:liftM2;

    <para id="x_BY">It executes the first action, then the second, then combines
      their results using the pure function <varname>f</varname>, and
      wraps that result.  In addition to <function>liftM2</function>,
      the variants in <code>Control.Monad</code> go up to
      <function>liftM5</function>.</para>
  </sect1>

  <sect1>
    <title>Putting a few misconceptions to rest</title>

    <para id="x_CY">We've now seen enough examples of monads in action to have
      some feel for what's going on.  Before we continue, there are a
      few oft-repeated myths about monads that we're going to address.
      You're bound to encounter these assertions <quote>in the
	wild</quote>, so you might as well be prepared with a few good
      retorts.</para>

    <itemizedlist>
      <listitem>
	<para id="x_DY"><emphasis>Monads are hard to understand.</emphasis>
	  We've already shown that monads <quote>fall out
	    naturally</quote> from several problems.  We've found that
	  the best key to understanding them is to explain several
	  concrete examples, then talk about what they have in
	  common.</para>
      </listitem>

      <listitem>
	<para id="x_EY"><emphasis>Monads are only useful for I/O and imperative
	    coding.</emphasis> While we use monads for I/O in Haskell,
	  they're valuable for many other purposes besides.  We've
	  already used them for short-circuiting a chain of
	  computations, hiding complicated state, and logging.  Even
	  so, we've barely scratched the surface.</para>
      </listitem>

      <listitem>
	<para id="x_FY"><emphasis>Monads are unique to Haskell.</emphasis>
	  Haskell is probably the language that makes the most
	  explicit use of monads, but people write them in other
	  languages, too, ranging from C++ to OCaml.</para>
      </listitem>

      <listitem>
	<para id="x_GY"><emphasis>Monads are for controlling the order of
	    evaluation.</emphasis></para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>Building the Logger monad</title>
    
    <para id="x_HY">The definition of our <type>Logger</type> type is very
      simple.</para>

    &Logger.hs:Logger;

    <para id="x_IY">It's a two-tuple, where the first element is the result of
      an action, and the second is a list of messages logged while
      that action was run.</para>

    <para id="x_JY">We've wrapped the tuple in a &newtype; to make it a distinct
      type.  The <function>runLogger</function> function extracts the
      tuple from its wrapper.  The function that we're exporting to
      execute a logged action, <function>execLogger</function>, is
      just a synonym for <function>runLogger</function>.</para>

    &Logger.hs:execLogger;

    <para id="x_KY">Our <function>record</function> helper function creates a
      singleton list of the message we pass it.  The result of this
      action is <code>()</code>, so that's the value we put in the
      result slot.</para>

    <para id="x_LY">Let's begin our <code>Monad</code> instance with &return;,
      which is trivial: it logs nothing, and stores its input in the
      return slot of the tuple.</para>

    &Logger.hs:return;

    <para id="x_MY">Slightly more interesting is &bind;, which is the heart of
      the monad.  It combines an action and a monadic function to give
      a new result and a new log.</para>

    &Logger.hs:bind;

    <para id="x_NY">Let's spell out explicitly what is going on. We use
      <function>runLogger</function> to extract the result
      <varname>a</varname> from the action <varname>m</varname>, and
      we pass it to the monadic function <varname>k</varname>.  We
      extract the result <varname>b</varname> from that in turn, and
      put it into the result slot of the final action.  We concatenate
      the logs <varname>w</varname> and <varname>x</varname> to give
      the new log.</para>

    <sect2>
      <title>Sequential logging, not sequential evaluation</title>

      <para id="x_OY">Our definition of &bind; ensures that messages logged on
	the left will appear in the new log before those on the right.
	However, it says nothing about when the values
	<varname>a</varname> and <varname>b</varname> are evaluated:
	&bind; is lazy.</para>

      <para id="x_PY">Like most other aspects of a monad's behaviour, strictness
	is under the control of the monad's implementor.  It's not a
	constant that's shared by all monads.  Indeed, some monads
	come in multiple flavours, each with different levels of
	strictness.</para>
    </sect2>

    <sect2>
      <title>The writer monad</title>

      <para id="x_vq">Our <type>Logger</type> monad is a specialised version of
	the standard <type>Writer</type> monad, which can be found in
	the <type>Control.Monad.Writer</type> module of the
	<code>mtl</code> package.  We will present a
	<type>Writer</type> example in <xref
	  linkend="monadcase.io.class"/>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>The Maybe monad</title>

    <para id="x_QY">The <type>Maybe</type> type is very nearly the simplest
      instance of <code>Monad</code>.  It represents a computation
      that might not produce a result.</para>

    &Maybe.hs:instance;

    <para id="x_RY">When we chain together a number of computations over
      <type>Maybe</type> using &bind; or &bind_;, and any returns
      <code>Nothing</code>, then we don't evaluate any of the
      remaining computations.</para>

    <para id="x_SY">Note, though, that the chain is not completely
      short-circuited.  Each &bind; or &bind_; in the chain will still
      match a <code>Nothing</code> on its left, and produce a
      <function>Nothing</function> on its right, all the way to the
      end.  It's easy to forget this point: when a computation in the
      chain fails, the subsequent production, chaining, and
      consumption of <code>Nothing</code> values is cheap at runtime,
      but it's not free.</para>

    <sect2>
      <title>Executing the Maybe monad</title>

      <para id="x_TY">A function suitable for executing the <type>Maybe</type>
	monad is <function>maybe</function>.  (Remember that
	<quote>executing</quote> a monad involves evaluating it and
	returning a result that's had the monad's type wrapper
	removed.)</para>

      &Maybe.hs:maybe;

      <para id="x_UY">Its first parameter is the value to return if the result
	is <code>Nothing</code>.  The second is a function to call on
	a result wrapped in the <code>Just</code> constructor; the
	result of that application is then returned.</para>

      <para id="x_VY">Since the <type>Maybe</type> ADT is so simple, it's about
	as common to simply pattern-match on a <type>Maybe</type>
	value as it is to call <function>maybe</function>.  Each one
	is more readable in different circumstances.</para>
    </sect2>

    <sect2>
      <title>Maybe at work, and good API design</title>

      <para id="x_WY">Here's an example of <type>Maybe</type> in use as a monad.
	Given a customer's name, we want to find the billing address
	of their mobile phone carrier.</para>

      &Carrier.hs:findCarrierBillingAddress;

      <para id="x_XY">Our first version is the dreaded ladder of code marching
	off the right of the screen, with many boilerplate &case;
	expressions.</para>

      &Carrier.hs:variation1;

      <para id="x_YY">The <code>Data.Map</code> module's
	<function>lookup</function> function has a monadic return
	type.</para>

      &carrier.ghci:lookup;

      <para id="x_ZY">In other words, if the given key is present in the map,
	<function>lookup</function> injects it into the monad using
	&return;.  Otherwise, it calls &fail;.  This is a lovely piece
	of API design!  The behaviours of success and failure are
	automatically customised to our needs, based on the monad
	we're calling <function>lookup</function> from.  Better yet,
	<function>lookup</function> itself doesn't know or care what
	those behaviours are.</para>

      <para id="x_aY">The &case; expressions above typecheck because we're
	comparing the result of <function>lookup</function> against
	values of type <type>Maybe</type>.  But the code is horrible;
	let's make more sensible use of <type>Maybe</type>'s status as
	a monad.</para>

      &Carrier.hs:variation2;

      <para id="x_bY">If any of these lookups fails, the definitions of &bind;
	and &bind_; mean that the result of the function as a whole
	will be <code>Nothing</code>, just as it was for our first
	attempt that used &case; explicitly.</para>

      <para id="x_cY">This version is much tidier.  That being said, the
	&return; isn't necessary.  Stylistically, it makes the code
	look more regular, and perhaps more familiar to the eyes of an
	imperative programmer, but behaviourally it's redundant.
	Here's an equivalent piece of code.</para>

      &Carrier.hs:variation2a;

      <para id="x_dY">When we introduced maps, we mentioned in <xref
	linkend="barcode.map.partial"/> that the type signatures of
	functions in the <code>Data.Map</code> module often make them
	awkward to partially apply.  The <function>lookup</function>
	function is a good example.  If we <function>flip</function>
	its arguments, we can write the function body as a
	one-liner.</para>
	  
      &Carrier.hs:variation3;

    </sect2>
  </sect1>

  <sect1>
    <title>The list monad</title>

    <para id="x_eY">While the <code>Maybe</code> type can represent either no
      value or one one, there are many situations where we might want
      to return more than one result.  Obviously, a list is well
      suited to this purpose. The type of a list suggests that we
      might be able to use it as a monad, because its type constructor
      has one free variable.  And sure enough, we can use a list as a
      monad.</para>

    <para id="x_fY">Rather than simply present the Prelude's <code>Monad</code>
      instance for the list type, let's try to figure out what the
      instance <emphasis>ought</emphasis> to look like.  This is easy
      to do: we'll look at the types of &bind; and &return;, and
      perform some substitutions, and see if we can use a few familiar
      list functions.</para>

    <para id="x_gY">The more obvious of the two functions is &return;.  We know
      that it takes a type <varname role="type">a</varname>, and wraps
      it in a type constructor <varname role="type">m</varname> to
      give the type <varname role="type">m a</varname>.  We also know
      that the type constructor here is <type>[]</type>.  Substituting
      this type constructor for the type variable <varname
	role="type">m</varname> gives us the type <type>[] a</type>
      (yes, this really is valid notation!), which we can rewrite in
      more familiar form as <type>[a]</type>.</para>

    <para id="x_hY">We now know that &return; for lists should have the type
      <code>a &larrow; [a]</code>.  There are only a few sensible
      possibilities for an implementation of this function.  It might
      return the empty list, a singleton list, or an infinite list.
      The most appealing behaviour, based on what we know so far about
      monads, is the singleton list: it doesn't throw information
      away, nor does it repeat it infinitely.</para>

    &ListMonad.hs:returnSingleton;

    <para id="x_iY">If we perform the same substitution trick on the type of
      &bind; as we did with &return;, we discover that it should have
      the type <code>[a] &rarrow; (a &rarrow; [b]) &rarrow;
      [b]</code>.  This seems close to the type of
      <function>map</function>.</para>

    &listmonad.ghci:map;

    <para id="x_jY">The ordering of the types in <function>map</function>'s
      arguments doesn't match, but that's easy to fix.</para>

    &listmonad.ghci:flipMap;

    <para id="x_kY">We've still got a problem: the second argument of <code>flip
	map</code> has the type <code>a &rarrow; b</code>, whereas the
      second argument of &bind; for lists has the type <code>a
      &rarrow; [b]</code>.  What do we do about this?</para>

    <para id="x_lY">Let's do a little more substitution and see what happens
      with the types.  The function <code>flip map</code> can return
      any type <varname role="type">b</varname> as its result.  If we
      substitute <varname role="type">[b]</varname> for <varname
	role="type">b</varname> in both places where it appears in
      <code>flip map</code>'s type signature, its type signature reads
      as <code>a &rarrow; (a &rarrow; [b]) &rarrow; [[b]]</code>.  In
      other words, if we map a function that returns a list over a
      list, we get a list of lists back.</para>

    &listmonad.ghci:flipMapApp;

    <para id="x_mY">Interestingly, we haven't really changed how closely our
      type signatures match.  The type of &bind; is <code>[a] &rarrow;
      (a &rarrow; [b]) &rarrow; [b]</code>, while that of <code>flip
	map</code> when the mapped function returns a list is
      <code>[a] &rarrow; (a &rarrow; [b]) &rarrow; [[b]]</code>.
      There's still a mismatch in one type term; we've just moved that
      term from the middle of the type signature to the end.  However,
      our juggling wasn't in vain: we now need a function that takes a
      <type>[[b]]</type> and returns a <type>[b]</type>, and one
      readily suggests itself in the form of
      <function>concat</function>.</para>

    &listmonad.ghci:concat;

    <para id="x_nY">The types suggest that we should flip the arguments to
      <function>map</function>, then <function>concat</function> the
      results to give a single list.</para>

    &listmonad.ghci:bind;

    <para id="x_oY">This is exactly the definition of &bind; for lists.</para>

    &ListMonad.hs:instance;

    <para id="x_pY">It applies <varname>f</varname> to every element in the list
      <varname>xs</varname>, and concatenates the results to return a
      single list.</para>

    <para id="x_qY">With our two core <code>Monad</code> definitions in hand,
      the implementations of the non-core definitions that remain,
      &bind_; and &fail;, ought to be obvious.</para>

    &ListMonad.hs:rest;

    <sect2>
      <title>Understanding the list monad</title>

      <para id="x_rY">The list monad is similar to a familiar Haskell tool, the
	list comprehension.  We can illustrate this similarity by
	computing the Cartesian product of two lists.  First, we'll
	write a list comprehension.</para>

      &CartesianProduct.hs:comprehensive;

      <para id="x_sY">For once, we'll use explicit notation for the monadic code
	instead of block notation.  This will highlight how
	structurally similar the monadic code is to the list
	comprehension.</para>

      &CartesianProduct.hs:monadic;

      <para id="x_tY">The only real difference is that the value we're
	constructing comes at the end of the sequence of expressions,
	instead of the beginning as in the list comprehension. Also,
	the results of the two functions are identical.</para>
      
      &cartesian.ghci:comparison;

      <para id="x_uY">It's easy to be baffled by the list monad early on, so
	let's walk through our monadic Cartesian product code again in
	more detail.  This time, we'll rearrange the function to use
	layout instead of explicit notation.</para>

      &CartesianProduct.hs:blockyDo;
      
      <para id="x_vY">For every element in the list <varname>xs</varname>, the
	rest of the function is evaluated once, with
	<varname>x</varname> bound to a different value from the list
	each time.  Then for every element in the list
	<varname>ys</varname>, the remainder of the function is
	evaluated once, with <varname>y</varname> bound to a different
	value from the list each time.</para>

      <para id="x_wY">What we really have here is a doubly nested loop!  This
	highlights an important fact about monads: you
	<emphasis>cannot</emphasis> predict how a block of monadic
	code will behave unless you know what monad it will execute
	in.</para>

      <para id="x_xY">We'll now walk through the code even more explicitly, but
	first let's get rid of the &do; notation, to make the
	underlying structure clearer.  We've indented the code a
	little unusually to make the loop nesting more obvious.</para>

      &CartesianProduct.hs:blockyPlain;

      <para id="x_yY">If <varname>xs</varname> has the value
	<code>[1,2,3]</code>, the two lines that follow are evaluated
	with <varname>x</varname> bound to <code>1</code>, then to
	<code>2</code>, and finally to <varname>3</varname>. If
	<varname>ys</varname> has the value <code>[True,
	  False]</code>, the final line is evaluated
	<emphasis>six</emphasis> times: once with <varname>x</varname>
	as <code>1</code> and <varname>y</varname> as
	<code>True</code>; again with <varname>x</varname> as
	<code>1</code> and <varname>y</varname> as <code>False</code>;
	and so on.  The &return; expression wraps each tuple in a
	single-element list.</para>
    </sect2>

    <sect2>
      <title>Putting the list monad to work</title>

      <remark>XXX I think I need a shortish, compelling example here,
	and I don't have any in mind.  Help!</remark>
    </sect2>
  </sect1>

  <sect1 id="monads.do">
    <title>Desugaring of do blocks</title>

    <para id="x_zY">Haskell's &do; syntax is an example of <emphasis>syntactic
	sugar</emphasis>: it provides an alternative way of writing
      monadic code, without using &bind; and anonymous functions.
      <emphasis>Desugaring</emphasis> is the translation of syntactic
      sugar back to the core language.</para>

    <para id="x_AZ">The rules for desugaring a &do; block are easy to follow. We
      can think of a compiler as applying these rules mechanically and
      repeatedly to a &do; block until no more &do; keywords
      remain.</para>

    <para id="x_BZ">A &do; keyword followed by a single action is translated to
      that action by itself.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation1;</entry>
	    <entry>&Do.hs:translated1;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para id="x_CZ">A &do; keyword followed by more than one action is
      translated to the first action, then &bind_;, followed by a &do;
      keyword and the remaining actions.  When we apply this rule
      repeatedly, the entire &do; block ends up chained together by
      applications of &bind_;.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation2;</entry>
	    <entry>&Do.hs:translated2;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para id="x_DZ">The &larrow; notation has a translation that's worth paying
      close attention to.  On the left of the &larrow; is a normal
      Haskell pattern. This can be a single variable or something more
      complicated.  A guard expression is not allowed.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation3;</entry>
	    <entry>&Do.hs:translated3;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para id="x_EZ">This pattern is translated into a &let; binding that
      declares a local function with a unique name (we're just using
      <varname>f</varname> as an example above).  The action on the
      right of the &larrow; is then chained with this function using
      &bind;.</para>

    <para id="x_FZ">What's noteworthy about this translation is that if the
      pattern match fails, the local function calls the monad's &fail;
      implementation. Here's an example using the <type>Maybe</type>
      monad.</para>

    &Do.hs:robust;

    <para id="x_GZ">The &fail; implementation in the <type>Maybe</type> monad
      simply returns <code>Nothing</code>.  If the pattern match in
      the above function fails, we thus get <code>Nothing</code> as
      our result.</para>

    &do.ghci:robust;

    <para id="x_HZ">Finally, when we write a &let; expression in a &do; block,
      we can omit the usual &in; keyword.  Subsequent actions in the
      block must be lined up with the &let; keyword.</para>

    <informaltable role="comparison">
      <tgroup cols="2">
	<tbody>
	  <row>
	    <entry>&Do.hs:doNotation4;</entry>
	    <entry>&Do.hs:translated4;</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2>
      <title>Monads as a programmable semicolon</title>

      <para id="x_IZ">Back in <xref linkend="deftypes.block"/>, we
	mentioned that layout is the norm in Haskell, but it's not
	<emphasis>required</emphasis>.  We can write a &do; block
	using explicit structure instead of layout.</para>

      <informaltable role="comparison">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>&Do.hs:semicolon;</entry>
	      <entry>&Do.hs:semicolonTranslated;</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para id="x_JZ">Even though this use of explicit structure is rare, the
	fact that it uses semicolons to separate expressions has given
	rise to an apt slogan: monads are a kind of
	<quote>programmable semicolon</quote>, because the behaviours
	of &bind_; and &bind; are different in each monad.</para>
    </sect2>

    <sect2 id="monads.do.avoid">
      <title>Why go sugar-free?</title>

      <para id="x_KZ">When we write &bind; explicitly in our code, it reminds us
	that we're calling stitching functions together using
	combinators, not simply sequencing actions.</para>

      <para id="x_LZ">As long as you feel like a novice with monads, we think
	you should prefer to explicitly write &bind; over the
	syntactic sugar of &do; notation.  The repeated reinforcement
	of what's really happening seems, for many programmers, to
	help to keep things clear. (It can be easy for an imperative
	programmer to relax a little too much from exposure to the
	<type>IO</type> monad, and assume that a &do; block means
	nothing more than a simple sequence of actions.)</para>

      <para id="x_MZ">Once you're feeling more familiar with monads, you can
	choose whichever style seems more appropriate for writing a
	particular function.  Indeed, when you read other people's
	monadic code, you'll see that it's unusual, but by no means
	rare, to mix <emphasis>both</emphasis> &do; notation and
	&bind; in a single function.</para>
    </sect2>
  </sect1>

  <sect1 id="monads.state">
    <title>The state monad</title>

    <para id="x_NZ">We discovered earlier in this chapter that the
      <type>Parse</type> from <xref
	linkend="binary"/> was a monad.  It has two logically
      distinct aspects.  One is the idea of a parse failing, and
      providing a message with the details: we represented this using
      the <type>Either</type> type.  The other involves carrying
      around a piece of implicit state, in our case the partially
      consumed <type>ByteString</type>.</para>

    <para id="x_OZ">This need for a way to read and write state is
      common enough in Haskell programs that the standard libraries
      provide a monad named <type>State</type> that is dedicated to
      this purpose. This monad lives in the
      <code>Control.Monad.State</code> module.</para>

    <para id="x_PZ">Where our <type>Parse</type> type carried around a
      <type>ByteString</type> as its piece of state, the
      <type>State</type> monad can carry any type of state.  We'll
      refer to the state's unknown type as <varname
	role="type">s</varname>.</para>

    <para id="x_QZ">What's an obvious and general thing we might want
      to do with a state?  Given a state value, we inspect it, then
      produce a result and a new state value.  Let's say the result
      can be of any type <varname role="type">a</varname>.  A type
      signature that captures this idea is <type>s -&gt; (a,
	s)</type>: take a state <varname role="type">s</varname>, and
      return a result <varname role="type">a</varname> and a new state
      <varname role="type">s</varname>.</para>

    <sect2>
      <title>Almost a state monad</title>

      <para id="x_RZ">Let's develop some simple code that's
	<emphasis>almost</emphasis> the <type>State</type> monad, then
	we'll take a look at the real thing.  We'll start with our
	type definition, which has exactly the obvious type we
	described above.</para>

      &SimpleState.hs:SimpleState;

      <para id="x_SZ">Yes, this is a type synonym, not a new type, and
	so we're cheating a little.  Bear with us for now; this
	simplifies the description that follows.</para>

      <para id="x_TZ">Earlier in this chapter, we said that a monad
	has a type constructor with a single type variable, and yet
	here we have a type with two variables.  The key here is to
	understand that we can partially apply a
	<emphasis>type</emphasis> just as we can partially apply a
	normal function.  This is easiest to follow with an
	example.</para>

      &SimpleState.hs:StringState;

      <para id="x_UZ">Here, we've bound the type variable <varname
	  role="type">s</varname> to <type>String</type>. The type
	<type>StringState</type> still has an unbound type variable
	<varname role="type">a</varname>, though.  It's now more
	obvious that we have a suitable type constructor for a monad.
	In other words, our monad's type constructor is
	<type>SimpleState s</type>, not <type>SimpleState</type>
	alone.</para>

      <para id="x_VZ">The next ingredient we need to make a monad is a
	definition for the &return; function.</para>

      &SimpleState.hs:returnSt;

      <para id="x_WZ">All this does is take the result and the current
	state, and <quote>tuple them up</quote>.  You may by now be
	used to the idea that a Haskell function with multiple
	parameters is just a chain of single-parameter functions, but
	just in case you're not, here's a more familiar way of writing
	<function>returnSt</function> that makes it more obvious how
	simple this function is.</para>

      &SimpleState.hs:returnAlt;

      <para id="x_XZ">Our final piece of the monadic puzzle is a
	definition for &bind;.  Here it is, using the actual variable
	names from the standard library's definition of &bind; for
	<type>State</type>.</para>

      &SimpleState.hs:bindSt;

      <para id="x_YZ">Those single-letter variable names aren't
	exactly a boon to readability, so let's see if we can
	substitute some more meaningful names.</para>

      &SimpleState.hs:bindAlt;

      <para id="x_ZZ">To understand this definition, remember that
	<varname>step</varname> is a function with the type <type>s
	  -&gt; (a, s)</type>.  When we evaluate this, we get a tuple,
	and we have to use this to return a new function of type
	<type>s -&gt; (a, s)</type>.  This is perhaps easier to follow
	if we get rid of the <type>SimpleState</type> type synonyms
	from <function>bindAlt</function>'s type signature, and
	examine the types of its parameters and result.</para>

      &SimpleState.hs:bindAlt.type;

    </sect2>
    
    <sect2>
      <title>Reading and modifying the state</title>

      <para id="x_aZ">The definitions of &bind; and &return; for the
	state monad simply act as plumbing: they move a piece of state
	around, but they don't touch it in any way.  We need a few
	other simple functions to actually do useful work with the
	state.</para>

      &SimpleState.hs:getPut;

      <para id="x_bZ">The <function>getSt</function> function simply
	takes the current state and returns it as the result, while
	<function>putSt</function> ignores the current state and
	replaces it with a new state.</para>
    </sect2>
      
    <sect2>
      <title>Will the real state monad please stand up?</title>

      <para id="x_cZ">The only simplifying trick we played in the
	previous section was to use a type synonym instead of a type
	definition for <type>SimpleState</type>.  In order to define a
	<code>Monad</code> instance, we have to provide a proper type
	constructor as well as definitions for &bind; and &return;.
	This leads us to the <emphasis>real</emphasis> definition of
	<type>State</type>.</para>

      &State.hs:State;

      <para id="x_dZ">All we've done is wrap our <type>s -&gt; (a,
	  s)</type> type in a <code>State</code> constructor.  By
	using Haskell's record syntax to define the type, we're
	automatically given a <function>runState</function> function
	that will unwrap a <type>State</type> value from its
	constructor.  The type of <function>runState</function> is
	<type>State s a -&gt; s -&gt; (a, s)</type>.</para>

      <para id="x_eZ">The definition of &return; is almost the same as
	for <type>SimpleState</type>, except we wrap our function with
	a <code>State</code> constructor.</para>

      &State.hs:returnState;

      <para id="x_fZ">The definition of &bind; is a little more
	complicated, because it has to use
	<function>runState</function> to remove the <code>State</code>
	wrappers.</para>

      &State.hs:bindState;

      <para id="x_gZ">This function differs from our earlier
	<function>bindSt</function> only in adding the wrapping and
	unwrapping of a few values.  By separating the <quote>real
	  work</quote> from the bookkeeping, we've hopefully made it
	clearer what's really happening.</para>

      <para id="x_hZ">We modify the functions for reading and
	modifying the state in the same way, by adding a little
	wrapping.</para>

      &State.hs:getPut;

    </sect2>

    <sect2 id="monads.state.random">
      <title>Using the state monad: generating random values</title>

      <para id="x_iZ">We've already used <type>Parse</type>, our
	precursor to the state monad, to parse binary data.  If we'd
	been using the state monad directly, we would have used a
	<type>ByteString</type> as the state.</para>

      <para id="x_jZ">The State monad will probably feel much familiar
	to you than many other monads if you have a background in
	imperative languages.  After all, imperative languages are all
	about carrying around some implicit state, reading some parts,
	and modifying others through assignment, and this is just what
	the state monad is for.</para>

      <para id="x_kZ">So instead of unnecessarily cheerleading for the
	idea of using the state monad, we'll begin by demonstrating
	how to use it for something simple: pseudorandom value
	generation.  In an imperative language, there's usually an
	easily available source of uniform pseudorandom numbers.  For
	example, in C, there's a standard <function>rand</function>
	function that generates a pseudorandom number, using a global
	state that it updates.</para>

      <para id="x_lZ">Haskell's standard random generation module is
	named <code>System.Random</code>.  It allows the generation of
	random values of any type, not just numbers.  The module
	contains several handy functions that live in the
	<type>IO</type> monad.  For example, a rough equivalent of C's
	<function>rand</function> function would be the
	following:</para>

      &Random.hs:rand;

      <para id="x_mZ">(The <function>randomR</function> function takes
	an inclusive range within which the generated random value
	should lie.)</para>

      <para id="x_nZ">The <code>System.Random</code> module provides a
	typeclass, <code>RandomGen</code>, that lets us define new
	sources of random values.  The type <type>StdGen</type> is the
	standard <code>RandomGen</code> instance, and generated
	pseudorandom values.  If we had an external source of truly
	random data, we could make it an instance of
	<code>RandomGen</code> and get truly random, instead of merely
	pseudorandom, values.</para>

      <para id="x_oZ">Another typeclass, <code>Random</code>,
	indicates how to generate random values of a particular type.
	The module defines <code>Random</code> instances for all of
	the usual simple types.</para>

      <para id="x_pZ">Incidentally, the definition of
	<function>rand</function> above reads and modifies a built-in
	global random generator that inhabits the <type>IO</type>
	monad.</para>

    </sect2>

    <sect2>
      <title>A first attempt at purity</title>

      <para id="x_qZ">After all of our emphasis so far on avoiding the
	<type>IO</type> monad wherever possible, it would be a shame
	if we were dragged back into it just to generate some random
	values.  Indeed, <code>System.Random</code> contains pure
	random number generation functions.</para>

      <para id="x_rZ">The traditional downside of purity is that we
	have to get or create a random number generator, then ship it
	from the point we created it to the place where it's needed.
	When we finally call it, it returns a <emphasis>new</emphasis>
	random number generator: we're in pure code, remember, so we
	can't modify the state of the existing generator.</para>

      <para id="x_sZ">If we forget about immutability and reuse the
	same generator within a function, we get back exactly the same
	<quote>random</quote> number every time.</para>

      &Random.hs:twoBadRandoms;

      <para id="x_tZ">Needless to say, this has nasty
	consequences.</para>

      &random.ghci:twoBadRandoms;

      <para id="x_uZ">(The <function>random</function> function uses
	an implicit range instead of the user-supplied range used by
	<function>randomR</function>.  The
	<function>getStdGen</function> function retrieves the current
	value of the global standard number generator from the
	<type>IO</type> monad.)</para>

      <para id="x_vZ">Unfortunately, correctly passing around and
	using successive versions of the generator does not make for
	palatable reading.  Here's a simple example.</para>

      &Random.hs:twoGoodRandoms;

      <para id="x_wZ">Now that we know about the state monad, though,
	it looks like a fine candidate to hide the generator.</para>
    </sect2>

    <sect2>
      <title>Random values in the state monad</title>

      <para id="x_xZ">Here's a state monad that carries around a
	<type>StdGen</type> as its piece of state.</para>

      &Random.hs:RandomState;

      <para id="x_yZ">The type synonym is of course not necessary, but
	it's handy. It saves a little keyboarding, and if we wanted to
	swap another random generator for <type>StdGen</type>, it
	would reduce the number of type signatures we'd need to
	change.</para>

      <para id="x_zZ">Generating a random value is now a matter of
	fetching the current generator, using it, then modifying the
	state to replace it with the new generator.</para>

      &Random.hs:getRandom;

      <para id="x_Aa">We can now use some of the monadic machinery
	that we saw earlier to write a much more concise function for
	giving us a pair of random numbers.</para>

      &Random.hs:getTwoRandoms;

      <sect3>
	<title>Exercises</title>

	<qandaset defaultlabel="number">
	  <qandaentry>
	    <question>
	      <para id="x_Ba">Rewrite <function>getRandom</function>
		to use &do; notation.</para>
	    </question>
	  </qandaentry>
	</qandaset>

      </sect3>
    </sect2>

    <sect2>
      <title>Running the state monad</title>

      <para id="x_Ca">As we've already mentioned, each monad has its
	own specialised evaluation functions.  In the case of the
	state monad, we have several to choose from.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_Da"><function>runState</function> returns both
	    the result and the final state.</para>
	</listitem>
	<listitem>
	  <para id="x_Ea"><function>evalState</function> returns only
	    the result, throwing away the final state.</para>
	</listitem>
	<listitem>
	  <para id="x_Fa"><function>execState</function> throws the
	    result away, returning only the final state.</para>
	</listitem>
      </itemizedlist>

      <para id="x_Ga">The <function>evalState</function> and
	<function>execState</function> functions are simply
	compositions of <function>fst</function> and
	<function>snd</function> with <function>runState</function>,
	respectively. Thus, of the three,
	<function>runState</function> is the one most worth
	remembering.</para>

      <para id="x_Th">Here's a complete example of how to run our
	<function>getTwoRandoms</function> function.</para>

      &Random.hs:runTwoRandoms;

      <para id="x_Uh">The call to <function>runState</function> follows a
	standard pattern: we pass it a function in the state monad and
	an initial state.  It returns the result of the function and
	the final state.</para>

      <para id="x_Vh">The code surrounding the call to
	<function>runState</function> merely obtains the current
	global <type>StdGen</type> value, then replaces it afterwards
	so that subsequent calls to <function>runTwoRandoms</function>
	or other random generation functions will pick up the updated
	state.</para>
    </sect2>

    <sect2>
      <title>What about a bit more state?</title>

      <para id="x_Wh">It's a little hard to imagine writing much interesting
	code in which there's only a single state value to pass
	around.  When we want to track multiple pieces of state at
	once, the usual trick is to maintain them in a data type.
	Here's an example: keeping track of the number of random
	numbers we are handing out.</para>

      &Random.hs:CountedRandom;

      <para id="x_Xh">This example happens to consume both elements of the
	state, and construct a completely new state, every time we
	call into it.  More frequently, we're likely to read or modify
	only part of a state.  This function gets the number of random
	values generated so far.</para>

      &Random.hs:getCount;

      <para id="x_Yh">We deliberately used record syntax to define our
	<type>CountedRandom</type> state, and this example should make
	it clear why.  It gives us accessor functions that we can glue
	together with <function>get</function> to read specific pieces
	of the state.</para>

      <para id="x_Zh">If we want to partially update a state, the code doesn't
	come out quite so appealingly.</para>

      &Random.hs:putCount;

      <para id="x_ah">Here, instead of a function, we're using record update
	syntax.  The expression <code>st { crCount = a }</code>
	creates a new value that's an identical copy of
	<varname>st</varname>, except in its <code>crCount</code>
	field, which is given the value <varname>a</varname>. Because
	this is a syntactic hack, we don't get the same kind of
	flexibility as with a function.  Record syntax may not exhibit
	Haskell's usual elegance, but it at least gets the job
	done.</para>

      <para id="x_bh">There exists a function named <function>modify</function>
	that combines the <function>get</function> and
	<function>put</function> steps. It takes as argument a state
	transformation function, but it's hardly more satisfactory: we
	still can't escape from the clumsiness of record update
	syntax.</para>

      &Random.hs:putCountModify;
    </sect2>
  </sect1>

  <sect1>
    <title>Monads and functors</title>

    <para id="x_Ha">Functors and monads are closely related.  The
      terms are borrowed from a branch of mathematics called category
      theory, but they did not make the transition completely
      unscathed.</para>

    <para id="x_ch">In category theory, a monad is built from a functor.  You
      might expect that in Haskell, the <code>Monad</code> typeclass
      would thus be a subclass of <code>Functor</code>, but it isn't
      defined as such in the standard Prelude.  This is an unfortunate
      oversight</para>

    <para id="x_dh">However, authors of Haskell libraries use a workaround: when
      someone defines an instance of <code>Monad</code> for a type,
      they almost always write a <code>Functor</code> instance for it,
      too.  You can fairly reliably take it for granted that you'll be
      able to use the <code>Functor</code> typeclass's
      <function>fmap</function> function with any monad.</para>

    <para id="x_eh">If we compare the type signature of
      <function>fmap</function> with those of some of the standard
      monad functions that we've already seen, and we get a hint as to
      what <function>fmap</function> on a monad does.</para>

    &monadness.ghci:fmap;

    <para id="x_fh">Sure enough, <function>fmap</function> lifts a pure function
      into the monad, just as <function>liftM</function> does.</para>

    <sect2 id="monads.join">
      <title>Another way of looking at monads</title>

      <para id="x_gh">Now that we know about the relationship between functors
	and monads, If we take a look back at the list monad, we can
	see something interesting.  Specifically, take a look at the
	definition of &bind; for lists.</para>

      &ListMonad.hs:instance.noid;

      <para id="x_hh">Recall that <varname>f</varname> has type <type>a -&gt;
	  [a]</type>.  When we call <code>map f xs</code>, we get back
	a value of type <type>[[a]]</type>, which we have to
	<quote>flatten</quote> using <code>concat</code>.</para>

      <para id="x_ih">Consider what we could do if <code>Monad</code> was a
	subclass of <function>Functor</function>.  Since
	<function>fmap</function> for lists is defined to be
	<function>map</function>, we could replace
	<function>map</function> with <function>fmap</function> in the
	definition of &bind;.  This is not very interesting by itself,
	but suppose we could go further.</para>

      <para id="x_jh">The <function>concat</function> function is of type
	<type>[[a]] -&gt; [a]</type>: as we mentioned, it flattens the
	nesting of lists.  We could generalise this type signature
	from lists to monads, giving us the <quote>remove a level of
	  nesting</quote> type <type>m (m a) -&gt; m a</type>.  The
	function that has this type is conventionally named
	<function>join</function>.</para>

      <para id="x_kh">If we had definitions of <function>join</function> and
	<function>fmap</function>, we wouldn't need to write a
	definition of &bind; for every monad, because it would be
	completely generic.  Here's what an alternative definition of
	the <code>Monad</code> typeclass might look like, along with a
	definition of &bind;.</para>

      &AltMonad.hs:AltMonad;

      <para id="x_lh">Neither definition of a monad is <quote>better</quote>,
	since if we have <function>join</function> we can write
	&bind;, and vice versa, but the different perspectives can be
	refreshing.</para>

      <para id="x_mh">Removing a layer of monadic wrapping can, in fact, be
	useful in realistic circumstances.  We can find a generic
	definition of <function>join</function> in the
	<code>Control.Monad</code> module.</para>

      &MonadJoin.hs:join;

      <para id="x_nh">Here are some examples of what it does.</para>

      &monadjoin.ghci:examples;
    </sect2>
  </sect1>

  <sect1>
    <title>The monad laws, and good coding style</title>

    <para id="x_oh">In <xref linkend="binary.functor.laws"/>, we introduced
      two rules for how functors should always behave.</para>

    &MonadLaws.hs:functor;
    
    <para id="x_ph">Not surprisingly, there are also rules for how monads ought
      to behave.  The three laws below are referred to as the monad
      laws.  A Haskell implementation doesn't enforce these laws: it's
      up to the author of a <code>Monad</code> instance to follow
      them.</para>

    <para id="x_qh">The monad laws are simply formal ways of saying <quote>a
	monad shouldn't surprise me</quote>.  In principle, we could
      probably get away with skipping over them entirely.  It would be
      a shame if we did, however, because the laws contain gems of
      wisdom that we might otherwise overlook.</para>

    <tip>
      <title>Reading the laws</title>

      <para id="x_rh">You can read each law below as <quote>the expression on
	  the left of the <code>==</code> is equivalent to that on the
	  right.</quote></para>
    </tip>

    <para id="x_sh">The first law states that &return; is a <emphasis>left
	identity</emphasis> for &bind;.</para>

    &MonadLaws.hs:leftIdentity;
    
    <para id="x_th">Another way to phrase this is that there's no reason to use
      &return; to wrap up a pure value if all you're going to do is
      unwrap it again with &bind;.  It's actually a common style error
      among programmers new to monads to wrap a value with &return;,
      then unwrap it with &bind; a few lines later in the same
      function.  Here's the same law written with &do;
      notation.</para>

    &MonadLaws.hs:leftIdentityDo;

    <para id="x_uh">This law has practical consequences for our coding style: we
      don't want to write unnecessary code, and the law lets us assume
      that the terse code will be identical in its effect to the more
      verbose version.</para>

    <para id="x_vh">The second monad law states that &return; is a
      <emphasis>right identity</emphasis> for &bind;.</para>

    &MonadLaws.hs:rightIdentity;

    <para id="x_wh">This law also has style consequences in real programs,
      particularly if you're coming from an imperative language:
      there's no need to call &return; if the last action in a block
      would otherwise be returning the correct result.  Let's look at
      this law in &do; notation.</para>

    &MonadLaws.hs:rightIdentityDo;

    <para id="x_xh">Once again, if we assume that a monad obeys this law, we can
      write the shorter code in the knowledge that it will have the
      same effect as the longer code.</para>

    <para id="x_yh">The final law is concerned with associativity.</para>

    &MonadLaws.hs:associativity;

    <para id="x_zh">This law can be a little more difficult to follow, so let's
      look at the contents of the parentheses on each side of the
      equation.  We can rewrite the expression on the left as
      follows.</para>

    &MonadLaws.hs:associativityLeft;

    <para id="x_Ai">On the right, we can also rearrange things.</para>

    &MonadLaws.hs:associativityRight;

    <para id="x_Bi">We're now claiming that the following two expressions are
      equivalent.</para>

    &MonadLaws.hs:associativityRewrite;

    <para id="x_Ci">What this means is if we want to break up an action into
      smaller pieces, it doesn't matter which sub-actions we hoist out
      to make new actions with, provided we preserve their ordering.
      If we have three actions chained together, we can substitute the
      first two and leave the third in place, or we can replace the
      second two and leave the first in place.</para>

    <para id="x_Di">Even this more complicated law has a practical consequence.
      If you're familiar with the terminology of software refactoring,
      this law essentially states that the <quote>extract
	method</quote> technique applies to Haskell monads.</para>

    <para id="x_Ei">We've now seen how each of the monad laws offers us an
      insight into writing better monadic code.  The first two laws
      show us how to avoid unnecessary use of &return;.  The third
      suggests that we can safely refactor a complicated action into
      several simpler ones. We can now safely let the details fade, in
      the knowledge that our <quote>do what I mean</quote> intuitions
      won't be violated when we use properly written monads.  Don't
      forget to check these laws yourself when you create a
      monad!</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
