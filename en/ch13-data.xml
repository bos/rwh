<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.data">
  <title>Data Structures</title>
  <remark>
    FIXME:
    association lists
    Data.Map
    Mutable storage with MVars
  </remark>

  <para>
    Back in <remark>FIXME: add ref to chapter 3ish</remark>, you saw how to
    use &type; to create handy aliases for types.  That's a useful feature,
    but in this chapter we'll take it a step further.  We'll show you how to
    create entirely new types.  After doing that, we'll also show you some of
    the built-in tools that Haskell provides for arranging large amounts of
    data.
  </para>

  <sect1 id="hs.data.intro">
    <title>Creating New Types</title>
    <para>
      To create a new type, we use the &data; keyword.  You can create an
      amazing variety of types using &data;.  We'll take a look at them,
      starting with the most simple, and moving on to more complex types.
    </para>

    <sect2 id="hs.data.basic">
      <title>Basic Type Creation</title>
      <para>
        To create a new type, we use the &data; keyword.  In its most simple,
        though probably useless<footnote><para>The built-in type
            <literal>()</literal> carries no data, so there is little need to
            define your own unless you are writing FFI interfaces to C types.
        </para></footnote>, form, you can create a type like this:
      </para>
      &data1.hs:useless;
      <para>
        This defines a new type called <literal>Silly</literal>.  There is one
        <emphasis>type constructor</emphasis> for <literal>Silly</literal>:
        <literal>Foo</literal>.  When you write <literal>Foo</literal> in your
        program, this <literal>Foo</literal> is a value of type
        <literal>Silly</literal>.  You can actually use the same word for both,
        but it must start with an uppercase letter.
      </para>
      <para>
        Looking at it with &ghci;, there's not much you can do with it yet:
      </para>
      &data1.ghci:useless;
      <para>
        Note that &ghci; doesn't know how to display <literal>Foo</literal> to
        the screen, or how to compare it to itself.  That's because we haven't
        made our new type a member of the &Show; and &Eq; typeclasses.  We'll
        make a new example that is a member of these classes, and then we'll
        get more information out of &ghci;.  For more on typeclasses, refer to
        <xref linkend="hs.typeclasses"/>.
      </para>
      &data1.hs:silly2;
      <para>
        We've also defined a function that takes any parameter and returns
        a value of type <literal>Silly2</literal>.  Let's play with this in
        &ghci;.
      </para>
      &data1.ghci:useless2;
      <para>
        You can see here how the types interact.  Since <literal>Foo</literal>
        is of type <literal>Silly</literal> and <literal>Foo2</literal> is of
        type <literal>Silly2</literal>, you can't compare them directly.
      </para>
      <para>  
        Let's now expand on this
        foundation with some more things that can be done with &data;.
      </para>
    </sect2>

    <sect2 id="hs.data.multi">
      <title>Multiple Type Constructors</title>
      <para>
        One way to make &data; more useful is to have multiple type
        constructors.  Here's an example:
      </para>
      &data1.hs:color;
      <para>
        This defined one new type named <literal>Color</literal>.  You can
        create a value of type <literal>Color</literal> by using any of the
        three literals <literal>Red</literal>, <literal>Green</literal>, or
        <literal>Blue</literal>.  There are several reasons this might be
        useful as opposed to using something like a &String; to store simple
        color names:
      </para>
      <itemizedlist>
        <listitem><para>You are guaranteed that a <literal>Color</literal>
            always represents one of these three values</para></listitem>
        <listitem><para>When you do pattern matching on a
            <literal>Color</literal>, the compiler will warn you if you don't
            consider all three possible values</para></listitem>
        <listitem><para>It is possible to hide the implemention of
            <literal>Color</literal> from users when exporting symbols from the
            module; you can include <literal>Color</literal> in the list but
            not the three constructors
            <remark>FIXME: need to go into detail about exporting types
            somewhere and add a ref to it from here</remark>
            </para></listitem>
      </itemizedlist>
      <para>
        Let's look at some example code that uses the Color:
      </para>
      &data1.hs:color2;
      <para>
        That's pretty simple: a function that takes a <literal>Color</literal> 
        and converts it to
        a &String;.  Note that we don't have to deal with the case where the
        input to the function is something other than our three colors, because
        that can't possibly happen.
      </para>
      <para>
        You use a type defined in this way all the time.  Haskell 98 defines
        this:
      </para>
      <programlisting>
  data Bool =  False | True deriving 
                             (Read, Show, Eq, Ord, Enum, Bounded)
      </programlisting>
      <para>
        As you'll see in the rest of this chapter, many of the core Haskell
        features you rely upon are actually defined in the prelude using
        &data;.  That is, they're not built into the compiler in any special
        way.  The only thing special about them is that they are loaded for you
        by default since they're in the prelude.
      </para>
      <remark>FIXME: have we discussed prelude?</remark>
    </sect2>

    <sect2 id="hs.data.records">
      <title>Defining Records</title>
      <para>
        Custom types need not be defined solely in terms of static data.  They
        can also take parameters.  Let's say that we wanted to take our
        color example a new direction and let a user represent arbitrary colors
        in the RGB (red, green, blue) colorspace.  We could use an 
        <literal>(Int, Int, Int)</literal> tuple for this, but to illustrate
        records, let's define a new type.
      </para>
      &color.hs:custom;
      <para>
        This defines a new type <literal>CustomColor</literal> and one type
        constructor also named <literal>CustomColor</literal>.  This type
        constructor, however, requires three parameters, all &Int;s.
      </para>
      <para>
        The type constructor here is a unique beast in Haskell.  You can use it
        as a function that takes three parameters, and it will return to you
        one value ot type <literal>CustomColor</literal>.  You can also use it
        to perform pattern matching in function or case definitions.
      </para>
      <para>
        Let's use &ghci; to inspect this for a bit:
      </para>
      <para>
        You can see that <literal>CustomColor 100 0 50</literal> returns a
        single value of type <literal>CustomColor</literal>.  Now you're
        probably wondering how to extract the data from that
        <literal>CustomColor</literal>.  We use pattern matching to do that.
        Here's how:
      </para>
      &color.hs:extract;
      <para>
        We used pattern matching to match the <literal>CustomColor</literal>.
        The three &Int;s were assigned to <literal>red</literal>, 
        <literal>green</literal>, and <literal>blue</literal>, and then printed
        out.  You can see that this worked by using &ghci;:
      </para>
      &color.ghci:extract;
      <para>
        This sort of record is used in the standard Haskell library in the
        <literal>System.Time.ClockTime</literal> type:
      </para>
      <programlisting>
  data ClockTime = TOD Integer Integer
       deriving (Eq, Ord)
      </programlisting>
      <para>
        A <literal>ClockTime</literal> consists of two &Integer;s.  The first
        is the number of whole seconds since midnight UTC on January 1, 1970.
        The second is an additional number of picoseconds.  Since an &Integer;
        can be negative and is unbounded, a <literal>ClockTime</literal> can
        effectively represent any moment in history down to the picosecond.
      </para>
      <para>
        This is useful as it is, but when you have half a dozen or more
        values to store in your record, it can get annoying to have to match
        them all.  There's where named fields come in, which we'll discuss
        next.
      </para>
    </sect2>

    <sect2 id="hs.data.named">
      <title>Records with Named Fields</title>
      <para>
        Our earlier example of a type that holds a color looked easy enough.
        But you have to remember the ordering of the fields that are part of
        the type.  Also, you always have to pattern match all fields, even if
        you're interested in only one.  Of course, you could write a function
        such as <literal>getRed</literal> to do that, but there's an easier
        way.
      </para>
      <para>
        In Haskell, records can have named fields.  When you name the fields
        in a record, you can still access it just as you would without the
        named fields.  But you gain two things: automatic functions for
        picking out specific fields, plus an easier way to create and update
        these objects.
      </para>
      <para>
        Let's take a look at a re-designed <literal>CustomColor</literal>
        type that uses named fields:
      </para>
      &colornamed.hs:custom;
      <para>
        This record stores exactly the same amount of information as our
        ealier <literal>CustomColor</literal>.  But now we can take advantage
        of named fields.  Let's see how that works with &ghci;:
      </para>
      &colornamed.ghci:custom;
      &colornamed.ghci:create;
      <para>
        First, we inspected the type of the <literal>CustomColor</literal>
        constructor.  Note that it's type is exactly the same as the
        constructor for the type 
        that didn't use named fields.  Then, we created a object
        with identical data three different ways.  The first way didn't make
        use of the named fields.  The second and third ways did.  Notice that
        when you use named fields, you don't have to specify the values in
        order.
      </para>
      <para>
        Haskell automatically creates accessor functions for each of the
        named fields.  Let's look at how we extract the red component of our
        color:
      </para>
      &colornamed.ghci:extract;
      <para>
        We can use that to write a modified <literal>color2string</literal>
        function that accesses each named field without having to pattern
        match each individual field.  For reference, the original
        <literal>color2string</literal> is included here as
        <literal>color2string2</literal>.
      </para>
      &colornamed.hs:extract;
      &colornamed.hs:extract2;
      <para>
        In the first function, we took a <literal>CustomColor</literal> and
        assigned the entire thing to <literal>cc</literal>.  In the second
        function, we used pattern matching to pick it apart up front.
      </para>
      <para>
        Named fields also make it easy to modify one or more components of a
        type.  Here's an example:
      </para>
      &colornamed.ghci:update;
      <para>
        With just three fields, the burden of pattern matching isn't all that
        great.  But what if you had a dozen or more?  Named fields really
        help out in that case.  The standard Haskell library uses named
        fields in <literal>System.Time.CalendarTime</literal>.  Here's a
        excerpt from its definition:
      </para>
      <programlisting>
data CalendarTime = CalendarTime {
  ctYear :: Int,
  ctMonth :: Month,
  ctDay :: Int,
  ctHour :: Int,
  ctMin :: Int,
  ctSec :: Int,
  ctPicosec :: Integer,
  ctWDay :: Day,
  ctYDay :: Int,
  ctTZName :: String,
  ctTZ :: Int,
  ctIsDST :: Bool
}
      </programlisting>
      <para>
        Named fields are a tremendous time saver here.  If you have a
        <literal>CalendarTime</literal> and want to extract just the year,
        you can simply say <literal>ctYear ct</literal> rather than having to
        match against 12 different fields in order.
      </para>
    </sect2>
    <sect2 id="hs.data.polymorphic">
      <title>Polymorphic Types</title>
      <para>
        Sometimes you don't know in advance what the types of the data you
        want to store will be.  For instance, our
        <literal>CustomColor</literal> type used &Int;s.  But one could
        certainly also represent color values as a &Float; or an &Integer;.
        Haskell makes it possible to write generic code that
        could work with any of those.  Why not make the type generic as well?
      </para>
      <para>
        Haskell has a well-known type that is defined just this way: &Maybe;.
        It's defined in the prelude like this:
      </para>
      <programlisting>
data  Maybe a  =  Nothing | Just a
  deriving (Eq, Ord)
      </programlisting>
      <para>
        This type is often used when the result of a function could be an
        error or some other invalid result (&Nothing;), or else a real value
        (&Just;).  For instance, if you are searching in a list for the first
        result that matches search criteria, you will either find something
        or you won't.  If you do, you could get back the data wrapped in
        &Just;, and if you don't, you could get back &Nothing;.
      </para>
      <para>
        &Maybe; is a polymorphic type because its type depends on the type of
        data that is encapsulated within it.  You can, in fact, encapsulate
        <emphasis>any</emphasis> type of data within it.  Let's look at this
        with &ghci;.
      </para>
      &maybe.ghci:maybe1;
      <para>
        Notice here that the type of &Nothing; is <literal>Maybe a</literal>,
        but the type of <literal>Just "hi"</literal> is <literal>Maybe
          [Char]</literal>.  The reason for this is Haskell's type inference.
        &Nothing; doesn't actually encapsulate any data, so it -- by itself
        -- is valid with any &Just;.  You can also give it an explicit type
        to force it to behave a certain way.
      </para>
      <para>
        Let's push the type system and see what it lets us do with &Maybe;.
      </para>
      &maybe.ghci:maybe2;
      <para>
        You can compare &Nothing; to a &Just; easily enough; that comparison
        will of course always be false.  The comparison between two &String;s
        wrapped in &Just; also works.  But the type checker wisely gives an
        error on the last attempt, because you're trying to compare a
        &String; to a number.
      </para>
      <para>
        You'll see &Maybe; used quite a bit throughout this book, and in
        Haskell code in general.
      </para>
    </sect2>
    <sect2 id="hs.data.combining">
      <title>A Final Word on Types</title>
      <para>
        We've shown you a lot of different ways to create your own types.
        Note that, by using multiple constructors, you can effectively
        combine various approaches in a single type.  For instance, you could
        say <literal>data Foo a = Bar | Baz Int | Other a</literal> if you so
        desire.  This may be useful in certain situations.
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.data.assoc">
    <title>Association Lists</title>
    <para>
      Often times, we have to deal with data that is unordered but is indexed
      by a key.  For instance, a Unix administrator might have a list of
      numeric UIDs and the textual usernames that they correspond to.  The
      utility of this list is being able to look up a textual username for a
      given UID, not the order of the data.  In otherwords, the UID is a key
      into a database.
    </para>
    <para>
      In Haskell, there are several ways to handle data that is structured in
      this way.  The two most common are association lists and the
      <literal>Data.Map</literal> module.  Association lists are handy
      because they are simple.  They are standard Haskell lists, so all the
      functions that work on those lists work on association lists.  However,
      for large data sets, <literal>Data.Map</literal> will have a
      considerable performance advantage over association lists.  We'll
      consider both in this chapter.
    </para>
    <para>
      An association list is just a normal list containing (key, value)
      tuples.  The type of a list of mappings from UID to username might be
      <literal>[(Integer, String)]</literal>.  You could use just about any
      type for both the key and the value.
    </para>
    <para>
      You can built association lists just like you would build any other
      list.  Haskell comes with one built-in function called 
      <literal>Data.List.lookup</literal> to look up data in an association
      list.  Its type is <literal>Eq a => a -> [(a, b)] -> Maybe b</literal>.
      Can you guess how it works from that type?  Let's take a look in
      &ghci;.
    </para>
    &lookup.ghci:lookup1;
    <para>
      The <literal>lookup</literal> function is really simple.  Here's
      one way you could write it:
    </para>
    &lookup.hs:standalone;
    <para>
      This function returns &Nothing; if passed the empty list.  Otherwise,
      it compares the key with the key we're looking for.  If a match is
      found, the corresponding value is returned.  Otherwise, it searches
      the rest of the list.
    </para>
    <para>
      Let's take a look at a more complex example of association lists.
      On Unix/Linux machines,
      there is a file called <literal>/etc/passwd</literal> that stores
      usernames, UIDs, home directories, and various other information.
      Let's write a program that parses such a file, creates an association
      list, and lets the user look up a username by giving a UID.
    </para>
    &passwd-al.hs:all;
    <para>
      Let's look at this program.  The heart of it is
      <literal>findByUID</literal>, which is a simple function that parses
      the input one line at a time, then calls <literal>lookup</literal> over
      the result.  The remaining program is concerned with parsing the input.
      The input file looks like this:
    </para>
    <programlisting>
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
jgoerzen:x:1000:1000:John Goerzen,,,:/home/jgoerzen:/bin/bash
    </programlisting>
    <para>
      This is an excerpt from <literal>/etc/passwd</literal> on a live
      system.  The <literal>split</literal> function separates a line into
      fields by looking for colons.  Note the type of the function, though:
      it's so generic that it can be used on lists of things other than
      strings even.
    </para>
    <para>
      As you might imagine, if you have a large amount of data, searching
      through it can be slow.  <literal>lookup</literal> may have to search
      through an entire list.  If you have hundreds of thousands of entries,
      this could take a long time.  
      Changing existing data can be slow, too.  The
      <literal>Data.Map</literal> module addresses both of these concerns,
      and we'll cover it in the next section.
    </para>
    <para>
      Association lists have a couple of advantages, though.  One is that
      they are simple to use, build, and understand.  Another is that they
      are standard lists and can be manipulated by standard list functions
      such as <literal>sort</literal>, <literal>reverse</literal>,
      <literal>head</literal>, and <literal>tail</literal>.  Finally,
      association lists preserve their original order, while maps may not.
    </para>
  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
