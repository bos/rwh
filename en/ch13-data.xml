<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.data" revision="alpha">
  <title>Data Structures</title>
  <remark>
    FIXME:
    Mutable storage with MVars needs to go in threading area
  </remark>

  <para id="x_RH">
    Back in <remark>FIXME: add ref to chapter 3ish</remark>, you saw how to
    use &type; to create handy aliases for types.  That's a useful feature,
    but in this chapter we'll take it a step further.  We'll show you how to
    create entirely new types.  After doing that, we'll also show you some of
    the built-in tools that Haskell provides for arranging large amounts of
    data.
  </para>
  <para id="x_pL">
    Before going on, there's a word that you might expect to see frequently
    in a chapter such as this: <emphasis>object</emphasis>.  You're not going
    to see it at all in this chapter because Haskell isn't an object-oriented
    language.  Concepts in this chapter may have similar-sounding names, but
    are likely quite different than the object-oriented ideas you may be
    familiar with already.
  </para>
  <para id="x_qL">
    In this chapter, you'll learn how to create and use your own types.
    We'll start with very basic types, and progress all the way to defining
    your own numeric types.  We'll have an example showing you how you can
    extend Haskell's numeric type system to support units of measure and
    symbolic manipulations.  We think you'll find Haskell's typing system
    powerful and -- surprise -- even exciting.
  </para>

  <sect1 id="hs.data.intro">
    <title>Creating New Types</title>
    <para id="x_SH">
      To create a new type, we use the &data; keyword.  You can create an
      amazing variety of types using &data;.  We'll take a look at them,
      starting with the most simple, and moving on to more complex types.
    </para>

    <sect2 id="hs.data.basic">
      <title>Basic Type Creation</title>
      <para id="x_TH">
        To create a new type, we use the &data; keyword.  In its most simple,
        though probably useless<footnote><para id="x_UH">The built-in type
            <literal>()</literal> carries no data, so there is little need to
            define your own unless you are writing FFI interfaces to C types.
        </para></footnote>, form, you can create a type like this:
      </para>
      &data1.hs:useless;
      <para id="x_VH">
        This defines a new type called <literal>Silly</literal>.  There is one
        <emphasis>type constructor</emphasis> for <literal>Silly</literal>:
        <literal>Foo</literal>.  When you write <literal>Foo</literal> in your
        program, this <literal>Foo</literal> is a value of type
        <literal>Silly</literal>.  You can actually use the same word for both,
        but it must start with an uppercase letter.
      </para>
      <para id="x_WH">
        Looking at it with &ghci;, there's not much you can do with it yet:
      </para>
      &data1.ghci:useless;
      <para id="x_XH">
        Note that &ghci; doesn't know how to display <literal>Foo</literal> to
        the screen, or how to compare it to itself.  That's because we haven't
        made our new type a member of the &Show; and &Eq; typeclasses.  We'll
        make a new example that is a member of these classes, and then we'll
        get more information out of &ghci;.  For more on typeclasses, refer to
        <xref linkend="hs.typeclasses"/>.
      </para>
      &data1.hs:silly2;
      <para id="x_YH">
        We've also defined a function that takes any parameter and returns
        a value of type <literal>Silly2</literal>.  Let's play with this in
        &ghci;.
      </para>
      &data1.ghci:useless2;
      <para id="x_ZH">
        You can see here how the types interact.  Since <literal>Foo</literal>
        is of type <literal>Silly</literal> and <literal>Foo2</literal> is of
        type <literal>Silly2</literal>, you can't compare them directly.
      </para>
      <para id="x_aH">  
        Let's now expand on this
        foundation with some more things that can be done with &data;.
      </para>
    </sect2>

    <sect2 id="hs.data.multi">
      <title>Multiple Type Constructors</title>
      <para id="x_bH">
        One way to make &data; more useful is to have multiple type
        constructors.  Here's an example:
      </para>
      &data1.hs:color;
      <para id="x_cH">
        This defined one new type named <literal>Color</literal>.  You can
        create a value of type <literal>Color</literal> by using any of the
        three literals <literal>Red</literal>, <literal>Green</literal>, or
        <literal>Blue</literal>.  There are several reasons this might be
        useful as opposed to using something like a &String; to store simple
        color names:
      </para>
      <itemizedlist>
        <listitem><para id="x_dH">You are guaranteed that a <literal>Color</literal>
            always represents one of these three values</para></listitem>
        <listitem><para id="x_eH">When you do pattern matching on a
            <literal>Color</literal>, the compiler will warn you if you don't
            consider all three possible values</para></listitem>
        <listitem><para id="x_fH">It is possible to hide the implemention of
            <literal>Color</literal> from users when exporting symbols from the
            module; you can include <literal>Color</literal> in the list but
            not the three constructors
            <remark>FIXME: need to go into detail about exporting types
            somewhere and add a ref to it from here</remark>
            </para></listitem>
      </itemizedlist>
      <para id="x_gH">
        Let's look at some example code that uses the Color:
      </para>
      &data1.hs:color2;
      <para id="x_hH">
        That's pretty simple: a function that takes a <literal>Color</literal> 
        and converts it to
        a &String;.  Note that we don't have to deal with the case where the
        input to the function is something other than our three colors, because
        that can't possibly happen.
      </para>
      <para id="x_iH">
        You use a type defined in this way all the time.  Haskell 98 defines
        this:
      </para>
      <programlisting>
  data Bool =  False | True deriving 
                             (Read, Show, Eq, Ord, Enum, Bounded)
      </programlisting>
      <para id="x_jH">
        As you'll see in the rest of this chapter, many of the core Haskell
        features you rely upon are actually defined in the prelude using
        &data;.  That is, they're not built into the compiler in any special
        way.  The only thing special about them is that they are loaded for you
        by default since they're in the prelude.
      </para>
      <remark>FIXME: have we discussed prelude?</remark>
    </sect2>

    <sect2 id="hs.data.records">
      <title>Defining Records</title>
      <para id="x_kH">
        Custom types need not be defined solely in terms of static data.  They
        can also take parameters.  Let's say that we wanted to take our
        color example a new direction and let a user represent arbitrary colors
        in the RGB (red, green, blue) colorspace.  We could use an 
        <literal>(Int, Int, Int)</literal> tuple for this, but to illustrate
        records, let's define a new type.
      </para>
      &color.hs:custom;
      <para id="x_lH">
        This defines a new type <literal>CustomColor</literal> and one type
        constructor also named <literal>CustomColor</literal>.  This type
        constructor, however, requires three parameters, all &Int;s.
      </para>
      <para id="x_mH">
        The type constructor here is a unique beast in Haskell.  You can use it
        as a function that takes three parameters, and it will return to you
        one value ot type <literal>CustomColor</literal>.  You can also use it
        to perform pattern matching in function or case definitions.
      </para>
      <para id="x_nH">
        Let's use &ghci; to inspect this for a bit:
      </para>
      <para id="x_oH">
        You can see that <literal>CustomColor 100 0 50</literal> returns a
        single value of type <literal>CustomColor</literal>.  Now you're
        probably wondering how to extract the data from that
        <literal>CustomColor</literal>.  We use pattern matching to do that.
        Here's how:
      </para>
      &color.hs:extract;
      <para id="x_pH">
        We used pattern matching to match the <literal>CustomColor</literal>.
        The three &Int;s were assigned to <literal>red</literal>, 
        <literal>green</literal>, and <literal>blue</literal>, and then printed
        out.  The matching is positional; you could just as easily have used
        <literal>(CustomColor x y z)</literal>, and <literal>x</literal>
        would have held the first &Int;.  
        You can see that this worked by using &ghci;:
      </para>
      &color.ghci:extract;
      <para id="x_qH">
        This sort of record is used in the standard Haskell library in the
        <literal>System.Time.ClockTime</literal> type:
      </para>
      <programlisting>
  data ClockTime = TOD Integer Integer
       deriving (Eq, Ord)
      </programlisting>
      <para id="x_rH">
        A <literal>ClockTime</literal> consists of two &Integer;s.  The first
        is the number of whole seconds since midnight UTC on January 1, 1970.
        The second is an additional number of picoseconds.  Since an &Integer;
        can be negative and is unbounded, a <literal>ClockTime</literal> can
        effectively represent any moment in history down to the picosecond.
      </para>
      <para id="x_sH">
        This is useful as it is, but when you have half a dozen or more
        values to store in your record, it can get annoying to have to match
        them all.  There's where named fields come in, which we'll discuss
        next.
      </para>
    </sect2>

    <sect2 id="hs.data.named">
      <title>Records with Named Fields</title>
      <para id="x_tH">
        Our earlier example of a type that holds a color looked easy enough.
        But you have to remember the ordering of the fields that are part of
        the type.  Also, you always have to pattern match all fields, even if
        you're interested in only one.  Of course, you could write a function
        such as <literal>getRed</literal> to do that, but there's an easier
        way.
      </para>
      <para id="x_uH">
        In Haskell, records can have named fields.  When you name the fields
        in a record, you can still access it just as you would without the
        named fields.  But you gain two things: automatic functions for
        picking out specific fields, plus an easier way to create and update
        these records.
      </para>
      <para id="x_vH">
        Let's take a look at a re-designed <literal>CustomColor</literal>
        type that uses named fields:
      </para>
      &colornamed.hs:custom;
      <para id="x_wH">
        This record stores exactly the same amount of information as our
        ealier <literal>CustomColor</literal>.  But now we can take advantage
        of named fields.  Let's see how that works with &ghci;:
      </para>
      &colornamed.ghci:custom;
      &colornamed.ghci:create;
      <para id="x_xH">
        First, we inspected the type of the <literal>CustomColor</literal>
        constructor.  Note that it's type is exactly the same as the
        constructor for the type 
        that didn't use named fields.  Then, we created a record
        with identical data three different ways.  The first way didn't make
        use of the named fields.  The second and third ways did.  Notice that
        when you use named fields, you don't have to specify the values in
        order.
      </para>
      <para id="x_yH">
        Haskell automatically creates accessor functions for each of the
        named fields.  For this reason, your field names must be unique in
        your entire module.  Let's look at how we extract the red component of our
        color:
      </para>
      &colornamed.ghci:extract;
      <para id="x_zH">
        We can use that to write a modified <literal>color2string</literal>
        function that accesses each named field without having to pattern
        match each individual field.  For reference, the original
        <literal>color2string</literal> is included here as
        <literal>color2string2</literal>.
      </para>
      &colornamed.hs:extract;
      &colornamed.hs:extract2;
      <para id="x_AI">
        In the first function, we took a <literal>CustomColor</literal> and
        assigned the entire thing to <literal>cc</literal>.  In the second
        function, we used pattern matching to pick it apart up front.
      </para>
      <para id="x_BI">
        Named fields also make it easy to modify one or more components of a
        type.  Here's an example:
      </para>
      &colornamed.ghci:update;
      <para id="x_CI">
        With just three fields, the burden of pattern matching isn't all that
        great.  But what if you had a dozen or more?  Named fields really
        help out in that case.  The standard Haskell library uses named
        fields in <literal>System.Time.CalendarTime</literal>.  Here's a
        excerpt from its definition:
      </para>
      <programlisting>
data CalendarTime = CalendarTime {
  ctYear :: Int,
  ctMonth :: Month,
  ctDay :: Int,
  ctHour :: Int,
  ctMin :: Int,
  ctSec :: Int,
  ctPicosec :: Integer,
  ctWDay :: Day,
  ctYDay :: Int,
  ctTZName :: String,
  ctTZ :: Int,
  ctIsDST :: Bool
}
      </programlisting>
      <para id="x_DI">
        Named fields are a tremendous time saver here.  If you have a
        <literal>CalendarTime</literal> and want to extract just the year,
        you can simply say <literal>ctYear ct</literal> rather than having to
        match against 12 different fields in order.
      </para>
    </sect2>
    <sect2 id="hs.data.polymorphic">
      <title>Polymorphic Types</title>
      <para id="x_EI">
        Sometimes you don't know in advance what the types of the data you
        want to store will be.  For instance, our
        <literal>CustomColor</literal> type used &Int;s.  But one could
        certainly also represent color values as a &Float; or an &Integer;.
        Haskell makes it possible to write generic code that
        could work with any of those.  Why not make the type generic as well?
      </para>
      <para id="x_FI">
        Haskell has a well-known type that is defined just this way: &Maybe;.
        It's defined in the prelude like this:
      </para>
      <programlisting>
data  Maybe a  =  Nothing | Just a
  deriving (Eq, Ord)
      </programlisting>
      <para id="x_GI">
        This type is often used when the result of a function could be an
        error or some other invalid result (&Nothing;), or else a real value
        (&Just;).  For instance, if you are searching in a list for the first
        result that matches search criteria, you will either find something
        or you won't.  If you do, you could get back the data wrapped in
        &Just;, and if you don't, you could get back &Nothing;.
      </para>
      <para id="x_HI">
        &Maybe; is a polymorphic type because its type depends on the type of
        data that is encapsulated within it.  You can, in fact, encapsulate
        <emphasis>any</emphasis> type of data within it.  Let's look at this
        with &ghci;.
      </para>
      &maybe.ghci:maybe1;
      <para id="x_II">
        Notice here that the type of &Nothing; is <literal>Maybe a</literal>,
        but the type of <literal>Just "hi"</literal> is <literal>Maybe
          [Char]</literal>.  The reason for this is Haskell's type inference.
        &Nothing; doesn't actually encapsulate any data, so it&emdash;by itself
       &emdash;is valid with any &Just;.  You can also give it an explicit type
        to force it to behave a certain way, as we did with 
        <literal>Nothing :: Maybe [Char]</literal>.
      </para>
      <para id="x_JI">
        Let's push the type system and see what it lets us do with &Maybe;.
      </para>
      &maybe.ghci:maybe2;
      <para id="x_KI">
        You can compare &Nothing; to a &Just; easily enough; that comparison
        will of course always be false.  The comparison between two &String;s
        wrapped in &Just; also works.  But the type checker wisely gives an
        error on the last attempt, because you're trying to compare a
        &String; to a number.
      </para>
      <para id="x_LI">
        You'll see &Maybe; used quite a bit throughout this book, and in
        Haskell code in general.
      </para>
    </sect2>
    <sect2 id="hs.data.combining">
      <title>A Final Word on Types</title>
      <para id="x_MI">
        We've shown you a lot of different ways to create your own types.
        Note that, by using multiple constructors, you can effectively
        combine various approaches in a single type.  For instance, you could
        say <literal>data Foo a = Bar | Baz Int | Other a</literal> if you so
        desire.  This may be useful in certain situations.
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.data.assoc">
    <title>Association Lists and Maps</title>
    <para id="x_NI">
      Often times, we have to deal with data that is unordered but is indexed
      by a key.  For instance, a Unix administrator might have a list of
      numeric UIDs and the textual usernames that they correspond to.  The
      utility of this list is being able to look up a textual username for a
      given UID, not the order of the data.  In otherwords, the UID is a key
      into a database.
    </para>
    <para id="x_OI">
      In Haskell, there are several ways to handle data that is structured in
      this way.  The two most common are association lists and the
      <literal>Data.Map</literal> module.  Association lists are handy
      because they are simple.  They are standard Haskell lists, so all the
      functions that work on those lists work on association lists.  However,
      for large data sets, <literal>Data.Map</literal> will have a
      considerable performance advantage over association lists.  We'll
      consider both in this chapter.
    </para>
    <para id="x_PI">
      An association list is just a normal list containing (key, value)
      tuples.  The type of a list of mappings from UID to username might be
      <literal>[(Integer, String)]</literal>.  You could use just about any
      type for both the key and the value.
    </para>
    <para id="x_rI">
      You can built association lists just like you would build any other
      list.  Haskell comes with one built-in function called 
      <literal>Data.List.lookup</literal> to look up data in an association
      list.  Its type is <literal>Eq a => a -> [(a, b)] -> Maybe b</literal>.
      Can you guess how it works from that type?  Let's take a look in
      &ghci;.
    </para>
    &lookup.ghci:lookup1;
    <para id="x_sI">
      The <literal>lookup</literal> function is really simple.  Here's
      one way you could write it:
    </para>
    &lookup.hs:standalone;
    <para id="x_tI">
      This function returns &Nothing; if passed the empty list.  Otherwise,
      it compares the key with the key we're looking for.  If a match is
      found, the corresponding value is returned.  Otherwise, it searches
      the rest of the list.
    </para>
    <para id="x_uI">
      Let's take a look at a more complex example of association lists.
      On Unix/Linux machines,
      there is a file called <literal>/etc/passwd</literal> that stores
      usernames, UIDs, home directories, and various other information.
      Let's write a program that parses such a file, creates an association
      list, and lets the user look up a username by giving a UID.
    </para>
    &passwd-al.hs:all;
    <para id="x_vI">
      Let's look at this program.  The heart of it is
      <literal>findByUID</literal>, which is a simple function that parses
      the input one line at a time, then calls <literal>lookup</literal> over
      the result.  The remaining program is concerned with parsing the input.
      The input file looks like this:
    </para>
    <programlisting>
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
jgoerzen:x:1000:1000:John Goerzen,,,:/home/jgoerzen:/bin/bash
    </programlisting>
    <para id="x_wI">
      The <literal>Data.Map</literal> module has some functions with same
      names as those in <literal>Prelude</literal> or other common modules.
      Therefore, when using it, most people import it using
      <literal>import qualified Data.Map as Map</literal> and use
      <literal>Map.<replaceable>function</replaceable></literal> to refer to
      functions in that module.  
      Let's start our look at <literal>Data.Map</literal> by
      taking a look at some ways to build a map.
    </para>
    <para id="x_xI">
      Functions like <literal>Map.insert</literal> work in the usual Haskell
      way: they return a copy of the input data, with the requested change
      applied.  This is quite handy with maps.  It means that you can use
      <literal>foldl</literal> to build up a map as in the
      <literal>mapFold</literal> example.  Or, you can chain together
      calls to <literal>Map.insert</literal> as in the
      <literal>mapManual</literal> example.  Let's use &ghci; to verify
      that all of these maps are as expected:
    </para>
    <para id="x_yI">
      Notice that the output from <literal>mapManual</literal> doesn't occur
      in the order it was passed in.  Maps do not guarantee that they will
      preserve the original ordering.
    </para>
    <para id="x_zI">
      Maps operate similar in concept to association lists.  The
      <literal>Data.Map</literal> module provides functions for adding and
      removing data from maps.  It also provides functions for converting
      maps back and forth to association lists, filtering them, modifying
      them, and folding them.  The library documentation for this module is
      good, so instead of going into detail on each function, we're going to
      present an example that ties together much of the concepts we've
      discussed in this chapter.
    </para>
  </sect1>

  <sect1 id="hs.data.funcs">
    <title>Functions Are Data, Too</title>
    <para id="x_rL">
      Back in the beginning of the chapter, we reminded you that Haskell isn't
      object-oriented.  Part of Haskell's power is the ease with which you
      can create and manipulate functions with it.  Let's take a look at a
      record that stores a function as one of its fields:
    </para>
    &funcrecs.hs:all;
    <para id="x_sL">
      Notice the type of the <literal>colorCalc</literal> field: it's a
      function.  It takes an <literal>Int</literal> and returns a tuple of
      <literal>(CuscomColor, Int)</literal>.  We create two
      <literal>FuncRec</literal> records: <literal>plus5</literal> and
      <literal>always0</literal>.  Notice that the
      <literal>colorCalc</literal> for both of them will always return the
      color purple.  <literal>FuncRec</literal> itself has no field to store
      the color in, yet that value somehow becomes part of the function
      itself.  This is called a <emphasis>closure</emphasis>.  Let's play
      with this a bit:
    </para>
    &funcrecs.ghci:all;
    <para id="x_tL">
      That worked well enough, but you might be wondering how to do something
      more advanced such as making a piece of data available multiple places.
      A type construction function can be helpful.  Here's an example:
    </para>
    &funcrecs2.hs:all;
    <para id="x_uL">
      Here we have a function called <literal>mkFuncRec</literal> that
      takes a &String; and another function as parameters, and returns
      a new <literal>FuncRec</literal> record.  Notice how both parameters to
      <literal>mkFuncRec</literal> are used multiple places.  Let's try it
      out:
    </para>
    &funcrecs2.ghci:all;
    <para id="x_vL">
      Notice the creation of <literal>plus5a</literal>.  We changed the
      <literal>name</literal> field, but not the <literal>namedCalc</literal>
      field.  That's why <literal>name</literal> has the new name, but
      <literal>namedCalc</literal> still returns the name that was passed to
      <literal>mkFuncRec</literal>; it doesn't change unless we explicitly
      change it.
    </para>
  </sect1>

  <sect1 id="hs.data.passwd">
    <title>Extended Example: /etc/passwd</title>
    <para id="x_AJ">
      In order to illustrate the usage of a number of different data
      structures together, we've prepared an extended example.  This example
      parses and stores entries from files in the format of
      a typical <literal>/etc/passwd</literal> file.
    </para>
    &passwdmap.hs:all;
    <para id="x_BJ">
      This example maintains two maps: one from username to
      <literal>PasswdEntry</literal> and another one from UID to
      <literal>PasswdEntry</literal>.  Database developers may find it
      convenient to think of this has having two different indices into the
      data to speed searching on different fields.
    </para>
    <para id="x_CJ">
      Take a look at the &Show; and &Read; instances for
      <literal>PasswdEntry</literal>.  There is already a standard format for
      rendering data of this type as a string: the colon-separated version
      already used by the system.  So our &Show; function displays a
      <literal>PasswdEntry</literal> in the format, and &Read; parses that
      format.
    </para>
  </sect1>

  <sect1 id="hs.data.num">
    <title>Extended example: Numeric Types</title>
    <para id="x_wL">
      We've told you how powerful and expressive Haskell's type system is.
      We've shown you a lot of ways to use that power.  Here's a chance to
      really see that in action.
    </para>
    <para id="x_xL">
      Back in <xref linkend="hs.typeclasses.wellknown.numeric"/>, we showed
      the numeric typeclasses that come with Haskell.  Let's see what we can
      do by defining new types and utilizing the numeric typeclasses to
      integrate them with basic mathematics in Haskell.
    </para>
    <para id="x_yL">
      Let's start by thinking through what we'd like to see out of &ghci;
      when we interact with our new types.  To start with, it might be nice
      to render numeric expressions as strings, making sure to indicate
      proper precedence.  Perhaps we could create a function called
      <literal>prettyShow</literal> to do that.
    </para>
    &num.ghci:prettyshow;
    <para id="x_zL">
      That looks nice, but it wasn't all that smart.  We could easily
      simplify out the <literal>1 *</literal> part of the expression.  How
      about a function to do some very basic simplification?
    </para>
    &num.ghci:simplify;
    <para id="x_AM">
      How about converting a numeric expression to Reverse Polish Notation
      (RPN)?  RPN is a postfix notation that never requires parentheses, and
      is commonly found on HP calculators.  RPN is a stack-based notation.
      You enter numbers onto the stack, and when you enter operations, they
      pop the most recent numbers off the stack and place the result on the
      stack.
    </para>
    &num.ghci:rpnshow;
    <para id="x_BM">
      Maybe it would be nice to be able to represent simple expressions with
      symbols for the unknowns.
    </para>
    &num.ghci:symbols;
    <para id="x_CM">
      It's often important to track units of measure when working with
      numbers.  For instance, when you see the number 5, does it mean 5
      meters, 5 feet, or 5 bytes?  Of course, if you divide 5 meters by 2
      seconds, the system ought to be able to figure out the appropriate
      units.  Moreover, it should stop you from adding 2 seconds to 5 meters.
    </para>
    &num.ghci:units;
    <para id="x_DM">
      If we define an expression or a function that is valid for all numbers,
      we should be able to calculate the result, or render the expression.
      For instance, if we define <literal>test</literal> to have type
      <literal>Num a => a</literal>, and say <literal>test = 2 * 5 +
        3</literal>, then we ought to be able to do this:
    </para>
    &num.ghci:func;
    <para id="x_EM">
      Since we have units, we should be able to handle some basic
      trigonometry as well.  Many of these operations operate on angles.
      Let's make sure that we can handle both degrees and radians.
    </para>
    &num.ghci:trig;
    <para id="x_FM">
      Finally, we ought to be able to put all this together and combine
      different kinds of expressions together.
    </para>
    &num.ghci:final;
    <para id="x_GM">
      Perhaps a future excercise could enhance <literal>prettyShow</literal>
      to remove unnecessary parentheses as well.
    </para>
    <para id="x_HM">
      Everything you've just seen is possible with Haskell types and classes.
      In fact, you've been reading a real &ghci; session demonstrating
      <literal>num.hs</literal>, which you'll see shortly.
    </para>
    <sect2>
      <title>First Steps</title>
      <para id="x_IM">
        Let's think about how we would accomplish everything shown above.  To
        start with, we might use &ghci; to check the type of
        <literal>(+)</literal>, which is <literal>Num a => a -> a ->
          a</literal>.  If we want to make possible some custom behavior for
        the plus operator, then we will have to define a new type and make it
        an instance of &Num;.  This type will need to store an expression
        symbolically.  We can start by thinking of operations such as addition.
        To store that, we will need to store the operation itself, its left
        side, and its right side.  The left and right sides could themselves be
        expressions.
      </para>
      <para id="x_JM">
        We can therefore think of an expression as a sort of tree.  Let's start
        with some simple types.
      </para>
      &numsimple.hs:all;
      <para id="x_KM">
        First, we define a type called <literal>Op</literal>.  This type
        simply represents some of the operations we will intend to support.
        Next, there is a definition for <literal>SymbolicManip a</literal>.
        Because of the <literal>Num a</literal> constraint, any
        <literal>Num</literal> can be used for the <literal>a</literal>.  So
        a full type may be something like <literal>SymbolicManip
          Int</literal>.
      </para>
      <para id="x_LM">
        A <literal>SymbolicManip</literal> type can be a plain number, or it
        can be some arithmetic operation.  The type for the
        <literal>Arith</literal> constructor is recursive, which is perfectly
        legal in Haskell.  <literal>Arith</literal> creates a
        <literal>SymbolicManip</literal> out of an <literal>Op</literal> and
        two other <literal>SymbolicManip</literal> items.  Let's look at an
        example:
      </para>
      &numsimple.ghci:all;
      <para id="x_MM">
        You can see that we already have a very basic representation of
        expressions working.  Notice how Haskell "converted" <literal>5 * 10
          + 2</literal> into a <literal>SymbolicManip</literal>, and even
        handled order of evaluation properly.  This wasn't really a true
        conversion; <literal>SymbolicManip</literal> is a first-class number
        now.  Integer numeric literals are internally treated as being wrapped 
        in <literal>fromInteger</literal> anyway, so <literal>5</literal> is just as valid as
        a <literal>SymbolicManip Int</literal> as it as an
        <literal>Int</literal>.
      </para>
      <para id="x_NM">
        From here, then, our task is simple: extend the
        <literal>SymbolicManip</literal> type to be able to represent all the
        operations we will want to perform, implement instances of it for the
        other numeric typeclasses, and implement our own instance of &Show;
        for <literal>SymbolicManip</literal> that renders this tree in a more
        accessible fashion.
      </para>
    </sect2>
    <sect2>
      <title>Completed Code</title>
      <para id="x_OM">
        Here is the completed <literal>num.hs</literal>, which was used with
        the &ghci; examples at the beginning of this chapter.
      </para>
      &num.hs:all;
      <para id="x_PM">
        Here we have done what we set out to accomplish: implemented more
        instances for <literal>SymbolicManip</literal>.  We have also
        introduced another type called <literal>Units</literal> which stores
        a number and a unit of measure.  We implement several show-like
        functions which render the <literal>SymbolicManip</literal> or
        <literal>Units</literal> in different ways.  
      </para>
      <para id="x_QM">
        There is one other point that this example drives home.  In many
        languages, even those with objects and overloading, there are still
        some parts of the language that are special in some way.  In Haskell,
        the "special" bits are extremely small.  We have just developed a new
        representation for something as fundamental as a number, and it has
        been really quite easy.  Haskell takes code reuse and
        interchangability to the extreme.  It is easy to make code generic
        and work on things of many different types.  It's also easy to make
        up new types and make them automatically be 
        first-class features of the system.
      </para>
    </sect2>

  </sect1>

</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book")
end:
-->
