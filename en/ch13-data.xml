<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.data" revision="unpublished">
  <title>Data Structures</title>
  <remark>
    FIXME:
    Mutable storage with MVars needs to go in threading area
  </remark>

  <para id="x_RH">
    Back in <remark>FIXME: add ref to chapter 3ish</remark>, you saw how to
    use &type; to create handy aliases for types.  That's a useful feature,
    but in this chapter we'll take it a step further.  We'll show you how to
    create entirely new types.  After doing that, we'll also show you some of
    the built-in tools that Haskell provides for arranging large amounts of
    data.
  </para>
  <para>
    Before going on, there's a word that you might expect to see frequently
    in a chapter such as this: <emphasis>object</emphasis>.  You're not going
    to see it at all in this chapter because Haskell isn't an object-oriented
    language.  Concepts in this chapter may have similar-sounding names, but
    are likely quite different than the object-oriented ideas you may be
    familiar with already.
  </para>
  <para>
    In this chapter, you'll learn how to create and use your own types.
    We'll start with very basic types, and progress all the way to defining
    your own numeric types.  We think you'll find Haskell's typing system
    powerful and -- surprise -- even exciting.
  </para>

  <sect1 id="hs.data.intro">
    <title>Creating New Types</title>
    <para id="x_SH">
      To create a new type, we use the &data; keyword.  You can create an
      amazing variety of types using &data;.  We'll take a look at them,
      starting with the most simple, and moving on to more complex types.
    </para>

    <sect2 id="hs.data.basic">
      <title>Basic Type Creation</title>
      <para id="x_TH">
        To create a new type, we use the &data; keyword.  In its most simple,
        though probably useless<footnote><para id="x_UH">The built-in type
            <literal>()</literal> carries no data, so there is little need to
            define your own unless you are writing FFI interfaces to C types.
        </para></footnote>, form, you can create a type like this:
      </para>
      &data1.hs:useless;
      <para id="x_VH">
        This defines a new type called <literal>Silly</literal>.  There is one
        <emphasis>type constructor</emphasis> for <literal>Silly</literal>:
        <literal>Foo</literal>.  When you write <literal>Foo</literal> in your
        program, this <literal>Foo</literal> is a value of type
        <literal>Silly</literal>.  You can actually use the same word for both,
        but it must start with an uppercase letter.
      </para>
      <para id="x_WH">
        Looking at it with &ghci;, there's not much you can do with it yet:
      </para>
      &data1.ghci:useless;
      <para id="x_XH">
        Note that &ghci; doesn't know how to display <literal>Foo</literal> to
        the screen, or how to compare it to itself.  That's because we haven't
        made our new type a member of the &Show; and &Eq; typeclasses.  We'll
        make a new example that is a member of these classes, and then we'll
        get more information out of &ghci;.  For more on typeclasses, refer to
        <xref linkend="hs.typeclasses"/>.
      </para>
      &data1.hs:silly2;
      <para id="x_YH">
        We've also defined a function that takes any parameter and returns
        a value of type <literal>Silly2</literal>.  Let's play with this in
        &ghci;.
      </para>
      &data1.ghci:useless2;
      <para id="x_ZH">
        You can see here how the types interact.  Since <literal>Foo</literal>
        is of type <literal>Silly</literal> and <literal>Foo2</literal> is of
        type <literal>Silly2</literal>, you can't compare them directly.
      </para>
      <para id="x_aH">  
        Let's now expand on this
        foundation with some more things that can be done with &data;.
      </para>
    </sect2>

    <sect2 id="hs.data.multi">
      <title>Multiple Type Constructors</title>
      <para id="x_bH">
        One way to make &data; more useful is to have multiple type
        constructors.  Here's an example:
      </para>
      &data1.hs:color;
      <para id="x_cH">
        This defined one new type named <literal>Color</literal>.  You can
        create a value of type <literal>Color</literal> by using any of the
        three literals <literal>Red</literal>, <literal>Green</literal>, or
        <literal>Blue</literal>.  There are several reasons this might be
        useful as opposed to using something like a &String; to store simple
        color names:
      </para>
      <itemizedlist>
        <listitem><para id="x_dH">You are guaranteed that a <literal>Color</literal>
            always represents one of these three values</para></listitem>
        <listitem><para id="x_eH">When you do pattern matching on a
            <literal>Color</literal>, the compiler will warn you if you don't
            consider all three possible values</para></listitem>
        <listitem><para id="x_fH">It is possible to hide the implemention of
            <literal>Color</literal> from users when exporting symbols from the
            module; you can include <literal>Color</literal> in the list but
            not the three constructors
            <remark>FIXME: need to go into detail about exporting types
            somewhere and add a ref to it from here</remark>
            </para></listitem>
      </itemizedlist>
      <para id="x_gH">
        Let's look at some example code that uses the Color:
      </para>
      &data1.hs:color2;
      <para id="x_hH">
        That's pretty simple: a function that takes a <literal>Color</literal> 
        and converts it to
        a &String;.  Note that we don't have to deal with the case where the
        input to the function is something other than our three colors, because
        that can't possibly happen.
      </para>
      <para id="x_iH">
        You use a type defined in this way all the time.  Haskell 98 defines
        this:
      </para>
      <programlisting>
  data Bool =  False | True deriving 
                             (Read, Show, Eq, Ord, Enum, Bounded)
      </programlisting>
      <para id="x_jH">
        As you'll see in the rest of this chapter, many of the core Haskell
        features you rely upon are actually defined in the prelude using
        &data;.  That is, they're not built into the compiler in any special
        way.  The only thing special about them is that they are loaded for you
        by default since they're in the prelude.
      </para>
      <remark>FIXME: have we discussed prelude?</remark>
    </sect2>

    <sect2 id="hs.data.records">
      <title>Defining Records</title>
      <para id="x_kH">
        Custom types need not be defined solely in terms of static data.  They
        can also take parameters.  Let's say that we wanted to take our
        color example a new direction and let a user represent arbitrary colors
        in the RGB (red, green, blue) colorspace.  We could use an 
        <literal>(Int, Int, Int)</literal> tuple for this, but to illustrate
        records, let's define a new type.
      </para>
      &color.hs:custom;
      <para id="x_lH">
        This defines a new type <literal>CustomColor</literal> and one type
        constructor also named <literal>CustomColor</literal>.  This type
        constructor, however, requires three parameters, all &Int;s.
      </para>
      <para id="x_mH">
        The type constructor here is a unique beast in Haskell.  You can use it
        as a function that takes three parameters, and it will return to you
        one value ot type <literal>CustomColor</literal>.  You can also use it
        to perform pattern matching in function or case definitions.
      </para>
      <para id="x_nH">
        Let's use &ghci; to inspect this for a bit:
      </para>
      <para id="x_oH">
        You can see that <literal>CustomColor 100 0 50</literal> returns a
        single value of type <literal>CustomColor</literal>.  Now you're
        probably wondering how to extract the data from that
        <literal>CustomColor</literal>.  We use pattern matching to do that.
        Here's how:
      </para>
      &color.hs:extract;
      <para id="x_pH">
        We used pattern matching to match the <literal>CustomColor</literal>.
        The three &Int;s were assigned to <literal>red</literal>, 
        <literal>green</literal>, and <literal>blue</literal>, and then printed
        out.  The matching is positional; you could just as easily have used
        <literal>(CustomColor x y z)</literal>, and <literal>x</literal>
        would have held the first &Int;.  
        You can see that this worked by using &ghci;:
      </para>
      &color.ghci:extract;
      <para id="x_qH">
        This sort of record is used in the standard Haskell library in the
        <literal>System.Time.ClockTime</literal> type:
      </para>
      <programlisting>
  data ClockTime = TOD Integer Integer
       deriving (Eq, Ord)
      </programlisting>
      <para id="x_rH">
        A <literal>ClockTime</literal> consists of two &Integer;s.  The first
        is the number of whole seconds since midnight UTC on January 1, 1970.
        The second is an additional number of picoseconds.  Since an &Integer;
        can be negative and is unbounded, a <literal>ClockTime</literal> can
        effectively represent any moment in history down to the picosecond.
      </para>
      <para id="x_sH">
        This is useful as it is, but when you have half a dozen or more
        values to store in your record, it can get annoying to have to match
        them all.  There's where named fields come in, which we'll discuss
        next.
      </para>
    </sect2>

    <sect2 id="hs.data.named">
      <title>Records with Named Fields</title>
      <para id="x_tH">
        Our earlier example of a type that holds a color looked easy enough.
        But you have to remember the ordering of the fields that are part of
        the type.  Also, you always have to pattern match all fields, even if
        you're interested in only one.  Of course, you could write a function
        such as <literal>getRed</literal> to do that, but there's an easier
        way.
      </para>
      <para id="x_uH">
        In Haskell, records can have named fields.  When you name the fields
        in a record, you can still access it just as you would without the
        named fields.  But you gain two things: automatic functions for
        picking out specific fields, plus an easier way to create and update
        these records.
      </para>
      <para id="x_vH">
        Let's take a look at a re-designed <literal>CustomColor</literal>
        type that uses named fields:
      </para>
      &colornamed.hs:custom;
      <para id="x_wH">
        This record stores exactly the same amount of information as our
        ealier <literal>CustomColor</literal>.  But now we can take advantage
        of named fields.  Let's see how that works with &ghci;:
      </para>
      &colornamed.ghci:custom;
      &colornamed.ghci:create;
      <para id="x_xH">
        First, we inspected the type of the <literal>CustomColor</literal>
        constructor.  Note that it's type is exactly the same as the
        constructor for the type 
        that didn't use named fields.  Then, we created a record
        with identical data three different ways.  The first way didn't make
        use of the named fields.  The second and third ways did.  Notice that
        when you use named fields, you don't have to specify the values in
        order.
      </para>
      <para id="x_yH">
        Haskell automatically creates accessor functions for each of the
        named fields.  For this reason, your field names must be unique in
        your entire module.  Let's look at how we extract the red component of our
        color:
      </para>
      &colornamed.ghci:extract;
      <para id="x_zH">
        We can use that to write a modified <literal>color2string</literal>
        function that accesses each named field without having to pattern
        match each individual field.  For reference, the original
        <literal>color2string</literal> is included here as
        <literal>color2string2</literal>.
      </para>
      &colornamed.hs:extract;
      &colornamed.hs:extract2;
      <para id="x_AI">
        In the first function, we took a <literal>CustomColor</literal> and
        assigned the entire thing to <literal>cc</literal>.  In the second
        function, we used pattern matching to pick it apart up front.
      </para>
      <para id="x_BI">
        Named fields also make it easy to modify one or more components of a
        type.  Here's an example:
      </para>
      &colornamed.ghci:update;
      <para id="x_CI">
        With just three fields, the burden of pattern matching isn't all that
        great.  But what if you had a dozen or more?  Named fields really
        help out in that case.  The standard Haskell library uses named
        fields in <literal>System.Time.CalendarTime</literal>.  Here's a
        excerpt from its definition:
      </para>
      <programlisting>
data CalendarTime = CalendarTime {
  ctYear :: Int,
  ctMonth :: Month,
  ctDay :: Int,
  ctHour :: Int,
  ctMin :: Int,
  ctSec :: Int,
  ctPicosec :: Integer,
  ctWDay :: Day,
  ctYDay :: Int,
  ctTZName :: String,
  ctTZ :: Int,
  ctIsDST :: Bool
}
      </programlisting>
      <para id="x_DI">
        Named fields are a tremendous time saver here.  If you have a
        <literal>CalendarTime</literal> and want to extract just the year,
        you can simply say <literal>ctYear ct</literal> rather than having to
        match against 12 different fields in order.
      </para>
    </sect2>
    <sect2 id="hs.data.polymorphic">
      <title>Polymorphic Types</title>
      <para id="x_EI">
        Sometimes you don't know in advance what the types of the data you
        want to store will be.  For instance, our
        <literal>CustomColor</literal> type used &Int;s.  But one could
        certainly also represent color values as a &Float; or an &Integer;.
        Haskell makes it possible to write generic code that
        could work with any of those.  Why not make the type generic as well?
      </para>
      <para id="x_FI">
        Haskell has a well-known type that is defined just this way: &Maybe;.
        It's defined in the prelude like this:
      </para>
      <programlisting>
data  Maybe a  =  Nothing | Just a
  deriving (Eq, Ord)
      </programlisting>
      <para id="x_GI">
        This type is often used when the result of a function could be an
        error or some other invalid result (&Nothing;), or else a real value
        (&Just;).  For instance, if you are searching in a list for the first
        result that matches search criteria, you will either find something
        or you won't.  If you do, you could get back the data wrapped in
        &Just;, and if you don't, you could get back &Nothing;.
      </para>
      <para id="x_HI">
        &Maybe; is a polymorphic type because its type depends on the type of
        data that is encapsulated within it.  You can, in fact, encapsulate
        <emphasis>any</emphasis> type of data within it.  Let's look at this
        with &ghci;.
      </para>
      &maybe.ghci:maybe1;
      <para id="x_II">
        Notice here that the type of &Nothing; is <literal>Maybe a</literal>,
        but the type of <literal>Just "hi"</literal> is <literal>Maybe
          [Char]</literal>.  The reason for this is Haskell's type inference.
        &Nothing; doesn't actually encapsulate any data, so it -- by itself
        -- is valid with any &Just;.  You can also give it an explicit type
        to force it to behave a certain way, as we did with 
        <literal>Nothing :: Maybe [Char]</literal>.
      </para>
      <para id="x_JI">
        Let's push the type system and see what it lets us do with &Maybe;.
      </para>
      &maybe.ghci:maybe2;
      <para id="x_KI">
        You can compare &Nothing; to a &Just; easily enough; that comparison
        will of course always be false.  The comparison between two &String;s
        wrapped in &Just; also works.  But the type checker wisely gives an
        error on the last attempt, because you're trying to compare a
        &String; to a number.
      </para>
      <para id="x_LI">
        You'll see &Maybe; used quite a bit throughout this book, and in
        Haskell code in general.
      </para>
    </sect2>
    <sect2 id="hs.data.combining">
      <title>A Final Word on Types</title>
      <para id="x_MI">
        We've shown you a lot of different ways to create your own types.
        Note that, by using multiple constructors, you can effectively
        combine various approaches in a single type.  For instance, you could
        say <literal>data Foo a = Bar | Baz Int | Other a</literal> if you so
        desire.  This may be useful in certain situations.
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.data.assoc">
    <title>Association Lists and Maps</title>
    <para id="x_NI">
      Often times, we have to deal with data that is unordered but is indexed
      by a key.  For instance, a Unix administrator might have a list of
      numeric UIDs and the textual usernames that they correspond to.  The
      utility of this list is being able to look up a textual username for a
      given UID, not the order of the data.  In otherwords, the UID is a key
      into a database.
    </para>
    <para id="x_OI">
      In Haskell, there are several ways to handle data that is structured in
      this way.  The two most common are association lists and the
      <literal>Data.Map</literal> module.  Association lists are handy
      because they are simple.  They are standard Haskell lists, so all the
      functions that work on those lists work on association lists.  However,
      for large data sets, <literal>Data.Map</literal> will have a
      considerable performance advantage over association lists.  We'll
      consider both in this chapter.
    </para>
    <para id="x_PI">
      An association list is just a normal list containing (key, value)
      tuples.  The type of a list of mappings from UID to username might be
      <literal>[(Integer, String)]</literal>.  You could use just about any
      type for both the key and the value.
    </para>
    <para id="x_rI">
      You can built association lists just like you would build any other
      list.  Haskell comes with one built-in function called 
      <literal>Data.List.lookup</literal> to look up data in an association
      list.  Its type is <literal>Eq a => a -> [(a, b)] -> Maybe b</literal>.
      Can you guess how it works from that type?  Let's take a look in
      &ghci;.
    </para>
    &lookup.ghci:lookup1;
    <para id="x_sI">
      The <literal>lookup</literal> function is really simple.  Here's
      one way you could write it:
    </para>
    &lookup.hs:standalone;
    <para id="x_tI">
      This function returns &Nothing; if passed the empty list.  Otherwise,
      it compares the key with the key we're looking for.  If a match is
      found, the corresponding value is returned.  Otherwise, it searches
      the rest of the list.
    </para>
    <para id="x_uI">
      Let's take a look at a more complex example of association lists.
      On Unix/Linux machines,
      there is a file called <literal>/etc/passwd</literal> that stores
      usernames, UIDs, home directories, and various other information.
      Let's write a program that parses such a file, creates an association
      list, and lets the user look up a username by giving a UID.
    </para>
    &passwd-al.hs:all;
    <para id="x_vI">
      Let's look at this program.  The heart of it is
      <literal>findByUID</literal>, which is a simple function that parses
      the input one line at a time, then calls <literal>lookup</literal> over
      the result.  The remaining program is concerned with parsing the input.
      The input file looks like this:
    </para>
    <programlisting>
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
jgoerzen:x:1000:1000:John Goerzen,,,:/home/jgoerzen:/bin/bash
    </programlisting>
    <para id="x_wI">
      The <literal>Data.Map</literal> module has some functions with same
      names as those in <literal>Prelude</literal> or other common modules.
      Therefore, when using it, most people import it using
      <literal>import qualified Data.Map as Map</literal> and use
      <literal>Map.<replaceable>function</replaceable></literal> to refer to
      functions in that module.  
      Let's start our look at <literal>Data.Map</literal> by
      taking a look at some ways to build a map.
    </para>
    <para id="x_xI">
      Functions like <literal>Map.insert</literal> work in the usual Haskell
      way: they return a copy of the input data, with the requested change
      applied.  This is quite handy with maps.  It means that you can use
      <literal>foldl</literal> to build up a map as in the
      <literal>mapFold</literal> example.  Or, you can chain together
      calls to <literal>Map.insert</literal> as in the
      <literal>mapManual</literal> example.  Let's use &ghci; to verify
      that all of these maps are as expected:
    </para>
    <para id="x_yI">
      Notice that the output from <literal>mapManual</literal> doesn't occur
      in the order it was passed in.  Maps do not guarantee that they will
      preserve the original ordering.
    </para>
    <para id="x_zI">
      Maps operate similar in concept to association lists.  The
      <literal>Data.Map</literal> module provides functions for adding and
      removing data from maps.  It also provides functions for converting
      maps back and forth to association lists, filtering them, modifying
      them, and folding them.  The library documentation for this module is
      good, so instead of going into detail on each function, we're going to
      present an example that ties together much of the concepts we've
      discussed in this chapter.
    </para>
  </sect1>

  <sect1 id="hs.data.funcs">
    <title>Functions Are Data, Too</title>
    <para>
      Back in the beginning of the chapter, we reminded you that Haskell isn't
      object-oriented.  Part of Haskell's power is the ease with which you
      can create and manipulate functions with it.  Let's take a look at a
      record that stores a function as one of its fields:
    </para>
    &funcrecs.hs:all;
    <para>
      Notice the type of the <literal>colorCalc</literal> field: it's a
      function.  It takes an <literal>Int</literal> and returns a tuple of
      <literal>(CuscomColor, Int)</literal>.  We create two
      <literal>FuncRec</literal> records: <literal>plus5</literal> and
      <literal>always0</literal>.  Notice that the
      <literal>colorCalc</literal> for both of them will always return the
      color purple.  <literal>FuncRec</literal> itself has no field to store
      the color in, yet that value somehow becomes part of the function
      itself.  This is called a <emphasis>closure</emphasis>.  Let's play
      with this a bit:
    </para>
    &funcrecs.ghci:all;
    <para>
      That worked well enough, but you might be wondering how to do something
      more advanced such as making a piece of data available multiple places.
      A type construction function can be helpful.  Here's an example:
    </para>
    &funcrecs2.hs:all;
    <para>
      Here we have a function called <literal>mkFuncRec</literal> that
      takes a &String; and another function as parameters, and returns
      a new <literal>FuncRec</literal> record.  Notice how both parameters to
      <literal>mkFuncRec</literal> are used multiple places.  Let's try it
      out:
    </para>
    &funcrecs2.ghci:all;
    <para>
      Notice the creation of <literal>plus5a</literal>.  We changed the
      <literal>name</literal> field, but not the <literal>namedCalc</literal>
      field.  That's why <literal>name</literal> has the new name, but
      <literal>namedCalc</literal> still returns the name that was passed to
      <literal>mkFuncRec</literal>; it doesn't change unless we explicitly
      change it.
    </para>
  </sect1>

  <sect1 id="hs.data.passwd">
    <title>Extended Example: /etc/passwd</title>
    <para id="x_AJ">
      In order to illustrate the usage of a number of different data
      structures together, we've prepared an extended example.  This example
      parses and stores entries from files in the format of
      a typical <literal>/etc/passwd</literal> file.
    </para>
    &passwdmap.hs:all;
    <para id="x_BJ">
      This example maintains two maps: one from username to
      <literal>PasswdEntry</literal> and another one from UID to
      <literal>PasswdEntry</literal>.  Database developers may find it
      convenient to think of this has having two different indices into the
      data to speed searching on different fields.
    </para>
    <para id="x_CJ">
      Take a look at the &Show; and &Read; instances for
      <literal>PasswdEntry</literal>.  There is already a standard format for
      rendering data of this type as a string: the colon-separated version
      already used by the system.  So our &Show; function displays a
      <literal>PasswdEntry</literal> in the format, and &Read; parses that
      format.
    </para>
  </sect1>


</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
