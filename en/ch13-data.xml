<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.data">
  <title>Data Structures</title>
  <remark>
    FIXME:
    records
    association lists
    Data.Map
    Mutable storage with MVars
  </remark>

  <para>
    Back in <remark>FIXME: add ref to chapter 3ish</remark>, you saw how to
    use &type; to create handy aliases for types.  That's a useful feature,
    but in this chapter we'll take it a step further.  We'll show you how to
    create entirely new types.  After doing that, we'll also show you some of
    the built-in tools that Haskell provides for arranging large amounts of
    data.
  </para>

  <sect1 id="hs.data.intro">
    <title>Creating New Types</title>
    <para>
      To create a new type, we use the &data; keyword.  You can create an
      amazing variety of types using &data;.  We'll take a look at them,
      starting with the most simple, and moving on to more complex types.
    </para>

    <sect2 id="hs.data.basic">
      <title>Basic Type Creation</title>
      <para>
        To create a new type, we use the &data; keyword.  In its most simple,
        though probably useless<footnote><para>The built-in type
            <literal>()</literal> carries no data, so there is little need to
            define your own unless you are writing FFI interfaces to C types.
        </para></footnote>, form, you can create a type like this:
      </para>
      &data1.hs:useless;
      <para>
        This defines a new type called <literal>Silly</literal>.  There is one
        <emphasis>type constructor</emphasis> for <literal>Silly</literal>:
        <literal>Foo</literal>.  When you write <literal>Foo</literal> in your
        program, this <literal>Foo</literal> is a value of type
        <literal>Silly</literal>.  You can actually use the same word for both,
        but it must start with an uppercase letter.
      </para>
      <para>
        Looking at it with &ghci;, there's not much you can do with it yet:
      </para>
      &data1.ghci:useless;
      <para>
        Note that &ghci; doesn't know how to display <literal>Foo</literal> to
        the screen, or how to compare it to itself.  That's because we haven't
        made our new type a member of the &Show; and &Eq; typeclasses.  We'll
        make a new example that is a member of these classes, and then we'll
        get more information out of &ghci;.  For more on typeclasses, refer to
        <xref linkend="hs.typeclasses"/>.
      </para>
      &data1.hs:silly2;
      <para>
        We've also defined a function that takes any parameter and returns
        a value of type <literal>Silly2</literal>.  Let's play with this in
        &ghci;.
      </para>
      &data1.ghci:useless2;
      <para>
        You can see here how the types interact.  Since <literal>Foo</literal>
        is of type <literal>Silly</literal> and <literal>Foo2</literal> is of
        type <literal>Silly2</literal>, you can't compare them directly.
      </para>
      <para>  
        Let's now expand on this
        foundation with some more things that can be done with &data;.
      </para>
    </sect2>

    <sect2 id="hs.data.multi">
      <title>Multiple Type Constructors</title>
      <para>
        One way to make &data; more useful is to have multiple type
        constructors.  Here's an example:
      </para>
      &data1.hs:color;
      <para>
        This defined one new type named <literal>Color</literal>.  You can
        create a value of type <literal>Color</literal> by using any of the
        three literals <literal>Red</literal>, <literal>Green</literal>, or
        <literal>Blue</literal>.  There are several reasons this might be
        useful as opposed to using something like a &String; to store simple
        color names:
      </para>
      <itemizedlist>
        <listitem><para>You are guaranteed that a <literal>Color</literal>
            always represents one of these three values</para></listitem>
        <listitem><para>When you do pattern matching on a
            <literal>Color</literal>, the compiler will warn you if you don't
            consider all three possible values</para></listitem>
        <listitem><para>It is possible to hide the implemention of
            <literal>Color</literal> from users when exporting symbols from the
            module; you can include <literal>Color</literal> in the list but
            not the three constructors
            <remark>FIXME: need to go into detail about exporting types
            somewhere and add a ref to it from here</remark>
            </para></listitem>
      </itemizedlist>
      <para>
        Let's look at some example code that uses the Color:
      </para>
      &data1.hs:color2;
      <para>
        That's pretty simple: a function that takes a <literal>Color</literal> 
        and converts it to
        a &String;.  Note that we don't have to deal with the case where the
        input to the function is something other than our three colors, because
        that can't possibly happen.
      </para>
      <para>
        You use a type defined in this way all the time.  Haskell 98 defines
        this:
      </para>
      <programlisting>
  data Bool =  False | True deriving 
                             (Read, Show, Eq, Ord, Enum, Bounded)
      </programlisting>
      <para>
        As you'll see in the rest of this chapter, many of the core Haskell
        features you rely upon are actually defined in the prelude using
        &data;.  That is, they're not built into the compiler in any special
        way.  The only thing special about them is that they are loaded for you
        by default since they're in the prelude.
      </para>
      <remark>FIXME: have we discussed prelude?</remark>
    </sect2>

    <sect2 id="hs.data.records">
      <title>Defining Records</title>
      <para>
        Custom types need not be defined solely in terms of static data.  They
        can also take parameters.  Let's say that we wanted to take our
        color example a new direction and let a user represent arbitrary colors
        in the RGB (red, green, blue) colorspace.  We could use an 
        <literal>(Int, Int, Int)</literal> tuple for this, but to illustrate
        records, let's define a new type.
      </para>
      &color.hs:custom;
      <para>
        This defines a new type <literal>CustomColor</literal> and one type
        constructor also named <literal>CustomColor</literal>.  This type
        constructor, however, requires three parameters, all &Int;s.
      </para>
      <para>
        The type constructor here is a unique beast in Haskell.  You can use it
        as a function that takes three parameters, and it will return to you
        one value ot type <literal>CustomColor</literal>.  You can also use it
        to perform pattern matching in function or case definitions.
      </para>
      <para>
        Let's use &ghci; to inspect this for a bit:
      </para>
      <para>
        You can see that <literal>CustomColor 100 0 50</literal> returns a
        single value of type <literal>CustomColor</literal>.  Now you're
        probably wondering how to extract the data from that
        <literal>CustomColor</literal>.  We use pattern matching to do that.
        Here's how:
      </para>
      &color.hs:extract;
      <para>
        We used pattern matching to match the <literal>CustomColor</literal>.
        The three &Int;s were assigned to <literal>red</literal>, 
        <literal>green</literal>, and <literal>blue</literal>, and then printed
        out.  You can see that this worked by using &ghci;:
      </para>
      &color.ghci:extract;
      <para>
        This sort of record is used in the standard Haskell library in the
        <literal>System.Time.ClockTime</literal> type:
      </para>
      <programlisting>
  data ClockTime = TOD Integer Integer
       deriving (Eq, Ord)
      </programlisting>
      <para>
        A <literal>ClockTime</literal> consists of two &Integer;s.  The first
        is the number of whole seconds since midnight UTC on January 1, 1970.
        The second is an additional number of picoseconds.  Since an &Integer;
        can be negative and is unbounded, a <literal>ClockTime</literal> can
        effectively represent any moment in history down to the picosecond.
      </para>
      <para>
        This is useful as it is, but when you have half a dozen or more
        values to store in your record, it can get annoying to have to match
        them all.  There's where named fields come in, which we'll discuss
        next.
      </para>
    </sect2>
  </sect1>


</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
