<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.typeclasses">
  <title>Using Typeclasses</title>

  <para>
    Typeclasses are one of the most powerful features in Haskell.  They
    are also at the heart of some basic language features such as equality
    testing and numeric operators.  Before we talk about what exactly
    typeclasses are, though, we'd like to first explain the need for them.
  </para>

  <sect1 id="hs.typeclasses.need">
    <title>The need for typeclasses</title>
    <para>
      Let's imaging that for some unfathomable reason, the designers of the
      Haskell language neglected to implement the equality test
      <function>==</function>.  Once you got over your shock at hearing this, 
      you resolved to implement your own equality tests.  Your application
      consisted of a simple <type>Color</type> type, and so your first
      equality test is for this type.  Your first attempt might look like
      <xref linkend="hs.typeclasses.ex.naiveeq"/>.
    </para>
    <example id="hs.typeclasses.ex.naiveeq">
      <title>Naive Equality -- Colors (naiveeq.hs)</title>
      &naiveeq.hs:color;
    </example>
    <para>
      You can test this with <application>ghci</application> or
      <application>hugs</application>:
    </para>
    <screen>
$ <userinput>ghci naiveeq.hs</userinput>
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; <userinput>colorEq Red Red</userinput>
True
*Main&gt; <userinput>colorEq Red Blue</userinput>
False
</screen>
    <para>
      Now, let's say that you want to add an equality test for
      <type>String</type>s.
      Since a Haskell <type>String</type> is a list of characters, we can
      write a simple function to perform that test, as seen in <xref
        linkend="hs.typeclasses.ex.naiveeq.string"/>.  For simplicity, we
      cheat a bit and use the <function>==</function> operator a couple
      of times.
    </para>
    <example id="hs.typeclasses.ex.naiveeq.string">
      <title>Naive Equality -- Strings (naiveeq.hs)</title>
      &naiveeq.hs:string;
    </example>
    <para>
      You should now be able to see a problem: we have to define a new
      function for every different type that we want to be able to compare.
      That's inefficient and annoying.  It's much more convenient to be able
      to just use <function>==</function> to compare anything.  As it turns
      out, this is exactly what Haskell's typeclasses are for.  
    </para>
  </sect1>
  <sect1 id="hs.typeclasses.whatarethey">
    <title>What are typeclasses?</title>
    <remark>FIXME: I don't like this explanation, or maybe just not here..
    maybe move to later on. --jg</remark>
    <para>
      Typeclasses define a set of functions that can operate on more than one
      type of data.  A typeclass defines an interface, and perhaps even
      default implementations of functions.  You then create an instance for
      each type that should conform to the typeclass.  Once that is done, a
      function that's part of the typeclass definition can be called with any
      type that's an instance of the typeclass as a parameter.
    </para>
    <para>
      Those familiar with object-oriented programming can think of
      typeclasses as objects in reverse.  In OOP, when you define an object,
      you define what its parent classes are at that time.  You must also
      define how it implements the methods in the parent class, if you need a
      custom implementation.
    </para>
    <para>
      With typeclasses, you have greater freedom.  Let's say that you have a
      type from a third party.  Perhaps that third party didn't make it part
      of a typeclass that you'd like it to be part of.  No problem; you can
      define an instance yourself.  With OOP, the best you can do is subclass
      an object and use multiple inheritance (or, in Java, interfaces) to
      make the child object behave as you like.  But you're still stuck if
      you have a parent object from somewhere.
    </para>

  </sect1>


  <sect1 id="hs.typeclasses.defining">
    <title>Defining new typeclasses</title>
    <para>
      Let's use typeclasses to solve our equality dilemma from earlier in the
      chapter.  The first thing that we need to do is define the typeclass
      itself.  What we want is a function that takes two parameters, both the
      same type, and returns a <type>Bool</type> indicating whether or not
      they are equal.  Here's our first definition of a typeclass:
    </para>
    <remark>FIXME: Should we make this a formal example even though it's short? 
    --jg</remark>
    &eqclasses.hs:basiceq;
    <para>
      This says that we are declaring a typeclass named
      <varname>BasicEq</varname>, and we'll refer to instance types with the
      letter <parameter>a</parameter>.  This typeclass defines one function.
      That function takes two parameters -- both corresponding to instance
      types -- and returns a <type>Bool</type>.
    </para>
    <para>
      On the first line, the name of the parameter <parameter>a</parameter>
      was chosen arbitrarily.  We could have used any name.  The key is that,
      when you list the types of your functions, you must use that name to
      refer to instance types.
    </para>
    <para>
      Let's look at this in <application>ghci</application>.  <remark>FIXME:
        insert reference to where this is defined</remark>
      Recall that you
      can type <command>:t</command> in <application>ghci</application> to 
      have it show you the type of something.  Let's see what it says about
      <function>isEqual</function>:
    </para>
    <screen>
$ <userinput>ghci eqclasses.hs</userinput>
[1 of 1] Compiling Main             ( eqclasses.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; <userinput>:t isEqual</userinput>
isEqual :: (BasicEq a) => a -> a -> Bool
    </screen>
    <para>
      You can read that this way: "For all types of <type>a</type>, so
      long as <type>a</type> is an instance of
      <varname>BasicEq</varname>, <function>isEqual</function> takes two
      parameters of type <type>a</type> and returns a <type>Bool</type>".
    </para>
    <para>
      Now that we've seen a very simple typeclass, let's expand it a bit.  
      A not-equal-to function might be useful.
      Here's what we might say to define a typeclass with two functions:
    </para>
    <remark>FIXME: formal example? --jg</remark>
    &eqclasses.hs:basiceq2;
    <para>
      Someone providing an instance of <varname>BasicEq2</varname> will
      be required to define two functions: <function>isEqual2</function> and
      <function>isNotEqual2</function>.
    </para>
    <para>
      While our definition of <varname>BasicEq2</varname> is fine, it seems
      that we're making extra work for ourselves.  Logically speaking, if we
      know what <function>isEqual</function> or
      <function>isNotEqual</function> would return, we know how to figure out
      what the other function would return, for all types.  Rather than
      making users of the typeclass define both functions for all types, we
      can provide default implementations for them.  Then, users will only
      have to implement one function.  <xref linkend="hs.typeclasses.ex.basiceq3"/> shows how
      to do this.
    </para>
    <example id="hs.typeclasses.ex.basiceq3">
      <title>BasicEq3 Typeclass Definition (eqclasses.hs)</title>
      &eqclasses.hs:basiceq3;
    </example>
    <para>
      People implementing this class must provide an implementation of at
      least one function.  They can implement both if they wish, but they
      will not be required to.
    </para>
    <para>
      With <varname>BasicEq3</varname>, we have provided a class that does
      very much the same thing as Haskell's built-in <function>==</function>
      and <function>/=</function> operators.  In fact, these operators are
      defined by a typeclass that looks almost identical to
      <varname>BasicEq3</varname>.  The Haskell 98 Report <remark>FIXME: add
        reference? --jg</remark> defines a typeclass that implements equality
      comparison.  See <xref linkend="hs.typeclasses.ex.eq"/> for the built-in
        <varname>Eq</varname> typeclass, and note how similar it is to our
        <varname>BasicEq3</varname> typeclass.
    </para>
    <remark>FIXME: do we have rights to quote this?  I figure it is probably
    fair use in any case. -- jg</remark>
    <example id="hs.typeclasses.ex.eq">
      <title>Haskell Standard Eq Typeclass</title>
      <programlisting>
class  Eq a  where
    (==), (/=) :: a -> a -> Bool

        -- Minimal complete definition:
        --      (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)
       </programlisting>
     </example>

  </sect1>

  <sect1 id="hs.typeclasses.instances">
    <title>Declaring typeclass instances</title>
    <para>
      Now that you know how to define typeclasses, it's time to learn how to
      define instances of typeclasses.  An instance is just a type.  Making
      it an instance of a particular typeclass means implementing the
      functions necessary for that typeclass.
    </para>
    <para>
      Recall our attempt to create a test for equality over a
      <literal>Color</literal> type back in <xref
      linkend="hs.typeclasses.ex.naiveeq"/>. <remark>FIXME:
      how can we insert the page number here? --jg</remark>
      Now let's see how we could make that same <literal>Color</literal>
      type a member of the <literal>BasicEq3</literal> class.
    </para>
    &eqclasses.hs:basiceq3inst;
    <para>
      Notice that we provide essentially the same function as we used
      back in <xref linkend="hs.typeclasses.ex.naiveeq"/>.  In fact, the
      implementation is identical.  However, in this case, we can use
      <literal>isEqual3</literal> on <emphasis>any</emphasis> type that
      we declare is an instance of <literal>BasicEq3</literal>, not just
      this one color type.  We could define equality tests for any anything
      from numbers to graphics using the same basic pattern.  In fact, as you
      will see in <xref linkend="hs.typeclasses.wellknown.equality"/>, this
      works the same as making Haskell's <literal>==</literal> operator
      work for your own custom types.
    </para>
    <para>
      Note also that the <literal>BasicEq3</literal> class defined both
      <literal>isEqual3</literal> and <literal>isNotEqual3</literal>, but we
      defined only one of them.  That's because of the default implementation
      contained in <literal>BasicEq3</literal>.  Since we didn't explicitly
      define <literal>isNotEqual3</literal>, the compiler automatically uses
      the default implementation given in the <literal>BasicEq3</literal>
      declaration.
    </para>

  </sect1>

  <sect1 id="hs.typeclasses.wellknown">
    <title>Well-known typeclasses</title>

    <para>
      Now that you're familiar with defining your own typeclasses and making
      your types instances of typeclasses, it's time to introduce you to
      typeclasses that are a standard part of Haskell.  As we mentioned at
      the beginning of this chapter, typeclasses are at the core of some
      imporant aspects of the language.  We'll cover the most common ones
      here.
    </para>

    <sect2 id="hs.typeclasses.wellknown.show">
      <title>Show</title>
      <para>
        The <literal>Show</literal> typeclass is used to convert types to
        <literal>String</literal>s.  It is perhaps most commonly used to
        convert numbers to <literal>String</literal>s, but it is defined for
        so many types that it can be used to convert quite a bit more.  You
        can also, of course, define instances for your own types as well.
      </para>
      <para>
        The most important function of <literal>Show</literal> is
        <literal>show</literal>.  It takes one argument: the type to convert.
        It returns a <literal>String</literal> representing that type.
      </para>
      <para>
        Here is an example usage, from taken from a quick session with ghci:
      </para>
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.read">
      <title>Read</title>
      <para>
        FIXME
      </para>
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.numeric">
      <title>Numeric Types</title>
      <para>
        FIXME
      </para>
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.equality">
      <title>Equality, Ordering, Enum, and Comparisons</title>
      <para>
        FIXME
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.typeclasses.auto.derivation">
    <title>Automatic Derivation</title>
    <para>
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.overlapping">
    <title>Overlapping Instances</title>
    <para>
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.undecidable">
    <title>Undecidable Instances</title>
    <para>
      FIXME
    </para>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
