<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.typeclasses">
  <title>Using Typeclasses</title>

  <para>
    Typeclasses are one of the most powerful features in Haskell.  They
    are also at the heart of some basic language features such as equality
    testing and numeric operators.  Before we talk about what exactly
    typeclasses are, though, we'd like to first explain the need for them.
  </para>

  <sect1 id="hs.typeclasses.need">
    <title>The need for typeclasses</title>
    <para>
      Let's imaging that for some unfathomable reason, the designers of the
      Haskell language neglected to implement the equality test
      <function>==</function>.  Once you got over your shock at hearing this, 
      you resolved to implement your own equality tests.  Your application
      consisted of a simple <type>Color</type> type, and so your first
      equality test is for this type.  Your first attempt might look like
      <xref linkend="hs.typeclasses.ex.naiveeq"/>.
    </para>
    <example id="hs.typeclasses.ex.naiveeq">
      <title>Naive Equality -- Colors (naiveeq.hs)</title>
      &naiveeq.hs:color;
    </example>
    <para>
      You can test this with <application>ghci</application> or
      <application>hugs</application>:
    </para>
    <screen>
$ <userinput>ghci naiveeq.hs</userinput>
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; <userinput>colorEq Red Red</userinput>
True
*Main&gt; <userinput>colorEq Red Blue</userinput>
False
</screen>
    <para>
      Now, let's say that you want to add an equality test for
      <type>String</type>s.
      Since a Haskell <type>String</type> is a list of characters, we can
      write a simple function to perform that test, as seen in <xref
        linkend="hs.typeclasses.ex.naiveeq.string"/>.  For simplicity, we
      cheat a bit and use the <function>==</function> operator a couple
      of times.
    </para>
    <example id="hs.typeclasses.ex.naiveeq.string">
      <title>Naive Equality -- Strings (naiveeq.hs)</title>
      &naiveeq.hs:string;
    </example>
    <para>
      You should now be able to see a problem: we have to define a new
      function for every different type that we want to be able to compare.
      That's inefficient and annoying.  It's much more convenient to be able
      to just use <function>==</function> to compare anything.  As it turns
      out, this is exactly what Haskell's typeclasses are for.  
    </para>
  </sect1>
  <sect1 id="hs.typeclasses.whatarethey">
    <title>What are typeclasses?</title>
    <remark>FIXME: I don't like this explanation, or maybe just not here..
    maybe move to later on. --jg</remark>
    <para>
      Typeclasses define a set of functions that can operate on more than one
      type of data.  A typeclass defines an interface, and perhaps even
      default implementations of functions.  You then create an instance for
      each type that should conform to the typeclass.  Once that is done, a
      function that's part of the typeclass definition can be called with any
      type that's an instance of the typeclass as a parameter.
    </para>
    <para>
      Those familiar with object-oriented programming can think of
      typeclasses as objects in reverse.  In OOP, when you define an object,
      you define what its parent classes are at that time.  You must also
      define how it implements the methods in the parent class, if you need a
      custom implementation.
    </para>
    <para>
      With typeclasses, you have greater freedom.  Let's say that you have a
      type from a third party.  Perhaps that third party didn't make it part
      of a typeclass that you'd like it to be part of.  No problem; you can
      define an instance yourself.  With OOP, the best you can do is subclass
      an object and use multiple inheritance (or, in Java, interfaces) to
      make the child object behave as you like.  But you're still stuck if
      you have a parent object from somewhere.
    </para>

  </sect1>


  <sect1 id="hs.typeclasses.defining">
    <title>Defining new typeclasses</title>
    <para>
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.instances">
    <title>Declaring typeclass instances</title>
    <para>
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.wellknown">
    <title>Well-known typeclasses</title>

    <para>
      FIXME
    </para>

    <sect2 id="hs.typeclasses.wellknown.readshow">
      <title>Read and Show</title>
      <para>
        FIXME
      </para>
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.numeric">
      <title>Numeric Types</title>
      <para>
        FIXME
      </para>
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.equality">
      <title>Equality, Ordering, Enum, and Comparisons</title>
      <para>
        FIXME
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.typeclasses.overlapping">
    <title>Overlapping Instances</title>
    <para>
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.undecidable">
    <title>Undecidable Instances</title>
    <para>
      FIXME
    </para>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
