<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.typeclasses">
  <title>Using Typeclasses</title>

  <para>
    Typeclasses are one of the most powerful features in Haskell.  They
    are also at the heart of some basic language features such as equality
    testing and numeric operators.  Before we talk about what exactly
    typeclasses are, though, we'd like to first explain the need for them.
  </para>

  <sect1 id="hs.typeclasses.need">
    <title>The need for typeclasses</title>
    <para>
      Let's imaging that for some unfathomable reason, the designers of the
      Haskell language neglected to implement the equality test
      <function>==</function>.  Once you got over your shock at hearing this, 
      you resolved to implement your own equality tests.  Your application
      consisted of a simple <type>Color</type> type, and so your first
      equality test is for this type.  Your first attempt might look like
      <xref linkend="hs.typeclasses.ex.naiveeq"/>.
    </para>
    <example id="hs.typeclasses.ex.naiveeq">
      <title>Naive Equality -- Colors (naiveeq.hs)</title>
      &naiveeq.hs:color;
    </example>
    <para>
      You can test this with &ghci; or
      <application>hugs</application>:
    </para>
    <screen>
$ <userinput>ghci naiveeq.hs</userinput>
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; <userinput>colorEq Red Red</userinput>
True
*Main&gt; <userinput>colorEq Red Blue</userinput>
False
</screen>
    <para>
      Now, let's say that you want to add an equality test for
      &String;s.
      Since a Haskell &String; is a list of characters, we can
      write a simple function to perform that test, as seen in <xref
        linkend="hs.typeclasses.ex.naiveeq.string"/>.  For simplicity, we
      cheat a bit and use the <function>==</function> operator a couple
      of times.
    </para>
    <example id="hs.typeclasses.ex.naiveeq.string">
      <title>Naive Equality -- Strings (naiveeq.hs)</title>
      &naiveeq.hs:string;
    </example>
    <para>
      You should now be able to see a problem: we have to define a new
      function for every different type that we want to be able to compare.
      That's inefficient and annoying.  It's much more convenient to be able
      to just use <function>==</function> to compare anything.  As it turns
      out, this is exactly what Haskell's typeclasses are for.  
    </para>
  </sect1>
  <sect1 id="hs.typeclasses.whatarethey">
    <title>What are typeclasses?</title>
    <remark>FIXME: I don't like this explanation, or maybe just not here..
    maybe move to later on. --jg</remark>
    <para>
      Typeclasses define a set of functions that can operate on more than one
      type of data.  A typeclass defines an interface, and perhaps even
      default implementations of functions.  You then create an instance for
      each type that should conform to the typeclass.  Once that is done, a
      function that's part of the typeclass definition can be called with any
      type that's an instance of the typeclass as a parameter.
    </para>
    <para>
      Those familiar with object-oriented programming can think of
      typeclasses as objects in reverse.  In OOP, when you define an object,
      you define what its parent classes are at that time.  You must also
      define how it implements the methods in the parent class, if you need a
      custom implementation.
    </para>
    <para>
      With typeclasses, you have greater freedom.  Let's say that you have a
      type from a third party.  Perhaps that third party didn't make it part
      of a typeclass that you'd like it to be part of.  No problem; you can
      define an instance yourself.  With OOP, the best you can do is subclass
      an object and use multiple inheritance (or, in Java, interfaces) to
      make the child object behave as you like.  But you're still stuck if
      you have a parent object from somewhere.
    </para>

  </sect1>


  <sect1 id="hs.typeclasses.defining">
    <title>Defining new typeclasses</title>
    <para>
      Let's use typeclasses to solve our equality dilemma from earlier in the
      chapter.  The first thing that we need to do is define the typeclass
      itself.  What we want is a function that takes two parameters, both the
      same type, and returns a <type>Bool</type> indicating whether or not
      they are equal.  Here's our first definition of a typeclass:
    </para>
    <remark>FIXME: Should we make this a formal example even though it's short? 
    --jg</remark>
    &eqclasses.hs:basiceq;
    <para>
      This says that we are declaring a typeclass named
      <varname>BasicEq</varname>, and we'll refer to instance types with the
      letter <parameter>a</parameter>.  This typeclass defines one function.
      That function takes two parameters -- both corresponding to instance
      types -- and returns a <type>Bool</type>.
    </para>
    <para>
      On the first line, the name of the parameter <parameter>a</parameter>
      was chosen arbitrarily.  We could have used any name.  The key is that,
      when you list the types of your functions, you must use that name to
      refer to instance types.
    </para>
    <para>
      Let's look at this in &ghci;.  <remark>FIXME:
        insert reference to where this is defined</remark>
      Recall that you
      can type <command>:t</command> in &ghci; to 
      have it show you the type of something.  Let's see what it says about
      <function>isEqual</function>:
    </para>
    <screen>
$ <userinput>ghci eqclasses.hs</userinput>
[1 of 1] Compiling Main             ( eqclasses.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; <userinput>:t isEqual</userinput>
isEqual :: (BasicEq a) => a -> a -> Bool
    </screen>
    <para>
      You can read that this way: "For all types of <type>a</type>, so
      long as <type>a</type> is an instance of
      <varname>BasicEq</varname>, <function>isEqual</function> takes two
      parameters of type <type>a</type> and returns a <type>Bool</type>".
    </para>
    <para>
      Now that we've seen a very simple typeclass, let's expand it a bit.  
      A not-equal-to function might be useful.
      Here's what we might say to define a typeclass with two functions:
    </para>
    <remark>FIXME: formal example? --jg</remark>
    &eqclasses.hs:basiceq2;
    <para>
      Someone providing an instance of <varname>BasicEq2</varname> will
      be required to define two functions: <function>isEqual2</function> and
      <function>isNotEqual2</function>.
    </para>
    <para>
      While our definition of <varname>BasicEq2</varname> is fine, it seems
      that we're making extra work for ourselves.  Logically speaking, if we
      know what <function>isEqual</function> or
      <function>isNotEqual</function> would return, we know how to figure out
      what the other function would return, for all types.  Rather than
      making users of the typeclass define both functions for all types, we
      can provide default implementations for them.  Then, users will only
      have to implement one function.  <xref linkend="hs.typeclasses.ex.basiceq3"/> shows how
      to do this.
    </para>
    <example id="hs.typeclasses.ex.basiceq3">
      <title>BasicEq3 Typeclass Definition (eqclasses.hs)</title>
      &eqclasses.hs:basiceq3;
    </example>
    <para>
      People implementing this class must provide an implementation of at
      least one function.  They can implement both if they wish, but they
      will not be required to.
    </para>
    <para>
      With <varname>BasicEq3</varname>, we have provided a class that does
      very much the same thing as Haskell's built-in <function>==</function>
      and <function>/=</function> operators.  In fact, these operators are
      defined by a typeclass that looks almost identical to
      <varname>BasicEq3</varname>.  The Haskell 98 Report <remark>FIXME: add
        reference? --jg</remark> defines a typeclass that implements equality
      comparison.  See <xref linkend="hs.typeclasses.ex.eq"/> for the built-in
        <varname>Eq</varname> typeclass, and note how similar it is to our
        <varname>BasicEq3</varname> typeclass.
    </para>
    <remark>FIXME: do we have rights to quote this?  I figure it is probably
    fair use in any case. -- jg</remark>
    <example id="hs.typeclasses.ex.eq">
      <title>Haskell Standard Eq Typeclass</title>
      <programlisting>
class  Eq a  where
    (==), (/=) :: a -> a -> Bool

        -- Minimal complete definition:
        --      (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)
       </programlisting>
     </example>

  </sect1>

  <sect1 id="hs.typeclasses.instances">
    <title>Declaring typeclass instances</title>
    <para>
      Now that you know how to define typeclasses, it's time to learn how to
      define instances of typeclasses.  An instance is just a type.  Making
      it an instance of a particular typeclass means implementing the
      functions necessary for that typeclass.
    </para>
    <para>
      Recall our attempt to create a test for equality over a
      <literal>Color</literal> type back in <xref
      linkend="hs.typeclasses.ex.naiveeq"/>. <remark>FIXME:
      how can we insert the page number here? --jg</remark>
      Now let's see how we could make that same <literal>Color</literal>
      type a member of the <literal>BasicEq3</literal> class.
    </para>
    &eqclasses.hs:basiceq3inst;
    <para>
      Notice that we provide essentially the same function as we used
      back in <xref linkend="hs.typeclasses.ex.naiveeq"/>.  In fact, the
      implementation is identical.  However, in this case, we can use
      <literal>isEqual3</literal> on <emphasis>any</emphasis> type that
      we declare is an instance of <literal>BasicEq3</literal>, not just
      this one color type.  We could define equality tests for any anything
      from numbers to graphics using the same basic pattern.  In fact, as you
      will see in <xref linkend="hs.typeclasses.wellknown.equality"/>, this
      works the same as making Haskell's <literal>==</literal> operator
      work for your own custom types.
    </para>
    <para>
      Note also that the <literal>BasicEq3</literal> class defined both
      <literal>isEqual3</literal> and <literal>isNotEqual3</literal>, but we
      defined only one of them.  That's because of the default implementation
      contained in <literal>BasicEq3</literal>.  Since we didn't explicitly
      define <literal>isNotEqual3</literal>, the compiler automatically uses
      the default implementation given in the <literal>BasicEq3</literal>
      declaration.
    </para>

  </sect1>

  <sect1 id="hs.typeclasses.wellknown">
    <title>Well-known typeclasses</title>

    <para>
      Now that you're familiar with defining your own typeclasses and making
      your types instances of typeclasses, it's time to introduce you to
      typeclasses that are a standard part of Haskell.  As we mentioned at
      the beginning of this chapter, typeclasses are at the core of some
      imporant aspects of the language.  We'll cover the most common ones
      here.
    </para>

    <sect2 id="hs.typeclasses.wellknown.show">
      <title>Show</title>
      <para>
        The <literal>Show</literal> typeclass is used to convert types to
        &String;s.  It is perhaps most commonly used to
        convert numbers to &String;s, but it is defined for
        so many types that it can be used to convert quite a bit more.  You
        can also, of course, define instances for your own types as well.
      </para>
      <para>
        The most important function of <literal>Show</literal> is
        <literal>show</literal>.  It takes one argument: the type to convert.
        It returns a &String; representing that type.
        &ghci; reports that this way:
      </para>

      &show.ghci:showtype;

      <para>
        Let's look at some examples of converting numbers to strings:
      </para>
      &show.ghci:showex;
      <para>
        Remember that &ghci; displays results as they would
        be entered into Haskell.  So the expression <literal>show 1</literal>
        returns a single-character string containing the digit
        <literal>1</literal>.  That is, the quotes are not part of the string
        itself.  We can make that clear by using
        <literal>printStrLn</literal>:
      </para>
      &show.ghci:printshowex;
      <para>
        You can also use <literal>show</literal> on
        &String;s:
      </para>
      &show.ghci:showstr;
      <para>
        Running <literal>show</literal> on &String;s can be
        confusing.  Since <literal>show</literal> generates a result that
        is suitable for a Haskell literal, <literal>show</literal> adds
        quotes and escaping suitable for inclusion in a Haskell program.
        &ghci; also uses <literal>show</literal> to
        display results, so quotes and escaping get added twice.  Using
        <literal>putStrLn</literal> can help make this difference clear.
      </para>

      <para>
        You can define a <literal>Show</literal> instance for your own types
        easily.  Here's an example:
      </para>

      &eqclasses.hs:show;

      <para>
        This example defines an instance of <literal>Show</literal> for our
        type 
        <literal>Color</literal> (see <xref
          linkend="hs.typeclasses.ex.naiveeq"/>).  The implementation is
        simple: we define a function <literal>show</literal> and that's all
        that's needed.
      </para>

    </sect2>

    <sect2 id="hs.typeclasses.wellknown.read">
      <title>Read</title>
      <para>
        The &Read; typeclass is essentially the opposite of &Show;: it will
        take a &String;, parse it, and return data in a native Haskell type.
        The most useful function in &Read; is &read;.
        You can ask &ghci; for its type like this:
      </para>

      &read.ghci:readtype;

      <para>
        Here's an example illustrating the use of &read; and &show;:
      </para>

      &read.hs:read;

      <para>
        This is a simple example of &read; and &show; together.  Notice that
        we gave an explicit typecast to &Integer; when processing the &read;.
        That's because &read; returns a value of type
        <literal>Read a => a</literal> and &show; expects a value of type
        <literal>Show a => a</literal>.  There are many, many types that are
        defined for both &Read; and &Show;.  Without knowing a specific type,
        the compiler can't possibly guess from these many types which one is
        needed -- at least not in this case.  Therefore, we give an explicit
        cast.
      </para>
      <para>
        You can see the same effect at work if you try to use &read; on the
        &ghci; command line.  &ghci; internally uses &show; to display
        results, meaning that you can hit this ambiguous typing problem there
        as well.  You'll need to explicitly cast your &read; results in
        &ghci; as shown here:
      </para>
      &read.ghci:readerrors;
      <para>
        Recall the type of &read;:
        <literal>(Read a) => String -&gt; a</literal>.  The
        <literal>a</literal> here is the type of each instance of &Read;.
        Which particular parsing function is called depends upon the type
        that is expected from the return value of &read;.  Let's see how that
        works:
      </para>
      &read.ghci:readtypes;
      <para>
        Notice the error when trying to parse <literal>5.0</literal> as an
        Integer.  The compiler selected a different parser there because the
        return value of &read; was expected to be of a different type.
      </para>
      <para>
        The &Read; class provides for some fairly complicated parsers.  Most
        people, however, choose to use Parsec for complicated parsers these
        days.  <remark>FIXME: insert xref to parsec</remark>  You can 
        define a simple parser by providing an implementation for the
        <literal>readsPrec</literal> function.  Your implementation can
        return a list containing exactly one tuple on a successful parse, or
        an empty list on an unsuccessful parse.  Here's an example
        implementation:
      </para>
      &eqclasses.hs:read;
      <para>
        This example handles the known cases for the three colors.  It
        returns an empty list (resulting in a "no parse" message) for others.
        The function is supposed to return the part of the input that was not
        parsed, so that the system can integrate the parsing of different
        types together.  Here's an example of using this new instance of
        &Read;:
      </para>
      &read.ghci:readcolor;
      <para>
        Notice the error on the final attempt.  That's because our parser is
        not smart enough to handle leading spaces yet.  If we modified it to
        accept leading spaces, that attempt would work.
      </para>
    </sect2>

    <sect2 id="hs.typeclasses.wellknown.numeric">
      <title>Numeric Types</title>
      <para>
        Haskell has a powerful set of numeric types.  You can using everyting
        from fast 32-bit or 64-bit integers to arbitrary-precision rational
        numbers.  Yet you probably know that operators such as
        <literal>+</literal> can work with just about all of these.  This
        feature is implemented using typeclasses.  As a side benefit, it
        allows you to define your own numeric types and make them first-class
        citizens in Haskell.
      </para>
      <para>
        Let's begin our discussion of the typeclasses surrounding nmeric
        types with an examination of the types themselves.  <xref
          linkend="hs.numerictypes.summary"/> describes the most
        commonly-used numeric types in Haskell.  Note that there are also
        many more numeric types available for specific purposes such as
        interfacing to C.
      </para>
      <table id="hs.numerictypes.summary" tocentry="1">
        <title>Selected Numeric Types</title>
        <tgroup cols='2' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&Double;</entry>
              <entry>Double-precision floating point</entry>
            </row>
            <row>
              <entry>&Float;</entry>
              <entry>Single-precision floating point</entry>
            </row>
            <row>
              <entry>&Int;</entry>
              <entry>Fixed-precision signed integer; minimum range [-2^29..2^29-1]</entry>
            </row>
            <row>
              <entry>&Int16;</entry>
              <entry>16-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int32;</entry>
              <entry>32-bit signed integer</entry>
            </row>
            <row>
              <entry>&Int64;</entry>
              <entry>64-bit signed integer</entry>
            </row>
            <row>
              <entry>&Integer;</entry>
              <entry>Arbitrary-precision signed integer; range limited only by
                machine resources</entry>
            </row>
            <row>
              <entry>&Rational;</entry>
              <entry>Arbitrary-precision rational numbers.  Stored as a
                ratio of two &Integer;s.</entry>
            </row>
            <row>
              <entry>&Word;</entry>
              <entry>Fixed-precision unsigned integer; storage size same as
                &Int;</entry>
            </row>
            <row>
              <entry>&Word16;</entry>
              <entry>16-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word32;</entry>
              <entry>32-bit unsigned integer</entry>
            </row>
            <row>
              <entry>&Word64;</entry>
              <entry>64-bit unsigned integer</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
        These are quite a few different numeric types.  There are some
        operations, such as addition, that ought to work with all of them.
        There are others, such as <literal>asin</literal>, that only apply to
        floating-point types.  <xref linkend="hs.numerictypes.funcs"/>
        summarizes the different functions that operate on numeric types,
        <!-- fixme and
        <xref linkend="hs.numerictypes.typeclasses"/> matches the types with
        their respective typeclasses. -->
      </para>

      <remark>FIXME: how to sort the operators?</remark>

      <table id="hs.numerictypes.funcs" tocentry="1">
        <title>Selected Numeric Functions</title>
        <tgroup cols='3' align='left'>
          <colspec colname='c1'/>
          <colspec colname='c2'/>
          <colspec colname='c3'/>
          <thead>
            <row>
              <entry>Function</entry>
              <entry>Type</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>(.&amp;.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Bitwise and</literal></entry>
            </row>
            <row>
              <entry><literal>(.|.)</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Bitwise or</literal></entry>
            </row>
            <row>
              <entry><literal>shift</literal></entry>
              <entry><literal>Bits a => a -> Int -> a</literal></entry>
              <entry><literal>Shift left by the specified number of bits,
                  which may be negative for a right shift.</literal></entry>
            </row>
            <row>
              <entry><literal>xor</literal></entry>
              <entry><literal>Bits a => a -> a -> a</literal></entry>
              <entry><literal>Bitwise exclusive or</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </table>


            <!-- classes:

            Bits
            -->

    </sect2>

    <sect2 id="hs.typeclasses.wellknown.equality">
      <title>Equality, Ordering, Enum, and Comparisons</title>
      <para>
        FIXME
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.typeclasses.auto.derivation">
    <title>Automatic Derivation</title>
    <para>
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.overlapping">
    <title>Overlapping Instances</title>
    <para>
      FIXME
    </para>
  </sect1>

  <sect1 id="hs.typeclasses.undecidable">
    <title>Undecidable Instances</title>
    <para>
      FIXME
    </para>
  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "chapter")
end:
-->
