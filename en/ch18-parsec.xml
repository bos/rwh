<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="hs.parsec" revision="alpha">
  <title>Using Parsec</title>
  <remark>FIXME: do we still want to discuss parsing non-character data and
  a configuration file?</remark>
  <para id="x_DJ">
    The task of parsing a file, or data of various types, is a common one for
    programmers.  You already learned about Haskell's support for regular
    expressions back in <xref linkend="hs.glob.regex"/>.  Regular expressions
    are nice for many tasks.  But they can become quite complex and difficult
    when dealing with a data format that is complex.  For instance, you
    probably wouldn't want to use regular expressions to parse C source code.
  </para>

  <para id="x_EJ">
    Haskell has a very useful and unique library called Parsec.  Parsec
    is a parser combinator library.  With Parsec, you will combine small
    parsing functions together to build up more complex parsers.  Parsec
    provides some simple parsing functions, as well as functions to tie them
    all together.  It should come as no surprise that this parser library for
    Haskell is built around the notion of functions.
  </para>

  <para id="x_FJ">
    Those of you that are familiar with parser tools in other languages may
    be interested to know that Parsec can take the place of both parser tools
    such as Yacc and lexers such as flex.  Parsec can also be used to
    implement a single-stange parser.
  </para>

  <para id="x_GJ">
    In this chapter, we will use Parsec to build up a parser for CSV files.
    We will also use Parsec to build a more complex parser for sectioned 
    configuration files.
  </para>
  <sect1 id="hs.parsec.firststeps">
    <title>First Steps with Parsec: Simple CSV Parsing</title>
    <para id="x_HJ">
      Let's jump right in by writing some code for parsing a CSV file.
      CSV files are often used as a plain text representation of spreadsheets
      or databases.  Each line is a record, and each field in the record is
      separated from the next by a comma.  There are ways of dealing with
      fields that contain commas, but to start with, we won't worry about it.
    </para>
    <para id="x_IJ">
      This first example is much longer than it really needs to be.  We will
      introduce more Parsec features in a little bit that will shrink the
      parser down to only four lines!
    </para>
    &csv1.hs:all;
    <para id="x_JJ">
      Before looking at all this code in detail, 
      let's play with it a bit and see what
      it does.
    </para>
    &csv1.ghci:s1;
    <para id="x_KJ">
      That makes sense: parsing the empty string returns an empty list.
      Let's try parsing a single cell.
    </para>
    &csv1.ghci:s2;
    <para id="x_LJ">
      Look at that.  Recall how we defined that each line must end with the
      end-of-line character, and we didn't give it.  Parsec's error message
      helpfully indicated the line number and column number of the problem,
      and even told us what it was expecting!  Let's give it an end-of-line
      character and continue experimenting.
    </para>
    &csv1.ghci:s3;
    <para id="x_MJ">
      You can see that <literal>parseCSV</literal> is doing exactly what we
      wanted it to do.  It's even handling empty cells and empty lines
      properly.
    </para>
    <para id="x_NJ">
      Let's take a look at the code for this example.  We didn't use many
      shortcuts here, so remember that this will get shorter and simpler!
    </para>
    <para id="x_OJ">
      We've built it from the
      top down,
      so our first function is <literal>csvFile</literal>.  The type of this
      function is <literal>GenParser Char st [[String]]</literal>.  This
      means that the type of the input is a sequence of characters, which is
      exactly what a Haskell string is, since <literal>String</literal> is
      the same as <literal>[Char]</literal>.  It also means that we will
      return a value of type <literal>[[String]]</literal>: a list of a list
      of strings.  The <literal>st</literal> can be ignored for now.
    </para>
    <para id="x_PJ">
      Parsec programmers usually omit type declarations, since we write so
      many small functions.  Haskell's type inference can figure it out.
      We've listed the types for the first example here so you can get a
      better idea of what's going on.  You can always use
      <literal>:t</literal> in &ghci; to inspect types as well.
    </para>
    <para id="x_QJ">
      The <literal>csvFile</literal> uses a &do; block.  Parsec is a monadic
      parser combinator, but we are not using the &IO; monad here.
      As we discussed in <remark>fixme: insert ref</remark>, not all monads
      are &IO; monads.
    </para>
    <para id="x_RJ">
      We start by running <literal>many line</literal>.
      <literal>many</literal> is a function that takes a function as an
      argument.  It tries to repeatedly
      parse the input using the function passed to it.  It gathers up the
      results from all that repeated parsing and returns a list of them.  So,
      here, we are storing the results of parsing all lines in
      <literal>result</literal>.  Then we look for the end-of-file indicator,
      called <literal>eof</literal>.  Finally, we return the
      <literal>result</literal>.  So, a CSV file is made of of many lines,
      then the end of file.  You can often read out Parsec functions in plain
      English just like that.
    </para>
    <para id="x_SJ">
      Now we must answer the question: what is a line?  We define the
      <literal>line</literal> function to do just that.  Reading the
      function, we can see that a line consists of cells followed by the end
      of line character.
    </para>
    <para id="x_TJ">
      So what are cells?  We defined them in the <literal>cells</literal>
      function.  The cells of a line start with the content of the first
      cell, then continue with the content of the remaining cells, if any.
      The result is simply the first cell and the remaining cells assembled
      into a list.
    </para>
    <para id="x_UJ">Let's skip over <literal>remainingCells</literal> for a minute and
      look at <literal>cellContent</literal>.  A cell contains any number of
      characters, but each character must not be a comma or end of line
      character.  The <literal>noneOf</literal> function matches one item, so
      long as it isn't in the list of items that we pass.  So, saying
      <literal>many (noneOf ",\n")</literal> defines a cell the way we want
      it.
    </para>
    <para id="x_VJ">
      Back in <literal>remainingCells</literal>, we have the first example of
      a choice in Parsec.  The choice operator is &PChoice;.  This operator
      behaves like this: it will first try the parser on the left.  If it
      consumed no input, it will try the parser on the right.
    </para>
    <para id="x_WJ">
      So, in <literal>remainingCells</literal>, our task is to come up with
      all the cells after the first.  Recall that
      <literal>cellContent</literal> uses <literal>noneOf ",\n"</literal>.
      So it will not consume the comma or end-of-line character from the
      input.  If we see a comma after parsing a cell, it means that at least
      one more cell follows.  Otherwise, we're done.  So, our first choice in
      <literal>remainingCells</literal> is <literal>char ','</literal>.  This
      parser simply matches the passed character in the input.  If we found a
      comma, we want this function to return the remaining cells on the line.
      At this point, the "remaining cells" looks exactly like the start of
      the line, so we call <literal>cells</literal> recursively to parse
      them.  If we didn't find a comma, we return the empty list, signifying
      no remaining cells on the line.
    </para>
    <para id="x_XJ">
      Finally, we must define what the end-of-line indicator is.  We set it
      to <literal>char '\n'</literal>, which will suit our purposes fine for
      now.
    </para>
    <para id="x_YJ">
      At the very end of the program, we define a function
      <literal>parseCSV</literal> that takes a &String; and parses it as a
      CSV file.  This function is just a shortcut that calls Parsec's
      <literal>parse</literal> function, filling in a few parameters.
      <literal>parse</literal> returns <literal>Either ParseError
        [[String]]</literal> for the CSV file.  If there was an error, the
      return vaule will be &Left; with the error; otherwise, it will be
      &Right; with the result.
    </para>
  </sect1>

  <sect1 id="hs.parsec.sep">
    <title>The sepBy and endBy Combinators</title>
    <para id="x_ZJ">
      We promised you earlier that we could simply our CSV parser
      significantly by using a few Parsec helper functions.  There are two
      that will dramatically simplify this code.  The first is
      <literal>endBy</literal>, which takes two functions.  It applies the
      first function, notes its result, then applies the second.  It will do
      this over and over, and return a list of the results from the first
      function.
    </para>
    <para id="x_aJ">
      The second tool for us is <literal>sepBy</literal>.  It's like
      <literal>endBy</literal>, but expects the very last item to not end
      with the separator.
    </para>
    <para id="x_bJ">
      So, we can use <literal>endBy</literal> to parse lines, since every
      line must end with the end-of-line character.  We can use
      <literal>sepBy</literal> to parse cells, since the last cell will not
      end with a comma.  Take a look at how much simpler our parser is now:
    </para>
    &csv2.hs:all;
    <para id="x_cJ">
      This program behaves exactly the same as the first one.  You can verify
      that by using &ghci; to re-run our examples from the earlier example.
      You'll get the same result from every one.  Yet the program is much
      shorter and more readable.  It won't be long before you can translate
      Parsec code like this into a file format definition in plain English.
      As you read over this code, you can see that:
    </para>
    <itemizedlist>
      <listitem><para id="x_dJ">A CSV file contains 0 or more lines, 
          each of which is terminated
          by the end-of-line character.</para></listitem>
      <listitem><para id="x_eJ">A line contains 0 or more cells, separated by a comma.
        </para>
      </listitem>
      <listitem><para id="x_fJ">A cell contains 0 or more characters, which must be
          neither the comma nor the end-of-line character.
        </para>
      </listitem>
      <listitem><para id="x_gJ">The end-of-line character is the newline,
          <literal>\n</literal>.
        </para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="hs.parsec.choices">
    <title>Choices and Errors</title>
    <para id="x_hJ">
      Different operating systems use different characters to mark the
      end-of-line.  Unix/Linux systems, plus Windows in text mode, use
      simply <literal>"\n"</literal>.
      <remark>FIXME: verify this on Windows</remark>  
      DOS and Windows systems use <literal>"\n\r"</literal>, and Macs
      traditionally use <literal>"\r\n"</literal>.  We could also support
      a bare <literal>"\r"</literal> in case anybody uses that.
    </para>
    <para id="x_iJ">
      We could easily adapt our example to be able to handle all these types
      of line endings in a single file.  We would need to make two
      modifications: adjust <literal>eol</literal> to recognize the different
      endings, and adjust the <literal>noneOf</literal> pattern in
      <literal>cell</literal> to ignore <literal>\r</literal>.
    </para>
    <para id="x_jJ">
      This must be done carefully.  Recall that our earlier definition of
      <literal>eol</literal> was simply <literal>char '\n'</literal>.  There
      is a parser called <literal>string</literal> that we can use to match
      the multi-character patterns.  Let's start by thinking of how we would
      add support for <literal>\n\r</literal>.
    </para>
    <para id="x_kJ">
      Our first attempt might look like this:
    </para>
    &csv3.hs:eol;
    <para id="x_lJ">
      This isn't quite right.  Recall that the &PChoice; operator always
      tries the left alternative first.  Looking for the single character
      <literal>\n</literal> will match both types of line endings, so it will
      look to the system that the following line begins with
      <literal>\r</literal>.  Not what we want.  Try it in &ghci;:
    </para>
    &csv3.ghci:s1;
    <para id="x_mJ">
      It may look like it worked for both endings, but actually looking at it
      this way, we can't tell.  If it left something un-parsed, we don't
      know, because we're not looking for anything else.  So let's look for
      the end-of-file after our end of line:
    </para>
    &csv3.ghci:s2;
    <para id="x_nJ">
      As expected, we got an error from the <literal>\n\r</literal> ending.
      So the next temptation may
      be to try it this way:
    </para>
    &csv4.hs:eol;
    <para id="x_oJ">
      This also isn't right.  Recall that &PChoice; only attempts the option
      on the right of the option on the left consumed no input.  But by the
      time we are able to see if there is a <literal>\r</literal> after the
      <literal>\n</literal>, we've already consumed the
      <literal>\n</literal>.  This time, we fail on the other case in &ghci;:
    </para>
    &csv4.ghci:s1;
    <para id="x_pJ">
      We've stumbled upon the lookahead problem.  It turns out that, when
      writing parsers, it's often very convenient to be able to "look ahead"
      at the data that's coming in.  Parsec supports this, but before showing
      you how to use it, let's see how you would have to write this to get
      along without it.  You'd have to manually expand all the options after
      the <literal>\n</literal> like this:
    </para>
    &csv5.hs:eol;
    <para id="x_qJ">
      This function first looks for <literal>\n</literal>.  If it is found,
      then it will look for <literal>\r</literal>, consuming it if possible.
      Since the return type of <literal>char '\r'</literal> is a
      <literal>Char</literal>, the alternative action is to simply return a
      <literal>Char</literal> without attempting to parse anything.  Parsec
      has a function <literal>option</literal> that can also express this
      idiom as <literal>option '\n' (char '\r')</literal>.  Let's test this
      with &ghci;.
    </para>
    &csv5.ghci:s1;
    <para id="x_rJ">
      This time, we got the right result!  But we could have done it easier
      with Parsec's lookahead support.
    </para>
    <sect2 id="hs.parsec.lookahead">
      <title>Lookahead</title>
      <para id="x_sJ">
        Parsec has a function called &try; that is used to express
        lookaheads.  &try; takes one function, a parser.  It applies that
        parser.  If the parser doesn't succeed, &try; behaves as if it hadn't
        consumed any input at all.  So, when you use &try; on the left side
        of &PChoice;, Parsec will try the option on the right even if the
        lift side failed after consuming some input.  &try; only has an
        effect if it is on the left of a &PChoice;.  Keep in mind, though,
        that many functions use
        &PChoice; interally.  Sometimes you may want
        to add it to your code just in case it will be used on the left of a
        &PChoice;, and that works fine.  Here's a way to add
        expanded end-of-line support to our CSV parser using &try;:
      </para>
      &csv6.hs:all;
      <para id="x_tJ">
        Here we put both of the two-character endings first, and run both
        tests under &try;.  Both of them occur to the left of a &PChoice;, so
        they will do the right thing.  We could have put <literal>string
          "\n"</literal> within a &try;, but it wouldn't have altered any
        behavior since they look at only one character anyway.  We can load
        this up and test the <literal>eol</literal> function in &ghci;.
      </para>
      &csv6.ghci:s1;
      <para id="x_uJ">
        All four endings were handled properly.  You can also test the full
        CSV parser with some different endings like this:
      </para>
      &csv6.ghci:s2;
      <para id="x_vJ">
        As you can see, this program even supports different line endings
        within a single file.
      </para>
    </sect2>

    <sect2 id="hs.parsec.error">
      <title>Error Handling</title>
      <para id="x_wJ">
        At the beginning of this chapter, you saw how Parsec could generate
        error messages that list the location where the error occured as well
        as what was expected.  As parsers get more complex, the list of what
        was expected can become cumbersome.  Parsec provides a way for you to
        specify custom error messages in the event of parse failures.
      </para>
      <para id="x_xJ">
        Let's look at what happens on an error when our current CSV parser:
      </para>
      &csv6.ghci:error;
      <para id="x_yJ">
        That's a pretty long, and technical, error message.  We could make an
        attempt to resolve this by using the monad &fail; function like so:
      </para>
      &csv7.hs:eol;
      <para id="x_zJ">
        Under &ghci;, we can see the result:
      </para>
      &csv7.ghci:s1;
      <para id="x_AK">
        We added to the error result, but didn't really help clean up the
        output.  Parsec has an &PQ; operator that is designed for just these
        situations.  It is similar to &PChoice; in that it first tries the
        parser on its left.  Instead of trying another parser in the event of
        a failure, it presents an error message.  Here's how we'd use it:
      </para>
      &csv8.hs:eol;
      <para id="x_BK">
        Now, when you generate an error, you'll get more helpful output:
      </para>
      &csv8.ghci:s1;
      <para id="x_CK">
        That's pretty helpful!  The general rule of thumb is that you put a
        human description of what you're looking for to the right of
        &PQ;.
      </para>
    </sect2>
  </sect1>

  <sect1 id="hs.csv">
    <title>Extended Example: Full CSV Parser</title>
    <para id="x_DK">
      Our earlier CSV examples have had an important flaw: they weren't able
      to handle cells that contain a comma.  CSV generating programs
      typically put quotation marks around such data.  But then you have
      another problem: what to do if a cell contains a quotation mark and a
      comma.  In these cases, the embedded quotation marks are doubled up.
    </para>
    <para id="x_EK">
      Here is a full CSV parser.  You can use this from &ghci;, or if you
      compile it to a standalone program, it will parse a CSV file on
      standard input and convert it a different format on output.
    </para>
    &csv9.hs:all;
    <para id="x_FK">
      That's a full-featured CSV parser in just 21 lines of code, plus an
      additional 10 lines for the <literal>parseCSV</literal> and
      <literal>main</literal> utility functions.
    </para>
    <para id="x_GK">
      Let's look at the changes in this program from the previous versions.
      First, a cell may now be either a bare cell or a "quoted" cell.  We
      give the <literal>quotedCell</literal> option first, because we want to
      follow that path if the first character in a cell is the quote mark.
    </para>
    <para id="x_HK">
      The <literal>quotedCell</literal> begins and ends with a quote mark,
      and contains zero or more characters.  These characters can't be copied
      directly, though, because they may contain embedded, doubled-up, quote
      marks themselves.  So we define a custom <literal>quotedChar</literal>
      to process them.
    </para>
    <para id="x_IK">
      When we're processing characters inside a quoted cell, we first say
      <literal>noneOf "\""</literal>.  This will match and return any single
      character as long as it's not the quote mark.  Otherwise, if it is the
      quote mark, we see if we have two of them in a row.  If so, we return a
      single quote mark to go on our result string.
    </para>
    <para id="x_JK">
      Notice that &try; in <literal>quotedChar</literal> on the
      <emphasis>right</emphasis> side of &PChoice;.  Recall that I said that
      &try; only has an effect if it is on the left side of &PChoice;.  This
      &try; does occur on the left side of a &PChoice;, but on the left of
      one that must be within the implementation of <literal>many</literal>.
    </para>
    <para id="x_KK">
      This &try; is actually quite important.  Let's say you are parsing a
      quoted cell and are getting towards the end of it.  There will be
      another cell following.  So you will expect to see a quote to end the
      current cell, followed by a comma.  When you hit
      <literal>quotedChar</literal>, you will fail the
      <literal>noneOf</literal> test and proceed to the test that looks for
      two quotes in a row.  You'll also fail that one because you'll have a
      quote, then a comma.  If you hadn't used &try;, you'd crash with an
      error at this point, saying that it was expecting the second quote,
      because the first quote was already consumed.  Since we use &try;, this
      is properly recognized as not a character that's part of the cell, so
      it terminates the <literal>many quotedChar</literal> expression as
      expected.  Lookahead has once again proven very useful, and the fact
      that it is so easy to add makes it a remarkable tool in Parsec.
    </para>
    <para id="x_LK">
      You can test this program with &ghci; over some quoted cells:
    </para>
    &csv9.ghci:s1;
    <para id="x_MK">
      Let's run it over a real CSV file.  Here's a CSV file generated by a
      spreadsheet program:
    </para>
    <programlisting>
"Product","Price"
"O'Reilly Socks",10
"Shirt with ""Haskell"" text",20
"Shirt, ""O'Reilly"" version",20
"Haskell Caps",15
    </programlisting>
    <para id="x_NK">
      Now, we can run this under our test program and watch:
    </para>
    <screen>
$ <userinput>runhaskell csv9.hs &lt; test.csv</userinput>
["Product","Price"]
["O'Reilly Socks","10"]
["Shirt with \"Haskell\" text","20"]
["Shirt, \"O'Reilly\" version","20"]
["Haskell Caps","15"]
    </screen>
  </sect1>
</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
