<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="parsec" revision="alpha;beta">
  <title>Using Parsec</title>
  <remark>FIXME: do we still want to discuss parsing non-character data and
  a configuration file?</remark>
  <para id="x_DJ">
    The task of parsing a file, or data of various types, is a common one for
    programmers.  You already learned about Haskell's support for regular
    expressions back in <xref linkend="glob.regex"/>.  Regular expressions
    are nice for many tasks.  But they can become quite complex and difficult
    when dealing with a data format that is complex.  For instance, you
    probably wouldn't want to use regular expressions to parse C source code.
  </para>

  <para id="x_EJ">
    Haskell has a very useful and unique library called Parsec.  Parsec
    is a parser combinator library.  With Parsec, you will combine small
    parsing functions together to build up more complex parsers.  Parsec
    provides some simple parsing functions, as well as functions to tie them
    all together.  It should come as no surprise that this parser library for
    Haskell is built around the notion of functions.
  </para>

  <para id="x_FJ">
    Those of you that are familiar with parser tools in other languages may
    be interested to know that Parsec can take the place of both parser tools
    such as Yacc and lexers such as flex.  Parsec can also be used to
    implement a single-stange parser.
  </para>

  <para id="x_GJ">
    In this chapter, we will use Parsec to build up a parser for CSV files.
    We will also use Parsec to build a more complex parser for sectioned 
    configuration files.
  </para>
  <sect1 id="parsec.firststeps">
    <title>First Steps with Parsec: Simple CSV Parsing</title>
    <para id="x_HJ">
      Let's jump right in by writing some code for parsing a CSV file.
      CSV files are often used as a plain text representation of spreadsheets
      or databases.  Each line is a record, and each field in the record is
      separated from the next by a comma.  There are ways of dealing with
      fields that contain commas, but to start with, we won't worry about it.
    </para>
    <para id="x_IJ">
      This first example is much longer than it really needs to be.  We will
      introduce more Parsec features in a little bit that will shrink the
      parser down to only four lines!
    </para>
    &csv1.hs:all;
    <para id="x_JJ">
      Before looking at all this code in detail, 
      let's play with it a bit and see what
      it does.
    </para>
    &csv1.ghci:s1;
    <para id="x_KJ">
      That makes sense: parsing the empty string returns an empty list.
      Let's try parsing a single cell.
    </para>
    &csv1.ghci:s2;
    <para id="x_LJ">
      Look at that.  Recall how we defined that each line must end with the
      end-of-line character, and we didn't give it.  Parsec's error message
      helpfully indicated the line number and column number of the problem,
      and even told us what it was expecting!  Let's give it an end-of-line
      character and continue experimenting.
    </para>
    &csv1.ghci:s3;
    <para id="x_MJ">
      You can see that <literal>parseCSV</literal> is doing exactly what we
      wanted it to do.  It's even handling empty cells and empty lines
      properly.
    </para>
    <para id="x_NJ">
      Let's take a look at the code for this example.  We didn't use many
      shortcuts here, so remember that this will get shorter and simpler!
    </para>
    <para id="x_OJ">
      We've built it from the
      top down,
      so our first function is <literal>csvFile</literal>.  The type of this
      function is <literal>GenParser Char st [[String]]</literal>.  This
      means that the type of the input is a sequence of characters, which is
      exactly what a Haskell string is, since <literal>String</literal> is
      the same as <literal>[Char]</literal>.  It also means that we will
      return a value of type <literal>[[String]]</literal>: a list of a list
      of strings.  The <literal>st</literal> can be ignored for now.
    </para>
    <para id="x_PJ">
      Parsec programmers usually omit type declarations, since we write so
      many small functions.  Haskell's type inference can figure it out.
      We've listed the types for the first example here so you can get a
      better idea of what's going on.  You can always use
      <literal>:t</literal> in &ghci; to inspect types as well.
    </para>
    <para id="x_QJ">
      The <literal>csvFile</literal> uses a &do; block.  As this
      implies, Parsec is a monadic library: it defines its own special
      parsing monad, <type>GenParser</type>.
    </para>
    <para id="x_RJ">
      We start by running <literal>many line</literal>.
      <literal>many</literal> is a function that takes a function as an
      argument.  It tries to repeatedly
      parse the input using the function passed to it.  It gathers up the
      results from all that repeated parsing and returns a list of them.  So,
      here, we are storing the results of parsing all lines in
      <literal>result</literal>.  Then we look for the end-of-file indicator,
      called <literal>eof</literal>.  Finally, we return the
      <literal>result</literal>.  So, a CSV file is made of of many lines,
      then the end of file.  You can often read out Parsec functions in plain
      English just like that.
    </para>
    <para id="x_SJ">
      Now we must answer the question: what is a line?  We define the
      <literal>line</literal> function to do just that.  Reading the
      function, we can see that a line consists of cells followed by the end
      of line character.
    </para>
    <para id="x_TJ">
      So what are cells?  We defined them in the <literal>cells</literal>
      function.  The cells of a line start with the content of the first
      cell, then continue with the content of the remaining cells, if any.
      The result is simply the first cell and the remaining cells assembled
      into a list.
    </para>
    <para id="x_UJ">Let's skip over <literal>remainingCells</literal> for a minute and
      look at <literal>cellContent</literal>.  A cell contains any number of
      characters, but each character must not be a comma or end of line
      character.  The <literal>noneOf</literal> function matches one item, so
      long as it isn't in the list of items that we pass.  So, saying
      <literal>many (noneOf ",\n")</literal> defines a cell the way we want
      it.
    </para>
    <para id="x_VJ">
      Back in <literal>remainingCells</literal>, we have the first example of
      a choice in Parsec.  The choice operator is &PChoice;.  This operator
      behaves like this: it will first try the parser on the left.  If it
      consumed no input, it will try the parser on the right.
    </para>
    <para id="x_WJ">
      So, in <literal>remainingCells</literal>, our task is to come up with
      all the cells after the first.  Recall that
      <literal>cellContent</literal> uses <literal>noneOf ",\n"</literal>.
      So it will not consume the comma or end-of-line character from the
      input.  If we see a comma after parsing a cell, it means that at least
      one more cell follows.  Otherwise, we're done.  So, our first choice in
      <literal>remainingCells</literal> is <literal>char ','</literal>.  This
      parser simply matches the passed character in the input.  If we found a
      comma, we want this function to return the remaining cells on the line.
      At this point, the "remaining cells" looks exactly like the start of
      the line, so we call <literal>cells</literal> recursively to parse
      them.  If we didn't find a comma, we return the empty list, signifying
      no remaining cells on the line.
    </para>
    <para id="x_XJ">
      Finally, we must define what the end-of-line indicator is.  We set it
      to <literal>char '\n'</literal>, which will suit our purposes fine for
      now.
    </para>
    <para id="x_YJ">
      At the very end of the program, we define a function
      <literal>parseCSV</literal> that takes a &String; and parses it as a
      CSV file.  This function is just a shortcut that calls Parsec's
      <literal>parse</literal> function, filling in a few parameters.
      <literal>parse</literal> returns <literal>Either ParseError
        [[String]]</literal> for the CSV file.  If there was an error, the
      return vaule will be &Left; with the error; otherwise, it will be
      &Right; with the result.
    </para>
  </sect1>

  <sect1 id="parsec.sep">
    <title>The sepBy and endBy Combinators</title>
    <para id="x_ZJ">
      We promised you earlier that we could simplify our CSV parser
      significantly by using a few Parsec helper functions.  There are two
      that will dramatically simplify this code.  The first is
      <literal>endBy</literal>, which takes two functions.  It applies the
      first function, notes its result, then applies the second.  It will do
      this over and over, and return a list of the results from the first
      function.
    </para>
    <para id="x_aJ">
      The second tool for us is <literal>sepBy</literal>.  It's like
      <literal>endBy</literal>, but expects the very last item to not end
      with the separator.
    </para>
    <para id="x_bJ">
      So, we can use <literal>endBy</literal> to parse lines, since every
      line must end with the end-of-line character.  We can use
      <literal>sepBy</literal> to parse cells, since the last cell will not
      end with a comma.  Take a look at how much simpler our parser is now:
    </para>
    &csv2.hs:all;
    <para id="x_cJ">
      This program behaves exactly the same as the first one.  You can verify
      that by using &ghci; to re-run our examples from the earlier example.
      You'll get the same result from every one.  Yet the program is much
      shorter and more readable.  It won't be long before you can translate
      Parsec code like this into a file format definition in plain English.
      As you read over this code, you can see that:
    </para>
    <itemizedlist>
      <listitem><para id="x_dJ">A CSV file contains 0 or more lines, 
          each of which is terminated
          by the end-of-line character.</para></listitem>
      <listitem><para id="x_eJ">A line contains 0 or more cells, separated by a comma.
        </para>
      </listitem>
      <listitem><para id="x_fJ">A cell contains 0 or more characters, which must be
          neither the comma nor the end-of-line character.
        </para>
      </listitem>
      <listitem><para id="x_gJ">The end-of-line character is the newline,
          <literal>\n</literal>.
        </para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="parsec.choices">
    <title>Choices and Errors</title>
    <para id="x_hJ">
      Different operating systems use different characters to mark the
      end-of-line.  Unix/Linux systems, plus Windows in text mode, use
      simply <literal>"\n"</literal>.
      <remark>FIXME: verify this on Windows</remark>  
      DOS and Windows systems use <literal>"\n\r"</literal>, and Macs
      traditionally use <literal>"\r\n"</literal>.  We could also support
      a bare <literal>"\r"</literal> in case anybody uses that.
    </para>
    <para id="x_iJ">
      We could easily adapt our example to be able to handle all these types
      of line endings in a single file.  We would need to make two
      modifications: adjust <literal>eol</literal> to recognize the different
      endings, and adjust the <literal>noneOf</literal> pattern in
      <literal>cell</literal> to ignore <literal>\r</literal>.
    </para>
    <para id="x_jJ">
      This must be done carefully.  Recall that our earlier definition of
      <literal>eol</literal> was simply <literal>char '\n'</literal>.  There
      is a parser called <literal>string</literal> that we can use to match
      the multi-character patterns.  Let's start by thinking of how we would
      add support for <literal>\n\r</literal>.
    </para>
    <para id="x_kJ">
      Our first attempt might look like this:
    </para>
    &csv3.hs:eol;
    <para id="x_lJ">
      This isn't quite right.  Recall that the &PChoice; operator always
      tries the left alternative first.  Looking for the single character
      <literal>\n</literal> will match both types of line endings, so it will
      look to the system that the following line begins with
      <literal>\r</literal>.  Not what we want.  Try it in &ghci;:
    </para>
    &csv3.ghci:s1;
    <para id="x_mJ">
      It may look like it worked for both endings, but actually looking at it
      this way, we can't tell.  If it left something un-parsed, we don't
      know, because we're not looking for anything else.  So let's look for
      the end-of-file after our end of line:
    </para>
    &csv3.ghci:s2;
    <para id="x_nJ">
      As expected, we got an error from the <literal>\n\r</literal> ending.
      So the next temptation may
      be to try it this way:
    </para>
    &csv4.hs:eol;
    <para id="x_oJ">
      This also isn't right.  Recall that &PChoice; only attempts the option
      on the right of the option on the left consumed no input.  But by the
      time we are able to see if there is a <literal>\r</literal> after the
      <literal>\n</literal>, we've already consumed the
      <literal>\n</literal>.  This time, we fail on the other case in &ghci;:
    </para>
    &csv4.ghci:s1;
    <para id="x_pJ">
      We've stumbled upon the lookahead problem.  It turns out that, when
      writing parsers, it's often very convenient to be able to "look ahead"
      at the data that's coming in.  Parsec supports this, but before showing
      you how to use it, let's see how you would have to write this to get
      along without it.  You'd have to manually expand all the options after
      the <literal>\n</literal> like this:
    </para>
    &csv5.hs:eol;
    <para id="x_qJ">
      This function first looks for <literal>\n</literal>.  If it is found,
      then it will look for <literal>\r</literal>, consuming it if possible.
      Since the return type of <literal>char '\r'</literal> is a
      <literal>Char</literal>, the alternative action is to simply return a
      <literal>Char</literal> without attempting to parse anything.  Parsec
      has a function <literal>option</literal> that can also express this
      idiom as <literal>option '\n' (char '\r')</literal>.  Let's test this
      with &ghci;.
    </para>
    &csv5.ghci:s1;
    <para id="x_rJ">
      This time, we got the right result!  But we could have done it easier
      with Parsec's lookahead support.
    </para>
    <sect2 id="parsec.lookahead">
      <title>Lookahead</title>
      <para id="x_sJ">
        Parsec has a function called &try; that is used to express
        lookaheads.  &try; takes one function, a parser.  It applies that
        parser.  If the parser doesn't succeed, &try; behaves as if it hadn't
        consumed any input at all.  So, when you use &try; on the left side
        of &PChoice;, Parsec will try the option on the right even if the
        lift side failed after consuming some input.  &try; only has an
        effect if it is on the left of a &PChoice;.  Keep in mind, though,
        that many functions use
        &PChoice; interally.  Sometimes you may want
        to add it to your code just in case it will be used on the left of a
        &PChoice;, and that works fine.  Here's a way to add
        expanded end-of-line support to our CSV parser using &try;:
      </para>
      &csv6.hs:all;
      <para id="x_tJ">
        Here we put both of the two-character endings first, and run both
        tests under &try;.  Both of them occur to the left of a &PChoice;, so
        they will do the right thing.  We could have put <literal>string
          "\n"</literal> within a &try;, but it wouldn't have altered any
        behavior since they look at only one character anyway.  We can load
        this up and test the <literal>eol</literal> function in &ghci;.
      </para>
      &csv6.ghci:s1;
      <para id="x_uJ">
        All four endings were handled properly.  You can also test the full
        CSV parser with some different endings like this:
      </para>
      &csv6.ghci:s2;
      <para id="x_vJ">
        As you can see, this program even supports different line endings
        within a single file.
      </para>
    </sect2>

    <sect2 id="parsec.error">
      <title>Error Handling</title>
      <para id="x_wJ">
        At the beginning of this chapter, you saw how Parsec could generate
        error messages that list the location where the error occured as well
        as what was expected.  As parsers get more complex, the list of what
        was expected can become cumbersome.  Parsec provides a way for you to
        specify custom error messages in the event of parse failures.
      </para>
      <para id="x_xJ">
        Let's look at what happens on an error when our current CSV parser:
      </para>
      &csv6.ghci:error;
      <para id="x_yJ">
        That's a pretty long, and technical, error message.  We could make an
        attempt to resolve this by using the monad &fail; function like so:
      </para>
      &csv7.hs:eol;
      <para id="x_zJ">
        Under &ghci;, we can see the result:
      </para>
      &csv7.ghci:s1;
      <para id="x_AK">
        We added to the error result, but didn't really help clean up the
        output.  Parsec has an &PQ; operator that is designed for just these
        situations.  It is similar to &PChoice; in that it first tries the
        parser on its left.  Instead of trying another parser in the event of
        a failure, it presents an error message.  Here's how we'd use it:
      </para>
      &csv8.hs:eol;
      <para id="x_BK">
        Now, when you generate an error, you'll get more helpful output:
      </para>
      &csv8.ghci:s1;
      <para id="x_CK">
        That's pretty helpful!  The general rule of thumb is that you put a
        human description of what you're looking for to the right of
        &PQ;.
      </para>
    </sect2>
  </sect1>

  <sect1 id="csv">
    <title>Extended Example: Full CSV Parser</title>
    <para id="x_DK">
      Our earlier CSV examples have had an important flaw: they weren't able
      to handle cells that contain a comma.  CSV generating programs
      typically put quotation marks around such data.  But then you have
      another problem: what to do if a cell contains a quotation mark and a
      comma.  In these cases, the embedded quotation marks are doubled up.
    </para>
    <para id="x_EK">
      Here is a full CSV parser.  You can use this from &ghci;, or if you
      compile it to a standalone program, it will parse a CSV file on
      standard input and convert it a different format on output.
    </para>
    &csv9.hs:all;
    <para id="x_FK">
      That's a full-featured CSV parser in just 21 lines of code, plus an
      additional 10 lines for the <literal>parseCSV</literal> and
      <literal>main</literal> utility functions.
    </para>
    <para id="x_GK">
      Let's look at the changes in this program from the previous versions.
      First, a cell may now be either a bare cell or a "quoted" cell.  We
      give the <literal>quotedCell</literal> option first, because we want to
      follow that path if the first character in a cell is the quote mark.
    </para>
    <para id="x_HK">
      The <literal>quotedCell</literal> begins and ends with a quote mark,
      and contains zero or more characters.  These characters can't be copied
      directly, though, because they may contain embedded, doubled-up, quote
      marks themselves.  So we define a custom <literal>quotedChar</literal>
      to process them.
    </para>
    <para id="x_IK">
      When we're processing characters inside a quoted cell, we first say
      <literal>noneOf "\""</literal>.  This will match and return any single
      character as long as it's not the quote mark.  Otherwise, if it is the
      quote mark, we see if we have two of them in a row.  If so, we return a
      single quote mark to go on our result string.
    </para>
    <para id="x_JK">
      Notice that &try; in <literal>quotedChar</literal> on the
      <emphasis>right</emphasis> side of &PChoice;.  Recall that I said that
      &try; only has an effect if it is on the left side of &PChoice;.  This
      &try; does occur on the left side of a &PChoice;, but on the left of
      one that must be within the implementation of <literal>many</literal>.
    </para>
    <para id="x_KK">
      This &try; is actually quite important.  Let's say you are parsing a
      quoted cell and are getting towards the end of it.  There will be
      another cell following.  So you will expect to see a quote to end the
      current cell, followed by a comma.  When you hit
      <literal>quotedChar</literal>, you will fail the
      <literal>noneOf</literal> test and proceed to the test that looks for
      two quotes in a row.  You'll also fail that one because you'll have a
      quote, then a comma.  If you hadn't used &try;, you'd crash with an
      error at this point, saying that it was expecting the second quote,
      because the first quote was already consumed.  Since we use &try;, this
      is properly recognized as not a character that's part of the cell, so
      it terminates the <literal>many quotedChar</literal> expression as
      expected.  Lookahead has once again proven very useful, and the fact
      that it is so easy to add makes it a remarkable tool in Parsec.
    </para>
    <para id="x_LK">
      You can test this program with &ghci; over some quoted cells:
    </para>
    &csv9.ghci:s1;
    <para id="x_MK">
      Let's run it over a real CSV file.  Here's a CSV file generated by a
      spreadsheet program:
    </para>
    <programlisting>
"Product","Price"
"O'Reilly Socks",10
"Shirt with ""Haskell"" text",20
"Shirt, ""O'Reilly"" version",20
"Haskell Caps",15
    </programlisting>
    <para id="x_NK">
      Now, we can run this under our test program and watch:
    </para>
    <screen>
$ <userinput>runhaskell csv9.hs &lt; test.csv</userinput>
["Product","Price"]
["O'Reilly Socks","10"]
["Shirt with \"Haskell\" text","20"]
["Shirt, \"O'Reilly\" version","20"]
["Haskell Caps","15"]
    </screen>
  </sect1>

  <sect1>
    <title>Parsec and MonadPlus</title>

    <para id="x_Wj">Parsec's <type>GenParser</type> monad is an instance of the
      <type>MonadPlus</type> typeclass that we introduced in
	<xref linkend="monadcase.monadplus"/>.  The value
      <code>mzero</code> represents a parse failure, while
      <function>mplus</function> combines two alternative parses into
      one, using <function>(&lt;|>)</function>.</para>
  </sect1>

  <sect1 id="applicative.urlencoded">
    <title>Parsing an URL-encoded query string</title>

    <para id="x_Xj">When we introduced
      <code>application/x-www-form-urlencoded</code> text in <xref
      linkend="monadcase.urlencoded"/>, we mentioned that we'd write a
      parser for these strings.  We can quickly and easily do this
      using Parsec.</para>
    
    <para id="x_Yj">Each key-value pair is separated by the
      <literal>&amp;</literal> character.</para>

    &FormParse.hs:p_query;

    <para id="x_Zj">Notice that in the type signature, we're using
      <type>Maybe</type> to represent a value: the HTTP specification
      is unclear about whether a key <emphasis>must</emphasis> have an
      associated value, and we'd like to be able to distinguish
      between <quote>no value</quote> and <quote>empty
	value</quote>.</para>

    &FormParse.hs:p_pair;

    <para id="x_aj">The <function>many1</function> function is similar to
      <function>many</function>: it applies its parser repeatedly,
      returning a list of their results.  While
      <function>many</function> will succeed and return an empty list
      if its parser never succeeds, <function>many1</function> will
      fail if its parser never succeeds, and will otherwise return a
      list of at least one element.</para>

    <para id="x_bj">The <function>optionMaybe</function> function modifies the
      behaviour of a parser.  If the parser fails,
      <function>optionMaybe</function> doesn't fail: it returns
      <code>Nothing</code>.  Otherwise, it wraps the parser's
      successful result with <code>Just</code>.  This gives us the
      ability to distinguish between <quote>no value</quote> and
      <quote>empty value</quote>, as we mentioned above.</para>

    <para id="x_cj">Individual characters can be encoded in one of several
      ways.</para>

    &FormParse.hs:p_char;

    <para id="x_dj">Some characters can be represented literally.  Spaces are
      treated specially, using a <code>+</code> character.  Other
      characters must be encoded as a <code>%</code> character
      followed by two hexadecimal digits.  The <code>Numeric</code>
      module's <function>readHex</function> parses a hex string as
      a number.</para>

    &formParse.ghci:test;

    <para id="x_ej">As appealing and readable as this parser is, we can profit
      from stepping back and taking another look at some of our
      building blocks.</para>
  </sect1>

  <sect1>
    <title>Supplanting regular expressions for casual parsing</title>
    
    <para id="x_fj">In many popular languages, people tend to put regular
      expressions to work for <quote>casual</quote> parsing. They're
      notoriously tricky for this purpose: hard to write, difficult to
      debug, nearly incomprehensible after a few months of neglect,
      and no error messages on failure.</para>

    <para id="x_gj">If we can write compact Parsec parsers, we'll gain in
      readability, expressiveness, and error reporting.  Our parsers
      won't be as short as regular expressions, but they'll be close
      enough to negate much of the temptation of regexps.</para>
  </sect1>

  <sect1>
    <title>Parsing without variables</title>

    <para id="x_hj">A few of our parsers above use &do; notation and bind the
      result of an intermediate parse to a variable, for later use.
      One such function is <function>p_pair</function>.</para>

    &FormParse.hs:p_pair.noid;

    <para id="x_ij">We can get rid of the need for explicit variables by using
      the <function>liftM2</function> combinator from
      <code>Control.Monad</code>.</para>

    &FormParse.hs:p_pair_app1;

    <para id="x_jj">This parser has exactly the same type and behaviour as
      <function>p_pair</function>, but it's one line long.  Instead of
      writing our parser in a <quote>procedural</quote> style, we've
      simply switched to a programming style that emphasises that
      we're <emphasis>applying</emphasis> parsers and
      <emphasis>combining</emphasis> their results.</para>

    <para id="x_kj">We can take this applicative style of writing a parser much
      further.  In most cases, the extra compactness that we will gain
      will <emphasis>not</emphasis> come at any cost in readability,
      beyond the initial effort of coming to grips with the
      idea.</para>
  </sect1>

  <sect1>
    <title>Applicative functors for parsing</title>

    <para id="x_lj">The standard Haskell libraries include a module named
      <code>Control.Applicative</code>, which we already encountered
      in <xref linkend="binary.fmap"/>.  This module defines a
      typeclass named <type>Applicative</type>, which represents an
      <emphasis>applicative functor</emphasis>.  This is a little bit
      more structured than a functor, but a little bit less than a
      monad.  It also defines <type>Alternative</type>, which is
      similar to <type>MonadPlus</type></para>

    <para id="x_mj">As usual, we think that the best way to introduce
      applicative functors is by putting them to work.  In theory,
      every monad is an applicative functor, but not every applicative
      functor is a monad.  Because applicative functors were added to
      the standard Haskell libraries long after monads, we often don't
      get an <type>Applicative</type> instance for free: frequently,
      we have to declare the monad we're using to be
      <type>Applicative</type> or <type>Alternative</type>.</para>

    <para id="x_nj">To do this for <code>Parsec</code>, we'll write a small
      module that we can import instead of the normal
      <code>Parsec</code> module.</para>

    &ApplicativeParsec.hs:ApplicativeParsec;

    <para id="x_oj">For convenience, our module's export section exports all the
      names we imported from both the <code>Applicative</code> and
      <code>Parsec</code> modules.</para>
  </sect1>

  <sect1>
    <title>Applicative parsing by example</title>

    <para id="x_pj">We'll begin by rewriting our existing form parser from the
      bottom up, beginning with <function>p_hex</function>, which
      parses a hexadecimal escape sequence.</para>

    &FormApp.hs:p_hex;

    <para id="x_qj">Here's our applicative version.</para>

    &FormApp.hs:a_hex;

    <para id="x_rj">Although the individual parsers are mostly untouched, the
      combinators that we're gluing them together with have changed.
      The only familiar one is <function>(&lt;$&gt;)</function>, which
      we already know is a synonym for
      <function>fmap</function>.</para>

    <para id="x_sj">From our definition of <type>Applicative</type>, we know
      that <function>(&lt;*&gt;)</function> is
      <function>ap</function>.</para>

    <para id="x_tj">The remaining unfamiliar combinator is
      <function>(*&gt;)</function>, which applies its first argument,
      throws away its result, then applies the second and returns its
      result.  In other words, it's similar to
      <function>(&gt;&gt;)</function>.</para>

    <tip>
      <title>A handy tip about angle brackets</title>

      <para id="x_uj">Before we continue, here's a useful aid for remembering
	what all the angle brackets are for in the combinators from
	<code>Control.Applicative</code>: if there's an angle bracket
	pointing to some side, the result from that side should be
	used.</para>

      <para id="x_vj">For example, <function>(*&gt;)</function> returns the
	result on its right; <function>(&lt;*&gt;)</function> returns
	results from both sides; and <function>(&lt;*)</function>,
	which we have not yet seen, returns the result on its
	left.</para>
    </tip>

    <para id="x_wj">Although the concepts here should mostly be familiar from
      our earlier coverage of functors and monads, we'll walk through
      this function to explain what's happening.  First, to get a grip
      on our types, we'll hoist <function>hexify</function> to the top
      level and give it a signature.</para>

    &FormApp.hs:hexify;

    <para id="x_xj">Parsec's <function>hexDigit</function> parser parses a
      single hexadecimal digit.</para>

    &formApp.ghci:hexDigit;

    <para id="x_yj">Therefore, <code>char '%' *&gt; hexDigit</code> has the same
      type, since <function>(*&gt;)</function> returns the result on
      its right.  (Remember that <type>CharParser</type> is nothing
      more than a synonym for <type>GenParser Char</type>.)</para>

    &formApp.ghci:char;

    <para id="x_zj">The expression <code>hexify &lt;%$&gt; (char '%' *&gt;
	hexDigit)</code> is a parser that matches a <quote>%</quote>
      character followed by hex digit, and whose result is a
      function.</para>

    &formApp.ghci:func;

    <para id="x_Ak">Finally, <function>(&lt;*&gt;)</function> applies the parser
      on its left, then the parser on its right, and applies the
      function that's the result of the left parse to the value that's
      the result of the right.</para>

    <para id="x_Bk">If you've been able to follow this, then you understand the
      <function>(&lt;*&gt;)</function> and <function>ap</function>
      combinators: <function>(&lt;*&gt;)</function> is plain old
      <function>($)</function> lifted to applicative functors, and
      <function>ap</function> the same thing lifted to monads.</para>

    &formApp.ghci:ap;

    <para id="x_Ck">Next, we'll consider the <function>p_char</function>
      parser.</para>

    &FormApp.hs:p_char;

    <para id="x_Dk">This remains almost the same in an applicative style, save
      for one piece of convenient notation.</para>

    &FormApp.hs:a_char;

    <para id="x_Ek">Here, the <function>(&lt;$)</function> combinator uses the
      value on the left if the parser on the right succeeds.</para>

    <para id="x_Fk">Finally, the equivalent of <function>p_pair_app1</function> is
      almost identical.</para>

    &FormParse.hs:p_pair_app1.noid;

    <para id="x_Gk">All we've changed is the combinator we use for lifting: the
      <function>liftA</function> functions act in the same ways as
      their <function>liftM</function> cousins.</para>

    &FormApp.hs:a_pair;
  </sect1>

  <sect1>
    <title>Parsing JSON data</title>

    <para id="x_Hk">To give ourselves a better feel for parsing with applicative
      functors, and to explore a few more corners of Parsec, we'll
      write a JSON parser that follows the definition in RFC
      4627.</para>

    <remark>Insert a backreference to the introduction to JSON,
      whenever that shows up.</remark>

    <para id="x_Ik">At the top level, a JSON value must be either an object or
      an array.</para>

    &JSONParsec.hs:p_text;

    <para id="x_Jk">These are structurally similar, with an opening character,
      following by one or more items separated by commas, followed by
      a closing characters.  We capture this similarity by writing a
      small helper function.</para>

    &JSONParsec.hs:p_series;

    <para id="x_Kk">Here, we finally have a use for the
      <function>(&lt;*)</function> combinator that we introduced
      earlier.  We use it to skip over any white space that might
      follow certain tokens.  With this <function>p_series</function>
      function, parsing an array is simple.</para>

    &JSONParsec.hs:p_array;

    <para id="x_Lk">Dealing with a JSON object is hardly more complicated,
      requiring just a little more effort to product a name/value pair
      for each of the object's fields.</para>

    &JSONParsec.hs:p_object;

    <para id="x_Mk">Parsing an individual value is a matter of calling an
      existing parser, then wrapping its result with the appropriate
      <type>JValue</type> constructor.</para>

    &JSONParsec.hs:p_value;

    <para id="x_Nk">This leads us to the two most interesting parsers, for
      numbers and strings.  We'll deal with numbers first, since
      they're simpler.</para>

    &JSONParsec.hs:p_number;

    <para id="x_Ok">Our trick here is to take advantage of Haskell's standard
      number parsing library functions, which are defined in the
      <code>Numeric</code> module.  The <function>readFloat</function>
      function reads an unsigned floating point number, and
      <function>readSigned</function> takes a parser for an unsigned
      number and turns it into a parser for possibly signed
      numbers.</para>

    <para id="x_Pk">Since these functions know nothing about Parsec, we have to
      work with them specially.  Parsec's
      <function>getInput</function> function gives us direct access to
      Parsec's unconsumed input stream.  If <code>readSigned
	readFloat</code> succeeds, it returns both the parsed number
      and the rest of the unparsed input.  We then use
      <function>setInput</function> to give this back to Parsec as its
      new unconsumed input stream.</para>

    <para id="x_Qk">Parsing a string isn't difficult, merely detailed.</para>

    &JSONParsec.hs:p_string;

    <para id="x_Rk">We can parse and unescape an escape sequence with the help
      of a generic function for combining
      <type>Alternative</type>s.</para>

    &JSONParsec.hs:p_escape;

    <para id="x_Sk">(We're basing the name <function>asum</function> on the
      <function>msum</function> function in
      <code>Control.Monad</code>, which serves the same purpose for
      <type>MonadPlus</type> instances.  It's a little surprising that
      <function>asum</function> isn't already defined for us.)</para>

    <para id="x_Tk">Finally, JSON lets us encode a Unicode character in
      a string as <quote><code>\u</code></quote> followed by four
      hexadecimal digits.  Because the number of values that can be
      represented in 32 bits is much larger than the number of valid
      Unicode code points, we must check to ensure that we're decoding
      a value within the valid Unicode range, or else we could cause
      ourselves a runtime error.</para>

    &JSONParsec.hs:p_unicode;

    <para id="x_Uk">The only piece of functionality that applicative
      functors are missing compared to monads is the ability to bind a
      value to a variable, which we need here in order to be able to
      validate the value we're trying to decode.</para>

    <para id="x_Vk">This is the one place in our parser that we've needed to
      use a monadic function.  This pattern extends to more
      complicated parsers, too: only infrequently do we need the extra
      bit of power that monads offer.</para>

    <para id="x_Wk">As we write this book, applicative functors are still quite
      new to Haskell, and people are only beginning to explore the
      possible uses for them beyond the realm of parsing.</para>
  </sect1>
</chapter>
 

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
