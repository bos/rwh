Shared     1. Why functional programming? Why Haskell?
Shared     2. Getting started: compiler, interpreter, values, simple 
              functions, and types (DONE)
Shared     3. Syntax, type system basics, type class basics (DONE)
BOS        4. FP (DONE)
BOS/DONS   5. Write a real library: the rope data structure, cabal,
              building  projects
JG         6. Typeclasses and their use (DONE)
JG         7. All about I/O (DONE)
BOS        8. Bringing it all together: file name matching and 
              regular expressions (DONE)
BOS        9. I/O case study: a DSL for searching the filesystem (DONE)
BOS       10. Code case study: barcode recognition
DONS      11. Testing the Haskell way: QuickCheck
BOS       12. Handling binary files and formats
JG        13. Designing and using data structures (DONE)
BOS       14. Monads
BOS       15. Monad case study: refactoring the filesystem seacher
DONS      16. Monad transformers
JG        17. Using parsec: (DONE)
BOS            parsing a bioinformatics format
DONS      18. Interfacing with C: the FFI
DONS      19. Error handling
JG        20. Haskell for systems programming (DONE)
JG        21. Talking to databases (DONE)
JG        22. Web client programming: client/server networking
BOS       23. GUI programming: gtk2hs
          24. Data mining and web applications
JG/DONS   25. Basics of concurrent and parallel Haskell
DONS      26. Advanced concurrent and parallel programming
DONS      27. Concurrency case study: a lockless database with STM
DONS      28. Performance and efficiency: profiling
DONS      29. Advanced Haskell: MPTCs, TH, strong typing, GADTs
JG        30. Sockets, Syslog   (agreed to)
BOS       31. Reverse HTTP Proxy example
BOS    APP A. Installation of GHC (done)
BOS    APP B. Escapes (done)
JG     APP C. Posix (??)
JG     APP D. HUGS  (??)
JG     APP E. Data.Typeable (??)
