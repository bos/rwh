Shared     1. Why functional programming? Why Haskell?
Shared     2. Getting started: compiler, interpreter, values, simple 
              functions, and types (DONE)
BOS        3. Syntax, type system basics, type class basics (DONE)
BOS        4. Even more syntax, type system basics, type class basics (DONE)
BOS        5. FP (DONE)
BOS/DONS   6. Write a real library: the rope data structure, cabal,
              building  projects
JG         7. Typeclasses and their use (DONE)
JG         8. All about I/O (DONE)
BOS        9. Bringing it all together: file name matching and 
              regular expressions (DONE)
BOS       10. I/O case study: a DSL for searching the filesystem (DONE)
BOS       11. Handling binary files and formats (DONE)
DONS      12. Testing the Haskell way: QuickCheck
BOS       13. Code case study: barcode recognition (DONE)
JG        14. Designing and using data structures (DONE)
BOS       15. Monads (DONE)
BOS       16. Monad case study: refactoring the filesystem seacher
DONS      17. Monad transformers
JG        18. Using parsec: (DONE)
BOS            parsing JSON (DONE)
DONS      19. Interfacing with C: the FFI
DONS      20. Error handling
JG        21. Haskell for systems programming (DONE)
JG        22. Talking to databases (DONE)
JG        23. Web client programming: client/server networking
BOS       24. GUI programming: gtk2hs
          25. Data mining and web applications
JG/DONS   26. Basics of concurrent and parallel Haskell
DONS      27. Advanced concurrent and parallel programming
DONS      28. Concurrency case study: a lockless database with STM
DONS      29. Performance and efficiency: profiling
DONS      30. Advanced Haskell: MPTCs, TH, strong typing, GADTs
JG        31. Sockets, Syslog   (agreed to)
BOS       32. Reverse HTTP Proxy example
BOS    APP A. Installation of GHC (done)
BOS    APP B. Escapes (done)
JG     APP C. Posix (??)
JG     APP D. HUGS  (??)
JG     APP E. Data.Typeable (??)
